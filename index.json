[{"uri":"https://cppxl.github.io/research/kerberos-protocol/kerberos-protocol-in-windows/","title":"Windows中的kerberos协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/research/kerberos-protocol/","title":"Kerberos 协议","tags":[],"description":"","content":""},{"uri":"https://cppxl.github.io/tools/","title":"工具","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/research/tunnel-best-practice/transport-layer-tunnel/socks-protocol/","title":"Socks协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/research/tunnel-best-practice/","title":"隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/research/tunnel-best-practice/application-layer-tunnel/","title":"应用层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/research/tunnel-best-practice/transport-layer-tunnel/","title":"传输层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/research/tunnel-best-practice/network-layer-tunnel/","title":"网络层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/research/","title":"安全研究","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/vulnerability-analysis/","title":"漏洞分析","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/","title":"学习记录","tags":[],"description":"","content":"学习记录 记录一些平时学习记录，灵感来自@Kiprey\nasdf\r| 4 days ago\radsfadfasd\n2022\rtest\r3.000000 3 days | 4 days ago\radsfadfasd\n2022\rtest\r3.000000 3 days | 4 days ago\radsfadfasd\n2022\rtest\r3.000000 3 days | 4 days ago\radsfadfasd\n2022\rtest\r3.000000 3 days | 4 days ago\radsfadfasd\n2022\rtest\r3.000000 3 days | 4 days ago\radsfadfasd\n2022\rtest\r3.000000 3 days | 4 days ago\radsfadfasd\n2022\rtest\r3.000000 3 days | 4 days ago\radsfadfasd\n2022\rtest\r3.000000 3 days | 4 days ago\radsfadfasd\n2022\rCurrent position\r1 year 1 month 403.000000 8 days | 612 days ago\rI\u0026rsquo;m working here你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好\n2022\rOld position\r1 year 366.000000 1 day | 978 days ago\rI worked here\nadsfz 2022\r2021.11.22 - 2021.11.26 "},{"uri":"https://cppxl.github.io/others/","title":"其他","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://cppxl.github.io/research/kerberos-protocol/authentication-principle/","title":"认证原理","tags":[],"description":"","content":"认证原理 一、Kerberos概念 Kerberos是计算机网络授权协议，用于在非安全网络中，对个人通信过程中用安全的手段进行身份认证。其中客户端和服务端能够相互认证，识别对方身份。Kerberos是第三方认证，依赖于第三方服务器对彼此进行身份验证，Kerberos服务器本身成为KDC。 由三部分组成：\nKerberos知道用户和集群内服务以及各自的密码数据库 AS验证用户身份，验证通过就会返回给Client端一个TGT Client通过TGT向TGS获取ST 服务验证ST有效性，如果有效则Client可以访问服务 二、Kerberos名词解释 AS（Authentication Server）认证服务器 KDC（Key Distribution Center）密钥分发中心 TGT（Ticket Granting Ticket）票据授权票据，给票据授权的票据 TGS（Ticket Granting Service）票据授权服务 SS（Service Server）服务提供服务器 ST（Server Ticket）服务端票据 一般KDC同时包含AS和TGS\n三、Kerberos验证过程 Client登录，用户输入用户名和密码，会用单向函数根据密码生成客户端密钥（Client Secret Key）\nClient向AS发送A消息请求TGT\nA消息内容 用户名 请求服务名称，这里是TGS 网络地址 请求TGT的生命周期 该消息不会加密，也不会发送密码或者密码生成的密钥 AS检查用户名是否存在AS用户名数据库内，并使用数据库中用户密码生成的NTLM哈希解密客户端消息\n如果数据库内有该用户名则随机生成TGS会话密钥（TGS Session Key），同时给Client端发送两条消息\nB消息内容用客户端密钥加密 TGS名称 时间戳 生命周期 TGS会话密钥（TGS Session Key） C消息内容（TGT）用TGS密钥（TGS Secret Key）加密 用户名 TGS名称 时间戳 用户网络地址 生命周期 TGS会话密钥（TGS Session Key） Client用通过密码生成的客户端密钥解密B消息，如果密码正确则可以得到TGS会话密钥（TGS Session Key），将C消息（TGT）存储在本地凭据缓存内。\nClient向TGS请求ST，期间需要向TGS发送两条消息明文\nD消息内容 想要请求的服务ID即SS 生命周期 TGT E消息内容使用TGS会话密钥（TGS Session Key）加密即身份验证器 用户名 时间戳 TGS验证Client请求服务是否存在，存在则进入下一步。\nTGS提取D消息内的TGT，用TGS密钥解密（TGS Secret Key），从中提取TGS会话密钥（TGS Session Key），再用TGS会话密钥解密E得到用户名和时间戳，现在TGS得到了用户名和消息E的时间戳，以及消息C的用户名和时间戳\n比较两个用户名和时间戳 检查TGT生命周期是否过期 检查身份验证器（E消息）是否在缓存内(存疑) TGS生成随机服务会话（service session key）密钥，并发送两条消息给Client\nF消息内容用服务密钥(Service Secret Key)加密 用户名 服务名 时间戳 网络地址 生命周期 服务会话密钥 G消息内容用TGS会话密钥加密 服务名 时间戳 生命周期 服务会话密钥 因为Client有TGS会话密钥所以可以解密消息G得到服务会话密钥（service session key）\n客户端和SS连接，发送两条消息\n消息H用服务会话密钥加密内容身份验证器： 用户名 时间戳 消息L 即消息F SS收到请求，用服务密钥解密消息I即消息F得到服务会话密钥及用户名时间戳等信息，再用服务会话密钥解密消息H得到用户名和时间戳\nSS进行身份验证\n比较消息H内用户名和消息F内的用户名 比较消息H和消息F内的是时间戳 检查消息F内生命周期 检查身份验证器是否在缓存内 SS向Client验证身份，向其发送消息\n消息J使用服务会话密钥加密身份验证器 服务ID 时间戳（在消息H内的时间戳） 客户端收到SS的身份验证器消息（J），使用缓存内的服务会话密钥进行解密得到服务ID及时间戳，并验证是否有效\n参考链接\nhttps://www.vanimpe.eu/2017/05/26/kerberos-made-easy/ https://zh.wikipedia.org/wiki/Kerberos http://www.nosqlnotes.com/technotes/kerberos-protocol/ https://juejin.im/post/6844903955416219661\n简化模型 Client向AS发送明文消息，申请访问的服务 AS检查用户名是否存在本地数据库中，存在则返回两条消息 A：Client/TGS会话密钥(Client/TGS Session Key)用于Client和TGS通信，通过用户密钥加密 B：TGT（包含Client/TGS会话密钥、用户、用户网络地址、TGT有效期），通过TGS密钥加密 Client收到消息AB，用自己的用户密钥解密消息A得到和TGS通信的密钥TGS会话密钥 Client向TGS请求服务，发送两条消息 C：消息B和申请的服务ID（明文） D：认证符（包括用户ID、时间戳）通过(Client/TGS Session Key)加密 TGS拿到服务ID检查是否有该服务，如果有该服务则用TGS密钥解密消息B得到(Client/TGS Session Key)再用TGS会话密钥解密消息D得到用户ID、时间戳，与TGT内的用户ID和时间戳比对验证有效性。 通过之后TGS返回两条消息给Client E：ST（SS会话密钥、用户ID、用户网络地址、有效期）通过SS密钥加密 F：SS会话密钥，通过TGS会话密钥加密 Client通过TGS会话密钥解密消息F得到SS会话密钥 Client给SS发送两条消息 G：即消息E H：认证符，包含用户ID，时间戳，通过SS会话密钥加密 SS收到两条消息之后用SS密钥解密消息G（E）得到SS会话密钥，在通过会话密钥解密消息H得到用户ID、时间戳等信息，如果和消息G（E）内的时间戳和用户ID比对，通过则返回消息给Client I：消息H内的时间戳，通过SS会话密钥加密 Client收到消息之后用SS会话密钥解密得到时间戳，并验证，通过则可以向SS发送请求。 "},{"uri":"https://cppxl.github.io/others/how-to-reset-password-administrator-on-windows-server-2019/","title":"在Windows server 2019上重置密码","tags":[],"description":"","content":"重置windows server 2019的administrator密码 之前在Vmware上的Windows server 2019的Administrator密码忘记了，使用网上的方法时找不到用PE启动系统的办法，无奈只能使用其他办法。写此文记录一下。\n设置CD/DVD 首先在虚拟机-设置的硬件选项卡下面的CD/DVD设置为使用ISO映像文件并找到windows server 2019镜像位置，如下图\n之后选择虚拟机-电源-开机时打开固件启动虚拟机，虚拟机就会进入BIOS，在BIOS里选择CD/DVD启动，即会进入下图。\n参考链接\nhttps://www.osradar.com/how-to-reset-password-administrator-on-windows-server-2019/\n"},{"uri":"https://cppxl.github.io/vulnerability-analysis/cve-2021-40449-analyse/","title":"CVE 2021 40449 分析","tags":[],"description":"","content":"CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。\n基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。\n内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：\n在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。\n句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。\n句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。\nhttps://www.cnblogs.com/MisterXu/p/10846918.html\nDC：是一个内核对象，全称device context，设备上下文对象\nHDC：DC对象的句柄。\n释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。\neg：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-\u0026gt;p = method; p-\u0026gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i \u0026lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-\u0026gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(\u0026#34;第二次调用\\n\u0026#34;); p-\u0026gt;p(); return 0; } void method() { printf(\u0026#34;method\\n\u0026#34;); } void badMethod() { printf(\u0026#34;bad method\\n\u0026#34;); } 漏洞形成分析 该漏洞产生于win32kfull!GreResetDCInternal函数中，该函数内会获取DC对象内的函数指针，并执行该函数指针指向的函数，但并未检查DC对象是否异常。所以如果可以在调用函数指针之前释放DC对象，并重新申请该对象的内存空间，通过构造内存布局，修改原DC对象的函数指针指向其他任意内核函数，就可以在win32kfull!GreResetDCInternal内实现任意内核函数调用。\n根据代码，我们可以算出DCO对象和DC对象的函数指针的关系：function pointer=* (* (DCO +0x30)+0xad0)，其中DCO +0x30即指向DC对象的指针\nv10 = *(_QWORD *)(v8 + 48);\nv15 *= * (void (_fastcall * * )(QWORD, _QWORD))(*v10 + 2768);\n__int64 __usercall GreResetDCInternal@\u0026lt;rax\u0026gt;(HDC a1@\u0026lt;rcx\u0026gt;, __int64 a2@\u0026lt;rdx\u0026gt;, int *a3@\u0026lt;r8\u0026gt;) { __int64 v24; // [rsp+50h] [rbp-20h] __int64 v25; // [rsp+60h] [rbp-10h] DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v25, a1); // 利用构造函数从HDC创建DCOBJ对象 v8 = v25; ·········· v10 = *(_QWORD *)(v8 + 48);\t// 赋值 *(_QWORD *)(v10 + 1736) = 0i64; v24 = v11; ······· v9 = *(_QWORD *)(v25 + 512) != 0i64; v12 = *(_DWORD *)(v25 + 120) \u0026gt; 0; ······· v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的DC对象，返回对应的HDC句柄 if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));// 调用函数指针指向的函数，传入参数为用户传入的HDC对应的DC对象内的值 ······· HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······ bDeleteDCInternal(v6, 1i64, 0i64); // 传入了hdcOpenDCW返回的HDC，但HmgSwapLockedHandleContents交换了新旧句柄对应的DC对象，此时v6句柄对应旧DC对象。 ······ 调用该函数指针的时候，所用的两个参数也是源于用户传入的HDC句柄对应的DC对象。\nv10 = *(_QWORD *)(v8 + 48);\t_\n_v14[308] = *(_QWORD *)(v25 + 2464);\nv14[309] = *(_QWORD *)(v25 + 2472);\nv15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));\n在win32kfull!GreResetDCInternal函数的后半段会调用win32kbase!DeleteDCInternal函数释放传入该函数的HDC句柄所对应的DC对象，到这里就达成了use-after-free的free步骤。\nHDC v3; v3=a1; v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的HDC v6 = v13; if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64)); GreAcquireHmgrSemaphore(); LOBYTE(v23) = 1; HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······· // 删除HDC句柄对应的DC对象。 bDeleteDCInternal(v6, 1i64, 0i64); 如果在释放DC对象之后，重新申请DC对象空间，修改里面的函数指针内容，并通过某些步骤，让内核执行DC对象内的函数指针，即可达到use步骤让内核执行任意内核函数。\n漏洞利用分析 POC:https://github.com/KaLendsi/CVE-2021-40449-Exploit\nPOC代码分析：https://github.com/CppXL/cve-2021-40449-poc/blob/master/main.cpp\n要利用该漏洞，难点在于free DC对象之后怎么使得内核再次调用DC对象的函数指针，在正常GreResetDCInternal函数流程中，是先调用DC对象的函数指针再删除这个对象，即按照正常流程即不会有use-after-free的条件。\n在ring 3层调用ResetDC函数会通过系统调用进入内核调用函数NtGdiResetDC，在NtGdiResetDC会调用漏洞函数GreResetDCInternal，在GreResetDCInternal中会调用DC对象里面的函数指针。要利用该漏洞即要在调用函数指针之前完成三步动作：1、释放DC对象2、重新申请原DC对象的内存空间3、完成内存空间的布局。\n在函数GreResetDCInternal调用DC对象的函数指针之前会调用win32kbase!hdcOpenDCW函数。win32kbase!hdcOpenDCW函数会执行打印机驱动的用户态回调函数表里面的函数，该表里面存放了函数指针，该函数指针原先指向的是预定义的回调函数。在POC中覆盖这个函数指针，使其执行POC定义的回调函数。\n在自定义回调函数中再次执行ResetDC函数并传入同一HDC句柄，则会再次执行NtGdiResetDC和GreResetDCInternal函数，而在GreResetDCInternal的后半段，会释放传入的HDC对应的DC对象并创建新的DC对象。此时达到了free步骤。\n在第二次ResetDC调用完成后，原DC对象已被释放，此时可以重新申请原DC对象的内存空间并完成内存布局，将原DC对象的函数指针和函数指针的参数的位置设置为想要执行的内核函数的地址及参数。在执行完第一次回调之后，GreResetDCInternal 将调用原DC对象内的函数指针，即完成了任意内核函数调用，此时达到了use步骤。\n完整调用链如下图：\n其中漏洞相关的类定义如下，参考https://github.com/ZoloZiak/WinNT4/blob/master/private/ntos/w32/ntgdi/gre/dcobj.hxx#L97\nclass DCLEVEL { public: ... HDC hdcSave; ... } class DC : public OBJECT { public: DHPDEV dhpdev_; PDEV *ppdev_; ... HDC hdcNext_; // HDC链表指针 HDC hdcPrev_; ... DCLEVEL dclevel ... }; typedef DC *PDC; class XDCOBJ /* dco */ { public: PDC pdc; ... }; typedef XDCOBJ *PXDCOBJ; class DCOBJ : public XDCOBJ /* mdo */ { public: DCOBJ() { pdc = (PDC) NULL; } DCOBJ(HDC hdc) { vLock(hdc); } ~DCOBJ() { vUnlockNoNullSet(); } }; typedef DCOBJ *PDCOBJ; 类之间的关系可以简化为下图：\n调试 free部分 在free部分需要把我们想要释放的内存空间释放，并让后面的use部分成功申请到这块内存空间。\n调试环境：虚拟机windows 10 1607、物理机windows 10 2004\nPOC:https://github.com/KaLendsi/CVE-2021-40449-Exploit\n断点:\nbp win32kfull!NtGdiResetDC bp win32kfull!NtGdiResetDC+0xc1 \u0026#34;调用GreResetDCInternal函数\u0026#34; bp win32kfull!GreResetDCInternal+0x3a \u0026#34;调用DCOBJ构造函数\u0026#34; bp win32kfull!GreResetDCInternal+0x116 \u0026#34;调用_imp_hdcOpenDCW函数\u0026#34; bp win32kfull!GreResetDCInternal+0x136 \u0026#34;第二次DCOBJ\u0026#34; bp win32kfull!GreResetDCInternal+0x1b5 \u0026#34;调用DC对象函数指针\u0026#34; bp win32kfull!GreResetDCInternal+0x1d1 \u0026#34;调用HmgSwapLockedHandle函数\u0026#34; bp win32kfull!GreResetDCInternal+0x20d \u0026#34;调用_imp_bDeleteDCInternal函数\u0026#34; bp cve_2021_40449!hook_DrvEnablePDEV+0x12a \u0026#34;循环调用\u0026#34; bp win32kbase!PALMEMOBJ::bCreatePalette \u0026#34;调用win32kbase!PALMEMOBJ::bCreatePalette\u0026#34; 运行POC，断点bp win32kfull!NtGdiResetDC触发此时传入的句柄为rcx=00000000092105f1\n第一次调用win32kfull!GreResetDCInternal 时传入各个参数为rcx=00000000092105f1 rdx=0000000000000000 r8=ffffb101aadf2a44 即第一个句柄值为00000000092105f1\n第一次调用构造函数，利用DC对象创建DCO对象，此时rbx存放DCO对象的地址，\n根据漏洞形成分析的计算公式，可以很方便的得到DC对象内的函数指针指向的函数的地址为：ffffd548a1f10c30\n1: kd\u0026gt; dq rax ffffb101`aadf29c0 ffffd50e`041fd010 00000000`00000001 ffffb101`aadf29d0 00000268`6e766b20 000000d7`97aff680 ffffb101`aadf29e0 00000000`00000000 00000000`092105f1 ffffb101`aadf29f0 00000000`00000000 ffffd50e`041fb030 ffffb101`aadf2a00 ffffb101`aadf2b80 ffffd548`a1f18fe6 ffffb101`aadf2a10 00000000`00000001 00000000`00000000 ffffb101`aadf2a20 ffffb101`aadf2a44 ffffd50e`041fb030 ffffb101`aadf2a30 000000d7`97aff5d0 00000000`00000000 // rbx存放了构造函数产生的DCO对象地址 1: kd\u0026gt; dq rbx ffffd50e`041fd010 00000000`092105f1 80000001`00000000 ffffd50e`041fd020 ffffd800`b45ad780 00000268`6e75ea10 ffffd50e`041fd030 00100010`00000000 00000000`00000000 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ffffd50e`041fd050 ffffd800`b56f1260 00000009`1000a01f ffffd50e`041fd060 ffffd50e`041fd3d0 00000000`0088000b ffffd50e`041fd070 ffffd50e`000004f0 ffffd50e`00005d90 ffffd50e`041fd080 00000001`00000000 00000000`00000000 // ffffd50e`041fd010为rbx的值，此处ffffd50e`041fd010+0x30为PDC的地址，PDC指向DC对象即DC对象地址为ffffd50e`00052030 // 计算公式 *(dco地址+0x30)=dc地址 1: kd\u0026gt; dq ffffd50e`041fd010+0x30 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ffffd50e`041fd050 ffffd800`b56f1260 00000009`1000a01f ffffd50e`041fd060 ffffd50e`041fd3d0 00000000`0088000b ffffd50e`041fd070 ffffd50e`000004f0 ffffd50e`00005d90 ffffd50e`041fd080 00000001`00000000 00000000`00000000 ffffd50e`041fd090 00000000`00000000 00000000`00000000 ffffd50e`041fd0a0 ffffd50e`00001a10 ffffd50e`00004cb0 ffffd50e`041fd0b0 ffffd50e`000105f0 00000000`00000000 // ffffd50e`00052030+0xad0处为DC对象的函数指针，该指针指向了一个函数 // 计算公式 *(dc地址 +0xad0)=函数地址 1: kd\u0026gt; dq ffffd50e`00052030+0xad0 ffffd50e`00052b00 ffffd548`a1f10c30 ffffd548`a1db18c0 ffffd50e`00052b10 00000000`00000000 00000000`00000000 ffffd50e`00052b20 00000000`00000000 ffffd548`a1f10930 ffffd50e`00052b30 00000000`00000000 ffffd548`a1f11dc0 ffffd50e`00052b40 ffffd548`a1f0e6b0 ffffd548`a1f11b00 ffffd50e`00052b50 00000000`00000000 ffffd548`a1f0cd70 ffffd50e`00052b60 ffffd548`a1f0d1f0 ffffd548`a1f112f0 ffffd50e`00052b70 00000000`00000000 00000000`00000000 // 以下为函数的汇编 1: kd\u0026gt; u ffffd548`a1f10c30 win32kfull!UMPDDrvResetPDEV: ffffd548`a1f10c30 48895c2418 mov qword ptr [rsp+18h],rbx ffffd548`a1f10c35 4889742420 mov qword ptr [rsp+20h],rsi ffffd548`a1f10c3a 57 push rdi ffffd548`a1f10c3b 4883ec70 sub rsp,70h ffffd548`a1f10c3f 488b05ba440800 mov rax,qword ptr [win32kfull!_security_cookie (ffffd548`a1f95100)] ffffd548`a1f10c46 4833c4 xor rax,rsp ffffd548`a1f10c49 4889442468 mov qword ptr [rsp+68h],rax ffffd548`a1f10c4e 488bf9 mov rdi,rcx 之后通过hdcOpenDCW函数调用用户模式的回调函数，在回调函数中再次调用ResetDC函数，此时传入的HDC和第一次调用ResetDC的是同一个句柄。\n第二次调用win32kfull!GreResetDCInternal 时，传入同一个HDC句柄，即对应同一个DC对象。\n0: kd\u0026gt; t win32kfull!GreResetDCInternal: ffffd548`a1f03e58 488bc4 mov rax,rsp 1: kd\u0026gt; rrcx rcx=00000000092105f1 第二次调用DCOBJ构造函数时，由于传入的是同一个HDC句柄，所以HDC句柄引用次数+1，同时两次调用构造函数构造的对象关联到同一个DC对象。\n之后第二次调用win32kfull!_imp_hdcOpenDCW函数，在该函数内执行政策回调函数，win32kfull!imp_hdcOpenDCW返回一个HDC句柄值为0000000003210041，即创建了一个新的DC对象。之后通过新创建的DC对象创建DCO对象。\n在win32kfull!GreResetDCInternal后半段会调用win32kfull!_imp_HmgSwapLockedHandleContents交换第一个HDC句柄和第二次调用win32kfull!imp_hdcOpenDCW创建的HDC句柄。\n调用win32kfull!_imp_HmgSwapLockedHandleContents之后两个句柄对应的DC内容为已经发生了交换\n// 以下内容为旧DC对象，但是句柄为新句柄 1: kd\u0026gt; dq ffffd50e041fd010 ffffd50e`041fd010 00000000`03210041 80000001`00000000 ...... 1: kd\u0026gt; dq ffffd50e03fee010 // 以下内容为新DC对象，但句柄为旧句柄 ffffd50e`03fee010 00000000`092105f1 80000002`00000000 ...... 之后调用win32kfull!_imp_bDeleteDCInternal传入HDC句柄，该函数会释放HDC句柄对应的DC对象，而此时传入该函数的HDC句柄为第二次调用hdcOpenDCW函数返回的句柄，但之前交换过新旧句柄，所以实际上释放的是旧HDC句柄对应的DC对象。\n之前计算函数指针的时候，我们知道DCO +0x30是指向DC对象的指针，所以在调用win32kfull!_imp_bDeleteDCInternal函数之后，原DC对象的内存空间已经被释放，达成了use-after-free的第一步free。\nfunction pointer=* (* (DCO +0x30)+0xad0)，其中DCO +0x30即指向DC对象的指针\n0: kd\u0026gt; dq ffffd50e041fd010+0x30 // 取DC对象地址 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ...... 0: kd\u0026gt; !pool ffffd50e`00052030 // DC对象的内存已被释放，大小为e30 Pool page ffffd50e00052030 region is Paged session pool *ffffd50e00052000 size: e30 previous size: 0 (Free ) *GDev Pooltag GDev : Gdi pdev ffffd50e00052e30 size: 10 previous size: e30 (Free) Free ffffd50e00052e40 size: 1c0 previous size: 10 (Allocated) Usqu 之后只需要申请这块内存空间并构造，刚删除的时候，虽然DC对象已经被释放，但函数指针还是指向正确的函数地址，接下来就要申请空间，覆盖这块内存空间的函数指针的值即可。\n0: kd\u0026gt; dq ffffd50e041fd010+0x30\t// 取DC对象地址 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 0: kd\u0026gt; dq ffffd50e`00052030+0xad0\t// 取DC对象内的函数指针 ffffd50e`00052b00 ffffd548`a1f10c30 ffffd548`a1db18c0 0: kd\u0026gt; u ffffd548`a1f10c30 win32kfull!UMPDDrvResetPDEV: ffffd548`a1f10c30 48895c2418 mov qword ptr [rsp+18h],rbx ffffd548`a1f10c35 4889742420 mov qword ptr [rsp+20h],rsi ffffd548`a1f10c3a 57 push rdi ffffd548`a1f10c3b 4883ec70 sub rsp,70h ffffd548`a1f10c3f 488b05ba440800 mov rax,qword ptr [win32kfull!_security_cookie (ffffd548`a1f95100)] ffffd548`a1f10c46 4833c4 xor rax,rsp ffffd548`a1f10c49 4889442468 mov qword ptr [rsp+68h],rax ffffd548`a1f10c4e 488bf9 mov rdi,rcx use 部分 注：此部分为第二次调试，所以句柄、内存地址和前部分不一样。\n在poc里面会调用CreatePalette函数，该此函数会申请内核堆，\n第一个句柄rcx=0000000015213372\n// 第一个DCO对象 0: kd\u0026gt; dq rbx DBGHELP: SharedUserData - virtual symbol module ffff885e`847d2620 00000000`15213372 80000001`00000000 ...... // 第一个PDC 指向DC对象 0: kd\u0026gt; dq ffff885e`847d2620+0x30 ffff885e`847d2650 ffff885e`80063030 00000000`00000000 ...... // 第一个DC对象 0: kd\u0026gt; dq ffff885e`80063030 ffff885e`80063030 00000000`00000000 00000000`00000000 ffff885e`80063040 00000000`00000000 ffff885e`80046010 ffff885e`80063050 00000001`00000001 ffff885e`80063030 ffff885e`80063060 00000000`00000000 00000000`00008180 ffff885e`80063070 ffffb48d`a36b4e50 00000000`00000000 ffff885e`80063080 00000000`00000000 00000000`00000000 ffff885e`80063090 00000000`00000000 00000000`00000000 ffff885e`800630a0 00000000`00000000 00000000`00000000 第二个句柄rax=0000000001211b60\n1: kd\u0026gt; dq rdx DBGHELP: SharedUserData - virtual symbol module ffff885e`84121620 00000000`01211b60 80000001`00000000 ...... 1: kd\u0026gt; dq rdx+0x30 ffff885e`84121650 ffff885e`8006b030 00000000`00000000 ...... 1: kd\u0026gt; dq ffff885e`8006b030 ffff885e`8006b030 00000000`00000000 00000000`00000000 ffff885e`8006b040 00000000`00000000 ffff885e`80063030 ffff885e`8006b050 00000001`00000001 ffff885e`8006b030 ffff885e`8006b060 00000000`00000000 00000000`00008180 ffff885e`8006b070 ffffb48d`a317b8b0 00000000`00000000 ffff885e`8006b080 00000000`00000000 00000000`00000000 ffff885e`8006b090 00000000`00000000 00000000`00000000 ffff885e`8006b0a0 00000000`00000000 00000000`00000000 在DeleteDCInternel调用之后第一个DC对象的内存空间已经被释放\n0: kd\u0026gt; !pool ffff885e`80063030 // 注意，此时DC对象地址距离堆头地址为0x30大小 Pool page ffff885e80063030 region is Paged session pool *ffff885e80063000 size: e30 previous size: 0 (Free ) *GDev Pooltag GDev : Gdi pdev ffff885e80063e30 size: 70 previous size: e30 (Free) Free ffff885e80063ea0 size: b0 previous size: 70 (Free ) Usqm ffff885e80063f50 size: b0 previous size: b0 (Allocated) Usqm 根据调试，可以得知释放的DC对象内存大小为0xe30，所以要覆盖函数指针时，所申请的内存也要刚刚好或者接近这块内存大小才有可能申请到。在poc里面，使用CreatePalette申请这块内核堆。这个函数会通过系统调用进入内核函数win32kfull!NtGdiCreatePaletteInternal，该函数调用win32kbase!PALMEMOBJ::bCreatePalette创造Palette对象，win32kbase!PALMEMOBJ::bCreatePalette会调用AllocateObject为新对象申请空间，最终通过调用ExAllocatePoolWithTag函数分配堆空间，整个调用栈如下：\n0: kd\u0026gt; kb # RetAddr : Call Site 00 ffff880c`b95d39f4 : win32kbase!Win32AllocPool 01 ffff880c`b95d0042 : win32kbase!AllocateObject+0xc4 02 ffff880c`b9309ecc : win32kbase!PALMEMOBJ::bCreatePalette+0xb2 03 fffff800`b175a193 : win32kfull!NtGdiCreatePaletteInternal+0xcc 04 00007ffe`a2cb2604 : nt!KiSystemServiceCopyEnd+0x13 05 00007ff7`e44c2fe1 : win32u!NtGdiCreatePaletteInternal+0x14 06 00000000`00000d94 : cve_2021_40449!createPaletteofSize1+0xd1 [C:\\Users\\mimi\\source\\repos\\test\\cve-2021-40449\\main.cpp @ 71] ....... 2e 00007ffe`a2e9b26f : 0x000000d1`a374ef69 2f 00007ffe`a39e1a4a : gdi32full!GdiPrinterThunk+0x21f 30 00007ffe`a61889e4 : USER32!__ClientPrinterThunk+0x3a 31 00007ffe`a2cb6dc4 : ntdll!KiUserCallbackDispatcherContinue 32 00007ffe`a2e7edda : win32u!NtGdiResetDC+0x14 33 00007ffe`a3682371 : gdi32full!ResetDCWInternal+0x17a 34 00007ff7`e44c3296 : GDI32!ResetDCW+0x31 35 00000000`00000000 : cve_2021_40449!main+0x146 [C:\\Users\\mimi\\source\\repos\\test\\cve-2021-40449\\main.cpp @ 685] win32kbase!Win32AllocPool代码如下，最终是通过调用ExAllocatePoolWithTag申请堆，win32kbase!Win32AllocPool的a1参数为要申请的堆内存大小，调试过程中可以得知其要申请0xe20大小的堆，加上堆头，刚好接近刚释放的0xe3大小的堆空间大小。\n__int64 __fastcall Win32AllocPool(__int64 a1, unsigned int a2) { unsigned int v2; // ebx __int64 v3; // rdi __int64 result; // rax v2 = a2; v3 = a1; if ( (signed int)IsWin32AllocPoolImplSupported_0() \u0026lt; 0 ) result = 0i64; else result = Win32AllocPoolImpl_0(33i64, v3, v2); return result; } 同时在Poc代码分析里面分析了DC对象函数指针和堆头之间的位置关系，所以通过构造传入CreatePalette的LOGPALETTE结构可以刚刚好覆盖原DC对象内的函数指针以及该函数指针要调用的参数，内存分布具体见https://github.com/CppXL/cve-2021-40449-poc/blob/master/main.cpp 里面的注释。\n通过函数指针调用RtlSetAllBits函数并传入RtklBitMap型指针，其中RtlBitMap的buffer指向POC进程自身的权限位，如下图：\ntypedef struct _RTL_BITMAP { ULONG SizeOfBitMap; ULONG *Buffer; } RTL_BITMAP, *PRTL_BITMAP; 0: kd\u0026gt; dq ffff885e80063000+0x750 // 此处为RtlBitMap地址 ffff885e`80063750 ffffb48d`a3839010 ffffffff`ffffffff ffff885e`80063760 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063770 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063780 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063790 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637a0 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637b0 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637c0 ffffffff`ffffffff ffffffff`ffffffff 0: kd\u0026gt; dq ffffb48d`a3839010\t// 此处存放了RtlBitMap结构，0x00-0x08为size，0x08-0x10为buffer指针，指向了自身的权限位 ffffb48d`a3839010 00000000`00000080 ffffde8f`1fb2e9d0 ffffb48d`a3839020 41414141`41414141 41414141`41414141 ffffb48d`a3839030 00000000`00000000 00000000`00000000 ffffb48d`a3839040 00000000`00000000 00000000`00000000 ffffb48d`a3839050 00000000`00000000 00000000`00000000 ffffb48d`a3839060 00000000`00000000 00000000`00000000 ffffb48d`a3839070 00000000`00000000 00000000`00000000 ffffb48d`a3839080 00000000`00000000 00000000`00000000 0: kd\u0026gt; dq ffffde8f`1fb2e9d0 ffffde8f`1fb2e9d0 00000006`02880000 00000000`00800000 ffffde8f`1fb2e9e0 00000000`00800000 00000000`00000000 ffffde8f`1fb2e9f0 00000000`00000000 00000000`00000000 ffffde8f`1fb2ea00 20010000`00000000 0000000f`00000001 ffffde8f`1fb2ea10 000001e0`00000000 00000000`00001000 ffffde8f`1fb2ea20 00000000`00000000 ffffde8f`1fb2ee18 ffffde8f`1fb2ea30 00000000`00000000 ffffde8f`1f1007f0 ffffde8f`1fb2ea40 ffffde8f`1f1007f0 ffffde8f`1f10080c 调用DC里面的函数指针之前，自身权限位为正常权限。\n调用函数指针之后，可以看到权限位全部置为了1\n补丁分析 在漏洞利用分析里面分析过漏洞形成原因是因为在调用GreResetDCInternal函数时，使用DC对象指针的时候没有检查DC对象是否异常。而利用该漏洞是通过在调用回调函数时调用ResetDC实现的。\n我们再次回顾一下漏洞函数，在调用hdcOpenDCW也就是在调用回调函数之前会通过DCO的构造函数从DC构造DCO对象，在基本概念中知道，内核对象每被引用一次则对象引用计数器值会加一。调用构造函数时，DC对象引用加一，正常情况下此时DC对象引用次数要为1。如果在回调函数中再次调用ResetDC，则会第二次调用GreResetDCInternal，再次调用DCO的构造函数，DC对象引用再次加一，此时引用次数为2。\n所以判断DC对象异常可以通过判断DC对象的引用次数实现。\n__int64 __usercall GreResetDCInternal@\u0026lt;rax\u0026gt;(HDC a1@\u0026lt;rcx\u0026gt;, __int64 a2@\u0026lt;rdx\u0026gt;, int *a3@\u0026lt;r8\u0026gt;) { __int64 v24; // [rsp+50h] [rbp-20h] __int64 v25; // [rsp+60h] [rbp-10h] DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v25, a1); // 利用构造函数从HDC创建DCOBJ对象 v8 = v25; ·········· v10 = *(_QWORD *)(v8 + 48);\t// 赋值 *(_QWORD *)(v10 + 1736) = 0i64; v24 = v11; ······· v9 = *(_QWORD *)(v25 + 512) != 0i64; v12 = *(_DWORD *)(v25 + 120) \u0026gt; 0; ······· v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的DC对象，返回对应的HDC句柄 if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));// 调用函数指针指向的函数，传入参数为用户传入的HDC对应的DC对象内的值 ······· HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······ bDeleteDCInternal(v6, 1i64, 0i64); // 删除了hdcOpenDCW分配的HDC，但前面经过HmgSwapLockedHandleContents交换了句柄，实际删除的是旧的HDC ······ 在补丁中，增加了对DC对象引用次数进行判断的逻辑，如果在GreResetDCInternal函数中DC对象引用次数大于1则表明已经发生异常，进入异常逻辑抛出错误(因为按正常流程此处DC对象引用次数应为不应该大于1)。\n__int64 __fastcall sub_1C014CB0C(__int64 a1, __int64 a2, int *a3) { ...... int *v30; // [rsp+30h] [rbp-1h] ..... v9 = (__int64)v30; if ( !v30 ) { LABEL_6: EngSetLastError(6i64); LABEL_7: v13 = (__int64)v30; goto LABEL_8; } if ( *((_WORD *)v30 + 6) \u0026gt; 1u ) { if ( *(_DWORD *)\u0026amp;stru_1C032C3F8.Length \u0026gt; 5u \u0026amp;\u0026amp; (unsigned __int8)sub_1C00B5068(\u0026amp;stru_1C032C3F8, 0x400000000000i64) ) { v31 = \u0026amp;v25; v30 = \u0026amp;v26; v29 = \u0026amp;v28; v28 = 0x1000000i64; SysEntryGetDispatchTableValues(v10, (__int64)\u0026amp;unk_1C02F466B, v11, v12); } goto LABEL_6; } 参考链接：\nhttps://www.secrss.com/articles/35266\nhttps://mp.weixin.qq.com/s/AcFS0Yn9SDuYxFnzbBqhkQ\nhttps://bbs.pediy.com/thread-269930.htm\n"},{"uri":"https://cppxl.github.io/research/tunnel-best-practice/application-layer-tunnel/ssh-tunnel/","title":"SSH隧道","tags":[],"description":"","content":"SSH隧道 SSH提供了三种转发模式：本地端口转发、远程端口转发以及动态端口转发，本文将介绍这三种转发模式的用法。\n一些基本概念 本地主机：SSH客户端所在的主机。\n远程主机：相对于本地主机的概念，在本地主机之外的主机叫远程主机。\nSSH命令行参数解释\n-C:压缩传输，提高传输速度 -f:将ssh转入后台执行 -N:建立静默连接（连接后看不到具体会话） -g:允许远程主机连接本地用于转发的端口 -L:本地端口转发 -R:远程端口转发 本地端口转发 本地端口转发，即将本地端口转发到远程主机上，命令格式：ssh -L \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 在SSH Client运行命令ssh -CfNg -L 127.0.0.1:1313:127.0.0.1:1313 root@a.b.c.d ，将127.0.0.1:1313端口转发到SSH Server的127.0.0.1:1313端口上。此时SSH Client访问127.0.0.1:1313的结果跟访问在SSH Server端的127.0.0.1:1313结果一样。\n在SSH Client上\n此时在SSH Client上的ssh会监听127.0.0.1:1313这个端口，该端口的TCP数据通过ssh隧道传输到SSH server上。\n在SSH Server上，先监听127.0.0.1:1313端口，本文监听使用hugo 启动一个server。\n在SSH Client上使用curl 127.0.0.1:1313命令时返回的内容即为SSH Server上127.0.0.1:1313的内容\n同时本地端口转发命令中remote ip不止限制在127.0.0.1上，remote ip可以是任何一个SSH Server能够连接的host，实际上本地端口转发过程中，实际上是把SSH Server当作跳板机，连通SSH Client和SSH Server另外一端的主机，如下：\n|SSH Client| \u0026lt;-------------\u0026gt;|SSH Server| \u0026lt;--------------\u0026gt;|SSH Client不能访问但是SSH Server能访问的主机|\n本地端口转发一般应用场景为在渗透测试过程中控制了目标网络中带有SSH Server的一台机器，通过这台机器做为跳板机来访问内网其他主机上的服务。一定程度上规避防火墙的流量告警（因为ssh流量为加密流量）\n远程端口转发。 远程端口转发即和本地端口转发是相反的概念，本地端口转发是将本地端口转发到远程端口上，连接本地端口即跟连接远程端口一个效果。而远程端口转发即将远程端口转发到本地，使得连接远程端口即跟连接本地端口一样。命令格式：ssh -R \u0026lt;remote port\u0026gt;:\u0026lt;local ip\u0026gt;:\u0026lt;local port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 本次我们将SSH Client的3389端口转发到SSH Server（公网服务器）上，使得另外一台机器能够通过SSH Server的端口连接到位于局域网的SSH Client的远程桌面。\n在ssh client上运行命令\n此时任何连接SSH Server:9898的请求都会被转发到SSH Client的58989端口上，该端口监听的服务为远程桌面服务。在另外一台电脑（不同于SSH Server和SSH Client）使用远程桌面连接SSH Server:9898\n同本地端口转发一样，远程端口转发命令中的local ip可以是任何一个SSH Client能够连接的host，此时SSH Client被当作跳板机，连通SSH Client另外一端和SSH Server端的主机。\n|SSH Serve能够连通的主机| \u0026lt;--------------\u0026gt; |SSH Client| \u0026lt;--------------\u0026gt; |SSH Client能访问但是SSH Server不能访问的主机|\n远程端口转发应用场景一般是将局域网的某些服务通过SSH隧道暴露在公网上，或者在渗透测试过程中，控制了内网的某台主机，通过远程端口转发，将该主机作为跳板机来访问内网其他服务，因为此时SSH是从内网连接到外网，在流量上没有那么可疑。\n动态端口转发 在本地端口转发和远程端口转发过程中，一次性只能转发一个端口，在某些场景下效率太低了，而动态端口转发没有指定目的端口，相对于前两种来说更灵活。实际上动态端口转发即为SSH实现的SOCKS协议。命令格式:ssh -D port \u0026lt;username\u0026gt;@\u0026lt;SSH host\u0026gt;。\n在SSH Client执行命令即可在SSH Client和SSH Server之间建立socks5隧道，SSH Client可以连接该隧道来传输数据。\n组合利用 在一些情况下可以通过组合上面三种转发来达到意想不到的效果。\n例如，有两台位于互不相通的局域网主机，如果一台想要访问另外一台能够访问的服务时，可以以下面的方式达到目的\n在主机1上执行命令 ssh -CfNg -R 9898:192.168.50.1:22 root\u0026lt;SSH Server\u0026gt; 将主机1的ssh端口转发到公网服务器的9898端口。\n在主机2执行命令ssh -D 12222 -p 9898 \u0026lt;username\u0026gt;@\u0026lt;SSH Server\u0026gt; 此时ssh连接的是主机1，且建立了socks隧道，通过该隧道主机2可以方便的使用主机1能访问而主机2不能直接访问的服务。\n"},{"uri":"https://cppxl.github.io/others/vmware-based-implementation-of-small-domain-network-construction/","title":"基于Vmware的小型域网络搭建","tags":[],"description":"","content":"基于Vmware的小型域网络搭建 摘要 在渗透的日常学习过程中经常需要一个内网环境，本篇文章介绍如何使用Vmware和MikroTik搭建简易的二层内网环境。\n网络结构 整个网络分为结构分为三层，第一层模拟外网环境，第二层为DMZ区域，该区域通过边界路由器的端口映射，将第二层网络主机的一些端口映射到边界路由器上对外提供服务，第三层模拟办公网，该层网络为域网络，同时可以控制第二层网络的主机。\n整个网络拓扑图如下：\nIP设置：\n第一层网络为（外网）：192.168.59.0/24\n第二层网络为（DMZ区域）：192.168.72.0/24\n第三层网络为（办公网）：172.16.2.0/24\n路由器IP地址：\n边界路由器：192.168.59.141 | 192.168.72.2\n内网路由器：192.168.72.254 | 172.16.2.254\n网络搭建 网络设置 首先使用VMware的虚拟网络编辑器增加两个网络VMnet2、VMnet3，都勾选仅主机模式，同时取消下面两个勾，如下图：\nVMnet3同理，同时在DHCP设置处设置相应的IP地址和掩码。其中外层网络为nat模式，VMnet2为DMZ区域网络，VMnet3为办公网络\n虚拟机搭建 整个网络在最少情况下一共需要六台虚拟机，分为两台ROS，四台网络中的主机。\nROS从hxxps://mikrotik.com/download下载stable版本的ova格式的镜像，之后导入到VMware中。一共需要导入两次，分别命名为ROS，ROS-1。除了下载镜像之外还需要下载winbox方便对路由器进行设置。\n网络中主机分布：\nDMZ：Ubuntu 2004、windows7\n办公网：Windows server2019、windows7\n创建上述虚拟机，并将DMZ区域的主机的网卡设置为VMnet2，办公网的主机设置为VMnet3.\n将边界路由器ROS网卡设置为net模式和VMnet2模式，内网路由器设置为VMnet2和VMnet3模式。\nIP地址及路由器设置 经历上面的步骤之后，基本的网络拓扑已经搭建完成，接下来需要对网络内的主机和路由器进行设置使得网络中的主机能够相互ping通。\n首先设置两个网络中的主机IP地址\nDMZ：\nWindows7：192.168.72.4/24 网关192.168.72.2 DNS114.114.114.114\nUbuntu ：192.168.72.3/24 网关192.168.72.2 DNS114.\n114.114.114\n办公网：\nWindows server 2019：172.16.2.4/24 网关172.16. 2.254 DNS127.0.0.1\nwindows7：172.16.2.3/24 网关172.16.2.254 DNS172.16.2.4\n至此，两个网络的主机应该可以ping通同一个网络的主机。接下来设置两个ROS的IP地址。\n打开winbox，点击Neighbors按钮，会自动嗅探网络内的存活的路由器，如下图所示。\n上图为边界路由器的IP地址，如果分配了IP地址则可以在浏览器通过IP地址浏览路由器的web界面，在如果没有分配IP地址则通过wibbox使用MAC地址登录\n进入之后，在左侧选项卡会列出路由器拥有的所有网卡接口，点击之后进入到接口详情界面，在里面会列出该接口的一些基本信息，可以通过网卡的MAC分辨该网卡对应在vmware中的网卡，将两个网卡名称分别设置为ether1-wan和ether2-lan，之后在ip-\u0026gt;addresses选项卡中将ether-lan设置为下图。ether1-wan不用设置，因为该网卡网络类型为nat会自动dhcp分配\n之后在IP-\u0026gt;Firewall-\u0026gt;NAT中新建规则，chain：srcnat，out.interface:ether2-lan,action:masquerade\n该规则将使得路由器两边的网络联通。\n参考\nhttps://www.huaweicloud.com/articles/401014315f14d0fb8d5e3f5489693621.html http://www.roszj.com/1692.html http://www.irouteros.com/?p=583\n"},{"uri":"https://cppxl.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://cppxl.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]