<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>vulneribility analysis on chestnut's blog</title><link>https://www.ch35tnut.site/en/vulnerability/</link><description>Recent content in vulneribility analysis on chestnut's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 08 Sep 2021 21:49:43 +0800</lastBuildDate><atom:link href="https://www.ch35tnut.site/en/vulnerability/index.xml" rel="self" type="application/rss+xml"/><item><title>CVE-2021-40449 win32k 权限提升漏洞分析</title><link>https://www.ch35tnut.site/en/vulnerability/cve-2021-40449-win32k-eop/</link><pubDate>Tue, 09 Nov 2021 15:16:28 +0800</pubDate><guid>https://www.ch35tnut.site/en/vulnerability/cve-2021-40449-win32k-eop/</guid><description>CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。
基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。
内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：
在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。
句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。
句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。
https://www.cnblogs.com/MisterXu/p/10846918.html
DC：是一个内核对象，全称device context，设备上下文对象
HDC：DC对象的句柄。
释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。
eg：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-&amp;gt;p = method; p-&amp;gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i &amp;lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-&amp;gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(&amp;#34;第二次调用\n&amp;#34;); p-&amp;gt;p(); return 0; } void method() { printf(&amp;#34;method\n&amp;#34;); } void badMethod() { printf(&amp;#34;bad method\n&amp;#34;); } 漏洞形成分析 该漏洞产生于win32kfull!</description></item></channel></rss>