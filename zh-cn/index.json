[{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/windows-clfs-eop/","title":"Windows CLFS EoP","tags":[],"description":"","content":"Chapter X Some Chapter title 序号 漏洞名 编号 类型 2 windows CLFS 权限提升漏洞 CVE-2023-28252 权限提升 1 windows CLFS 权限提升漏洞 CVE-2022-37969 权限提升 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/","title":"Windows","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/ntlm/","title":"Ntlm 协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/","title":"协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/web/","title":"Web","tags":[],"description":"","content":"web Web安全研究相关\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/","title":"代码审计","tags":[],"description":"","content":"代码审计 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/kerberos-in-windows/","title":"Windows中的kerberos协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/","title":"Kerberos 协议","tags":[],"description":"","content":"kerberos协议研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/dll-inject/","title":"Dll注入","tags":[],"description":"","content":"Dll注入研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/transport-layer/socks/","title":"Socks协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/","title":"隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/application-layer/","title":"应用层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/transport-layer/","title":"传输层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/network-layer/","title":"网络层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/","title":"安全研究","tags":[],"description":"","content":"安全研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/pe/","title":"Pe","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/","title":"漏洞分析","tags":[],"description":"","content":"漏洞分析 序号 漏洞名 编号 类型 1 windows 权限提升漏洞 CVE-2021-40449 权限提升 "},{"uri":"https://www.ch35tnut.site/zh-cn/","title":"首页","tags":[],"description":"","content":"学习记录 记录一些平时学习和生活的日常。\n09-13至09-16\r| 260 days ago\r这周再写一个基于rust的loader，写了一半发现加载的dll太多了，再想办法用动态加载的方式加载dll，感觉用rust做有点难。\n用rust的内联汇编获取到了kernel32.dll和ntdll.dll的基址，还要继续完善。\n2023\r09-10至09-12\r2 days | 263 days ago\r中秋节，在家摸了几天🐟，啥都没干\n2023\r09-05至09-09\r4 days | 268 days ago\r这周编译了wireshark 1.8.5，通过diff1.8.5和1.8.6的源码找出1.8.5里面的漏洞，见\rwireshark 1.8.5代码审计\n2023\r09-03至09-04\r1 day | 270 days ago\r这两天，给hugo主题增加了timeline的shortcode，见\r增加timeline功能\n2023\r08-29至09-02\r4 days | 275 days ago\r周内看了一个几百行的代码，见\rnews_server审计\n2023\r"},{"uri":"https://www.ch35tnut.site/zh-cn/dailylife/","title":"生活随笔","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/","title":"杂项","tags":[],"description":"","content":"杂项 暂无\n"},{"uri":"https://www.ch35tnut.site/zh-cn/others/","title":"其他","tags":[],"description":"","content":"其他 "},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/","title":"Proxy Not Shell","tags":[],"description":"","content":"漏洞环境 Windows Server 2019 Windows Exchange 2019 CU9 漏洞分析 漏洞链包含了两个漏洞：\nCVE-2022-41040 Exchange 权限提升漏洞 CVE-2022-41082 Exchange 远程代码执行漏洞 CVE-2022-41040 是ProxyShell修复不完全的产物，在ProxyShell利用链中无需身份验证就可以通过autodiscover.json请求到/PowerShell接口，在CVE-2022-41040 中，仅需要低权限身份验证就可以请求到该接口，通过SSRF将低权限转换为高权限。\nCVE-2022-41082是Exchange的反序列化漏洞，通过传入恶意序列化数据，使得Exchange触发能够造成代码执行的反序列化过程，将指定数据反序列化到恶意类，从而在Exchange服务器上执行任意代码。\n在PoC中发送了以下三种类型的PSRP消息\n0x00010002 SESSION_CAPABILITY\nSESSION_CAPABILITY 应该是创建RunspacePool\n0x00010004 INIT_RUNSPACEPOOL\nINIT_RUNSPACEPOOL 应该是初始化RunspacePool\n0x00021006 CREATE_PIPELINE\n创建命令管道并在指定的 RunspacePool 中调用它\nPoC通过PSRP协议创建了远程PowerShell管道，并试图在这个管道内执行New-OfflineAddressBook这个cmdlet，并将对应的序列化数据传给了Exchange。\nPoC主要组成部分如下所示，BA标签内是base64编码的序列化System.UnitySerializationHolder对象\n\u0026lt;Obj N=\u0026#34;V\u0026#34; RefId=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;TN RefId=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;T\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/T\u0026gt; \u0026lt;T\u0026gt;System.Object\u0026lt;/T\u0026gt; \u0026lt;/TN\u0026gt; \u0026lt;ToString\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/ToString\u0026gt; \u0026lt;Props\u0026gt; \u0026lt;S N=\u0026#34;Name\u0026#34;\u0026gt;Type\u0026lt;/S\u0026gt; \u0026lt;Obj N=\u0026#34;TargetTypeForDeserialization\u0026#34;\u0026gt; \u0026lt;TN RefId=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;T\u0026gt;System.Exception\u0026lt;/T\u0026gt; \u0026lt;T\u0026gt;System.Object\u0026lt;/T\u0026gt; \u0026lt;/TN\u0026gt; \u0026lt;MS\u0026gt; \u0026lt;BA N=\u0026#34;SerializationData\u0026#34;\u0026gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAAAgU3lzdGVtLldpbmRvd3MuTWFya3VwLlhhbWxSZWFkZXIEAAAABgMAAABYUHJlc2VudGF0aW9uRnJhbWV3b3JrLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MzFiZjM4NTZhZDM2NGUzNQs=\u0026lt;/BA\u0026gt; \u0026lt;/MS\u0026gt; \u0026lt;/Obj\u0026gt; \u0026lt;/Props\u0026gt; \u0026lt;S\u0026gt; \u0026lt;![CDATA[\u0026lt;ResourceDictionary xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:System=\u0026#34;clr-namespace:System;assembly=mscorlib\u0026#34; xmlns:Diag=\u0026#34;clr-namespace:System.Diagnostics;assembly=system\u0026#34;\u0026gt;\u0026lt;ObjectDataProvider x:Key=\u0026#34;LaunchCalch\u0026#34; ObjectType=\u0026#34;{x:Type Diag:Process}\u0026#34; MethodName=\u0026#34;Start\u0026#34;\u0026gt;\u0026lt;ObjectDataProvider.MethodParameters\u0026gt;\u0026lt;System:String\u0026gt;cmd.exe\u0026lt;/System:String\u0026gt;\u0026lt;System:String\u0026gt;/c whoami\u0026gt; c:\\users\\public\\1.txt\u0026lt;/System:String\u0026gt; \u0026lt;/ObjectDataProvider.MethodParameters\u0026gt; \u0026lt;/ObjectDataProvider\u0026gt; \u0026lt;/ResourceDictionary\u0026gt;]]\u0026gt; \u0026lt;/S\u0026gt; \u0026lt;/Obj\u0026gt; XamlReader.Parse() BA标签数据 .....ÿÿÿÿ..............System.UnitySerializationHolder..... Data\tUnityType.AssemblyName......... System.Windows.Markup.XamlReader......... XPresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35. PoC部分由两个对象嵌套而成，大致结构如下所示：\nObj V(System.ServiceProcess.ServiceController): String Name=\u0026#34;Type\u0026#34; Obj TargetTypeForDeserialization(System.Exception): ByteArray SerializationData String SerializationData 代码逻辑\n代码逻辑如下图\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\r背景 1\rCenter Gradient\r页-1\r流程\rReadOneObject\rReadOneObject\t流程.8\rReadOneDeserializedObject 遍历XML树的标签\rReadOneDeserializedObject遍历XML树的标签\t动态连接线\r调用读取一个反序列化对象 object obj = this.ReadOneDeserializedObject\r调用，读取一个反序列化对象object obj = this.ReadOneDeserializedObject\t动态连接线.12\r碰到Obj标签调用读取一个Obj对象 if (this.IsNextElement(\u0026#34;Obj\u0026#34;)){ return thi...\r碰到Obj标签，调用，读取一个Obj对象if (this.IsNextElement(\u0026#34;Obj\u0026#34;)){return this.ReadPSObject();}\t流程.11\rReadPSObject 读取一个Obj对象\rReadPSObject读取一个Obj对象\t动态连接线.14\r碰到Props标签调用读取Props标签 if (this.IsNextElement(\u0026#34;Props\u0026#34;)){ this.R...\r碰到Props标签，调用，读取Props标签if (this.IsNextElement(\u0026#34;Props\u0026#34;)){this.ReadProperties(psobject);}\t流程.13\rReadProperties\rReadProperties\t动态连接线.16\r调用读取嵌套对象\r调用，读取嵌套对象\t流程.15\rReadOneObject\rReadOneObject\t动态连接线.20\r调用将反序列化数据 转换为目标类型此时目标类型为System.Exception\r调用，将反序列化数据转换为目标类型，此时目标类型为System.Exception\t流程.19\rConvertTo\rConvertTo\t动态连接线.22\r一系列调用\r一系列调用\t流程.21\rObject.Reader.Deserialize\rObject.Reader.Deserialize\t动态连接线.24\r调用解析内存中的序列化数据\r调用，解析内存中的序列化数据\t流程.23\r__BinaryParser.Run\r__BinaryParser.Run\t动态连接线.28\r流程.27\r将序列化数据解析为System.UnitySerializationHolder对象并载入m_assmblyName对应的...\r将序列化数据解析为System.UnitySerializationHolder对象，并载入m_assmblyName对应的DLL\t动态连接线.39\r流程.38\r转化为在m_assmblyName对应的DLL中的m_data对应类型的Type对象\r转化为在m_assmblyName对应的DLL中的m_data对应类型的Type对象\t动态连接线.41\r一系列返回\r一系列返回\t动态连接线.43\r流程.42\r将ConverTo返回的Type对象加入.adaptedMembers\r将ConverTo返回的Type对象加入.adaptedMembers\t流程.45\rGetTargetTypeForDeserialization\rGetTargetTypeForDeserialization\t流程.53\rReadOneDeserializedObject\rReadOneDeserializedObject\t流程.54\rReadOneObject\rReadOneObject\t动态连接线.56\r动态连接线.57\r动态连接线.58\r动态连接线.59\r调用\r调用\t动态连接线.61\r流程.60\rGetPSStandardMember\rGetPSStandardMember\t动态连接线.63\r流程.62\r读取adaptedMembers的TargetTypeForDeserialization并返回\r读取adaptedMembers的TargetTypeForDeserialization并返回\t动态连接线.66\r调用将外层对象序列化数据\r调用，将外层对象序列化数据\t流程.65\rLanguagePrimitives.ConvertTo\rLanguagePrimitives.ConvertTo\t动态连接线.69\r流程.68\r将S标签内数据转换为XamlReader对象触发代码执行\r将S标签内数据转换为XamlReader对象，触发代码执行\t在Exchange中，允许反序列化的类白名单和类反序列化相关信息定义在exchange.partial.types.ps1xml和exchange.types.ps1xml等文件中，Exchange会读取这些文件，在反序列化数据时，会payload里面的目标类和文件里面的白名单类做对比，只有在白名单内的类才允许反序列化。\nPoC由嵌套对象组成，在反序列化嵌套对象时，会先反序列化里层对象，而后反序列化外层对象。在Exchang反序列化PoC的里层对象时，将通过ConvertTo函数转换到目标类，传给ConvertTo的resultType值为System.Exception，System.Exception在exchange.partial.types.ps1xml中定义如下：\n\u0026lt;Type\u0026gt; \u0026lt;Name\u0026gt;System.Exception\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;CodeProperty IsHidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Name\u0026gt;SerializationData\u0026lt;/Name\u0026gt; \u0026lt;GetCodeReference\u0026gt; \u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt; \u0026lt;MethodName\u0026gt;GetSerializationData\u0026lt;/MethodName\u0026gt; \u0026lt;/GetCodeReference\u0026gt; \u0026lt;/CodeProperty\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;TypeConverter\u0026gt; \u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt; \u0026lt;/TypeConverter\u0026gt; \u0026lt;/Type\u0026gt; internal static object ConvertTo(object valueToConvert, Type resultType, bool recursion, IFormatProvider formatProvider, TypeTable backupTypeTable) { object result; using (LanguagePrimitives.typeConversion.TraceScope(\u0026#34;Converting \\\u0026#34;{0}\\\u0026#34; to \\\u0026#34;{1}\\\u0026#34;.\u0026#34;, valueToConvert, resultType)) { if (resultType == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;resultType\u0026#34;); } bool flag; result = LanguagePrimitives.FigureConversion(valueToConvert, resultType, out flag).Invoke(flag ? PSObject.Base(valueToConvert) : valueToConvert, resultType, recursion, flag ? ((PSObject)valueToConvert) : null, formatProvider, backupTypeTable); } return result; } 其定义了*\u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt;，Exchange将通过Microsoft.Exchange.Data.SerializationTypeConverter*类对里层序列化数据进行反序列化。Microsoft.Exchange.Data.SerializationTypeConverter经过一系列调用，最终由System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize方法进行反序列化。\n在该方法会调用System.Runtime.Serialization.Formatters.Binary.__BinaryParser.Run，这方法会循环读取内存中的里层对象的序列化数据，将其转换为System.UnitySerializationHolder对象。\n之后Exchange会通过Assembly.LoadFrom载入*System.UnitySerializationHolder.m_assemblyName所指明的DLL，并且返回System.UnitySerializationHolder.m_data*类型的Type对象。\ninternal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage) { ...... serParser.Run(); ...... if (!this.bMethodCall \u0026amp;\u0026amp; !this.bMethodReturn) { if (this.TopObject == null) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TopObject\u0026#34;)); } if (this.HasSurrogate(this.TopObject.GetType()) \u0026amp;\u0026amp; this.topId != 0L) { this.TopObject = this.m_objectManager.GetObject(this.topId); } if (this.TopObject is IObjectReference) { this.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); } } if (this.bFullDeserialization) { this.m_objectManager.RaiseDeserializationEvent(); } if (handler != null) { this.handlerObject = handler(this.headers); } if (this.bMethodCall) { object[] callA = this.TopObject as object[]; this.TopObject = this.binaryMethodCall.ReadArray(callA, this.handlerObject); } else if (this.bMethodReturn) { object[] returnA = this.TopObject as object[]; this.TopObject = this.binaryMethodReturn.ReadArray(returnA, methodCallMessage, this.handlerObject); } return this.TopObject; } 在一系列函数调用返回后，System.Management.Automation.InternalDeserializer.ReadProperties会将System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize返回的对象添加到PSObject.adaptedMembers中，需要注意的是该对象变量名为TargetTypeForDeserialization。\nprivate void ReadProperties(PSObject dso) { dso.isDeserialized = true; dso.adaptedMembers = new PSMemberInfoInternalCollection\u0026lt;PSPropertyInfo\u0026gt;(); dso.InstanceMembers.Add(PSObject.dotNetInstanceAdapter.GetDotNetMethod\u0026lt;PSMemberInfo\u0026gt;(dso, \u0026#34;GetType\u0026#34;)); PSGetMemberBinder.SetHasInstanceMember(\u0026#34;GetType\u0026#34;); dso.clrMembers = new PSMemberInfoInternalCollection\u0026lt;PSPropertyInfo\u0026gt;(); if (this.ReadStartElementAndHandleEmpty(\u0026#34;Props\u0026#34;)) { while (this._reader.NodeType == XmlNodeType.Element) { string name = this.ReadNameAttribute(); object serializedValue = this.ReadOneObject(); PSProperty member = new PSProperty(name, serializedValue); dso.adaptedMembers.Add(member); } this.ReadEndElement(); } } 在反序列化外层对象时，ReadOneObject会调用GetTargetTypeForDeserialization获取反序列化的目标类型，并通过ConvertTo转化为该对象。\n在GetTargetTypeForDeserialization函数中，将会调用GetPSStandardMember并传入硬编码的TargetTypeForDeserialization，在GetPSStandardMember中会通过TypeTableGetMemberDelegate创建成员集合，其中包括子类的成员属性，而后匹配其中的memberName项对应的值并返回。此时获取的值为XamlReader类型的Type对象。\ninternal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable) { PSMemberInfo psstandardMember = this.GetPSStandardMember(backupTypeTable, \u0026#34;TargetTypeForDeserialization\u0026#34;); if (psstandardMember != null) { return psstandardMember.Value as Type; } return null; } internal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName) { PSMemberInfo psmemberInfo = null; TypeTable typeTable = (backupTypeTable != null) ? backupTypeTable : this.GetTypeTable(); if (typeTable != null) { PSMemberSet psmemberSet = PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberSet\u0026gt;(this, typeTable, \u0026#34;PSStandardMembers\u0026#34;); if (psmemberSet != null) { psmemberSet.ReplicateInstance(this); psmemberInfo = new PSMemberInfoIntegratingCollection\u0026lt;PSMemberInfo\u0026gt;(psmemberSet, PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable))[memberName]; } } if (psmemberInfo == null) { psmemberInfo = (this.InstanceMembers[\u0026#34;PSStandardMembers\u0026#34;] as PSMemberSet); } return psmemberInfo; } 外层类类型定义为System.ServiceProcess.ServiceController，其定义在types.ps1xml文件内，定义如下。\n\u0026lt;Type\u0026gt; \u0026lt;Name\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;MemberSet\u0026gt; \u0026lt;Name\u0026gt;PSStandardMembers\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;PropertySet\u0026gt; \u0026lt;Name\u0026gt;DefaultDisplayPropertySet\u0026lt;/Name\u0026gt; \u0026lt;ReferencedProperties\u0026gt; \u0026lt;Name\u0026gt;Status\u0026lt;/Name\u0026gt; \u0026lt;Name\u0026gt;Name\u0026lt;/Name\u0026gt; \u0026lt;Name\u0026gt;DisplayName\u0026lt;/Name\u0026gt; \u0026lt;/ReferencedProperties\u0026gt; \u0026lt;/PropertySet\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;/MemberSet\u0026gt; \u0026lt;AliasProperty\u0026gt; \u0026lt;Name\u0026gt;Name\u0026lt;/Name\u0026gt; \u0026lt;ReferencedMemberName\u0026gt;ServiceName\u0026lt;/ReferencedMemberName\u0026gt; \u0026lt;/AliasProperty\u0026gt; \u0026lt;AliasProperty\u0026gt; \u0026lt;Name\u0026gt;RequiredServices\u0026lt;/Name\u0026gt; \u0026lt;ReferencedMemberName\u0026gt;ServicesDependedOn\u0026lt;/ReferencedMemberName\u0026gt; \u0026lt;/AliasProperty\u0026gt; \u0026lt;ScriptMethod\u0026gt; \u0026lt;Name\u0026gt;ToString\u0026lt;/Name\u0026gt; \u0026lt;Script\u0026gt; $this.ServiceName \u0026lt;/Script\u0026gt; \u0026lt;/ScriptMethod\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;/Type\u0026gt; 在GetPSStandardMember函数会试图获取System.ServiceProcess.ServiceController类的TargetTypeForDeserialization（传入的硬编码参数）属性，但其在文件内没有定义默认的TargetTypeForDeserialization值，所以外层类的members内没有TargetTypeForDeserialization名字的值，Exchange将试图从子类的members属性中检索TargetTypeForDeserialization名字的值，前面说过在对内层对象反序列化时，通过ReadProperties将名为TargetTypeForDeserialization的XamlReader类型的Type对象添加到了adaptedMembers中，此时Exchange将会检索到该对象并返回。\n获取到targetTypeForDeserialization之后，ReadOneObject调用LanguagePrimitives.ConvertTo将序列化数据转换为targetTypeForDeserialization(XamlReader)。\ninternal object ReadOneObject(out string streamName) { .... object obj = this.ReadOneDeserializedObject(out streamName, out flag); ..... Type targetTypeForDeserialization = psobject.GetTargetTypeForDeserialization(this._typeTable); .... object obj2 = LanguagePrimitives.ConvertTo(obj, targetTypeForDeserialization, true, CultureInfo.InvariantCulture, this._typeTable); ..... } ConvertTo函数会进行如下调用链，通过反射获取到XamlReader类的Parse方法后，将其调用，成功执行代码。\n调试 使用dnsPy附加到下面的进程\nc:\\windows\\system32\\inetsrv\\w3wp.exe -ap \u0026#34;MSExchangePowerShellAppPool\u0026#34; -v \u0026#34;v4.0\u0026#34; -c \u0026#34;C:\\Program Files\\Microsoft\\Exchange Server\\V15\\bin\\GenericAppPoolConfigWithGCServerEnabledFalse.config\u0026#34; -a \\\\.\\pipe\\iisipm319caf0c-5de0-4833-8a04-4b28f4a836ae -h \u0026#34;C:\\inetpub\\temp\\apppools\\MSExchangePowerShellAppPool\\MSExchangePowerShellAppPool.config\u0026#34; -w \u0026#34;\u0026#34; -m 0 在以下几个地方下断点\nSystem.Runtime.Serialization.Formatters.Binary ObjectReader.Deserialize 发送PoC，调试器在断点处断下，此时调用栈如下:\n此时为Exchange试图将Props标签内的序列化数据通过ConvertTo函数转化为System.Exception对象，System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize会通过serParser.Run()解析读入内存中的base64解码数据。\ninternal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage) { ..... serParser.Run(); if (this.bFullDeserialization) { this.m_objectManager.DoFixups(); } if (!this.bMethodCall \u0026amp;\u0026amp; !this.bMethodReturn) { if (this.TopObject == null) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TopObject\u0026#34;)); } if (this.HasSurrogate(this.TopObject.GetType()) \u0026amp;\u0026amp; this.topId != 0L) { this.TopObject = this.m_objectManager.GetObject(this.topId); } if (this.TopObject is IObjectReference) { this.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); } } if (this.bFullDeserialization) { this.m_objectManager.RaiseDeserializationEvent(); } if (handler != null) { this.handlerObject = handler(this.headers); } if (this.bMethodCall) { object[] callA = this.TopObject as object[]; this.TopObject = this.binaryMethodCall.ReadArray(callA, this.handlerObject); } else if (this.bMethodReturn) { object[] returnA = this.TopObject as object[]; this.TopObject = this.binaryMethodReturn.ReadArray(returnA, methodCallMessage, this.handlerObject); } return this.TopObject; } serParser.Run()会将内存序列化数据试图转化为System.UnitySerializationHolder 对象，代码如下，通过循环读取各个标志位调用不同方法从内存中读取指定类型的数据。构造出System.UnitySerializationHolder对象并载入System.UnitySerializationHolder.AssemblyName对应的DLL。\ninternal void Run() { try { bool flag = true; this.ReadBegin(); this.ReadSerializationHeaderRecord(); while (flag) { BinaryHeaderEnum binaryHeaderEnum = BinaryHeaderEnum.Object; BinaryTypeEnum binaryTypeEnum = this.expectedType; if (binaryTypeEnum != BinaryTypeEnum.Primitive) { if (binaryTypeEnum - BinaryTypeEnum.String \u0026gt; 6) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TypeExpected\u0026#34;)); } byte b = this.dataReader.ReadByte(); binaryHeaderEnum = (BinaryHeaderEnum)b; switch (binaryHeaderEnum) { case BinaryHeaderEnum.Object: this.ReadObject(); break; case BinaryHeaderEnum.ObjectWithMap: ..... this.ReadObjectWithMap(binaryHeaderEnum); break; case BinaryHeaderEnum.ObjectWithMapTyped: ...... this.ReadObjectWithMapTyped(binaryHeaderEnum); break; case BinaryHeaderEnum.ObjectString: ...... this.ReadObjectString(binaryHeaderEnum); break; case BinaryHea......flag2) { ObjectProgress objectProgress = (ObjectProgress)this.stack.Peek(); if (objectProgress == null) { this.expectedType = BinaryTypeEnum.ObjectUrt; this.expectedTypeInformation = null; flag2 = true; } else { flag2 = objectProgress.GetNext(out objectProgress.expectedType, out objectProgress.expectedTypeInformation); this.expectedType = objectProgress.expectedType; this.expectedTypeInformation = objectProgress.expectedTypeInformation; if (!flag2) { this.prs.Init(); if (objectProgress.memberValueEnum == InternalMemberValueE.Nested) { this.prs.PRparseTypeEnum = InternalParseTypeE.MemberEnd; this.prs.PRmemberTypeEnum = objectProgress.memberTypeEnum; this.prs.PRmemberValueEnum = objectProgress.memberValueEnum; this.objectReader.Parse(this.prs); } else { this.prs.PRparseTypeEnum = InternalParseTypeE.ObjectEnd; this.prs.PRmemberTypeEnum = objectProgress.memberTypeEnum; this.prs.PRmemberValueEnum = objectProgress.memberValueEnum; this.objectReader.Parse(this.prs); } this.stack.Pop(); this.PutOp(objectProgress); } } } } } } ...... } 将XamlReader读入内存\n在System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize中将通过\nthis.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); 将System.UnitySerializationHolder转化为Type类型的XamlReader对象，并通过反射获取了XamlReader类的各个属性。\n在最后将this.TopObject作为返回值返回，在经过一系列函数调用返回后，可以在调试器看到ConvertTo函数返回了Object类型对象obj2，可以看到其为类型为Type类型的XamlReader对象，之后ReadOneObject返回该对象。\n注：Type类型是Exchange内定义的抽象类，如下所示：\nnamespace System { // Token: 0x02000148 RID: 328 [ClassInterface(ClassInterfaceType.None)] [ComDefaultInterface(typeof(_Type))] [ComVisible(true)] [__DynamicallyInvokable] [Serializable] public abstract class Type : MemberInfo, _Type, IReflect { // Token: 0x17000217 RID: 535 // (get) Token: 0x060013E6 RID: 5094 RVA: 0x0003BE2A File Offset: 0x0003A02A public override MemberTypes MemberType { get { return MemberTypes.TypeInfo; } } (应该可以理解obj2为实现了Type这个抽象类的XamlReader对象，而XamlReader继承了Object这个父类，所以可以使用Object类型对象接受)\n在调用栈内，ReadOneObject由ReadProperties调用，回到ReadProperties逻辑中，Exchange会将ReadOneObject返回的的Type类型的XamlReader对象添加到dso.adaptedMembers中，而后这个dso将会返回到调用栈内的ReadOneObject函数。\n继续调试，此时嵌套对象的内层对象已反序列化，开始反序列化外层对象，回到程序中，从下图可以看到，将会调用psobject.GetTargetTypeForDeserialization获取目标反序列化类型，此时psobject内的adaptedMembers内有名为TargetTypeForDeserialization的对象，其类型为Type的XamlReader对象\n进入到psobject.GetTargetTypeForDeserialization内，调用this.GetPSStandardMember试图获取PSMemberInfo 对象，而后将其强转为Type对象返回，若失败则返回null\ninternal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable) { PSMemberInfo psstandardMember = this.GetPSStandardMember(backupTypeTable, \u0026#34;TargetTypeForDeserialization\u0026#34;); if (psstandardMember != null) { return psstandardMember.Value as Type; } return null; } 在GetPSStandardMember函数内，调用PSObject.TypeTableGetMemberDelegate并传入当前对象、允许的类型列表和硬编码PSStandardMembers以初始化PSMemberSet 对象。\ninternal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName) { PSMemberInfo psmemberInfo = null; TypeTable typeTable = (backupTypeTable != null) ? backupTypeTable : this.GetTypeTable(); if (typeTable != null) { PSMemberSet psmemberSet = PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberSet\u0026gt;(this, typeTable, \u0026#34;PSStandardMembers\u0026#34;); if (psmemberSet != null) { psmemberSet.ReplicateInstance(this); psmemberInfo = new PSMemberInfoIntegratingCollection\u0026lt;PSMemberInfo\u0026gt;(psmemberSet, PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable))[memberName]; } } if (psmemberInfo == null) { psmemberInfo = (this.InstanceMembers[\u0026#34;PSStandardMembers\u0026#34;] as PSMemberSet); } return psmemberInfo; } 而后调用PSMemberInfoIntegratingCollection构造函数，其中PSMemberInfoIntegratingCollection类继承了PSMemberInfo类。传入构造函数的collections变量来源于PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable) 函数的返回值，构造函数将collections赋给当前对象的collections属性。\ninternal class PSMemberInfoIntegratingCollection\u0026lt;T\u0026gt; : PSMemberInfoCollection\u0026lt;T\u0026gt;, IEnumerable\u0026lt;T\u0026gt;, IEnumerable where T : PSMemberInfo { // Token: 0x06002AC3 RID: 10947 RVA: 0x000C35F4 File Offset: 0x000C17F4 private void GenerateAllReservedMembers() { if (!this.mshOwner.hasGeneratedReservedMembers) { this.mshOwner.hasGeneratedReservedMembers = true; ReservedNameMembers.GeneratePSExtendedMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSBaseMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSObjectMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSAdaptedMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSTypeNames(this.mshOwner); } } internal PSMemberInfoIntegratingCollection(object owner, Collection\u0026lt;CollectionEntry\u0026lt;T\u0026gt;\u0026gt; collections) { if (owner == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;owner\u0026#34;); } this.mshOwner = (owner as PSObject); this.memberSetOwner = (owner as PSMemberSet); if (this.mshOwner == null \u0026amp;\u0026amp; this.memberSetOwner == null) { throw PSTraceSource.NewArgumentException(\u0026#34;owner\u0026#34;); } if (collections == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;collections\u0026#34;); } this.collections = collections; } GetMemberCollection代码如下，其会将对象的adaptedMembers属性添加到列表中，而在内层对象反序列化时已经将名为TargetTypeForDeserialization的XamlReader类型的Type对象加入到adaptedMembers属性中。所以返回的列表内也会包含该对象。\ninternal static Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt; GetMemberCollection(PSMemberViewTypes viewType, TypeTable backupTypeTable) { Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt; collection = new Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt;(); if ((viewType \u0026amp; PSMemberViewTypes.Extended) == PSMemberViewTypes.Extended) { if (backupTypeTable == null) { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.TypeTableGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), true, true, \u0026#34;type table members\u0026#34;)); } else { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;((PSObject msjObj) =\u0026gt; PSObject.TypeTableGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;(msjObj, backupTypeTable), (PSObject msjObj, string name) =\u0026gt; PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;(msjObj, backupTypeTable, name), true, true, \u0026#34;type table members\u0026#34;)); } } if ((viewType \u0026amp; PSMemberViewTypes.Adapted) == PSMemberViewTypes.Adapted) { **collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.AdapterGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.AdapterGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), false, false, \u0026#34;adapted members\u0026#34;));** } if ((viewType \u0026amp; PSMemberViewTypes.Base) == PSMemberViewTypes.Base) { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.DotNetGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.DotNetGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), false, false, \u0026#34;clr members\u0026#34;)); } return collection; } private static T AdapterGetMemberDelegate\u0026lt;T\u0026gt;(PSObject msjObj, string name) where T : PSMemberInfo { if (!msjObj.isDeserialized) { T t = msjObj.InternalAdapter.BaseGetMember\u0026lt;T\u0026gt;(msjObj.immediateBaseObject, name); PSObject.memberResolution.WriteLine(\u0026#34;Adapted member: {0}.\u0026#34;, (t == null) ? \u0026#34;not found\u0026#34; : t.Name); return t; } if (msjObj.adaptedMembers == null) { return default(T); } T t2 = msjObj.adaptedMembers[name] as T; PSObject.memberResolution.WriteLine(\u0026#34;Serialized adapted member: {0}.\u0026#34;, (t2 == null) ? \u0026#34;not found\u0026#34; : t2.Name); return t2; } 返回到GetPSStandardMember函数中，Exchange会匹配构造函数返回的对象的memberName属性，该属性来源于GetTargetTypeForDeserialization调用时传递的硬编码TargetTypeForDeserialization，即将从该对象中检索名为TargetTypeForDeserialization的值，前面提到过列表内已有该名字的对象，所以将匹配到XamlReader类型的Type对象，并返回给上层函数。\n返回到上层函数，GetTargetTypeForDeserialization返回了XamlReader类型。\n进入到ConvertTo函数内，valueToConvert为上层函数ReadOneObject函数传入的obj对象，其内包含了xaml反序列化的命令执行字符串。\n进入到LanguagePrimitives.FigureConversion在#3527处断点，此时fromType为String，toType为XamlReader\n进入FigureParseConversion内，将会通过反射获取到XamlReader的Parse方法。\nprivate static LanguagePrimitives.PSConverter\u0026lt;object\u0026gt; FigureParseConversion(Type fromType, Type toType) { ..... else if (fromType == typeof(string)) { MethodInfo methodInfo = null; try { methodInfo = toType.GetMethod(\u0026#34;Parse\u0026#34;, BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy, null, new Type[] { typeof(string), typeof(IFormatProvider) }, null); } catch (AmbiguousMatchException ex) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method with CultureInfo: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex.Message); } catch (ArgumentException ex2) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method with CultureInfo: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex2.Message); } if (methodInfo != null) { return new LanguagePrimitives.PSConverter\u0026lt;object\u0026gt;(new LanguagePrimitives.ConvertViaParseMethod { parse = methodInfo }.ConvertWithCulture); } try { methodInfo = toType.GetMethod(\u0026#34;Parse\u0026#34;, BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy, null, new Type[] { typeof(string) }, null); } catch (AmbiguousMatchException ex3) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex3.Message); } catch (ArgumentException ex4) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex4.Message); } if (methodInfo != null) { return new LanguagePrimitives.PSConverter\u0026lt;object\u0026gt;(new LanguagePrimitives.ConvertViaParseMethod { parse = methodInfo }.ConvertWithoutCulture); } } return null; } XamlReader.Parse方法将会由LanguagePrimitives.ConvertViaParseMethod.ConvertWithoutCulture方法调用。之后就是普通的反序列化过程了。\n小结 这个漏洞利用链核心是如何绕过Exchange黑名单类并使Exchange将攻击者控制的指定数据反序列化到指定危险类造成代码执行。\n漏洞利用了Exchange的合法功能，先构造了名为targetTypeForDeserialization 的XamlReader类型的Type对象序列化值，利用Microsoft.Exchange.Data.SerializationTypeConverter的特性返回了XamlReader类型的Type对象，而后ReadProperties将其加入到adaptedMember内。在外层对象反序列化时，构造的PSMembers包含了名为targetTypeForDeserialization的XamlReader类型的Type对象，Exchange会在PSMembers列表内匹配targetTypeForDeserialization项，从而控制了ConvertTo函数转化的目标类XamlReader，Exchange通过反射获取到了XamlReader的Parse方法，调用该方法反序列化攻击者可控的序列化数据，触发代码执行。\n在调试过程中需要将.NET Framework的优化关掉以便dnSpy调试\n[.NET Framework Debugging Control] GenerateTrackingInfo=1 AllowOptimize=0 COMPlus_ZapDisable=1 COMPlus_ReadyToRun=0 其他\nPSRP：PowerShell Remote Protocol powerShell远程协议，是微软提供的通过SOAP协议上执行PowerShell代码的协议\n参考资料\nhttps://www.zerodayinitiative.com/blog/2022/11/14/control-your-types-or-get-pwned-remote-code-execution-in-exchange-powershell-backend\nhttps://www.zerodayinitiative.com/blog/2021/8/17/from-pwn2own-2021-a-new-attack-surface-on-microsoft-exchange-proxyshell\nCreated at 2023-05-05T20:35:49+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/wireshark-185/","title":"Wireshark 1.8.5代码审计","tags":[],"description":"","content":"通过爬取wireshark的漏洞公告页面，筛选1.8.6修复的漏洞可以得到如下结果：\n1.8.6/1.8.7修复的漏洞\nwnpa-sec-2013-31. ETCH dissector large loop. Fixed in 1.8.7.\nThe ETCH dissector could go into a large loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-30. MySQL dissector infinite loop. Fixed in 1.8.7.\nThe MySQL dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-29. Websocket dissector crash. Fixed in 1.8.7.\nThe Websocket dissector could crash. Discovered by Moshe Kaplan.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-28. MPEG DSM-CC dissector crash. Fixed in 1.8.7.\nThe MPEG DSM-CC dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-27. DCP ETSI dissector crash. Fixed in 1.8.7.\nThe DCP ETSI dissector could crash. Discovered by Evan Jensen.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-26. PPP CCP dissector crash. Fixed in 1.8.7.\nThe PPP CCP dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-25. ASN.1 BER dissector crash. Fixed in 1.8.7, 1.6.15.\nThe ASN.1 BER dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-24. GTPv2 dissector crash. Fixed in 1.8.7.\nThe GTPv2 dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-23. RELOAD dissector infinite loop. Fixed in 1.8.7.\nThe RELOAD dissector could go into an infinite loop. Discovered by Evan Jensen.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-22. DTLS dissector crash. Fixed in 1.8.6, 1.6.14.\nThe DTLS dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-21. RELOAD dissector infinite loop. Fixed in 1.8.6.\nThe RELOAD dissector could go into an infinite loop. Discovered by Even Jensen.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-20. FCSP dissector infinite loop. Fixed in 1.8.6, 1.6.14.\nThe FCSP dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-19. CIMD dissector crash. Fixed in 1.8.6, 1.6.14.\nThe CIMD dissector could crash. Discovered by Moshe Kaplan.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-18. ACN dissector divide by zero. Fixed in 1.8.6, 1.6.14.\nThe ACN dissector could attempt to divide by zero. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-17. AMPQ dissector infinite loop. Fixed in 1.8.6, 1.6.14.\nThe AMPQ dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-16. Mount dissector crash. Fixed in 1.8.6, 1.6.14.\nThe Mount dissector could crash. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-15. RTPS and RTPS2 dissector crash. Fixed in 1.8.6, 1.6.14.\nThe RTPS and RTPS2 dissectors could crash. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-14. MPLS Echo dissector infinite loop. Fixed in 1.8.6.\nThe MPLS Echo dissector could go into an infinite loop. Discovered by Laurent Butti.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-13. MS-MMS dissector crash. Fixed in 1.8.6, 1.6.14.\nThe MS-MMS dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-12. CSN.1 dissector crash. Fixed in 1.8.6.\nThe CSN.1 dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-11. HART/IP dissector infinite loop. Fixed in 1.8.6.\nThe HART/IP dissectory could go into an infinite loop.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-10. TCP dissector crash. Fixed in 1.8.6.\nThe TCP dissector could crashIt may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nCreated att 2022-09-08T18:13:59+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/news-server/","title":"News Server审计","tags":[],"description":"","content":"代码地址\nhttps://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_install.sh\nhttps://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_server.c\nhttps://trailofbits.github.io/ctf/vulnerabilities/source.html\n编译：gcc -m32 -g -o news_server news_server.c\n目标：找出10个bug和漏洞\nnews_server默认工作在根目录，没有通过chdir切换工作目录（不知道算不算bug）\n修复：\nvoid handleConnection(FILE *logfile, int sock) { chdir(\u0026#34;/root/code/c/news_server/\u0026#34;); 在authenticate函数存在admin后门\nif (memcmp(pass, \u0026#34;baCkDoOr\u0026#34;, 9) == 0) { return 1; } authenticate 中直接拼接用户输入到命令，命令注入\nint authenticate(FILE *logfile, char *user, char *pass) { char search[512]; char path[1024]; char userfile[1024]; char data[1024]; FILE *file; int ret; memset(path, 0, sizeof(1024)); /* FIXME: hard coded admin backdoor for password recovery */\tif (memcmp(pass, \u0026#34;baCkDoOr\u0026#34;, 9) == 0) { return 1; } /* look up user by checking user files: done via system() to /bin/ls|grep user */ logData(logfile, \u0026#34;performing lookup for user via system()!\\n\u0026#34;); snprintf(userfile, sizeof(userfile)-1, \u0026#34;%s.txt\u0026#34;, user); snprintf(search, sizeof(userfile)-1, \u0026#34;stat %s`ls %s | grep %s`\u0026#34;, USERPATH, USERPATH, userfile); ret = system(search); 栈溢出、任意文件读（目录穿越）\nvoid readArticle(int sock, FILE *logfile, char *action) { FILE *file; char buf[100]; char path[100]; logData(logfile, \u0026amp;action[1]); strcpy(path, ARTICLEPATH); strcat(path, \u0026amp;action[1]); logData(logfile, \u0026#34;user request to read article: %s\u0026#34;, path); file = fopen(path, \u0026#34;r\u0026#34;); if (!file) { writeSock(sock, FILENOTAVAIL, sizeof(FILENOTAVAIL)); return; } /* fgets for the size of the buffer (100), from the file writing the article to the user each time! */ while (fgets(buf, 1000, file)) 文件写（目录穿越）、栈溢出11字节\nvoid writeArticle(int sock, FILE *logfile, char *action) { FILE *file;\tchar *p; size_t x, y; int complete = 0; char buf[1024]; char path[1024]; strcpy(path, ARTICLEPATH); strncat(path, \u0026amp;action[1], sizeof(path)); logData(logfile, \u0026#34;user writing article: %s\u0026#34;, path); file = fopen(\u0026amp;action[1], \u0026#34;w\u0026#34;); if (!file) { writeSock(sock, FILENOTAVAIL, sizeof(FILENOTAVAIL)); return; } writeSock(sock, BEGINFILE, sizeof(BEGINFILE)); "},{"uri":"https://www.ch35tnut.site/zh-cn/others/add-timeline-shortcode/","title":"给hugo-theme-learn增加timeline功能","tags":[],"description":"","content":"前言 现在使用hugo-theme-learn主题，但这个主题没有提供时间线功能，为了给首页增加时间线功能，花了两天研究了一下怎么添加时间线功能。\n为了方便增加时间线的事件，采用自定义shortcode的方式增加时间线，代码大部分参考引用链接里面的，魔改了一下以适应自己的主题，增加了过去多少天的显示。\n代码实现 在layout/shortcodes新增文件：event.html和timeline.html，内容分别如下\nevent.html {{$duration := \u0026#34;\u0026#34;}} {{$to := now }} {{ if ne (.Get \u0026#34;to\u0026#34;) \u0026#34;\u0026#34;}} {{$to = time (.Get \u0026#34;to\u0026#34;) }} {{end}} {{$enabledTime := ne (.Get \u0026#34;from\u0026#34;) \u0026#34;\u0026#34;}} {{if $enabledTime }} {{$from := time (.Get \u0026#34;from\u0026#34;) }} {{ $diff := $to.Sub $from }} {{ $days := div $diff.Hours 24 | math.Round }} {{$tmonths:=mul ($to.Sub $from).Hours 0.00136986301 }} {{$months := mod $tmonths 12 }} {{$years := math.Floor (div $tmonths 12)}} {{$yearStr := \u0026#34;years\u0026#34;}} {{if lt $years 2 }} {{$yearStr = \u0026#34;year\u0026#34;}} {{end}} {{$monthStr := \u0026#34;months\u0026#34;}} {{if lt $months 2 }} {{$monthStr = \u0026#34;month\u0026#34;}} {{end}} {{$daysStr := \u0026#34;days\u0026#34;}} {{ $idays :=int $days }} {{$duration = \u0026#34;\u0026#34;}} {{if gt $years 0 }} {{$duration = printf \u0026#34;%s %.0f %s\u0026#34; $duration $years $yearStr}} {{$idays = sub $idays (mul 365 $years)}} {{end}} {{if gt $months 0 }} {{$duration = printf \u0026#34;%s %d %s\u0026#34; $duration $months $monthStr}} {{$idays = sub $idays (mul 30 $months)}} {{end}} {{$idays = int $idays}} {{if gt $idays 0}} {{if lt $idays 2}} {{$daysStr = \u0026#34;day\u0026#34;}} {{end}} {{$duration = printf \u0026#34;%s %d %s\u0026#34; $duration $idays $daysStr}} {{end}} {{end}} {{ $from := .Get \u0026#34;from\u0026#34; | time }} {{ $to := now }} {{ $diff := $to.Sub $from }} {{ $ago := div $diff.Hours 24 | math.Round }} {{ $measure := cond (eq 1 $ago) \u0026#34;day\u0026#34; \u0026#34;days\u0026#34; }} {{ $seed := \u0026#34;foo\u0026#34; }} {{ $random := delimit (shuffle (split (md5 $seed) \u0026#34;\u0026#34; )) \u0026#34;\u0026#34; }} \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;{{.Get \u0026#34;title\u0026#34;}}\u0026lt;/div\u0026gt; {{if $enabledTime }} \u0026lt;div class=\u0026#34;moment\u0026#34; {{ if eq .Ordinal 0 }} id=\u0026#34;moment\u0026#34; {{ end }} {{ if ne .Ordinal 0 }}id=\u0026#34;moment-{{ substr $random 0 16}}\u0026#34;{{end}}\u0026gt; {{ if ne .Ordinal 0 }} {{$duration}} {{ end }} | {{ $ago }} {{ $measure}} ago \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;date\u0026#34;\u0026gt;{{$to.Year}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ if and (eq (.Ordinal) 0) $enabledTime }} \u0026lt;script\u0026gt; function non0plural(number, name) { if (number == 0) { return \u0026#34;\u0026#34; } if (number \u0026gt; 1) { return number + \u0026#34; \u0026#34; + name + \u0026#34;s\u0026#34; } return number + \u0026#34; \u0026#34; + name } function refresh() { start = dayjs({{.Get \u0026#34;from\u0026#34;}}) now = dayjs() total_days = now.diff(start,\u0026#34;d\u0026#34;,true) total_months = now.diff(start, \u0026#34;M\u0026#34;, true) months = total_months % 12 years = Math.floor((total_months) / 12) // for (var i = 0, els = document.querySelectorAll(`[id^=\u0026#34;moment\u0026#34;]`); i \u0026lt; els.length; i++) { // els[i].innerHTML = non0plural(years, \u0026#34;year\u0026#34;) + \u0026#34; \u0026#34; + non0plural(months.toFixed(8), \u0026#34;month\u0026#34;) // } // 如果月份大于1则 if(years\u0026gt;=1){ total_days-=365*years } if(months\u0026gt;=1){ total_days-=30*months } el = document.querySelector(\u0026#34;#moment\u0026#34;); el.innerHTML = years\u0026gt;1? non0plural(years, \u0026#34;year\u0026#34;):\u0026#34;\u0026#34; + \u0026#34; \u0026#34; + months\u0026gt;1? non0plural(months.toFixed(4), \u0026#34;month\u0026#34;):\u0026#34;\u0026#34; + total_days\u0026gt;=1?non0plural(total_days.toFixed(2),\u0026#34;day\u0026#34;):\u0026#34;\u0026#34; el.innerHTML = el.innerHTML + \u0026#34; ago\u0026#34; } window.setInterval(refresh, 100); \u0026lt;/script\u0026gt; {{ end }} timeline.html \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .timeline { position: relative; margin: 0 auto; } /* The actual timeline (the vertical ruler) */ .timeline::after { content: \u0026#34;\u0026#34;; position: absolute; width: 6px; background-color: #444; top: 0; bottom: 0; left: 10%; margin-left: -3px; } /* Container around content */ .timeline .container { padding: 10px 10px 10px 40px; margin-top: 10px; position: relative; /* background-color: gray; */ width: 90%; left: 10%; } /* The circles on the timeline */ .timeline .container::after { content: \u0026#34;\u0026#34;; position: absolute; width: 25px; height: 25px; left: -12px; background-color: rgb(106, 215, 229); border: 4px solid #444; top: 0px; border-radius: 50%; z-index: 1; } /* date display */ .timeline .container .date { position: absolute; top: 0px; z-index: 1; left: -15%; font-size: large; } /* Add arrows to the right container (pointing left) */ .timeline .container::before { content: \u0026#34; \u0026#34;; height: 0; position: absolute; top: 30px; width: 0; z-index: 1; left: 26px; border: medium solid #6ad7e5; border-width: 13px 13px 13px 0px; border-color: #6ad7e5 #6ad7e5 transparent transparent; } /* The actual content */ .timeline .content { box-shadow: 0 0 3px 3px #6ad7e5; background-color: white; position: relative; border-radius: 6px; transition: box-shadow 0.3s; } /* small shadow change on hover*/ .timeline .content:hover { box-shadow: 0 0 3px 4px #6ad7e5; } /* card title format */ .timeline .content .title { padding: 5px 30px; font-weight: bold; display: inline-block; } /* time moment format*/ .timeline .content .moment { color: #c41a16; text-align: right; position: absolute; top: 0; right: 0; padding: 5px; } /* body size */ .timeline .content .body { padding: 5px 30px; word-wrap: break-word; /* height: 73px; */ /* max-height: 120px; */ text-overflow: ellipsis; overflow: hidden; } /* responsive for small devices*/ @media screen and (max-width: 600px) { .timeline .container { padding: 10px 10px 0px 40px; left: 5%; width: 95%; } .timeline .container .date { font-size: small; transform: rotate(-90deg); left: -5%; top: 30px; } .timeline .container::after { left: 3px; } .timeline .content .body { padding: 5px 5px; } .timeline .content .moment { position: relative; } } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;timeline\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 由于event.html里面引用了dayjs，这个js不在当前主题内，可以在config.toml新增custom_js = [\u0026quot;js/dayjs.min.js\u0026quot;]，然后把dayjs.min.js放在theme\\hugo-theme-learn\\static\\js目录内，即可解决导入dayjs的问题。\n此时可以在需要添加时间线的地方使用timeline的shortcode添加，以下是我博客首页的时间线代码：\n{{\u0026lt; timeline \u0026gt;}} {{% event title=\u0026#34;09-03至09-04\u0026#34; from=\u0026#34;2022-09-03\u0026#34; to=\u0026#34;2022-09-04\u0026#34; %}} 这两天，给hugo主题增加了timeline的shortcode，见[增加timeline功能](others/add-timeline-shortcode) {{% /event %}} {{% event title=\u0026#34;08-29至09-02\u0026#34; from=\u0026#34;2022-08-29\u0026#34; to=\u0026#34;2022-09-02\u0026#34; %}} 周内审计了代码 {{% /event %}} {{\u0026lt; /timeline \u0026gt;}} 除了这个还顺便给博客新增了基于Github issue的评论功能，参考\rutteranc。\n参考\nhttps://metalblueberry.github.io/post/howto/2021-02-28_hugo_timeline_shortcode/\n"},{"uri":"https://www.ch35tnut.site/zh-cn/about/","title":"关于我","tags":[],"description":"","content":"关于我 21年毕业，目前在某安全厂商工作，主要研究二进制。\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/authentication-principle.zh.cn/","title":"认证原理","tags":[],"description":"","content":"认证原理 一、Kerberos概念 Kerberos是计算机网络授权协议，用于在非安全网络中，对个人通信过程中用安全的手段进行身份认证。其中客户端和服务端能够相互认证，识别对方身份。Kerberos是第三方认证，依赖于第三方服务器对彼此进行身份验证，Kerberos服务器本身成为KDC。 由三部分组成：\nKerberos知道用户和集群内服务以及各自的密码数据库 AS验证用户身份，验证通过就会返回给Client端一个TGT Client通过TGT向TGS获取ST 服务验证ST有效性，如果有效则Client可以访问服务 二、Kerberos名词解释 AS（Authentication Server）认证服务器 KDC（Key Distribution Center）密钥分发中心 TGT（Ticket Granting Ticket）票据授权票据，给票据授权的票据 TGS（Ticket Granting Service）票据授权服务 SS（Service Server）服务提供服务器 ST（Server Ticket）服务端票据 一般KDC同时包含AS和TGS\n三、Kerberos验证过程 Client登录，用户输入用户名和密码，会用单向函数根据密码生成客户端密钥（Client Secret Key）\nClient向AS发送A消息请求TGT\nA消息内容 用户名 请求服务名称，这里是TGS 网络地址 请求TGT的生命周期 该消息不会加密，也不会发送密码或者密码生成的密钥 AS检查用户名是否存在AS用户名数据库内，并使用数据库中用户密码生成的NTLM哈希解密客户端消息\n如果数据库内有该用户名则随机生成TGS会话密钥（TGS Session Key），同时给Client端发送两条消息\nB消息内容用客户端密钥加密 TGS名称 时间戳 生命周期 TGS会话密钥（TGS Session Key） C消息内容（TGT）用TGS密钥（TGS Secret Key）加密 用户名 TGS名称 时间戳 用户网络地址 生命周期 TGS会话密钥（TGS Session Key） Client用通过密码生成的客户端密钥解密B消息，如果密码正确则可以得到TGS会话密钥（TGS Session Key），将C消息（TGT）存储在本地凭据缓存内。\nClient向TGS请求ST，期间需要向TGS发送两条消息明文\nD消息内容 想要请求的服务ID即SS 生命周期 TGT E消息内容使用TGS会话密钥（TGS Session Key）加密即身份验证器 用户名 时间戳 TGS验证Client请求服务是否存在，存在则进入下一步。\nTGS提取D消息内的TGT，用TGS密钥解密（TGS Secret Key），从中提取TGS会话密钥（TGS Session Key），再用TGS会话密钥解密E得到用户名和时间戳，现在TGS得到了用户名和消息E的时间戳，以及消息C的用户名和时间戳\n比较两个用户名和时间戳 检查TGT生命周期是否过期 检查身份验证器（E消息）是否在缓存内(存疑) TGS生成随机服务会话（service session key）密钥，并发送两条消息给Client\nF消息内容用服务密钥(Service Secret Key)加密 用户名 服务名 时间戳 网络地址 生命周期 服务会话密钥 G消息内容用TGS会话密钥加密 服务名 时间戳 生命周期 服务会话密钥 因为Client有TGS会话密钥所以可以解密消息G得到服务会话密钥（service session key）\n客户端和SS连接，发送两条消息\n消息H用服务会话密钥加密内容身份验证器： 用户名 时间戳 消息L 即消息F SS收到请求，用服务密钥解密消息I即消息F得到服务会话密钥及用户名时间戳等信息，再用服务会话密钥解密消息H得到用户名和时间戳\nSS进行身份验证\n比较消息H内用户名和消息F内的用户名 比较消息H和消息F内的是时间戳 检查消息F内生命周期 检查身份验证器是否在缓存内 SS向Client验证身份，向其发送消息\n消息J使用服务会话密钥加密身份验证器 服务ID 时间戳（在消息H内的时间戳） 客户端收到SS的身份验证器消息（J），使用缓存内的服务会话密钥进行解密得到服务ID及时间戳，并验证是否有效\n参考链接\nhttps://www.vanimpe.eu/2017/05/26/kerberos-made-easy/ https://zh.wikipedia.org/wiki/Kerberos http://www.nosqlnotes.com/technotes/kerberos-protocol/ https://juejin.im/post/6844903955416219661\n简化模型 Client向AS发送明文消息，申请访问的服务 AS检查用户名是否存在本地数据库中，存在则返回两条消息 A：Client/TGS会话密钥(Client/TGS Session Key)用于Client和TGS通信，通过用户密钥加密 B：TGT（包含Client/TGS会话密钥、用户、用户网络地址、TGT有效期），通过TGS密钥加密 Client收到消息AB，用自己的用户密钥解密消息A得到和TGS通信的密钥TGS会话密钥 Client向TGS请求服务，发送两条消息 C：消息B和申请的服务ID（明文） D：认证符（包括用户ID、时间戳）通过(Client/TGS Session Key)加密 TGS拿到服务ID检查是否有该服务，如果有该服务则用TGS密钥解密消息B得到(Client/TGS Session Key)再用TGS会话密钥解密消息D得到用户ID、时间戳，与TGT内的用户ID和时间戳比对验证有效性。 通过之后TGS返回两条消息给Client E：ST（SS会话密钥、用户ID、用户网络地址、有效期）通过SS密钥加密 F：SS会话密钥，通过TGS会话密钥加密 Client通过TGS会话密钥解密消息F得到SS会话密钥 Client给SS发送两条消息 G：即消息E H：认证符，包含用户ID，时间戳，通过SS会话密钥加密 SS收到两条消息之后用SS密钥解密消息G（E）得到SS会话密钥，在通过会话密钥解密消息H得到用户ID、时间戳等信息，如果和消息G（E）内的时间戳和用户ID比对，通过则返回消息给Client I：消息H内的时间戳，通过SS会话密钥加密 Client收到消息之后用SS会话密钥解密得到时间戳，并验证，通过则可以向SS发送请求。 "},{"uri":"https://www.ch35tnut.site/zh-cn/others/how-to-reset-password-administrator-on-windows-server-2019/","title":"在Windows server 2019上重置密码","tags":[],"description":"","content":"重置windows server 2019的administrator密码 之前在Vmware上的Windows server 2019的Administrator密码忘记了，使用网上的方法时找不到用PE启动系统的办法，无奈只能使用其他办法。写此文记录一下。\n设置CD/DVD 首先在虚拟机-设置的硬件选项卡下面的CD/DVD设置为使用ISO映像文件并找到windows server 2019镜像位置，如下图\n之后选择虚拟机-电源-开机时打开固件启动虚拟机，虚拟机就会进入BIOS，在BIOS里选择CD/DVD启动，即会进入下图。\n参考链接\nhttps://www.osradar.com/how-to-reset-password-administrator-on-windows-server-2019/\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/application-layer/ssh-tunnel/","title":"SSH隧道","tags":[],"description":"","content":"SSH隧道 SSH提供了三种转发模式：本地端口转发、远程端口转发以及动态端口转发，本文将介绍这三种转发模式的用法。\n一些基本概念 本地主机：SSH客户端所在的主机。\n远程主机：相对于本地主机的概念，在本地主机之外的主机叫远程主机。\nSSH命令行参数解释\n-C:压缩传输，提高传输速度 -f:将ssh转入后台执行 -N:建立静默连接（连接后看不到具体会话） -g:允许远程主机连接本地用于转发的端口 -L:本地端口转发 -R:远程端口转发 本地端口转发 本地端口转发，即将本地端口转发到远程主机上，命令格式：ssh -L \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 在SSH Client运行命令ssh -CfNg -L 127.0.0.1:1313:127.0.0.1:1313 root@a.b.c.d ，将127.0.0.1:1313端口转发到SSH Server的127.0.0.1:1313端口上。此时SSH Client访问127.0.0.1:1313的结果跟访问在SSH Server端的127.0.0.1:1313结果一样。\n在SSH Client上\n此时在SSH Client上的ssh会监听127.0.0.1:1313这个端口，该端口的TCP数据通过ssh隧道传输到SSH server上。\n在SSH Server上，先监听127.0.0.1:1313端口，本文监听使用hugo 启动一个server。\n在SSH Client上使用curl 127.0.0.1:1313命令时返回的内容即为SSH Server上127.0.0.1:1313的内容\n同时本地端口转发命令中remote ip不止限制在127.0.0.1上，remote ip可以是任何一个SSH Server能够连接的host，实际上本地端口转发过程中，实际上是把SSH Server当作跳板机，连通SSH Client和SSH Server另外一端的主机，如下：\n|SSH Client| \u0026lt;-------------\u0026gt;|SSH Server| \u0026lt;--------------\u0026gt;|SSH Client不能访问但是SSH Server能访问的主机|\n本地端口转发一般应用场景为在渗透测试过程中控制了目标网络中带有SSH Server的一台机器，通过这台机器做为跳板机来访问内网其他主机上的服务。一定程度上规避防火墙的流量告警（因为ssh流量为加密流量）\n远程端口转发。 远程端口转发即和本地端口转发是相反的概念，本地端口转发是将本地端口转发到远程端口上，连接本地端口即跟连接远程端口一个效果。而远程端口转发即将远程端口转发到本地，使得连接远程端口即跟连接本地端口一样。命令格式：ssh -R \u0026lt;remote port\u0026gt;:\u0026lt;local ip\u0026gt;:\u0026lt;local port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 本次我们将SSH Client的3389端口转发到SSH Server（公网服务器）上，使得另外一台机器能够通过SSH Server的端口连接到位于局域网的SSH Client的远程桌面。\n在ssh client上运行命令\n此时任何连接SSH Server:9898的请求都会被转发到SSH Client的58989端口上，该端口监听的服务为远程桌面服务。在另外一台电脑（不同于SSH Server和SSH Client）使用远程桌面连接SSH Server:9898\n同本地端口转发一样，远程端口转发命令中的local ip可以是任何一个SSH Client能够连接的host，此时SSH Client被当作跳板机，连通SSH Client另外一端和SSH Server端的主机。\n|SSH Serve能够连通的主机| \u0026lt;--------------\u0026gt; |SSH Client| \u0026lt;--------------\u0026gt; |SSH Client能访问但是SSH Server不能访问的主机|\n远程端口转发应用场景一般是将局域网的某些服务通过SSH隧道暴露在公网上，或者在渗透测试过程中，控制了内网的某台主机，通过远程端口转发，将该主机作为跳板机来访问内网其他服务，因为此时SSH是从内网连接到外网，在流量上没有那么可疑。\n动态端口转发 在本地端口转发和远程端口转发过程中，一次性只能转发一个端口，在某些场景下效率太低了，而动态端口转发没有指定目的端口，相对于前两种来说更灵活。实际上动态端口转发即为SSH实现的SOCKS协议。命令格式:ssh -D port \u0026lt;username\u0026gt;@\u0026lt;SSH host\u0026gt;。\n在SSH Client执行命令即可在SSH Client和SSH Server之间建立socks5隧道，SSH Client可以连接该隧道来传输数据。\n组合利用 在一些情况下可以通过组合上面三种转发来达到意想不到的效果。\n例如，有两台位于互不相通的局域网主机，如果一台想要访问另外一台能够访问的服务时，可以以下面的方式达到目的\n在主机1上执行命令 ssh -CfNg -R 9898:192.168.50.1:22 root\u0026lt;SSH Server\u0026gt; 将主机1的ssh端口转发到公网服务器的9898端口。\n在主机2执行命令ssh -D 12222 -p 9898 \u0026lt;username\u0026gt;@\u0026lt;SSH Server\u0026gt; 此时ssh连接的是主机1，且建立了socks隧道，通过该隧道主机2可以方便的使用主机1能访问而主机2不能直接访问的服务。\n"},{"uri":"https://www.ch35tnut.site/zh-cn/others/vmware-based-implementation-of-small-domain-network-construction/","title":"基于Vmware的小型域网络搭建","tags":[],"description":"","content":"基于Vmware的小型域网络搭建 摘要 在渗透的日常学习过程中经常需要一个内网环境，本篇文章介绍如何使用Vmware和MikroTik搭建简易的二层内网环境。\n网络结构 整个网络分为结构分为三层，第一层模拟外网环境，第二层为DMZ区域，该区域通过边界路由器的端口映射，将第二层网络主机的一些端口映射到边界路由器上对外提供服务，第三层模拟办公网，该层网络为域网络，同时可以控制第二层网络的主机。\n整个网络拓扑图如下：\nIP设置：\n第一层网络为（外网）：192.168.59.0/24\n第二层网络为（DMZ区域）：192.168.72.0/24\n第三层网络为（办公网）：172.16.2.0/24\n路由器IP地址：\n边界路由器：192.168.59.141 | 192.168.72.2\n内网路由器：192.168.72.254 | 172.16.2.254\n网络搭建 网络设置 首先使用VMware的虚拟网络编辑器增加两个网络VMnet2、VMnet3，都勾选仅主机模式，同时取消下面两个勾，如下图：\nVMnet3同理，同时在DHCP设置处设置相应的IP地址和掩码。其中外层网络为nat模式，VMnet2为DMZ区域网络，VMnet3为办公网络\n虚拟机搭建 整个网络在最少情况下一共需要六台虚拟机，分为两台ROS，四台网络中的主机。\nROS从hxxps://mikrotik.com/download下载stable版本的ova格式的镜像，之后导入到VMware中。一共需要导入两次，分别命名为ROS，ROS-1。除了下载镜像之外还需要下载winbox方便对路由器进行设置。\n网络中主机分布：\nDMZ：Ubuntu 2004、windows7\n办公网：Windows server2019、windows7\n创建上述虚拟机，并将DMZ区域的主机的网卡设置为VMnet2，办公网的主机设置为VMnet3.\n将边界路由器ROS网卡设置为net模式和VMnet2模式，内网路由器设置为VMnet2和VMnet3模式。\nIP地址及路由器设置 经历上面的步骤之后，基本的网络拓扑已经搭建完成，接下来需要对网络内的主机和路由器进行设置使得网络中的主机能够相互ping通。\n首先设置两个网络中的主机IP地址\nDMZ：\nWindows7：192.168.72.4/24 网关192.168.72.2 DNS114.114.114.114\nUbuntu ：192.168.72.3/24 网关192.168.72.2 DNS114.\n114.114.114\n办公网：\nWindows server 2019：172.16.2.4/24 网关172.16. 2.254 DNS127.0.0.1\nwindows7：172.16.2.3/24 网关172.16.2.254 DNS172.16.2.4\n至此，两个网络的主机应该可以ping通同一个网络的主机。接下来设置两个ROS的IP地址。\n打开winbox，点击Neighbors按钮，会自动嗅探网络内的存活的路由器，如下图所示。\n上图为边界路由器的IP地址，如果分配了IP地址则可以在浏览器通过IP地址浏览路由器的web界面，在如果没有分配IP地址则通过wibbox使用MAC地址登录\n进入之后，在左侧选项卡会列出路由器拥有的所有网卡接口，点击之后进入到接口详情界面，在里面会列出该接口的一些基本信息，可以通过网卡的MAC分辨该网卡对应在vmware中的网卡，将两个网卡名称分别设置为ether1-wan和ether2-lan，之后在ip-\u0026gt;addresses选项卡中将ether-lan设置为下图。ether1-wan不用设置，因为该网卡网络类型为nat会自动dhcp分配\n之后在IP-\u0026gt;Firewall-\u0026gt;NAT中新建规则，chain：srcnat，out.interface:ether2-lan,action:masquerade\n该规则将使得路由器两边的网络联通。\n参考\nhttps://www.huaweicloud.com/articles/401014315f14d0fb8d5e3f5489693621.html http://www.roszj.com/1692.html http://www.irouteros.com/?p=583\n"},{"uri":"https://www.ch35tnut.site/zh-cn/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/tags/","title":"Tags","tags":[],"description":"","content":""}]