<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on chestnut's blog</title><link>https://www.ch35tnut.site/zh-cn/research/web/</link><description>Recent content in Web on chestnut's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 31 Jan 2024 08:22:24 +0000</lastBuildDate><atom:link href="https://www.ch35tnut.site/zh-cn/research/web/index.xml" rel="self" type="application/rss+xml"/><item><title>PHP Filter RCE 分析</title><link>https://www.ch35tnut.site/zh-cn/research/web/php-filter-rce/</link><pubDate>Fri, 29 Dec 2023 18:32:43 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/web/php-filter-rce/</guid><description>PHP filter是什么 PHP filter是PHP定义的一个伪协议，用于在数据流打开时进行筛选过滤，在数据读取或者写入的时候通过过滤器对数据进行处理。PHP filter 可以使用多个过滤器进行处理。
php://filter/过滤器|过滤器/resource=待过滤的数据流 require_once和require的参数是一个文件路径，指明要包含的文件，而PHP filter 提供了接口，使得可以通过这个接口访问到指定的文件内容，require在包含文件时，只关心文件内容，而不关心文件内容来自于何处，所以可以给require 传PHP filter参数，
如果有如下代码
&amp;lt;?php $file = $_GET[&amp;#39;page&amp;#39;]; require($file); 则可以通过如下请求泄露敏感信息
curl &amp;#34;http://localhost/test.php?page=php://filter/convert.base64-encode/resource=/etc/passwd&amp;#34; PHP的base64decode函数在处理base64编码的数据时，会自动规范化：去除字符串中不合法的字符并且忽略，而后尝试解码。 但PHP filter的base64解码行为和base64decode行为略有不同，PHP filter的base64-decode不能处理随即插入的等号，此时可以使用UTF-7编码规避，UTF-7编码会把等号转化为其他的base64字符。
通过编码前置字符 根据官网链接的reference 根据文档，如果开启了iconv支持，则可以通过伪协议php://convert.iconv.*.*调用iconv函数。
convert.iconv.&amp;lt;input-encoding&amp;gt;.&amp;lt;output-encoding&amp;gt; or convert.iconv.&amp;lt;input-encoding&amp;gt;/&amp;lt;output-encoding&amp;gt;
linux中可以使用iconv函数将字符串从一个编码转为另外一个编码，在PHP://filter中可以使用iconv过滤器调用到这个函数
php -r &amp;#34;echo file_get_contents(\&amp;#34;php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7/res ource=php://temp\&amp;#34;);&amp;#34; GyQpQw+AD0APQ-# 某些编码规定该编码会在数据之前预置一些字节，相当于签名，标识这段数据是该编码 在RFC 2781中就说明该编码会预置0XFEFF
The Unicode Standard and ISO 10646 define the character &amp;ldquo;ZERO WIDTH NON-BREAKING SPACE&amp;rdquo; (0xFEFF), which is also known informally as &amp;ldquo;BYTE ORDER MARK&amp;rdquo; (abbreviated &amp;ldquo;BOM&amp;rdquo;).This usage, suggested by Unicode and ISO 10646 Annex F (informative), is to prepend a 0xFEFF character to a stream of Unicode characters as a &amp;ldquo;signature&amp;rdquo;; a receiver of such a serialized stream may then use the initial character both as a hint that the stream consists of Unicode characters and as a way to recognize the serialization order.</description></item></channel></rss>