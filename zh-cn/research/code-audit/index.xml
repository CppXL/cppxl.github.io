<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>代码审计 on chestnut's blog</title><link>https://www.ch35tnut.site/zh-cn/research/code-audit/</link><description>Recent content in 代码审计 on chestnut's blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 05 Sep 2022 18:36:05 +0800</lastBuildDate><atom:link href="https://www.ch35tnut.site/zh-cn/research/code-audit/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeql</title><link>https://www.ch35tnut.site/zh-cn/research/code-audit/codeql/</link><pubDate>Sun, 10 Dec 2023 00:17:23 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/code-audit/codeql/</guid><description>&lt;h3 id="codeql-相关">CODEQL 相关&lt;/h3>
&lt;h1 id="记录codeql-学习">记录codeql 学习&lt;/h1>
&lt;p>记录codeql 学习&lt;/p></description></item><item><title>Wireshark 1.8.5代码审计</title><link>https://www.ch35tnut.site/zh-cn/research/code-audit/wireshark-185/</link><pubDate>Thu, 08 Sep 2022 18:13:59 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/code-audit/wireshark-185/</guid><description>&lt;p>通过爬取wireshark的漏洞公告页面，筛选1.8.6修复的漏洞可以得到如下结果：&lt;/p>
&lt;p>1.8.6/1.8.7修复的漏洞&lt;/p>
&lt;ul>
&lt;li>
&lt;p>wnpa-sec-2013-31. ETCH dissector large loop. Fixed in 1.8.7.&lt;/p>
&lt;p>The ETCH dissector could go into a large loop. Discovered by Moshe
&lt;a href="http://kaplan.it/" target="_blank">Kaplan.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-30. MySQL dissector infinite loop. Fixed in 1.8.7.&lt;/p>
&lt;p>The MySQL dissector could go into an infinite loop. Discovered by Moshe
&lt;a href="http://kaplan.it/" target="_blank">Kaplan.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-29. Websocket dissector crash. Fixed in 1.8.7.&lt;/p>
&lt;p>The Websocket dissector could crash. Discovered by Moshe
&lt;a href="http://kaplan.it/" target="_blank">Kaplan.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-28. MPEG DSM-CC dissector crash. Fixed in 1.8.7.&lt;/p>
&lt;p>The MPEG DSM-CC dissector could
&lt;a href="http://crash.it/" target="_blank">crash.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-27. DCP ETSI dissector crash. Fixed in 1.8.7.&lt;/p>
&lt;p>The DCP ETSI dissector could crash. Discovered by Evan
&lt;a href="http://jensen.it/" target="_blank">Jensen.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-26. PPP CCP dissector crash. Fixed in 1.8.7.&lt;/p>
&lt;p>The PPP CCP dissector could
&lt;a href="http://crash.it/" target="_blank">crash.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-25. ASN.1 BER dissector crash. Fixed in 1.8.7, 1.6.15.&lt;/p>
&lt;p>The ASN.1 BER dissector could
&lt;a href="http://crash.it/" target="_blank">crash.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-24. GTPv2 dissector crash. Fixed in 1.8.7.&lt;/p>
&lt;p>The GTPv2 dissector could
&lt;a href="http://crash.it/" target="_blank">crash.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-23. RELOAD dissector infinite loop. Fixed in 1.8.7.&lt;/p>
&lt;p>The RELOAD dissector could go into an infinite loop. Discovered by Evan
&lt;a href="http://jensen.it/" target="_blank">Jensen.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-22. DTLS dissector crash. Fixed in 1.8.6, 1.6.14.&lt;/p>
&lt;p>The DTLS dissector could crash. Discovered by Laurent
&lt;a href="http://butti.it/" target="_blank">Butti.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-21. RELOAD dissector infinite loop. Fixed in 1.8.6.&lt;/p>
&lt;p>The RELOAD dissector could go into an infinite loop. Discovered by Even
&lt;a href="http://jensen.it/" target="_blank">Jensen.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-20. FCSP dissector infinite loop. Fixed in 1.8.6, 1.6.14.&lt;/p>
&lt;p>The FCSP dissector could go into an infinite loop. Discovered by Moshe
&lt;a href="http://kaplan.it/" target="_blank">Kaplan.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-19. CIMD dissector crash. Fixed in 1.8.6, 1.6.14.&lt;/p>
&lt;p>The CIMD dissector could crash. Discovered by Moshe
&lt;a href="http://kaplan.it/" target="_blank">Kaplan.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-18. ACN dissector divide by zero. Fixed in 1.8.6, 1.6.14.&lt;/p>
&lt;p>The ACN dissector could attempt to divide by zero. Discovered by Alyssa
&lt;a href="http://milburn.it/" target="_blank">Milburn.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-17. AMPQ dissector infinite loop. Fixed in 1.8.6, 1.6.14.&lt;/p>
&lt;p>The AMPQ dissector could go into an infinite loop. Discovered by Moshe
&lt;a href="http://kaplan.it/" target="_blank">Kaplan.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-16. Mount dissector crash. Fixed in 1.8.6, 1.6.14.&lt;/p>
&lt;p>The Mount dissector could crash. Discovered by Alyssa
&lt;a href="http://milburn.it/" target="_blank">Milburn.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-15. RTPS and RTPS2 dissector crash. Fixed in 1.8.6, 1.6.14.&lt;/p>
&lt;p>The RTPS and RTPS2 dissectors could crash. Discovered by Alyssa
&lt;a href="http://milburn.it/" target="_blank">Milburn.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-14. MPLS Echo dissector infinite loop. Fixed in 1.8.6.&lt;/p>
&lt;p>The MPLS Echo dissector could go into an infinite loop. Discovered by Laurent
&lt;a href="http://butti.it/" target="_blank">Butti.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-13. MS-MMS dissector crash. Fixed in 1.8.6, 1.6.14.&lt;/p>
&lt;p>The MS-MMS dissector could crash. Discovered by Laurent
&lt;a href="http://butti.it/" target="_blank">Butti.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-12. CSN.1 dissector crash. Fixed in 1.8.6.&lt;/p>
&lt;p>The CSN.1 dissector could crash. Discovered by Laurent
&lt;a href="http://butti.it/" target="_blank">Butti.It&lt;/a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-11. HART/IP dissector infinite loop. Fixed in 1.8.6.&lt;/p>
&lt;p>The HART/IP dissectory could go into an infinite
&lt;a href="http://loop.it/" target="_blank">loop.It&lt;/a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wnpa-sec-2013-10. TCP dissector crash. Fixed in 1.8.6.&lt;/p>
&lt;p>The TCP dissector could crashIt may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Created att 2022-09-08T18:13:59+08:00&lt;/strong>&lt;/p></description></item><item><title>News Server审计</title><link>https://www.ch35tnut.site/zh-cn/research/code-audit/news-server/</link><pubDate>Tue, 06 Sep 2022 00:52:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/code-audit/news-server/</guid><description>&lt;p>代码地址&lt;/p>
&lt;blockquote>
&lt;p>
&lt;a href="https://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_install.sh" target="_blank">https://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_install.sh&lt;/a>&lt;/p>
&lt;p>
&lt;a href="https://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_server.c" target="_blank">https://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_server.c&lt;/a>&lt;/p>
&lt;p>
&lt;a href="https://trailofbits.github.io/ctf/vulnerabilities/source.html" target="_blank">https://trailofbits.github.io/ctf/vulnerabilities/source.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>编译：&lt;code>gcc -m32 -g -o news_server news_server.c&lt;/code>&lt;/p>
&lt;p>目标：找出10个bug和漏洞&lt;/p>
&lt;ol>
&lt;li>
&lt;p>news_server默认工作在根目录，没有通过chdir切换工作目录（不知道算不算bug）&lt;/p>
&lt;p>修复：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">handleConnection&lt;/span>(FILE &lt;span style="color:#f92672">*&lt;/span>logfile, &lt;span style="color:#66d9ef">int&lt;/span> sock) {
chdir(&lt;span style="color:#e6db74">&amp;#34;/root/code/c/news_server/&amp;#34;&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>在authenticate函数存在admin后门&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">if&lt;/span> (memcmp(pass, &lt;span style="color:#e6db74">&amp;#34;baCkDoOr&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>authenticate 中直接拼接用户输入到命令，命令注入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">authenticate&lt;/span>(FILE &lt;span style="color:#f92672">*&lt;/span>logfile, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>user, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pass)
{
&lt;span style="color:#66d9ef">char&lt;/span> search[&lt;span style="color:#ae81ff">512&lt;/span>];
&lt;span style="color:#66d9ef">char&lt;/span> path[&lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;span style="color:#66d9ef">char&lt;/span> userfile[&lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;span style="color:#66d9ef">char&lt;/span> data[&lt;span style="color:#ae81ff">1024&lt;/span>];
FILE &lt;span style="color:#f92672">*&lt;/span>file;
&lt;span style="color:#66d9ef">int&lt;/span> ret;
memset(path, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#ae81ff">1024&lt;/span>));
&lt;span style="color:#75715e">/* FIXME: hard coded admin backdoor for password recovery */&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (memcmp(pass, &lt;span style="color:#e6db74">&amp;#34;baCkDoOr&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#75715e">/* look up user by checking user files: done via system() to /bin/ls|grep user */&lt;/span>
logData(logfile, &lt;span style="color:#e6db74">&amp;#34;performing lookup for user via system()!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
snprintf(userfile, &lt;span style="color:#66d9ef">sizeof&lt;/span>(userfile)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;%s.txt&amp;#34;&lt;/span>, user);
snprintf(search, &lt;span style="color:#66d9ef">sizeof&lt;/span>(userfile)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;stat %s`ls %s | grep %s`&amp;#34;&lt;/span>, USERPATH, USERPATH, userfile);
ret &lt;span style="color:#f92672">=&lt;/span> system(search);
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>栈溢出、任意文件读（目录穿越）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">readArticle&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> sock, FILE &lt;span style="color:#f92672">*&lt;/span>logfile, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>action)
{
FILE &lt;span style="color:#f92672">*&lt;/span>file;
&lt;span style="color:#66d9ef">char&lt;/span> buf[&lt;span style="color:#ae81ff">100&lt;/span>];
&lt;span style="color:#66d9ef">char&lt;/span> path[&lt;span style="color:#ae81ff">100&lt;/span>];
logData(logfile, &lt;span style="color:#f92672">&amp;amp;&lt;/span>action[&lt;span style="color:#ae81ff">1&lt;/span>]);
strcpy(path, ARTICLEPATH);
strcat(path, &lt;span style="color:#f92672">&amp;amp;&lt;/span>action[&lt;span style="color:#ae81ff">1&lt;/span>]);
logData(logfile, &lt;span style="color:#e6db74">&amp;#34;user request to read article: %s&amp;#34;&lt;/span>, path);
file &lt;span style="color:#f92672">=&lt;/span> fopen(path, &lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>file)
{
writeSock(sock, FILENOTAVAIL, &lt;span style="color:#66d9ef">sizeof&lt;/span>(FILENOTAVAIL));
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#75715e">/* fgets for the size of the buffer (100), from the file
&lt;/span>&lt;span style="color:#75715e"> writing the article to the user each time! */&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> (fgets(buf, &lt;span style="color:#ae81ff">1000&lt;/span>, file))
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>文件写（目录穿越）、栈溢出11字节&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">writeArticle&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> sock, FILE &lt;span style="color:#f92672">*&lt;/span>logfile, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>action)
{
FILE &lt;span style="color:#f92672">*&lt;/span>file;
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p;
size_t x, y;
&lt;span style="color:#66d9ef">int&lt;/span> complete &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">char&lt;/span> buf[&lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;span style="color:#66d9ef">char&lt;/span> path[&lt;span style="color:#ae81ff">1024&lt;/span>];
strcpy(path, ARTICLEPATH);
strncat(path, &lt;span style="color:#f92672">&amp;amp;&lt;/span>action[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#66d9ef">sizeof&lt;/span>(path));
logData(logfile, &lt;span style="color:#e6db74">&amp;#34;user writing article: %s&amp;#34;&lt;/span>, path);
file &lt;span style="color:#f92672">=&lt;/span> fopen(&lt;span style="color:#f92672">&amp;amp;&lt;/span>action[&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#e6db74">&amp;#34;w&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>file)
{
writeSock(sock, FILENOTAVAIL, &lt;span style="color:#66d9ef">sizeof&lt;/span>(FILENOTAVAIL));
&lt;span style="color:#66d9ef">return&lt;/span>;
}
writeSock(sock, BEGINFILE, &lt;span style="color:#66d9ef">sizeof&lt;/span>(BEGINFILE));
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol></description></item></channel></rss>