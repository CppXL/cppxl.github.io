<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>代码审计 on chestnut's blog</title><link>https://www.ch35tnut.site/zh-cn/research/code-audit/</link><description>Recent content in 代码审计 on chestnut's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 05 Sep 2022 18:36:05 +0800</lastBuildDate><atom:link href="https://www.ch35tnut.site/zh-cn/research/code-audit/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeql</title><link>https://www.ch35tnut.site/zh-cn/research/code-audit/codeql/</link><pubDate>Sun, 10 Dec 2023 00:17:23 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/code-audit/codeql/</guid><description><h3 id="codeql-相关">CODEQL 相关</h3><h1 id="记录codeql-学习">记录codeql 学习</h1><p>记录codeql 学习</p></description></item><item><title>Wireshark 1.8.5代码审计</title><link>https://www.ch35tnut.site/zh-cn/research/code-audit/wireshark-185/</link><pubDate>Thu, 08 Sep 2022 18:13:59 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/code-audit/wireshark-185/</guid><description><p>通过爬取wireshark的漏洞公告页面，筛选1.8.6修复的漏洞可以得到如下结果：</p><p>1.8.6/1.8.7修复的漏洞</p><ul><li><p>wnpa-sec-2013-31. ETCH dissector large loop. Fixed in 1.8.7.</p><p>The ETCH dissector could go into a large loop. Discovered by Moshe<a href="http://kaplan.it/" target="_blank">Kaplan.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-30. MySQL dissector infinite loop. Fixed in 1.8.7.</p><p>The MySQL dissector could go into an infinite loop. Discovered by Moshe<a href="http://kaplan.it/" target="_blank">Kaplan.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-29. Websocket dissector crash. Fixed in 1.8.7.</p><p>The Websocket dissector could crash. Discovered by Moshe<a href="http://kaplan.it/" target="_blank">Kaplan.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-28. MPEG DSM-CC dissector crash. Fixed in 1.8.7.</p><p>The MPEG DSM-CC dissector could<a href="http://crash.it/" target="_blank">crash.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-27. DCP ETSI dissector crash. Fixed in 1.8.7.</p><p>The DCP ETSI dissector could crash. Discovered by Evan<a href="http://jensen.it/" target="_blank">Jensen.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-26. PPP CCP dissector crash. Fixed in 1.8.7.</p><p>The PPP CCP dissector could<a href="http://crash.it/" target="_blank">crash.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-25. ASN.1 BER dissector crash. Fixed in 1.8.7, 1.6.15.</p><p>The ASN.1 BER dissector could<a href="http://crash.it/" target="_blank">crash.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-24. GTPv2 dissector crash. Fixed in 1.8.7.</p><p>The GTPv2 dissector could<a href="http://crash.it/" target="_blank">crash.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-23. RELOAD dissector infinite loop. Fixed in 1.8.7.</p><p>The RELOAD dissector could go into an infinite loop. Discovered by Evan<a href="http://jensen.it/" target="_blank">Jensen.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-22. DTLS dissector crash. Fixed in 1.8.6, 1.6.14.</p><p>The DTLS dissector could crash. Discovered by Laurent<a href="http://butti.it/" target="_blank">Butti.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-21. RELOAD dissector infinite loop. Fixed in 1.8.6.</p><p>The RELOAD dissector could go into an infinite loop. Discovered by Even<a href="http://jensen.it/" target="_blank">Jensen.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-20. FCSP dissector infinite loop. Fixed in 1.8.6, 1.6.14.</p><p>The FCSP dissector could go into an infinite loop. Discovered by Moshe<a href="http://kaplan.it/" target="_blank">Kaplan.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-19. CIMD dissector crash. Fixed in 1.8.6, 1.6.14.</p><p>The CIMD dissector could crash. Discovered by Moshe<a href="http://kaplan.it/" target="_blank">Kaplan.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-18. ACN dissector divide by zero. Fixed in 1.8.6, 1.6.14.</p><p>The ACN dissector could attempt to divide by zero. Discovered by Alyssa<a href="http://milburn.it/" target="_blank">Milburn.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-17. AMPQ dissector infinite loop. Fixed in 1.8.6, 1.6.14.</p><p>The AMPQ dissector could go into an infinite loop. Discovered by Moshe<a href="http://kaplan.it/" target="_blank">Kaplan.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-16. Mount dissector crash. Fixed in 1.8.6, 1.6.14.</p><p>The Mount dissector could crash. Discovered by Alyssa<a href="http://milburn.it/" target="_blank">Milburn.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-15. RTPS and RTPS2 dissector crash. Fixed in 1.8.6, 1.6.14.</p><p>The RTPS and RTPS2 dissectors could crash. Discovered by Alyssa<a href="http://milburn.it/" target="_blank">Milburn.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-14. MPLS Echo dissector infinite loop. Fixed in 1.8.6.</p><p>The MPLS Echo dissector could go into an infinite loop. Discovered by Laurent<a href="http://butti.it/" target="_blank">Butti.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-13. MS-MMS dissector crash. Fixed in 1.8.6, 1.6.14.</p><p>The MS-MMS dissector could crash. Discovered by Laurent<a href="http://butti.it/" target="_blank">Butti.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-12. CSN.1 dissector crash. Fixed in 1.8.6.</p><p>The CSN.1 dissector could crash. Discovered by Laurent<a href="http://butti.it/" target="_blank">Butti.It</a> may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-11. HART/IP dissector infinite loop. Fixed in 1.8.6.</p><p>The HART/IP dissectory could go into an infinite<a href="http://loop.it/" target="_blank">loop.It</a> may be possible to make Wireshark consume excessive CPU resources by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li><li><p>wnpa-sec-2013-10. TCP dissector crash. Fixed in 1.8.6.</p><p>The TCP dissector could crashIt may be possible to make Wireshark crash by injecting a malformed packet onto the wire or by convincing someone to read a malformed packet trace file.</p></li></ul><p><strong>Created att 2022-09-08T18:13:59+08:00</strong></p></description></item><item><title>News Server审计</title><link>https://www.ch35tnut.site/zh-cn/research/code-audit/news-server/</link><pubDate>Tue, 06 Sep 2022 00:52:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/code-audit/news-server/</guid><description><p>代码地址</p><blockquote><p><a href="https://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_install.sh" target="_blank">https://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_install.sh</a></p><p><a href="https://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_server.c" target="_blank">https://trailofbits.github.io/ctf/vulnerabilities/source_workshop/news_server.c</a></p><p><a href="https://trailofbits.github.io/ctf/vulnerabilities/source.html" target="_blank">https://trailofbits.github.io/ctf/vulnerabilities/source.html</a></p></blockquote><p>编译：<code>gcc -m32 -g -o news_server news_server.c</code></p><p>目标：找出10个bug和漏洞</p><ol><li><p>news_server默认工作在根目录，没有通过chdir切换工作目录（不知道算不算bug）</p><p>修复：</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#a6e22e">handleConnection</span>(FILE<span style="color:#f92672">*</span>logfile,<span style="color:#66d9ef">int</span> sock) {</span></span><span style="display:flex;"><span><span style="color:#a6e22e">chdir</span>(<span style="color:#e6db74">"/root/code/c/news_server/"</span>);</span></span></code></pre></div></li><li><p>在authenticate函数存在admin后门</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">memcmp</span>(pass,<span style="color:#e6db74">"baCkDoOr"</span>,<span style="color:#ae81ff">9</span>)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) {</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span><span style="color:#ae81ff">1</span>;</span></span><span style="display:flex;"><span> }</span></span></code></pre></div></li><li><p>authenticate 中直接拼接用户输入到命令，命令注入</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#a6e22e">authenticate</span>(FILE<span style="color:#f92672">*</span>logfile,<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>user,<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>pass)</span></span><span style="display:flex;"><span>{</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> search[<span style="color:#ae81ff">512</span>];</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> path[<span style="color:#ae81ff">1024</span>];</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> userfile[<span style="color:#ae81ff">1024</span>];</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">1024</span>];</span></span><span style="display:flex;"><span> FILE<span style="color:#f92672">*</span>file;</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ret;</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#a6e22e">memset</span>(path,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(<span style="color:#ae81ff">1024</span>));</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#75715e">/* FIXME: hard coded admin backdoor for password recovery */</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">memcmp</span>(pass,<span style="color:#e6db74">"baCkDoOr"</span>,<span style="color:#ae81ff">9</span>)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)</span></span><span style="display:flex;"><span> {</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span><span style="color:#ae81ff">1</span>;</span></span><span style="display:flex;"><span> }</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#75715e">/* look up user by checking user files: done via system() to /bin/ls|grep user */</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">logData</span>(logfile,<span style="color:#e6db74">"performing lookup for user via system()!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);</span></span><span style="display:flex;"><span><span style="color:#a6e22e">snprintf</span>(userfile,<span style="color:#66d9ef">sizeof</span>(userfile)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#e6db74">"%s.txt"</span>, user);</span></span><span style="display:flex;"><span><span style="color:#a6e22e">snprintf</span>(search,<span style="color:#66d9ef">sizeof</span>(userfile)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#e6db74">"stat %s`ls %s | grep %s`"</span>, USERPATH, USERPATH, userfile);</span></span><span style="display:flex;"><span> ret<span style="color:#f92672">=</span><span style="color:#a6e22e">system</span>(search);</span></span></code></pre></div></li><li><p>栈溢出、任意文件读（目录穿越）</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#a6e22e">readArticle</span>(<span style="color:#66d9ef">int</span> sock, FILE<span style="color:#f92672">*</span>logfile,<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>action)</span></span><span style="display:flex;"><span>{</span></span><span style="display:flex;"><span> FILE<span style="color:#f92672">*</span>file;</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">100</span>];</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> path[<span style="color:#ae81ff">100</span>];</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#a6e22e">logData</span>(logfile,<span style="color:#f92672">&amp;</span>action[<span style="color:#ae81ff">1</span>]);</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#a6e22e">strcpy</span>(path, ARTICLEPATH);</span></span><span style="display:flex;"><span><span style="color:#a6e22e">strcat</span>(path,<span style="color:#f92672">&amp;</span>action[<span style="color:#ae81ff">1</span>]);</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#a6e22e">logData</span>(logfile,<span style="color:#e6db74">"user request to read article: %s"</span>, path);</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span> file<span style="color:#f92672">=</span><span style="color:#a6e22e">fopen</span>(path,<span style="color:#e6db74">"r"</span>);</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>file)</span></span><span style="display:flex;"><span> {</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writeSock</span>(sock, FILENOTAVAIL,<span style="color:#66d9ef">sizeof</span>(FILENOTAVAIL));</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span>;</span></span><span style="display:flex;"><span> }</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#75715e">/* fgets for the size of the buffer (100), from the file</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> writing the article to the user each time! */</span></span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">fgets</span>(buf,<span style="color:#ae81ff">1000</span>, file))</span></span></code></pre></div></li><li><p>文件写（目录穿越）、栈溢出11字节</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#a6e22e">writeArticle</span>(<span style="color:#66d9ef">int</span> sock, FILE<span style="color:#f92672">*</span>logfile,<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>action)</span></span><span style="display:flex;"><span>{</span></span><span style="display:flex;"><span> FILE<span style="color:#f92672">*</span>file;</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>p;</span></span><span style="display:flex;"><span><span style="color:#66d9ef">size_t</span> x, y;</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> complete<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">1024</span>];</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> path[<span style="color:#ae81ff">1024</span>];</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#a6e22e">strcpy</span>(path, ARTICLEPATH);</span></span><span style="display:flex;"><span><span style="color:#a6e22e">strncat</span>(path,<span style="color:#f92672">&amp;</span>action[<span style="color:#ae81ff">1</span>],<span style="color:#66d9ef">sizeof</span>(path));</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#a6e22e">logData</span>(logfile,<span style="color:#e6db74">"user writing article: %s"</span>, path);</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span> file<span style="color:#f92672">=</span><span style="color:#a6e22e">fopen</span>(<span style="color:#f92672">&amp;</span>action[<span style="color:#ae81ff">1</span>],<span style="color:#e6db74">"w"</span>);</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>file)</span></span><span style="display:flex;"><span> {</span></span><span style="display:flex;"><span><span style="color:#a6e22e">writeSock</span>(sock, FILENOTAVAIL,<span style="color:#66d9ef">sizeof</span>(FILENOTAVAIL));</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span>;</span></span><span style="display:flex;"><span> }</span></span><span style="display:flex;"><span/></span><span style="display:flex;"><span><span style="color:#a6e22e">writeSock</span>(sock, BEGINFILE,<span style="color:#66d9ef">sizeof</span>(BEGINFILE));</span></span></code></pre></div></li></ol></description></item></channel></rss>