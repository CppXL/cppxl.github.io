<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>安全研究 on chestnut's blog</title><link>https://www.ch35tnut.site/zh-cn/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/</link><description>Recent content in 安全研究 on chestnut's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 31 Jan 2024 08:22:24 +0000</lastBuildDate><atom:link href="https://www.ch35tnut.site/zh-cn/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>CommonsBeanutils1 Chain</title><link>https://www.ch35tnut.site/zh-cn/research/web/java-deserialization/commonsbeanutils1-chain/</link><pubDate>Fri, 12 Jan 2024 14:32:08 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/web/java-deserialization/commonsbeanutils1-chain/</guid><description>概述 在ysoserial中实现了CommonsBeanutils1反序列化链，可以利用这个链执行代码。
细节 在ysoserial中实现CommonsBeanutils1代码如下，首先new BeanComparator/PriorityQueue对象，在PriorityQueue对象内添加两个int对象，而后通过反射修改property字段存储的值
public class CommonsBeanutils1 implements ObjectPayload&amp;lt;Object&amp;gt; { public Object getObject(final String command) throws Exception { final Object templates = Gadgets.createTemplatesImpl(command); // mock method name until armed final BeanComparator comparator = new BeanComparator(&amp;#34;lowestSetBit&amp;#34;); // create queue with numbers and basic comparator final PriorityQueue&amp;lt;Object&amp;gt; queue = new PriorityQueue&amp;lt;Object&amp;gt;(2, comparator); // stub data for replacement later queue.add(new BigInteger(&amp;#34;1&amp;#34;)); queue.add(new BigInteger(&amp;#34;1&amp;#34;)); // switch method called by comparator Reflections.setFieldValue(comparator, &amp;#34;property&amp;#34;, &amp;#34;outputProperties&amp;#34;); // switch contents of queue final Object[] queueArray = (Object[]) Reflections.</description></item><item><title>JAVA URL DNS 研究</title><link>https://www.ch35tnut.site/zh-cn/research/web/java-deserialization/urldns/</link><pubDate>Mon, 08 Jan 2024 16:57:37 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/web/java-deserialization/urldns/</guid><description>前言
初步入门java反序列化学习，做一个学习记录，水一篇文章。如果有问题可以邮件：got_whipper.0p@icloud.com
URL类DNS请求 使用URL.equals会发起DNS请求
public class urltest { public static void main(String[] args) throws MalformedURLException { System.out.println(&amp;#34;hello &amp;#34;); URL u = new URL(&amp;#34;http://www.baidu.com&amp;#34;); URL u1 = new URL(&amp;#34;http://www.baidu.com&amp;#34;); System.out.println(u.equals(u1)); } } 跟进代码，equals代码如下，
protected boolean equals(URL u1, URL u2) { String ref1 = u1.getRef(); String ref2 = u2.getRef(); return (ref1 == ref2 || (ref1 != null &amp;amp;&amp;amp; ref1.equals(ref2))) &amp;amp;&amp;amp; sameFile(u1, u2); } 判断reference是否相同，而后使用sameFile函数，sameFile函数会查看其协议、uri、端口、主机是否相等。
protected boolean sameFile(URL u1, URL u2) { // Compare the protocols.</description></item><item><title>PHP Filter RCE 分析</title><link>https://www.ch35tnut.site/zh-cn/research/web/php-filter-rce/</link><pubDate>Fri, 29 Dec 2023 18:32:43 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/web/php-filter-rce/</guid><description>PHP filter是什么 PHP filter是PHP定义的一个伪协议，用于在数据流打开时进行筛选过滤，在数据读取或者写入的时候通过过滤器对数据进行处理。PHP filter 可以使用多个过滤器进行处理。
php://filter/过滤器|过滤器/resource=待过滤的数据流 require_once和require的参数是一个文件路径，指明要包含的文件，而PHP filter 提供了接口，使得可以通过这个接口访问到指定的文件内容，require在包含文件时，只关心文件内容，而不关心文件内容来自于何处，所以可以给require 传PHP filter参数，
如果有如下代码
&amp;lt;?php $file = $_GET[&amp;#39;page&amp;#39;]; require($file); 则可以通过如下请求泄露敏感信息
curl &amp;#34;http://localhost/test.php?page=php://filter/convert.base64-encode/resource=/etc/passwd&amp;#34; PHP的base64decode函数在处理base64编码的数据时，会自动规范化：去除字符串中不合法的字符并且忽略，而后尝试解码。 但PHP filter的base64解码行为和base64decode行为略有不同，PHP filter的base64-decode不能处理随即插入的等号，此时可以使用UTF-7编码规避，UTF-7编码会把等号转化为其他的base64字符。
通过编码前置字符 根据官网链接的reference 根据文档，如果开启了iconv支持，则可以通过伪协议php://convert.iconv.*.*调用iconv函数。
convert.iconv.&amp;lt;input-encoding&amp;gt;.&amp;lt;output-encoding&amp;gt; or convert.iconv.&amp;lt;input-encoding&amp;gt;/&amp;lt;output-encoding&amp;gt;
linux中可以使用iconv函数将字符串从一个编码转为另外一个编码，在PHP://filter中可以使用iconv过滤器调用到这个函数
php -r &amp;#34;echo file_get_contents(\&amp;#34;php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7/res ource=php://temp\&amp;#34;);&amp;#34; GyQpQw+AD0APQ-# 某些编码规定该编码会在数据之前预置一些字节，相当于签名，标识这段数据是该编码 在RFC 2781中就说明该编码会预置0XFEFF
The Unicode Standard and ISO 10646 define the character &amp;ldquo;ZERO WIDTH NON-BREAKING SPACE&amp;rdquo; (0xFEFF), which is also known informally as &amp;ldquo;BYTE ORDER MARK&amp;rdquo; (abbreviated &amp;ldquo;BOM&amp;rdquo;).This usage, suggested by Unicode and ISO 10646 Annex F (informative), is to prepend a 0xFEFF character to a stream of Unicode characters as a &amp;ldquo;signature&amp;rdquo;; a receiver of such a serialized stream may then use the initial character both as a hint that the stream consists of Unicode characters and as a way to recognize the serialization order.</description></item><item><title>Suid</title><link>https://www.ch35tnut.site/zh-cn/research/linux/suid/</link><pubDate>Fri, 08 Dec 2023 10:30:07 +0800</pubDate><guid>https://www.ch35tnut.site/zh-cn/research/linux/suid/</guid><description>简介 SUID全称Set owner User ID up on execution，是Linux给可执行文件的一个属性，设置了s位的程序在运行时其Effective UID将会设置为这个程序的所有者。比如，/bin/ping这个程序的所有者是0（root），它设置了s位，那么普通用户在运行ping时其Effective UID就是0，等同于拥有了root权限。
➜ c ls -ldb $(which pkexec) -rwsr-xr-x 1 root root 30872 2023年 2月13日 /usr/bin/pkexec SUID文件的出现是为了解决一些操作只能由root权限进行，但普通权限用户也需要能通过某种方式进行调用，比如passwd，/etc/shadow只有root可写，但用户自己显然需要可以修改密码，所以passwd被设置为SUID程序，使得普通用户能通过passwd临时获取到修改shadow文件的能力。
-rw-r----- 1 root shadow 1411 2023年 5月10日 /etc/shadow -rwsr-xr-x 1 root root 68248 2022年11月11日 /usr/bin/passwd Linux中每个用户都有独一无二的ID，称为UserID。 为进程定义了三个ID：
Real UserID Effective UserID Saved UserID Real UserID：对于一个进程，这个ID是启动这个进程的用户的用户ID，这个ID定义了这个进程有权访问那些文件。 Effective UserID：通常这个ID和Real UserID相同，但有时会不一样，来允许非特权用户访问只能由特权用户访问的文件。 当非特权的用户运行此文件时，euid是文件所属的用户id，ruid才是当前用户的id -rwsr-xr-x 1 root root 68248 2022年11月11日 /usr/bin/passwd ┌──(chestnut㉿chestnut)-[/root/code/c] └─$ passwd 为 chestnut 更改 STRESS 密码。 ➜ c ps -eo pid,euid,ruid | grep 1692693 1692693 0 1000 Saved UserID，当进程以提升权限运行时，需要做一些非特权的操作，可以通过临时切换到非特权账户来实现。 在执行低权限工作时，将Effective UID 更改为某个较低的权限值，并将 euid 保存到Saved userID（suid），以便在任务完成时用于切换回特权帐户。 https://www.</description></item></channel></rss>